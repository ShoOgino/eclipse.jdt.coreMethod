	/*
	 * (non-Javadoc)
	 *
	 * @see javax.tools.JavaCompiler#getTask(java.io.Writer,
	 *      javax.tools.JavaFileManager, javax.tools.DiagnosticListener,
	 *      java.lang.Iterable, java.lang.Iterable, java.lang.Iterable)
	 */
	@SuppressWarnings("unchecked")
	public CompilationTask getTask(Writer out,
			JavaFileManager fileManager,
			DiagnosticListener<? super JavaFileObject> diagnosticListener,
			Iterable<String> options,
			Iterable<String> classes,
			Iterable<? extends JavaFileObject> compilationUnits) {

		PrintWriter writerOut = null;
		PrintWriter writerErr = null;
		if (out == null) {
			writerOut = new PrintWriter(System.out);
			writerErr = new PrintWriter(System.err);
		} else {
			writerOut = new PrintWriter(out);
			writerErr = new PrintWriter(out);
		}
		this.compilationUnits = compilationUnits;
		this.diagnosticListener = diagnosticListener;
		if (fileManager != null) {
			this.fileManager = fileManager;
		} else {
			this.fileManager = this.getStandardFileManager(diagnosticListener, null, null);
		}

		initialize(writerOut, writerErr, false);
		this.options.put(CompilerOptions.OPTION_Compliance, CompilerOptions.VERSION_1_6);
		this.options.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_6);
		this.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_6);

		// TODO FIXME (olivier) REMOVE BEFORE 3.3 once the APT1.6 IS WORKING FINE
		for (String option : options ) {
			if ("-processorpath".equals(option) //$NON-NLS-1$
					|| ("-processor".equals(option))) { //$NON-NLS-1$
				this.options.put(CompilerOptions.OPTION_Process_Annotations, CompilerOptions.ENABLED);
				break;
			}
		}

		ArrayList<String> allOptions = new ArrayList<String>();
		if (options != null) {
			for (Iterator<String> iterator = options.iterator(); iterator.hasNext(); ) {
				this.fileManager.handleOption(iterator.next(), iterator);
			}
			for (String option : options) {
				allOptions.add(option);
			}
		}
		if (compilationUnits != null) {
			for (JavaFileObject javaFileObject : compilationUnits) {
				allOptions.add(new File(javaFileObject.toUri()).getAbsolutePath());
			}
		}

		final String[] optionsToProcess = new String[allOptions.size()];
		allOptions.toArray(optionsToProcess);
		try {
			this.configure(optionsToProcess);
		} catch (InvalidInputException e) {
			throw new RuntimeException(e);
		}

		if (this.fileManager instanceof StandardJavaFileManager) {
			StandardJavaFileManager javaFileManager = (StandardJavaFileManager) this.fileManager;

			Iterable<? extends File> location = javaFileManager.getLocation(StandardLocation.CLASS_OUTPUT);
			if (location != null) {
				this.setDestinationPath(location.iterator().next().getAbsolutePath());
			}
		}

		return new CompilationTask() {
			private boolean hasRun = false;
			public Boolean call() {
				// set up compiler with passed options
				if (this.hasRun) {
					throw new IllegalStateException("This task has already been run"); //$NON-NLS-1$
				}
				Boolean value = EclipseCompiler.this.call() ? Boolean.TRUE : Boolean.FALSE;
				this.hasRun = true;
				return value;
			}
			public void setLocale(Locale locale) {
				EclipseCompiler.this.setLocale(locale);
			}
			public void setProcessors(Iterable<? extends Processor> processors) {
				EclipseCompiler.this.options.put(CompilerOptions.OPTION_Process_Annotations, CompilerOptions.ENABLED);
				ArrayList<Processor> temp = new ArrayList<Processor>();
				for (Processor processor : processors) {
					temp.add(processor);
				}
				Processor[] processors2 = new Processor[temp.size()];
				temp.toArray(processors2);
				EclipseCompiler.this.processors = processors2;
			}
		};
	}

