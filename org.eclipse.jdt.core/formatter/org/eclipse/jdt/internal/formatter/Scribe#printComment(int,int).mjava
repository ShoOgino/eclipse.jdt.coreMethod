	/*
	 * Main method to print and format comments (javadoc, block and single line comments)
	 */
	void printComment(int kind, int trailing) {
		final boolean rejectLineComment = kind  == CodeFormatter.K_MULTI_LINE_COMMENT || kind == CodeFormatter.K_JAVA_DOC;
		final boolean rejectBlockComment = kind  == CodeFormatter.K_SINGLE_LINE_COMMENT || kind  == CodeFormatter.K_JAVA_DOC;
		final boolean rejectJavadocComment = kind  == CodeFormatter.K_SINGLE_LINE_COMMENT || kind  == CodeFormatter.K_MULTI_LINE_COMMENT;
		try {
			// if we have a space between two tokens we ensure it will be dumped in the formatted string
			int currentTokenStartPosition = this.scanner.currentPosition;
			boolean hasComment = false;
			boolean hasLineComment = false;
			boolean hasWhitespaces = false;
			int lines = 0;
			int previousFoundTaskCount = this.scanner.foundTaskCount;
			while ((this.currentToken = this.scanner.getNextToken()) != TerminalTokens.TokenNameEOF) {
				int foundTaskCount = this.scanner.foundTaskCount;
				switch(this.currentToken) {
					case TerminalTokens.TokenNameWHITESPACE :
						char[] whiteSpaces = this.scanner.getCurrentTokenSource();
						int whitespacesStartPosition = this.scanner.getCurrentTokenStartPosition();
						int whitespacesEndPosition = this.scanner.getCurrentTokenEndPosition();
						lines = 0;
						for (int i = 0, max = whiteSpaces.length; i < max; i++) {
							switch(whiteSpaces[i]) {
								case '\r' :
									if ((i + 1) < max) {
										if (whiteSpaces[i + 1] == '\n') {
											i++;
										}
									}
									lines++;
									break;
								case '\n' :
									lines++;
							}
						}
						// If following token is a line comment on the same line or the line just after,
						// then it might be not really formatted as a trailing comment
						boolean realTrailing = trailing > NO_TRAILING_COMMENT;
						if (realTrailing && this.scanner.currentCharacter == '/' && (lines == 0 || (lines == 1 && !hasLineComment && trailing == IMPORT_TRAILING_COMMENT))) {
							// sometimes changing the trailing may not be the best idea
							// for complex trailing comment, it's basically a good idea
							boolean canChangeTrailing = (trailing & COMPLEX_TRAILING_COMMENT) != 0;
							// for basic trailing comment preceded by a line comment, then it depends on the comments relative position
							// when following comment column (after having been rounded) is below the preceding one,
							// then it becomes not a good idea to change the trailing flag
							if (trailing == BASIC_TRAILING_COMMENT && hasLineComment) {
								int currentCommentIndentation = getCurrentIndentation(whiteSpaces, 0);
								int lastCommentIndentation = this.lastLineComment.currentIndentation;
								if (this.tabLength > 0) {
									if ((currentCommentIndentation % this.tabLength) == 0) {
										lastCommentIndentation = (lastCommentIndentation / this.tabLength) * this.tabLength;
									} else {
										currentCommentIndentation = ((currentCommentIndentation / this.tabLength) + 1) * this.tabLength;
									}
								}
								canChangeTrailing = currentCommentIndentation >= lastCommentIndentation;
							}
							// if the trailing can be change, then look at the following tokens
							if (canChangeTrailing) {
								int currentPosition = this.scanner.currentPosition;
								if (this.scanner.getNextToken() == TerminalTokens.TokenNameCOMMENT_LINE) {
									realTrailing = !hasLineComment;
									switch (this.scanner.getNextToken()) {
										case TerminalTokens.TokenNameCOMMENT_LINE:
											// at least two contiguous line comments
											// the formatter should not consider comments as trailing ones
											realTrailing = false;
											break;
										case TerminalTokens.TokenNameWHITESPACE:
											if (this.scanner.getNextToken() == TerminalTokens.TokenNameCOMMENT_LINE) {
												// at least two contiguous line comments
												// the formatter should not consider comments as trailing ones
												realTrailing = false;
											}
											break;
									}
								}
								this.scanner.resetTo(currentPosition, this.scanner.eofPosition - 1);
							}
						}
						// Look whether comments line may be contiguous or not
						// Note that when preceding token is a comment line, then only one line
						// is enough to have an empty line as the line end is included in the comment line...
						// If comments are contiguous, store the white spaces to be able to compute the current comment indentation
						if (lines > 1 || (lines == 1 && hasLineComment)) {
							this.lastLineComment.contiguous = false;
						}
						this.lastLineComment.leadingSpaces = whiteSpaces;
						this.lastLineComment.lines = lines;
						// Strategy to consume spaces and eventually leave at this stage
						// depends on the fact that a trailing comment is expected or not
						if (realTrailing) {
							// if a line comment is consumed, no other comment can be on the same line after
							if (hasLineComment) {
								if (lines >= 1) {
									currentTokenStartPosition = whitespacesStartPosition;
									preserveEmptyLines(lines, currentTokenStartPosition);
									addDeleteEdit(currentTokenStartPosition, whitespacesEndPosition);
									this.scanner.resetTo(this.scanner.currentPosition, this.scannerEndPosition - 1);
									return;
								}
								this.scanner.resetTo(currentTokenStartPosition, this.scannerEndPosition - 1);
								return;
							} 
							// if one or several new lines are consumed, following comments cannot be considered as trailing ones
							if (lines >= 1) {
								if (hasComment) {
									this.printNewLine(whitespacesStartPosition);
								}
								this.scanner.resetTo(currentTokenStartPosition, this.scannerEndPosition - 1);
								return;
							}
							// delete consumed white spaces
							hasWhitespaces = true;
							currentTokenStartPosition = this.scanner.currentPosition;
							addDeleteEdit(whitespacesStartPosition, whitespacesEndPosition);
						} else {
							if (lines == 0) {
								hasWhitespaces = true;
								addDeleteEdit(whitespacesStartPosition, whitespacesEndPosition);
							} else if (hasLineComment) {
								currentTokenStartPosition = whitespacesStartPosition;
								preserveEmptyLines(lines, currentTokenStartPosition);
								addDeleteEdit(currentTokenStartPosition, whitespacesEndPosition);
							} else if (hasComment) {
								if (lines == 1) {
									this.printNewLine(whitespacesStartPosition);
								} else {
									preserveEmptyLines(lines - 1, whitespacesStartPosition);
								}
								addDeleteEdit(whitespacesStartPosition, whitespacesEndPosition);
							} else if (lines != 0 && (!this.formatter.preferences.join_wrapped_lines || this.formatter.preferences.number_of_empty_lines_to_preserve != 0 || this.blank_lines_between_import_groups > 0)) {
								addReplaceEdit(whitespacesStartPosition, whitespacesEndPosition, getPreserveEmptyLines(lines-1));
							} else {
								addDeleteEdit(whitespacesStartPosition, whitespacesEndPosition);
							}
						}
						currentTokenStartPosition = this.scanner.currentPosition;
						break;
					case TerminalTokens.TokenNameCOMMENT_LINE :
						if (this.editsEnabled && foundTaskCount > previousFoundTaskCount) {
							setEditsEnabled(foundTaskCount, previousFoundTaskCount);
							if (!this.editsEnabled && this.editsIndex > 1) {
								OptimizedReplaceEdit currentEdit = this.edits[this.editsIndex-1];
								if (this.scanner.startPosition == currentEdit.offset+currentEdit.length) {
									printNewLinesBeforeDisablingComment();
								}
							}
							previousFoundTaskCount = foundTaskCount;
						}
						if (rejectLineComment) break;
						if (lines >= 1) {
							if (lines > 1) {
								preserveEmptyLines(lines - 1, this.scanner.getCurrentTokenStartPosition());
							} else if (lines == 1) {
								printNewLine(this.scanner.getCurrentTokenStartPosition());
							}
						} else if (hasWhitespaces) {
							space();
						}
						hasWhitespaces = false;
						printLineComment();
						currentTokenStartPosition = this.scanner.currentPosition;
						hasLineComment = true;
						lines = 0;
						if (!this.editsEnabled && foundTaskCount > previousFoundTaskCount) {
							setEditsEnabled(foundTaskCount, previousFoundTaskCount);
						}
						break;
					case TerminalTokens.TokenNameCOMMENT_BLOCK :
						if (this.editsEnabled && foundTaskCount > previousFoundTaskCount) {
							setEditsEnabled(foundTaskCount, previousFoundTaskCount);
							if (!this.editsEnabled && this.editsIndex > 1) {
								OptimizedReplaceEdit currentEdit = this.edits[this.editsIndex-1];
								if (this.scanner.startPosition == currentEdit.offset+currentEdit.length) {
									printNewLinesBeforeDisablingComment();
								}
							}
							previousFoundTaskCount = foundTaskCount;
						}
						if (trailing > NO_TRAILING_COMMENT && lines >= 1) {
							// a block comment on next line means that there's no trailing comment
							this.scanner.resetTo(this.scanner.getCurrentTokenStartPosition(), this.scannerEndPosition - 1);
							return;
						}
						this.lastLineComment.contiguous = false;
						if (rejectBlockComment) break;
						if (lines >= 1) {
							if (lines > 1) {
								preserveEmptyLines(lines - 1, this.scanner.getCurrentTokenStartPosition());
							} else if (lines == 1) {
								printNewLine(this.scanner.getCurrentTokenStartPosition());
							}
						} else if (hasWhitespaces) {
							space();
						}
						hasWhitespaces = false;
						printBlockComment(false);
						currentTokenStartPosition = this.scanner.currentPosition;
						hasLineComment = false;
						hasComment = true;
						lines = 0;
						if (!this.editsEnabled && foundTaskCount > previousFoundTaskCount) {
							setEditsEnabled(foundTaskCount, previousFoundTaskCount);
						}
						break;
					case TerminalTokens.TokenNameCOMMENT_JAVADOC :
						if (this.editsEnabled && foundTaskCount > previousFoundTaskCount) {
							setEditsEnabled(foundTaskCount, previousFoundTaskCount);
							if (!this.editsEnabled && this.editsIndex > 1) {
								OptimizedReplaceEdit currentEdit = this.edits[this.editsIndex-1];
								if (this.scanner.startPosition == currentEdit.offset+currentEdit.length) {
									printNewLinesBeforeDisablingComment();
								}
							}
							previousFoundTaskCount = foundTaskCount;
						}
						if (trailing > NO_TRAILING_COMMENT) {
							// a javadoc comment should not be considered as a trailing comment
							this.scanner.resetTo(this.scanner.getCurrentTokenStartPosition(), this.scannerEndPosition - 1);
							return;
						}
						this.lastLineComment.contiguous = false;
						if (rejectJavadocComment) break;
						if (lines >= 1) {
							if (lines > 1) {
								preserveEmptyLines(lines - 1, this.scanner.getCurrentTokenStartPosition());
							} else if (lines == 1) {
								printNewLine(this.scanner.getCurrentTokenStartPosition());
							}
						} else if (hasWhitespaces) {
							space();
						}
						hasWhitespaces = false;
						if (includesJavadocComments()) {
							printJavadocComment(this.scanner.startPosition, this.scanner.currentPosition);
						} else {
							printBlockComment(true);
						}
						if (!this.editsEnabled && foundTaskCount > previousFoundTaskCount) {
							setEditsEnabled(foundTaskCount, previousFoundTaskCount);
						}
						printNewLine();
						currentTokenStartPosition = this.scanner.currentPosition;
						hasLineComment = false;
						hasComment = true;
						lines = 0;
						break;
					default :
						this.lastLineComment.contiguous = false;
						// step back one token
						this.scanner.resetTo(currentTokenStartPosition, this.scannerEndPosition - 1);
						return;
				}
				previousFoundTaskCount = foundTaskCount;
			}
		} catch (InvalidInputException e) {
			throw new AbortFormatting(e);
		}
	}

