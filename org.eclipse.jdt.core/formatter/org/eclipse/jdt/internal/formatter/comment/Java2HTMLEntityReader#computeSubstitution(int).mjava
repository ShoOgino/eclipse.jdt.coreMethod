	/*
	 * @see org.eclipse.jdt.internal.ui.text.SubstitutionTextReader#computeSubstitution(int)
	 */
	protected String computeSubstitution(int c) throws IOException {
		StringBuffer buf = new StringBuffer();
		// Accumulate *s into the buffer until we see something other than *.
		while (c == '*') {
			this.bits &= ~BEGIN_LINE;
			c = nextChar();
			buf.append('*');
		}
		if (c == -1)
			// Snippet must have ended with *s.  Just return them.
			return buf.toString();
		if (c == '/' && buf.length() > 0) {
			/*
			 * Translate a * that precedes a / to &#42; so it isn't
			 * misinterpreted as the end of the Javadoc comment that contains
			 * the code we are formatting.
			 * See https://bugs.eclipse.org/bugs/show_bug.cgi?id=109636
			 */
			buf.setLength(buf.length() - 1);
			buf.append("&#42;/"); //$NON-NLS-1$
		} else if (c == '@' && (this.bits & BEGIN_LINE) != 0) {
			/*
			 * When @ is first on a line, translate it to &#064; so it isn't
			 * misinterpreted as a Javadoc tag.
			 * See https://bugs.eclipse.org/bugs/show_bug.cgi?id=197169
			 */
			buf.append("&#064;"); //$NON-NLS-1$
		} else {
			/*
			 * Ordinary processing.  If the character needs an entity in HTML,
			 * add the entity, otherwise add the character.
			 */
			String entity = (String) fgEntityLookup.get(String.valueOf((char) c));
			if (entity != null)
				buf.append(entity);
			else
				buf.append((char) c);
		}
		// Update bits for the benefit of the next character.
		if (c == '\n' || c == '\r') {
			this.bits |= BEGIN_LINE;
		} else if (!ScannerHelper.isWhitespace((char) c)) {
			this.bits &= ~BEGIN_LINE;
		}
		return buf.toString();
	}

