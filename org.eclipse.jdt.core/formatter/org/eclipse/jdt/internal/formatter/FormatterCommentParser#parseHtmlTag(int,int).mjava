/*
 * Parse an HTML tag expected to be either opening (e.g. <tag_name> ) or
 * closing (e.g. </tag_name>).
 */
protected boolean parseHtmlTag(int previousPosition, int endTextPosition) throws InvalidInputException {
	if (!this.parseHtmlTags) return false;
    boolean closing = false;
    boolean valid = false;
    boolean incremented = false;
    int start = this.scanner.currentPosition;
    int currentPosition = start;
    int htmlPtr = this.htmlTagsPtr;
    char firstChar = peekChar();
    boolean hasWhitespaces = firstChar == ' ' || ScannerHelper.isWhitespace(firstChar);
	try {
	    int token = readTokenAndConsume();
	    char[] htmlTag;
	    int htmlIndex;
	    switch (token) {
	    	case TerminalTokens.TokenNameIdentifier:
	    		// HTML tag opening
				htmlTag = this.scanner.getCurrentIdentifierSource();
				htmlIndex = getHtmlTagIndex(htmlTag);
				if (htmlIndex == JAVADOC_TAGS_ID_MASK) return false;
				if (htmlPtr >= 0) {
		    		int lastHtmlTagIndex = getHtmlTagIndex(this.htmlTags[htmlPtr]);
					if ((lastHtmlTagIndex & JAVADOC_TAGS_ID_MASK) == JAVADOC_IMMUTABLE_TAGS_ID) {
						// Do not accept tags inside immutable tags except the <pre> tag
						if ((htmlIndex & JAVADOC_TAGS_ID_MASK) == JAVADOC_CODE_TAGS_ID) {
							FormatJavadocBlock previousBlock = (FormatJavadocBlock) this.astStack[this.astPtr];
							FormatJavadocNode parentNode = previousBlock;
							FormatJavadocNode lastNode = parentNode;
							while (lastNode.getLastNode() != null) {
								parentNode = lastNode;
								lastNode = lastNode.getLastNode();
							}
							if (lastNode.isText()) {
								FormatJavadocText text = (FormatJavadocText) lastNode;
								if (text.separatorsPtr == -1) {
									break;
								}
							}
						}
		    			return false;
					}
	    		}
				if ((htmlIndex & JAVADOC_TAGS_ID_MASK) > JAVADOC_SINGLE_TAGS_ID) {
		    		if (this.htmlTagsPtr == -1 || !CharOperation.equals(this.htmlTags[this.htmlTagsPtr], htmlTag, false)) {
						if (++this.htmlTagsPtr == 0) { // lazy initialization
							this.htmlTags = new char[AST_STACK_INCREMENT][];
						} else { // resize if needed
							if (this.htmlTagsPtr == this.htmlTags.length) {
								System.arraycopy(this.htmlTags, 0, (this.htmlTags = new char[this.htmlTags.length + AST_STACK_INCREMENT][]), 0, this.htmlTagsPtr);
							}
						}
						this.htmlTags[this.htmlTagsPtr] = htmlTag;
						incremented = true;
		    		}
				}
				// Accept xhtml syntax
				currentPosition = this.scanner.currentPosition;
				if (readToken() == TerminalTokens.TokenNameDIVIDE) {
					consumeToken();
				}
		    	break;
	    	case TerminalTokens.TokenNameDIVIDE:
	    		// HTML tag closing
	    		if (this.htmlTagsPtr == -1) return false;
	    		htmlTag = this.htmlTags[this.htmlTagsPtr];
	    		if ((token = readTokenAndConsume()) != TerminalTokens.TokenNameIdentifier) {
	    			// not a closing html tag
	    			return false;
	    		}
				char[] identifier = this.scanner.getCurrentIdentifierSource();
				htmlIndex = getHtmlTagIndex(identifier);
				if (htmlIndex == JAVADOC_TAGS_ID_MASK) return false;
				int ptr = this.htmlTagsPtr;
	    		while (!CharOperation.equals(htmlTag, identifier, false)) {
	    			if (this.htmlTagsPtr <= 0) {
	    				// consider the closing tag as invalid
	    				this.htmlTagsPtr = ptr;
	    				return false;
	    			}
	    			this.htmlTagsPtr--;
		    		htmlTag = this.htmlTags[this.htmlTagsPtr];
	    		}
				// set closing flag
				htmlIndex |= JAVADOC_CLOSED_TAG;
				closing = true;
				currentPosition = this.scanner.currentPosition;
	    		break;
	    	default:
    			return false;
	    }
	    
	    // Looking for tag closing
	    switch (token = readTokenAndConsume()) {
	    	case TerminalTokens.TokenNameLESS:
	    	case TerminalTokens.TokenNameLESS_EQUAL:
	    		// consider that the closing '>' is missing
	    		return false;
	    	case TerminalTokens.TokenNameGREATER:
	    		// simple tag without attributes
	    		break;
	    	case TerminalTokens.TokenNameGREATER_EQUAL:
	    	case TerminalTokens.TokenNameRIGHT_SHIFT:
	    	case TerminalTokens.TokenNameRIGHT_SHIFT_EQUAL:
	    		// simple tag without attributes, but the closing '>' is followed by an '=' or '>'
	    		break;
	    	default:
	    		this.index = currentPosition;
	    		loop: while (true) {
//	    			currentPosition = this.index;
				    switch (readChar()) {
				    	case '<':
				    		if (hasWhitespaces) {
				    			// not 100% sure this is a tag definition => give up
				    			return false;
				    		}
				    		// opening tag => consider the current one as closed
				    		this.index = currentPosition;
				    		this.scanner.startPosition = currentPosition;
				    		this.scanner.currentPosition = currentPosition;
				    		this.scanner.currentCharacter = '<';
				    		break loop;
				    	case '>':
				    		// simple tag without attributes
				    		this.scanner.startPosition = this.index;
				    		this.scanner.currentPosition = this.index;
				    		this.scanner.currentCharacter = peekChar();
				    		break loop;
			    		default:
			    			break;
				    }
				    if (this.index >= this.javadocTextEnd) {
		    			// the end of the comment is reached => consider current tag as closed
			    		this.index = currentPosition;
			    		this.scanner.startPosition = currentPosition;
			    		this.scanner.currentPosition = currentPosition;
			    		break;
				    }
	    		}
		}

	    // Push texts
		if (this.lineStarted && this.textStart != -1 && this.textStart < endTextPosition) {
			pushText(this.textStart, endTextPosition, -1, htmlPtr);
		}
		pushText(previousPosition, this.index, htmlIndex, this.htmlTagsPtr);
		this.textStart = -1;
		valid = true;
	}
	finally {
		if (valid) {
			if (closing) {
				this.htmlTagsPtr--;
			}
		} else if (!this.abort) {
	    	if (incremented) {
	    		this.htmlTagsPtr--;
	    		if (this.htmlTagsPtr == -1) this.htmlTags = null;
	    	}
	    	this.scanner.resetTo(start, this.scanner.eofPosition-1);
	    	this.index = start;
		}
	}
    return valid;
}

