	private void formatMethodArguments(
			AbstractMethodDeclaration methodDeclaration,
			boolean spaceBeforeOpenParen,
			boolean spaceBetweenEmptyParameters,
			boolean spaceBeforeClosingParen,
			boolean spaceBeforeFirstParameter,
			boolean spaceBeforeComma,
			boolean spaceAfterComma,
			int methodDeclarationParametersAlignment) {

		this.scribe.printNextToken(TerminalTokens.TokenNameLPAREN, spaceBeforeOpenParen);

		final Argument[] arguments = methodDeclaration.arguments;
		if (arguments != null) {
			if (spaceBeforeFirstParameter) {
				this.scribe.space();
			}
			int argumentLength = arguments.length;
			Alignment argumentsAlignment = this.scribe.createAlignment(
					Alignment.METHOD_ARGUMENTS,
					methodDeclarationParametersAlignment,
					argumentLength,
					this.scribe.scanner.currentPosition);
			this.scribe.enterAlignment(argumentsAlignment);
			boolean ok = false;
			do {
				switch (methodDeclarationParametersAlignment & Alignment.SPLIT_MASK) {
					case Alignment.M_COMPACT_SPLIT:
					case Alignment.M_NEXT_PER_LINE_SPLIT:
						argumentsAlignment.startingColumn = this.scribe.column;
						break;
				}
				try {
					for (int i = 0; i < argumentLength; i++) {
						if (i > 0) {
							this.scribe.printNextToken(TerminalTokens.TokenNameCOMMA, spaceBeforeComma);
							this.scribe.printComment(CodeFormatter.K_UNKNOWN, Scribe.BASIC_TRAILING_COMMENT);
						}
						this.scribe.alignFragment(argumentsAlignment, i);
						if (i == 0) {
							int fragmentIndentation = argumentsAlignment.fragmentIndentations[0];
							if ((argumentsAlignment.mode & Alignment.M_INDENT_ON_COLUMN) != 0 && fragmentIndentation > 0) {
								this.scribe.indentationLevel = fragmentIndentation;
							}
						} else if (spaceAfterComma) {
							this.scribe.space();
						}
						arguments[i].traverse(this, methodDeclaration.scope);
						argumentsAlignment.startingColumn = -1;
					}
					ok = true;
				} catch (AlignmentException e) {
					this.scribe.redoAlignment(e);
				}
			} while (!ok);
			this.scribe.exitAlignment(argumentsAlignment, true);

			this.scribe.printNextToken(TerminalTokens.TokenNameRPAREN, spaceBeforeClosingParen);
		} else {
			this.scribe.printNextToken(TerminalTokens.TokenNameRPAREN, spaceBetweenEmptyParameters);
		}
	}

