	/**
	 * @see org.eclipse.jdt.internal.compiler.ASTVisitor#visit(org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration, org.eclipse.jdt.internal.compiler.lookup.CompilationUnitScope)
	 */
	public boolean visit(
		CompilationUnitDeclaration compilationUnitDeclaration,
		CompilationUnitScope scope) {
		
		/* 
		 * Package declaration
		 */
		if (compilationUnitDeclaration.currentPackage != null) {
			this.scribe.printComment();
			// OPTION
			// dump the package keyword
			int blankLinesBeforePackage = this.preferences.blank_lines_before_package;
			if (blankLinesBeforePackage > 0) {
				this.scribe.printEmptyLines(blankLinesBeforePackage - 1);
			}
			this.scribe.printNextToken(TerminalTokens.TokenNamepackage);
			this.scribe.space();
			this.scribe.printQualifiedReference(compilationUnitDeclaration.currentPackage.sourceEnd);
			this.scribe.printNextToken(TerminalTokens.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);
			this.scribe.printTrailingComment();
			int blankLinesAfterPackage = this.preferences.blank_lines_after_package;
			if (blankLinesAfterPackage > 0) {
				this.scribe.printEmptyLines(blankLinesAfterPackage);
			} else {
				this.scribe.printNewLine();
			}			
		} else {
			this.scribe.printComment();
		}
		
		/*
		 * Import statements
		 */
		final ImportReference[] imports = compilationUnitDeclaration.imports;
		if (imports != null) {
			int blankLinesBeforeImports = this.preferences.blank_lines_before_imports;
			if (blankLinesBeforeImports > 0) {
				this.scribe.printEmptyLines(blankLinesBeforeImports);
			}
			int importLength = imports.length;
			for (int i = 0; i < importLength; i++) {
				imports[i].traverse(this, scope);
			}			
			
			int blankLinesAfterImports = this.preferences.blank_lines_after_imports;
			if (blankLinesAfterImports > 0) {
				this.scribe.printEmptyLines(blankLinesAfterImports);
			}
		}

		formatEmptyTypeDeclaration(true);
		
		int blankLineBetweenTypeDeclarations = this.preferences.blank_lines_between_type_declarations;
		/*
		 * Type declarations
		 */
		final TypeDeclaration[] types = compilationUnitDeclaration.types;
		if (types != null) {
			int typesLength = types.length;
			for (int i = 0; i < typesLength - 1; i++) {
				types[i].traverse(this, scope);
				this.scribe.printComment();
				formatEmptyTypeDeclaration(false);
				if (blankLineBetweenTypeDeclarations != 0) {
					this.scribe.printEmptyLines(blankLineBetweenTypeDeclarations);
				} else {
					this.scribe.printNewLine();
				}
			}
			format(types[typesLength - 1]);
		}
		this.scribe.printComment();
		formatEmptyTypeDeclaration(false);
		return false;
	}

