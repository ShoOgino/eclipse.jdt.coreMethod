	/*
	 * Preserve empty lines depending on given count and preferences.
	 */
	private String getPreserveEmptyLines(int count) {
		if (count == 0) {
			// preserve line breaks in wrapping if specified
			// see bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=198074
			if (this.currentAlignment != null && !this.formatter.preferences.join_wrapped_lines) {
				// Insert a new line only if it has not been already done before
				// (see bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=283476)
				// or when there's no direct member alignment
				// (additional fix for bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=286601)
				if (this.lastNumberOfNewLines == 0 || this.memberAlignment == null || this.memberAlignment.location.inputOffset < this.currentAlignment.location.inputOffset) {
					
					// Debug
					if (DefaultCodeFormatter.DEBUG) {
						System.out.println("Preserve empty lines:"); //$NON-NLS-1$
						System.out.println(" - indentation level = "+this.indentationLevel); //$NON-NLS-1$
						System.out.println(" - current alignment: "); //$NON-NLS-1$
						System.out.print(this.currentAlignment.toString(new StringBuffer(), 1));
						if (this.memberAlignment != null) {
							System.out.println(" - member alignment: "); //$NON-NLS-1$
							System.out.print(this.memberAlignment.toString(new StringBuffer(), 1));
						}
					}

					// Reset indentation level to the location output
					this.indentationLevel = this.currentAlignment.location.outputIndentationLevel;

					// Create new line
					this.tempBuffer.setLength(0);
					this.tempBuffer.append(getNewLine());
					
					// Look for current indentation
					int currentIndentation = getCurrentIndentation(this.scanner.currentPosition);
					
					// Determine whether the alignment indentation can be used or not
					// So far, the best algorithm is to use it when
					// 1. this is not the opening brace of a local declaration assignment
					// 2. this is not the first opening brace
					//     or this is an array initializer alignment 
					//     or this is an binary expression alignment
					// 3. the indentation level is below the alignment break indentation
					int currentTokenStartPosition = this.scanner.currentPosition;
					int nextToken = -1;
					try {
						nextToken = this.scanner.getNextToken();
					} catch (InvalidInputException e) {
						// skip
					}
					this.scanner.resetTo(currentTokenStartPosition, this.scannerEndPosition - 1);
					boolean canUseAlignmentIndentation = (nextToken != TerminalTokens.TokenNameLBRACE || this.currentAlignment.kind != Alignment.LOCAL_DECLARATION_ASSIGNMENT);
					if (canUseAlignmentIndentation &&
							(!this.formatBrace ||
									this.currentAlignment.kind == Alignment.ARRAY_INITIALIZER ||
									this.currentAlignment.kind == Alignment.BINARY_EXPRESSION) &&
							this.indentationLevel < this.currentAlignment.breakIndentationLevel) {
						this.indentationLevel = this.currentAlignment.breakIndentationLevel;
					}
					
					// Use the current indentation if over the computed indentation
					if (this.indentationLevel < currentIndentation) {
						this.indentationLevel = currentIndentation;
					}
					
					// Debug
					if (DefaultCodeFormatter.DEBUG) {
						System.out.println(" - format brace = "+this.formatBrace); //$NON-NLS-1$
						System.out.println(" - current column = "+(currentIndentation+1)); //$NON-NLS-1$
						System.out.println(" - current position = "+this.scanner.currentPosition); //$NON-NLS-1$
						System.out.print(" - current line = "); //$NON-NLS-1$
						int linePtr = Arrays.binarySearch(this.lineEnds, this.scanner.currentPosition);
						if (linePtr < 0) {
							linePtr = -linePtr - 1;
						}
						int i = getLineEnd(linePtr)+1;
						char[] source = this.scanner.source;
						int sourceLength = source.length;
						while (i < sourceLength && source[i] != '\r') {
							System.out.print(source[i++]);
						}
						System.out.println();
						System.out.println(" - indentation level = "+this.indentationLevel); //$NON-NLS-1$
						System.out.println();
					}
					
					// Set the flag to indicate that a specific indentation is currently in used
					this.preserveLineBreakIndentation = true;
					
					// Print the computed indentation in the buffer
					printIndentationIfNecessary(this.tempBuffer);
					return this.tempBuffer.toString();
				}
			}
			return Util.EMPTY_STRING;
		}
		if (this.blank_lines_between_import_groups >= 0) {
			return getEmptyLines(this.blank_lines_between_import_groups);
		}
		if (this.formatter.preferences.number_of_empty_lines_to_preserve != 0) {
			int linesToPreserve = Math.min(count, this.formatter.preferences.number_of_empty_lines_to_preserve);
			return getEmptyLines(linesToPreserve);
		}
		return getNewLine();
	}

