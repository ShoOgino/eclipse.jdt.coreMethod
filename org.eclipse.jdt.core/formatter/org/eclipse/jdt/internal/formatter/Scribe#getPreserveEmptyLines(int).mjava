	/*
	 * Preserve empty lines depending on given count and preferences.
	 */
	private String getPreserveEmptyLines(int count) {
		if (count == 0) {
			// preserve line breaks in wrapping if specified
			// see bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=198074
			if (this.currentAlignment != null && !this.formatter.preferences.join_wrapped_lines) {
				// insert a new line only if it has not been already done before
				// see bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=283476
				if (this.lastNumberOfNewLines == 0) {
					// Reset indentation level to the location output
					this.indentationLevel = this.currentAlignment.location.outputIndentationLevel;
					this.numberOfIndentations = this.currentAlignment.location.numberOfIndentations;
					this.formatter.lastLocalDeclarationSourceStart = this.currentAlignment.location.lastLocalDeclarationSourceStart;
					// Create new line keeping the existing indentation
					StringBuffer buffer = new StringBuffer(getNewLine());
					int currentColumn = getCurrentIndentation(this.scanner.currentPosition);
					Alignment rootAlignment = this.currentAlignment;
					while (rootAlignment.enclosing != null) {
						rootAlignment = rootAlignment.enclosing;
					}
					Location location = rootAlignment.location;
					if (currentColumn > location.inputColumn) {
						int savedIndentation = this.indentationLevel;
						this.indentationLevel += currentColumn - location.inputColumn;
						printIndentationIfNecessary(buffer);
						this.indentationLevel = savedIndentation;
					} else {
						printIndentationIfNecessary(buffer);
					}
					return buffer.toString();
				}
			}
			return Util.EMPTY_STRING;
		}
		if (this.formatter.preferences.number_of_empty_lines_to_preserve != 0) {
			int linesToPreserve = Math.min(count, this.formatter.preferences.number_of_empty_lines_to_preserve);
			return getEmptyLines(linesToPreserve);
		}
		return getNewLine();
	}

