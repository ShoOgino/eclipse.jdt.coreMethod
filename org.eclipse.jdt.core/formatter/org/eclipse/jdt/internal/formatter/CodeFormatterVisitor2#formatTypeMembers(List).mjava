	private void formatTypeMembers(List bodyDeclarations) {
		Alignment2 memberAlignment = this.scribe.createMemberAlignment("typeMembers", this.preferences.align_type_members_on_columns ? Alignment.M_MULTICOLUMN : Alignment.M_NO_ALIGNMENT, 3, this.scribe.scanner.currentPosition); //$NON-NLS-1$
		this.scribe.enterMemberAlignment(memberAlignment);
		boolean isChunkStart = false;
		boolean ok = false;
		int startIndex = 0;
		do {
			try {
				for (int i = startIndex, max = bodyDeclarations.size(); i < max; i++) {
					BodyDeclaration bodyDeclaration = (BodyDeclaration) bodyDeclarations.get(i);
					switch(bodyDeclaration.getNodeType()) {
						case ASTNode.FIELD_DECLARATION :
							isChunkStart = memberAlignment.checkChunkStart(Alignment.CHUNK_FIELD, i, this.scribe.scanner.currentPosition);
							FieldDeclaration fieldDeclaration = (FieldDeclaration) bodyDeclaration;
							format(fieldDeclaration, isChunkStart, i == 0);
							break;
						case ASTNode.INITIALIZER :
							isChunkStart = memberAlignment.checkChunkStart(Alignment.CHUNK_FIELD, i, this.scribe.scanner.currentPosition);
							int newLineBeforeChunk = isChunkStart ? this.preferences.blank_lines_before_new_chunk : 0;
							if (newLineBeforeChunk > 0 && i != 0) {
								this.scribe.printEmptyLines(newLineBeforeChunk);
							} else if (i == 0) {
								int newLinesBeforeFirstClassBodyDeclaration = this.preferences.blank_lines_before_first_class_body_declaration;
								if (newLinesBeforeFirstClassBodyDeclaration > 0) {
									this.scribe.printEmptyLines(newLinesBeforeFirstClassBodyDeclaration);
								}
							}
							bodyDeclaration.accept(this);			
							break;
						case ASTNode.METHOD_DECLARATION :
							isChunkStart = memberAlignment.checkChunkStart(Alignment.CHUNK_METHOD, i, this.scribe.scanner.currentPosition);
							MethodDeclaration methodDeclaration = (MethodDeclaration) bodyDeclaration;
							format(methodDeclaration, isChunkStart, i == 0);
							break;
						case ASTNode.TYPE_DECLARATION :
						case ASTNode.ENUM_DECLARATION :
						case ASTNode.ANNOTATION_TYPE_DECLARATION :
							isChunkStart = memberAlignment.checkChunkStart(Alignment.CHUNK_TYPE, i, this.scribe.scanner.currentPosition);
							format((AbstractTypeDeclaration)bodyDeclaration, isChunkStart, i == 0);
					}
					if (isNextToken(TerminalTokens.TokenNameSEMICOLON)) {
						this.scribe.printNextToken(TerminalTokens.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);
						this.scribe.printTrailingComment();
					}
					this.scribe.printNewLine();
					// realign to the proper value
					if (this.scribe.memberAlignment != null) {
						// select the last alignment
						this.scribe.indentationLevel = this.scribe.memberAlignment.originalIndentationLevel;
					}
				}
				ok = true;
			} catch(AlignmentException e){
				startIndex = memberAlignment.chunkStartIndex;
				this.scribe.redoMemberAlignment(e);
			}
		} while (!ok);
		this.scribe.printComment();
		this.scribe.exitMemberAlignment(memberAlignment);
	}

