	private void handleBodyDeclarations(List<BodyDeclaration> bodyDeclarations) {
		BodyDeclaration previous = null;
		for (BodyDeclaration bodyDeclaration : bodyDeclarations) {
			int blankLines = 0;
			if (previous == null) {
				blankLines = this.options.blank_lines_before_first_class_body_declaration;
			} else if (!sameChunk(previous, bodyDeclaration)) {
				blankLines = this.options.blank_lines_before_new_chunk;
			} else if (bodyDeclaration instanceof FieldDeclaration) {
				blankLines = this.options.blank_lines_before_field;
			} else if (bodyDeclaration instanceof AbstractTypeDeclaration) {
				blankLines = this.options.blank_lines_before_member_type;
			} else if (bodyDeclaration instanceof MethodDeclaration) {
				blankLines = ((MethodDeclaration) bodyDeclaration).getBody() == null
						&& ((MethodDeclaration) previous).getBody() == null
								? this.options.blank_lines_before_abstract_method
								: this.options.blank_lines_before_method;
			} else if (bodyDeclaration instanceof AnnotationTypeMemberDeclaration) {
				blankLines = this.options.blank_lines_before_method;
			}
			putBlankLinesBefore(bodyDeclaration, blankLines);
			previous = bodyDeclaration;
		}
		if (previous != null) {
			Token lastToken = this.tm.lastTokenIn(previous.getParent(), -1);
			if (lastToken.tokenType == TokenNameRBRACE) // otherwise it's a fake type
				putBlankLinesBefore(lastToken, this.options.blank_lines_after_last_class_body_declaration);
		}
	}

