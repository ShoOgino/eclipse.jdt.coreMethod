	/**
	 * This method will adapt the selected regions if needed.
	 * If a region should be adapted (see isAdaptableRegion(IRegion))
	 * retrieve correct upper and lower bounds and replace the region.
	 */
	private void adaptRegions() {
		int max = this.regions.length;
		if (max == 1) {
			// It's not necessary to adapt the single region which covers all the source
			if (this.regions[0].getOffset() == 0 && this.regions[0].getLength() == this.scannerEndPosition) {
				this.adaptedRegions = this.regions;
				return;
			}
		}
		this.adaptedRegions = new IRegion[max];
		int commentIndex = 0;
		for (int i = 0; i < max; i++) {
			IRegion aRegion = this.regions[i];
			int offset = aRegion.getOffset();
			int length = aRegion.getLength();

			// First look if the region starts or ends inside a comment
			int index = getCommentIndex(commentIndex, offset);
			int adaptedOffset = offset;
			int adaptedLength = length;
			if (index >= 0) {
				// the offset of the region is inside a comment => restart the region from the comment start
				adaptedOffset = this.commentPositions[index][0];
				if (adaptedOffset < 0) adaptedOffset = -adaptedOffset;
				adaptedLength = length + offset - adaptedOffset;
				commentIndex = index;
				// include also the indentation edit just before the comment if any
				for (int j=0; j<this.editsIndex; j++) {
					int editOffset = this.edits[j].offset;
					int editEnd = editOffset + this.edits[j].length;
					if (editEnd == adaptedOffset) {
						if (j > 0 && this.edits[j].replacement.trim().length() == 0) {
							adaptedLength += adaptedOffset - this.edits[j].offset;
							adaptedOffset = editOffset;
							break;
						}
					} else if (editEnd > adaptedOffset) {
						break;
					}
				}
			}
			index = getCommentIndex(commentIndex, offset+length-1);
			if (index >= 0) {
				// the region end is inside a comment => set the region end at the comment end
				int commentEnd = this.commentPositions[index][1];
				if (commentEnd < 0) commentEnd = -commentEnd;
				adaptedLength = commentEnd - adaptedOffset;
				commentIndex = index;
			}
			if (adaptedLength != length) {
				// adapt the region and jump to next one
				this.adaptedRegions[i] = new Region(adaptedOffset, adaptedLength);
				continue;
			}

			if (offset > 0) {
				if (isAdaptableRegion(offset, length)) {
					// if we have a selection, search for overlapping edits
					int upperBound = offset;
					int lowerBound = 0;
					boolean upperFound = false;
					int regionEnd = offset + length;
					for (int j = 0, max2 = this.editsIndex - 1; j <= max2; j++) {
						// search for lower bound
						int editOffset = this.edits[j].offset;
						if (upperFound && lowerBound == 0) {
							int editLength = this.edits[j].length;
							if (editOffset == regionEnd) { // matching edit found
								lowerBound = regionEnd;
								break;
							} else if (editOffset + editLength < regionEnd) {
								continue;
							} else {
								lowerBound = editOffset + editLength; // upper and lower bounds found
								break;
							}
							// search for upper bound
						} else {
							int next = j+1;
							if (next == max2) {
								// https://bugs.eclipse.org/bugs/show_bug.cgi?id=213284
								// checked all edits, no upper bound found: leave the loop
								break;
							}
							if (this.edits[next].offset < offset) {
								continue;
							} else {
								upperBound = editOffset;
								upperFound = true;
								// verify if region end is at EOF
								if (this.scannerEndPosition == regionEnd) {
									lowerBound = this.scannerEndPosition - 1;
									break;
								}
							}
						}
					}
					if (lowerBound != 0) {
						if (offset != upperBound || regionEnd != lowerBound) { // ensure we found a different region
							this.adaptedRegions[i] = new Region(upperBound,
									lowerBound - upperBound);
						}
						// keep other unadaptable region
					} else {
						this.adaptedRegions[i] = this.regions[i];
					}
				} else {
					this.adaptedRegions[i] = this.regions[i];
				}
			} else {
				this.adaptedRegions[i] = this.regions[i];
			}
		}
	}

