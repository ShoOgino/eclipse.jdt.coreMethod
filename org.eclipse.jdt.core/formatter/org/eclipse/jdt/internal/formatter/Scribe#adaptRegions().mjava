	/**
	 * This method will adapt the selected regions if needed.
	 * If a region should be adapted (see isAdaptableRegion(IRegion))
	 * retrieve correct upper and lower bounds and replace the region.
	 */
	private void adaptRegions() {
		this.adaptedRegions = new IRegion[this.regions.length];
		for (int i = 0, max = this.regions.length; i < max; i++) {
			IRegion aRegion = this.regions[i];
			int offset = aRegion.getOffset();
			if (offset > 0) {
				int length = aRegion.getLength();
				if (isAdaptableRegion(offset, length)) {
					// if we have a selection, search for overlapping edits
					int upperBound = offset;
					int lowerBound = 0;
					boolean upperFound = false;
					int regionEnd = offset + length;
					for (int j = 0, max2 = this.editsIndex; j <= max2; j++) {
						// search for lower bound
						int editOffset = this.edits[j].offset;
						if (upperFound && lowerBound == 0) {
							int editLength = this.edits[j].length;
							if (editOffset == regionEnd) { // matching edit found
								lowerBound = regionEnd;
								break;
							} else if (editOffset + editLength < regionEnd) {
								continue;
							} else {
								lowerBound = editOffset + editLength; // upper and lower bounds found
								break;
							}
							// search for upper bound
						} else {
							int next = j+1;
							if (next == max2) {
								// https://bugs.eclipse.org/bugs/show_bug.cgi?id=213284
								// checked all edits, no upper bound found: leave the loop
								break;
							}
							if (this.edits[next].offset < offset) {
								continue;
							} else {
								upperBound = editOffset;
								upperFound = true;
								// verify if region end is at EOF
								if (this.scannerEndPosition == regionEnd + 1) {
									lowerBound = this.scannerEndPosition;
									break;
								}
							}
						}
					}
					if (lowerBound != 0) {
						if (offset != upperBound || regionEnd != lowerBound) { // ensure we found a different region
							this.adaptedRegions[i] = new Region(upperBound,
									lowerBound - upperBound);
						}
						// keep other unadaptable region
					} else {
						this.adaptedRegions[i] = this.regions[i];
					}
				} else {
					this.adaptedRegions[i] = this.regions[i];
				}
			} else {
				this.adaptedRegions[i] = this.regions[i];
			}
		}
	}

