	private void printJavadocImmutableText(FormatJavadocText text, FormatJavadocBlock block, boolean textOnNewLine) {

		try {
			// Iterate on text line separators
			int textLineStart = text.lineStart;
			this.scanner.tokenizeWhiteSpace = false;
			String newLineString = null;
			for (int idx=0, max=text.separatorsPtr; idx<=max ; idx++) {
				int start = (int) text.separators[idx];
				int lineStart = Util.getLineNumber(start, this.lineEnds, textLineStart-1, this.maxLines);
				while (textLineStart < lineStart) {
					int end = this.lineEnds[textLineStart-1];
					this.scanner.resetTo(end, start);
					int token = this.scanner.getNextToken();
					switch (token) {
						case TerminalTokens.TokenNameMULTIPLY:
						case TerminalTokens.TokenNameMULTIPLY_EQUAL:
							break;
						default:
							return;
					}
					if (this.scanner.currentCharacter == ' ') {
						this.scanner.getNextChar();
					}
					if (newLineString == null) {
						this.tempBuffer.setLength(0);
						this.column = 1;
						printIndentationIfNecessary(this.tempBuffer);
						this.tempBuffer.append(BLOCK_LINE_PREFIX);
						this.column += BLOCK_LINE_PREFIX_LENGTH;
						newLineString = this.tempBuffer.toString();
					}
					addReplaceEdit(end+1, this.scanner.getCurrentTokenEndPosition(), newLineString);
					textLineStart = Util.getLineNumber(this.scanner.currentPosition-1, this.lineEnds, textLineStart, this.maxLines);
				}
			}
		}
		catch (InvalidInputException iie) {
			// leave
		}
		finally {
			// Reset
			this.needSpace = false;
			this.scanner.tokenizeWhiteSpace = true;
			this.scanner.resetTo(text.sourceEnd+1, this.scannerEndPosition - 1);
		}
	}

