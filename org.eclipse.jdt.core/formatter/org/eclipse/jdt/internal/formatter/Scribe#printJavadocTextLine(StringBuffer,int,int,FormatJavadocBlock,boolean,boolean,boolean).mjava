	/*
	 * Returns whether the text has been modified or not.
	 */
	private void printJavadocTextLine(StringBuffer buffer, int textStart, int textEnd, FormatJavadocBlock block, boolean firstText, boolean needIndentation, boolean isHtmlTag) {

		boolean indentRootTags = this.formatter.preferences.comment_indent_root_tags && !block.isInDescription();
		boolean indentParamTag = this.formatter.preferences.comment_indent_parameter_description && block.isInParamTag();
		boolean headerLine = block.isHeaderLine() && this.lastNumberOfNewLines == 0;
		
		// First we need to know what is the indentation
		StringBuffer tokensBuffer = new StringBuffer();
		int firstColumn = 1 + this.indentationLevel + BLOCK_LINE_PREFIX_LENGTH;
		if (headerLine) firstColumn++;
		StringBuffer indentationBuffer = null;
		if (indentRootTags) {
			int indentLevel = this.indentationLevel;
			int indentations = this.numberOfIndentations;
			this.numberOfIndentations += (BLOCK_LINE_PREFIX_LENGTH / this.indentationSize) + 1;
			this.indentationLevel = this.numberOfIndentations * this.indentationSize;
			int currentColumn = this.column;
			this.column = firstColumn;
			if (indentParamTag) {
				this.indentationLevel += this.indentationSize;
				this.numberOfIndentations++;
			}
			printIndentationIfNecessary(indentationBuffer = new StringBuffer());
			if (needIndentation) {
				this.column = firstColumn;
				printIndentationIfNecessary(buffer);
			}
			firstColumn = this.indentationLevel + 1;
			this.column = currentColumn < firstColumn ? firstColumn : currentColumn;
			this.indentationLevel = indentLevel;
			this.numberOfIndentations = indentations;
		} else if (this.column < firstColumn) {
			this.column = firstColumn;
		}

		// Scan the text token per token to compact it and size it the max line length
		int maxColumn = this.formatter.preferences.comment_line_length + 1;
		try {
			this.scanner.resetTo(textStart, textEnd);
			this.scanner.skipComments = true;
			int previousToken = -1;
			boolean openedString  =false;
			boolean hasTokens = false;

			// Consume text token per token
    		while (!this.scanner.atEnd()) {
				int token;
				try {
					token = this.scanner.getNextToken();
				} catch (InvalidInputException iie) {
					boolean insertSpace = previousToken == TerminalTokens.TokenNameWHITESPACE || (this.scanner.startPosition == textStart && this.column > firstColumn && !(firstText || isHtmlTag));
					String msg = iie.getMessage();
					if (msg == Scanner.INVALID_CHARACTER_CONSTANT) {
						if (insertSpace) {
							tokensBuffer.append(' ');
						}
						tokensBuffer.append('\'');
					} else if (msg == Scanner.INVALID_CHAR_IN_STRING) {
						if (openedString) {
							openedString = false;
						} else {
							if (insertSpace) {
								tokensBuffer.append(' ');
							}
							openedString = true;
						}
						tokensBuffer.append('"');
					} else {
						// skip failure
					}
					// Need to retrieve correct position
					this.scanner.resetTo(this.scanner.startPosition, textEnd);
					this.scanner.getNextChar();
					previousToken = 1;
					continue;
				}
				switch (token) {
					case TerminalTokens.TokenNameWHITESPACE:
						previousToken = token;
						buffer.append(tokensBuffer);
						this.column += tokensBuffer.length();
						tokensBuffer.setLength(0);
						hasTokens = true;
						continue;
					case TerminalTokens.TokenNameStringLiteral:
						if (this.scanner.currentPosition > this.scanner.eofPosition) {
							this.scanner.resetTo(this.scanner.startPosition, textEnd);
							this.scanner.getNextChar();
							token = 1;
						}
						break;
					case TerminalTokens.TokenNameCharacterLiteral:
						if (this.scanner.currentPosition > this.scanner.eofPosition) {
							this.scanner.resetTo(this.scanner.startPosition, textEnd);
							this.scanner.getNextChar();
							token = 1;
						}
						break;
				}
    			int tokenStart = this.scanner.getCurrentTokenStartPosition();
	    		int tokenLength = (this.scanner.atEnd() ? this.scanner.eofPosition : this.scanner.currentPosition) - tokenStart;
	    		boolean insertSpace = previousToken == TerminalTokens.TokenNameWHITESPACE || (tokenStart == textStart && this.column > firstColumn && !(firstText || isHtmlTag));
	    		int lastColumn = this.column + tokensBuffer.length() + tokenLength;
	    		if (insertSpace) lastColumn++;
	    		if (headerLine) {
	    			// special case when text is on the same line of the javadoc's header
	    			if (lastColumn > maxColumn)  {
	    				lastColumn--; // new line gives an extra character
	    				this.lastNumberOfNewLines++; // in case we leave just after
	    				this.line++;
	    			}
	    		}
				if (lastColumn > maxColumn) {
					// not enough space on the line
					boolean alreadyHasNewLine = !hasTokens && tokensBuffer.length() > 0 && firstText && !isHtmlTag && this.lastNumberOfNewLines > 0;
					if (!alreadyHasNewLine) {
						if (lastColumn == this.column) {
							this.lastNumberOfNewLines++;
							this.line++;
						}
				    	buffer.append(this.lineSeparator);
				    	this.column = 1;
				    	printIndentationIfNecessary(buffer);
			    		buffer.append(BLOCK_LINE_PREFIX);
				    	this.column = headerLine ? firstColumn-1 : firstColumn;
				    	if (indentationBuffer != null) {
				    		buffer.append(indentationBuffer);
				    	}
					}
			    	if (tokensBuffer.length() > 0) {
			    		String tokensString = tokensBuffer.toString().trim();
						buffer.append(tokensString);
						this.column += tokensString.length();
						tokensBuffer.setLength(0);
			    	}
					buffer.append(this.scanner.source, tokenStart, tokenLength);
					hasTokens = true;
					this.column += tokenLength;
					if (headerLine) {
						firstColumn--;
						headerLine = false;
					}
    			} else {
					// append token to the line
		    		if (insertSpace) {
		    			tokensBuffer.append(' ');
		    		}
					tokensBuffer.append(this.scanner.source, tokenStart, tokenLength);
    			}
				previousToken = token;
    		}
		}
		finally {
			this.scanner.skipComments = false;
			// Add remaining buffered tokens
			if (tokensBuffer.length() > 0) {
				buffer.append(tokensBuffer);
				this.column += tokensBuffer.length();
			}
		}
    }

