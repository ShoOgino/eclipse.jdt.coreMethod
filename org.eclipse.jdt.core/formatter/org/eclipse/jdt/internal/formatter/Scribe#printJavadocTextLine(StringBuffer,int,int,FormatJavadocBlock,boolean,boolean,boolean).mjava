	/*
	 * Returns whether the text has been modified or not.
	 */
	private void printJavadocTextLine(StringBuffer buffer, int textStart, int textEnd, FormatJavadocBlock block, boolean firstText, boolean needIndentation, boolean isHtmlTag) {

		boolean headerLine = block.isHeaderLine() && this.lastNumberOfNewLines == 0;

		// First we need to know what is the indentation
		this.javadocTokensBuffer.setLength(0);
		int firstColumn = 1 + this.indentationLevel + BLOCK_LINE_PREFIX_LENGTH;
		int maxColumn = this.formatter.preferences.comment_line_length + 1;
		if (headerLine) {
			firstColumn++;
			maxColumn++;
		}
		if (needIndentation && this.commentIndentation != null) {
			buffer.append(this.commentIndentation);
	    	this.column += this.commentIndentation.length();
	    	firstColumn += this.commentIndentation.length();
		}
		if (this.column < firstColumn) {
			this.column = firstColumn;
		}

		// Scan the text token per token to compact it and size it the max line length
		String newLineString = null;
		try {
			this.scanner.resetTo(textStart, textEnd);
			this.scanner.skipComments = true;
			int previousToken = -1;
			boolean textOnNewLine = needIndentation;

			// Consume text token per token
    		while (!this.scanner.atEnd()) {
				int token;
				try {
					token = this.scanner.getNextToken();
				} catch (InvalidInputException iie) {
					token = consumeInvalidToken(textEnd);
				}
	    		int tokensBufferLength = this.javadocTokensBuffer.length();
    			int tokenStart = this.scanner.getCurrentTokenStartPosition();
	    		int tokenLength = (this.scanner.atEnd() ? this.scanner.eofPosition : this.scanner.currentPosition) - tokenStart;
				boolean insertSpace = (previousToken == TerminalTokens.TokenNameWHITESPACE || this.needSpace) && !textOnNewLine;
				String tokensBufferString = this.javadocTokensBuffer.toString().trim();
				switch (token) {
					case TerminalTokens.TokenNameWHITESPACE:
						if (tokensBufferLength > 0) {
							boolean shouldSplit = (this.column+tokensBufferLength) > maxColumn // the max length is reached
								&& !isHtmlTag
								&& (insertSpace || tokensBufferLength > 1) // allow to split at the beginning only when starting with an identifier or a token with a length > 1
								&& tokensBufferString.charAt(0) != '@'; // avoid to split just before a '@'
							if (shouldSplit) {
								this.lastNumberOfNewLines++;
								this.line++;
								if (newLineString == null) {
									this.tempBuffer.setLength(0);
									this.tempBuffer.append(this.lineSeparator);
							    	this.column = 1;
							    	printIndentationIfNecessary(this.tempBuffer);
						    		this.tempBuffer.append(BLOCK_LINE_PREFIX);
							    	this.column += BLOCK_LINE_PREFIX_LENGTH;
									if (this.commentIndentation != null) {
										this.tempBuffer.append(this.commentIndentation);
								    	this.column += this.commentIndentation.length();
									}
						    		firstColumn = this.column;
						    		newLineString = this.tempBuffer.toString();
								} else {
									this.column = firstColumn;
								}
								buffer.append(newLineString);
								buffer.append(tokensBufferString);
								this.column += tokensBufferString.length();
								if (headerLine) {
									firstColumn--;
									maxColumn--;
									headerLine = false;
								}
							} else {
								buffer.append(this.javadocTokensBuffer);
								this.column += tokensBufferLength;
							}
							this.javadocTokensBuffer.setLength(0);
						}
						textOnNewLine = false;
						previousToken = token;
						continue;
					case TerminalTokens.TokenNameCharacterLiteral:
						if (this.scanner.currentPosition > this.scanner.eofPosition) {
							this.scanner.resetTo(this.scanner.startPosition, textEnd);
							this.scanner.getNextChar();
							token = 1;
						}
						break;
				}
	    		int lastColumn = this.column + tokensBufferLength + tokenLength;
	    		if (insertSpace) lastColumn++;
				boolean shouldSplit = lastColumn > maxColumn // the max length is reached
					&& (!isHtmlTag || previousToken == -1) // not an html tag or just at the beginning of it
					&& token != TerminalTokens.TokenNameAT && (tokensBufferLength == 0 || this.javadocTokensBuffer.charAt(tokensBufferLength-1) != '@'); // avoid to split just before a '@'
				if (shouldSplit) {
					// not enough space on the line
					if ((tokensBufferLength > 0 || tokenLength < maxColumn) && !isHtmlTag && tokensBufferLength > 0 && (firstColumn+tokensBufferLength+tokenLength) >= maxColumn) {
						// there won't be enough room even if we break the line before the buffered tokens
						// So add the buffered tokens now
						buffer.append(this.javadocTokensBuffer);
						this.column += tokensBufferLength;
						this.javadocTokensBuffer.setLength(0);
						tokensBufferLength = 0;
						textOnNewLine = false;
					}
					if ((tokensBufferLength > 0 || /*(firstColumn+tokenLength) < maxColumn || (insertSpace &&*/ this.column > firstColumn) && (!textOnNewLine || !firstText)) {
						this.lastNumberOfNewLines++;
						this.line++;
						if (newLineString == null) {
							this.tempBuffer.setLength(0);
							this.tempBuffer.append(this.lineSeparator);
					    	this.column = 1;
					    	printIndentationIfNecessary(this.tempBuffer);
				    		this.tempBuffer.append(BLOCK_LINE_PREFIX);
					    	this.column += BLOCK_LINE_PREFIX_LENGTH;
							if (this.commentIndentation != null) {
								this.tempBuffer.append(this.commentIndentation);
						    	this.column += this.commentIndentation.length();
							}
				    		firstColumn = this.column;
				    		newLineString = this.tempBuffer.toString();
						} else {
							this.column = firstColumn;
						}
						buffer.append(newLineString);
					}
			    	if (tokensBufferLength > 0) {
			    		String tokensString = tokensBufferString;
						buffer.append(tokensString);
						this.column += tokensString.length();
						this.javadocTokensBuffer.setLength(0);
						tokensBufferLength = 0;
		    		}
					buffer.append(this.scanner.source, tokenStart, tokenLength);
					this.column += tokenLength;
					textOnNewLine = false;
					if (headerLine) {
						firstColumn--;
						maxColumn--;
						headerLine = false;
					}
    			} else {
					// append token to the line
		    		if (insertSpace) {
		    			this.javadocTokensBuffer.append(' ');
		    		}
					this.javadocTokensBuffer.append(this.scanner.source, tokenStart, tokenLength);
    			}
				previousToken = token;
    			this.needSpace = false;
    			if (headerLine && lastColumn == maxColumn && this.scanner.atEnd()) {
					this.lastNumberOfNewLines++;
					this.line++;
    			}
    		}
		}
		finally {
			this.scanner.skipComments = false;
			// Add remaining buffered tokens
			if (this.javadocTokensBuffer.length() > 0) {
				buffer.append(this.javadocTokensBuffer);
				this.column += this.javadocTokensBuffer.length();
			}
		}
    }

