	private void printJavadocBlockReference(StringBuffer buffer, FormatJavadocReference reference, FormatJavadocBlock block) {

		boolean indentRootTags = this.formatter.preferences.comment_indent_root_tags && !block.isInDescription();
		boolean indentParamTag = this.formatter.preferences.comment_indent_parameter_description && block.isInParamTag();
		boolean headerLine = block.isHeaderLine();
		StringBuffer tokensBuffer = new StringBuffer();
		
		// First we need to know what is the indentation
		int firstColumn = 1 + this.indentationLevel + BLOCK_LINE_PREFIX_LENGTH;
		if (headerLine) firstColumn++;
		StringBuffer indentationBuffer = null;
		if (indentRootTags) {
			int indentLevel = this.indentationLevel;
			int indentations = this.numberOfIndentations;
			this.numberOfIndentations += (BLOCK_LINE_PREFIX_LENGTH / this.indentationSize) + 1;
			this.indentationLevel = this.numberOfIndentations * this.indentationSize;
			int currentColumn = this.column;
			this.column = firstColumn;
			if (indentParamTag) {
				this.indentationLevel += this.indentationSize;
				this.numberOfIndentations++;
			}
			printIndentationIfNecessary(indentationBuffer = new StringBuffer());
			firstColumn = this.indentationLevel + 1;
			this.column = currentColumn;
			this.indentationLevel = indentLevel;
			this.numberOfIndentations = indentations;
		}

		// Scan the text token per token to compact it and size it the max line length
		int maxColumn = this.formatter.preferences.comment_line_length + 1;
		int previousToken = -1;
		this.scanner.resetTo(reference.sourceStart, reference.sourceEnd);
		while (!this.scanner.atEnd()) {
			int token;
			try {
				token = this.scanner.getNextToken();
				switch (token) {
					case TerminalTokens.TokenNameWHITESPACE:
						buffer.append(tokensBuffer);
						this.column += tokensBuffer.length();
						tokensBuffer.setLength(0);
						if (CharOperation.indexOf('\n', this.scanner.source, this.scanner.startPosition, this.scanner.getCurrentTokenEndPosition()) >= 0) {
							// consume line break
							loop: while (true) {
								token = this.scanner.getNextToken();
								switch (token) {
									case TerminalTokens.TokenNameWHITESPACE:
									case TerminalTokens.TokenNameMULTIPLY:
										previousToken = token; // will not insert space
										continue;
									default:
										break loop;
								}
							}
							break;
						}
						previousToken = token;
						continue;
					case TerminalTokens.TokenNameMULTIPLY:
						previousToken = token;
						continue;
				}
			} catch (InvalidInputException iie) {
				continue;
			}
			int tokenStart = this.scanner.getCurrentTokenStartPosition();
    		int tokenLength = (this.scanner.atEnd() ? this.scanner.eofPosition : this.scanner.currentPosition) - tokenStart;
    		int lastColumn = this.column + tokensBuffer.length() + tokenLength;
    		boolean insertSpace = previousToken == TerminalTokens.TokenNameWHITESPACE || previousToken == -1;
    		if (insertSpace) lastColumn++;
    		if (headerLine) {
    			// special case when text is on the same line of the javadoc's header
    			if (lastColumn > maxColumn)  {
    				lastColumn--; // new line gives an extra character
    			}
    		}
			if (lastColumn > maxColumn) {
		    	String tokensString = tokensBuffer.toString().trim();
		    	int indentLength = indentationBuffer==null ? 0 : indentationBuffer.length();
				if ((firstColumn-1+indentLength+tokensString.length()+tokenLength) > maxColumn) {
					// there won't be enough room even if we break the line before the buffered tokens
					// So add the buffered tokens now
					if (buffer.length() == 0) {
						buffer.append(' ');
						this.column++;
					}
					buffer.append(tokensString);
					this.column += tokensString.length();
					tokensBuffer.setLength(0);
				}
				// not enough space on the line
				this.lastNumberOfNewLines++;
				this.line++;
		    	buffer.append(this.lineSeparator);
		    	this.column = 1;
		    	printIndentationIfNecessary(buffer);
	    		buffer.append(BLOCK_LINE_PREFIX);
		    	this.column = headerLine ? firstColumn-1 : firstColumn;
		    	if (indentationBuffer != null) {
		    		buffer.append(indentationBuffer);
		    	}
		    	if (tokensBuffer.length() > 0) {
					buffer.append(tokensString);
					this.column += tokensString.length();
					tokensBuffer.setLength(0);
		    	}
				buffer.append(this.scanner.source, tokenStart, tokenLength);
				this.column += tokenLength;
				if (headerLine) {
					firstColumn--;
					headerLine = false;
				}
			} else {
				// append token to the line
				if (insertSpace) {
					tokensBuffer.append(' ');
				}
				tokensBuffer.append(this.scanner.source, tokenStart, tokenLength);
			}
			previousToken = token;
		}
		if (tokensBuffer.length() > 0) {
			buffer.append(tokensBuffer);
			this.column += tokensBuffer.length();
		}
    }

