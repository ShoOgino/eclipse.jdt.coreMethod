	public boolean visit(EnumDeclaration enumDeclaration, BlockScope scope) {
        /*
         * Print comments to get proper line number
         */
        this.scribe.printComment();
        final int line = this.scribe.line; 
        
        this.scribe.printModifiers(enumDeclaration.annotations, this);
		this.scribe.printNextToken(TerminalTokens.TokenNameenum, true); 
		this.scribe.printNextToken(TerminalTokens.TokenNameIdentifier, true); 

		/* 
		 * Super Interfaces 
		 */
		final TypeReference[] superInterfaces = enumDeclaration.superInterfaces;
		if (superInterfaces != null) {
			int superInterfaceLength = superInterfaces.length;
			Alignment interfaceAlignment =this.scribe.createAlignment(
					"superInterfaces",//$NON-NLS-1$
					this.preferences.alignment_for_superinterfaces_in_enum_declaration,
					superInterfaceLength+1,  // implements token is first fragment
					this.scribe.scanner.currentPosition);
			this.scribe.enterAlignment(interfaceAlignment);
			boolean ok = false;
			do {
				try {
					this.scribe.alignFragment(interfaceAlignment, 0);
					this.scribe.printNextToken(TerminalTokens.TokenNameimplements, true);
					for (int i = 0; i < superInterfaceLength; i++) {
						if (i > 0) {
							this.scribe.printNextToken(TerminalTokens.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_superinterfaces);
							this.scribe.printTrailingComment();
							this.scribe.alignFragment(interfaceAlignment, i + 1);
							if (this.preferences.insert_space_after_comma_in_superinterfaces) {
								this.scribe.space();
							}
							superInterfaces[i].traverse(this, scope);
						} else {
							this.scribe.alignFragment(interfaceAlignment, i + 1);
							this.scribe.space();
							superInterfaces[i].traverse(this, scope);
						}
					}
					ok = true;
				} catch (AlignmentException e) {
					this.scribe.redoAlignment(e);
				}
			} while (!ok);
			this.scribe.exitAlignment(interfaceAlignment, true);
		}

		/*
		 * Type body
		 */
		String enum_declaration_brace = this.preferences.brace_position_for_enum_declaration;

        formatLeftCurlyBrace(line, enum_declaration_brace);
		formatTypeOpeningBrace(enum_declaration_brace, this.preferences.insert_space_before_opening_brace_in_enum_declaration, enumDeclaration);
		
		if (this.preferences.indent_body_declarations_compare_to_type_header) {
			this.scribe.indent();
		}

		EnumConstant[] enumConstants = enumDeclaration.enumConstants;
		if (enumConstants != null) {
			int length = enumConstants.length;
			for (int i = 0; i < length; i++) {
				if (i < length - 1) {
					enumConstants[i].traverse(this, enumDeclaration.scope);					
					this.scribe.printNextToken(TerminalTokens.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_enum_declarations);
					if (this.preferences.insert_space_after_comma_in_enum_declarations) {
						this.scribe.space();
					}
					this.scribe.printTrailingComment();
				} else if (isComma()) {
					this.scribe.printNextToken(TerminalTokens.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_enum_declarations);
					if (this.preferences.insert_space_after_comma_in_enum_declarations) {
						this.scribe.space();
					}
					this.scribe.printTrailingComment();
				}
			}
			this.scribe.printNextToken(TerminalTokens.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);
			this.scribe.printTrailingComment();
		} else {
			this.scribe.printNewLine();
			this.scribe.printNextToken(TerminalTokens.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);
			this.scribe.printTrailingComment();
		}
		
		formatTypeMembers(enumDeclaration);

		this.scribe.printComment();
		
		if (this.preferences.indent_body_declarations_compare_to_enum_declaration_header) {
			this.scribe.unIndent();
		}
		
		if (this.preferences.insert_new_line_in_empty_enum_declaration) {
			this.scribe.printNewLine();
		}
		this.scribe.printNextToken(TerminalTokens.TokenNameRBRACE);
		this.scribe.printTrailingComment();
		if (enum_declaration_brace.equals(DefaultCodeFormatterConstants.NEXT_LINE_SHIFTED)) {
			this.scribe.unIndent();
		}
		if (hasComments()) {
			this.scribe.printNewLine();
		}
		return false;
	}

