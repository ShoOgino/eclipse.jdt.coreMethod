	private void printLineComment(int commentStart, int commentEnd) {

		// Compute indentation
		int firstColumn = this.column;
		int indentLevel = this.indentationLevel;
		int indentations = this.numberOfIndentations;
		this.indentationLevel = (this.column / this.tabLength) * this.tabLength;
		this.numberOfIndentations = this.indentationLevel / this.indentationSize;

		// Consume the comment prefix
		this.scanner.resetTo(commentStart, commentEnd);
		StringBuffer buffer = new StringBuffer();
		this.scanner.getNextChar();
		buffer.append(this.scanner.currentCharacter);
		this.scanner.getNextChar();
		buffer.append(this.scanner.currentCharacter);
		this.column += 2;
		StringBuffer tokensBuffer = new StringBuffer();
		boolean bufferHasTokens = false;

		// Scan the text token per token to compact it and size it the max line length
		int maxColumn = this.formatter.preferences.comment_line_length + 1;
		int previousToken = -1;
		int previousPosition = commentStart;
		char previousChar = 0;
		boolean firstWord = true;
		this.scanner.skipComments = true;

		// Consume text token per token
		while (!this.scanner.atEnd()) {
			int token;
			try {
				token = this.scanner.getNextToken();
			} catch (InvalidInputException iie) {
	    		if (previousToken == -1 || previousToken == TerminalTokens.TokenNameWHITESPACE) {
	    			tokensBuffer.append(' ');
	    		}
				this.scanner.resetTo(this.scanner.startPosition, commentEnd);
	    		char ch = (char) this.scanner.getNextChar();
				previousToken = TerminalTokens.TokenNameWHITESPACE;
				while (!ScannerHelper.isWhitespace(ch)) {
					tokensBuffer.append(ch);
					if (this.scanner.atEnd()) {
						previousToken = TerminalTokens.TokenNameEOF;
						break;
					}
					ch = (char) this.scanner.getNextChar();
				}
				continue;
			}
			switch (token) {
				case TerminalTokens.TokenNameWHITESPACE:
					previousToken = token;
					if (tokensBuffer.length() > 0) {
						buffer.append(tokensBuffer);
						this.column += tokensBuffer.length();
						tokensBuffer.setLength(0);
						bufferHasTokens = true;
					}
					previousPosition = this.scanner.currentPosition;
					previousChar = this.scanner.currentCharacter;
					continue;
				case TerminalTokens.TokenNameEOF:
					continue;
			}
			int tokenStart = this.scanner.getCurrentTokenStartPosition();
    		int tokenLength = (this.scanner.atEnd() ? this.scanner.eofPosition : this.scanner.currentPosition) - tokenStart;
    		boolean insertSpace = previousToken == -1 || previousToken == TerminalTokens.TokenNameWHITESPACE;
    		int lastColumn = this.column + tokensBuffer.length() + tokenLength;
    		if (insertSpace) lastColumn++;
			if (!firstWord && lastColumn > maxColumn) {
				// not enough space on the line
				this.line++;
				if ((firstColumn+tokensBuffer.length()+tokenLength) > maxColumn) {
					// there won't be enough room even if we break the line before the buffered tokens
					// So add the buffered tokens now
					buffer.append(tokensBuffer);
					this.column += tokensBuffer.length();
					tokensBuffer.setLength(0);
					bufferHasTokens = true;
				}
				if (bufferHasTokens) {
			    	buffer.append(this.lineSeparator);
			    	this.column = 1;
			    	printIndentationIfNecessary(buffer);
	    			buffer.append(LINE_COMMENT_PREFIX);
		    		this.column += LINE_COMMENT_PREFIX_LENGTH;
				}
		    	if (tokensBuffer.length() > 0) {
		    		if (ScannerHelper.isWhitespace(tokensBuffer.charAt(0))) {
						buffer.append(tokensBuffer.substring(1));
						this.column += tokensBuffer.length() - 1;
		    		} else {
						buffer.append(tokensBuffer);
						this.column += tokensBuffer.length();
		    		}
					tokensBuffer.setLength(0);
					if (insertSpace)  {
		    			buffer.append(' ');
		    			this.column++;
					}
		    	}
				buffer.append(this.scanner.source, tokenStart, tokenLength);
				bufferHasTokens = true;
				this.column += tokenLength;
				firstColumn = this.indentationLevel + LINE_COMMENT_PREFIX_LENGTH;
			} else {
				// append token to the line
				if (insertSpace)  {
	    			tokensBuffer.append(' ');
				}
				tokensBuffer.append(this.scanner.source, tokenStart, tokenLength);
			}
			previousToken = token;
			previousPosition = this.scanner.currentPosition;
			previousChar = this.scanner.currentCharacter;
			firstWord = false;
		}

		// Add remaining buffered tokens
		if (tokensBuffer.length() > 0) {
			buffer.append(tokensBuffer);
			this.column += tokensBuffer.length();
		}

		// Append separator if the comment is not at the end of file
		this.indentationLevel = indentLevel;
		this.numberOfIndentations = indentations;
		this.lastNumberOfNewLines = 0;
		if (previousChar == '\n' || previousChar == '\r') {
			// line comment is normally ended with new line
			this.column = 1;
			buffer.append(this.lineSeparator);
			this.line++;
			this.lastNumberOfNewLines++;
		} else {
			this.scanner.resetTo(previousPosition, commentEnd);
			while (!this.scanner.atEnd()) {
				this.scanner.getNextChar();
				if (this.scanner.currentCharacter == '\n' || this.scanner.currentCharacter == '\r') {
					// line comment is normally ended with new line
					buffer.append(this.lineSeparator);
					this.column = 1;
					this.line++;
					this.lastNumberOfNewLines++;
					break;
				}
			}
		}

		// Replace the existing comment with new one
		addReplaceEdit(commentStart, commentEnd, buffer.toString());
		this.scanner.skipComments = false;
	}

