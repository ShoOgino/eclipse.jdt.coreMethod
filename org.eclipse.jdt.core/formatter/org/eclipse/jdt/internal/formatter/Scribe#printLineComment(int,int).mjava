	private void printLineComment(int commentStart, int commentEnd) {

		// Compute indentation
		int firstColumn = this.column;
		int indentLevel = this.indentationLevel;
		int indentations = this.numberOfIndentations;
		this.indentationLevel = getNextIndentationLevel(firstColumn);
		this.numberOfIndentations = this.indentationLevel / this.indentationSize;

		// Consume the comment prefix
		StringBuffer buffer = new StringBuffer();
		this.scanner.getNextChar();
		buffer.append(this.scanner.currentCharacter);
		this.scanner.getNextChar();
		buffer.append(this.scanner.currentCharacter);
		this.column += 2;

		// Scan the text token per token to compact it and size it the max line length
		int maxColumn = this.formatter.preferences.comment_line_length + 1;
		int previousToken = -1;
		int previousPosition = commentStart;
		char previousChar = 0;
		boolean firstWord = true;

		// Consume text token per token
		while (!this.scanner.atEnd()) {
			int token;
			try {
				token = this.scanner.getNextToken();
			} catch (InvalidInputException iie) {
				String msg = iie.getMessage();
				if (msg == Scanner.INVALID_CHARACTER_CONSTANT) {
					buffer.append('\'');
				} else if (msg == Scanner.INVALID_CHAR_IN_STRING) {
					buffer.append('"');
				} else {
					// skip failure
				}
				// Need to retrieve correct position
				this.scanner.resetTo(this.scanner.startPosition, commentEnd);
				this.scanner.getNextChar();
				this.column++;
				continue;
			}
			switch (token) {
				case TerminalTokens.TokenNameWHITESPACE:
					previousToken = token;
					previousPosition = this.scanner.currentPosition;
					previousChar = this.scanner.currentCharacter;
					continue;
				case TerminalTokens.TokenNameEOF:
					continue;
			}
			int tokenStart = this.scanner.getCurrentTokenStartPosition();
    		int tokenLength = (this.scanner.atEnd() ? this.scanner.eofPosition : this.scanner.currentPosition) - tokenStart;
    		boolean insertSpace = previousToken == TerminalTokens.TokenNameWHITESPACE;
			this.column += tokenLength;
    		if (previousToken == -1 || insertSpace) this.column++;
    		int col = column; 
			if (!firstWord && col > maxColumn) {
				// not enough space on the line
				this.line++;
		    	buffer.append(this.lineSeparator);
		    	this.column = 1;
		    	printIndentationIfNecessary(buffer);
	    		buffer.append(LINE_COMMENT_PREFIX);
		    	this.column = firstColumn + LINE_COMMENT_PREFIX_LENGTH;
				buffer.append(this.scanner.source, tokenStart, tokenLength);
				this.column += tokenLength;
			} else {
				// append token to the line
				if (previousToken == -1 || insertSpace)  {
	    			buffer.append(' ');
				}
				buffer.append(this.scanner.source, tokenStart, tokenLength);
			}
			previousToken = token;
			previousPosition = this.scanner.currentPosition;
			previousChar = this.scanner.currentCharacter;
			firstWord = false;
		}

		// Append separator if the comment is not at the end of file
		this.indentationLevel = indentLevel;
		this.numberOfIndentations = indentations;
		this.lastNumberOfNewLines = 0;
		if (previousChar == '\n' || previousChar == '\r') {
			// line comment is normally ended with new line
			this.column = 1;
			buffer.append(this.lineSeparator);
			this.line++;
			this.lastNumberOfNewLines++;
		} else if (previousPosition < commentEnd) {
			this.scanner.resetTo(previousPosition, commentEnd);
			while (!this.scanner.atEnd()) {
				this.scanner.getNextChar();
				if (this.scanner.currentCharacter == '\n' || this.scanner.currentCharacter == '\r') {
					// line comment is normally ended with new line
					buffer.append(this.lineSeparator);
					this.column = 1;
					this.line++;
					this.lastNumberOfNewLines++;
					break;
				}
			}
		}

		// Replace the existing comment with new one
		addReplaceEdit(commentStart, commentEnd-1, buffer.toString());
	}

