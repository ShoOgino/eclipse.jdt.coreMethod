	/*
	 * Merged traversal of member (types, fields, methods)
	 */
	private void formatTypeMembers(TypeDeclaration typeDeclaration) {
		
		Alignment memberAlignment = this.scribe.createAlignment("typeMembers", this.preferences.type_member_alignment, 3, this.scribe.scanner.currentPosition); //$NON-NLS-1$
		this.scribe.enterAlignment(memberAlignment);
		AstNode[] members = computeMergedMemberDeclarations(typeDeclaration);
		boolean isChunkStart = false;
		boolean ok = false;
		int startIndex = 0;
		do {
			try {
				for (int i = startIndex, max = members.length; i < max; i++) {
					AstNode member = members[i];
					if (member instanceof FieldDeclaration) {
						isChunkStart = memberAlignment.checkChunkStart(Alignment.CHUNK_FIELD, i, this.scribe.scanner.currentPosition);
						if (member instanceof MultiFieldDeclaration){
							MultiFieldDeclaration multiField = (MultiFieldDeclaration) member;
							
							if (multiField.isStatic()) {
								format(multiField, this, typeDeclaration.staticInitializerScope, isChunkStart);
							} else {
								format(multiField, this, typeDeclaration.initializerScope, isChunkStart);
							}					
						} else if (member instanceof Initializer) {
							int newLineBeforeChunk = isChunkStart ? this.preferences.blank_lines_before_new_chunk : 0;
							if (newLineBeforeChunk > 0) {
								this.scribe.printNewLines(newLineBeforeChunk);
							}
							Initializer initializer = (Initializer) member;
							if (initializer.isStatic()) {
								initializer.traverse(this, typeDeclaration.staticInitializerScope);
							} else {
								initializer.traverse(this, typeDeclaration.initializerScope);
							}					
						} else {
							FieldDeclaration field = (FieldDeclaration) member;
							if (field.isStatic()) {
								format(field, this, typeDeclaration.staticInitializerScope, isChunkStart);
							} else {
								format(field, this, typeDeclaration.initializerScope, isChunkStart);
							}					
						}
					} else if (member instanceof AbstractMethodDeclaration) {
						isChunkStart = memberAlignment.checkChunkStart(Alignment.CHUNK_METHOD, i, this.scribe.scanner.currentPosition);
						format((AbstractMethodDeclaration) member, typeDeclaration.scope, isChunkStart);
					} else {
						isChunkStart = memberAlignment.checkChunkStart(Alignment.CHUNK_TYPE, i, this.scribe.scanner.currentPosition);
						format((MemberTypeDeclaration)member, typeDeclaration.scope, isChunkStart);
					}
					if (isSemiColon()) {
						this.scribe.printNextToken(ITerminalSymbols.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);
						this.scribe.printTrailingComment();
						this.scribe.printNewLine();
					}
				}
				ok = true;
			} catch(AlignmentException e){
				startIndex = memberAlignment.chunkStartIndex;
				this.scribe.redoAlignment(e);
			}
		} while (!ok);		
		this.scribe.exitAlignment(memberAlignment, true);
	}

