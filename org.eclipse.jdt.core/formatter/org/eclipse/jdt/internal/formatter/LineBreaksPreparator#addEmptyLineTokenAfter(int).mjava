	private void addEmptyLineTokenAfter(int tokenIndex) {
		if (tokenIndex + 1 >= this.tm.size())
			return;
		Token token = this.tm.get(tokenIndex);
		Token next = this.tm.get(tokenIndex + 1);
		if (this.tm.countLineBreaksBetween(token, next) < 2 || !this.options.indent_empty_lines)
			return;

		// find a line break and make a token out of it
		for (int i = token.originalEnd + 1; i < next.originalStart; i++) {
			char c = this.tm.charAt(i);
			char c2 = this.tm.charAt(i + 1);
			int lineBreakStart = (c == '\r' || c == '\n') ? i : -1;
			int lineBreakEnd = ((c2 == '\r' || c2 == '\n') && c2 != c) ? i + 1 : lineBreakStart;
			if (lineBreakStart >= 0) {
				Token emptyLineToken = new Token(lineBreakStart, lineBreakEnd, Token.TokenNameEMPTY_LINE);
				emptyLineToken.breakBefore();
				emptyLineToken.breakAfter();
				emptyLineToken.setToEscape(true); // force text builder to use toString()
				this.tm.insert(tokenIndex + 1, emptyLineToken);
				return;
			}
		}
		assert false;
	}

