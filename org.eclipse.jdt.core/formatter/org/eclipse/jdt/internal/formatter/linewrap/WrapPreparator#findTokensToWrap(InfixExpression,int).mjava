	private void findTokensToWrap(InfixExpression node, int depth) {
		Expression left = node.getLeftOperand();
		if (left instanceof InfixExpression && samePrecedence(node, (InfixExpression) left)) {
			findTokensToWrap((InfixExpression) left, depth + 1);
		} else if (this.wrapIndexes.isEmpty() // always add first operand, it will be taken as wrap parent
				|| !this.options.wrap_before_binary_operator) {
			this.wrapIndexes.add(this.tm.firstIndexIn(left, -1));
		}

		Expression right = node.getRightOperand();
		List<Expression> extended = node.extendedOperands();
		for (int i = -1; i < extended.size(); i++) {
			Expression operand = (i == -1) ? right : extended.get(i);
			if (operand instanceof InfixExpression && samePrecedence(node, (InfixExpression) operand)) {
				findTokensToWrap((InfixExpression) operand, depth + 1);
			}
			if (this.options.wrap_before_binary_operator) {
				int index = this.tm.firstIndexBefore(operand, -1);
				while (this.tm.get(index).isComment())
					index--;
				assert node.getOperator().toString().equals(this.tm.toString(index));
				this.wrapIndexes.add(index);
			} else {
				this.wrapIndexes.add(this.tm.firstIndexIn(operand, -1));
			}
		}
	}

