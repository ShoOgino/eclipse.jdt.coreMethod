	private boolean shouldWrap() {
		int lineLenght = this.options.comment_line_length;
		if (this.wrapDisabled || this.counter <= lineLenght)
			return false;
		if (this.potentialWrapToken != null && this.potentialWrapTokenSubstitute != null
				&& this.counterIfWrapped > lineLenght && this.counterIfWrappedSubstitute < this.counterIfWrapped) {
			// there is a normal token to wrap, but the line would overflow anyway - better use substitute
			this.potentialWrapToken = null;
		}
		if (this.potentialWrapToken == null && this.potentialWrapTokenSubstitute == null) {
			boolean isFormattingEnabled = this.blockStructure.size() > 1
					&& this.blockStructure.get(1).tokenType == TokenNameNotAToken;
			if (isFormattingEnabled) {
				// can't wrap, but the long comment cannot stay in one line
				this.lineCounter = Math.max(this.lineCounter, 3);
			}
			return false;
		}

		if (this.options.comment_new_lines_at_javadoc_boundaries) {
			if (getNext() == null) { // the closing token will go to the next line anyway
				this.lineCounter = Math.max(this.lineCounter, 3);
				return false;
			}
			if (this.lineCounter == 1) {
				// when wrapping the first line of javadoc (more asterisks in opening token), the line will
				// move to the left so it may not need wrapping in the end
				int openingTokenLength = this.tm.getLength(this.blockStructure.get(0), 0);
				if (this.counter - (openingTokenLength - 2) <= lineLenght) {
					this.counter -= (openingTokenLength - 2);
					this.lineCounter = Math.max(this.lineCounter, 3);
					return false;
				}
			}
		}
		return true;
	}

