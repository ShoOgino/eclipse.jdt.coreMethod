	@Override
	public boolean visit(ArrayInitializer node) {
		List<Expression> expressions = node.expressions();
		if (!expressions.isEmpty()) {
			for (Expression expression : expressions)
				this.wrapIndexes.add(this.tm.firstIndexIn(expression, -1));
			this.wrapParentIndex = this.tm.firstIndexBefore(expressions.get(0), TokenNameLBRACE);
			this.wrapGroupEnd = this.tm.lastIndexIn(node, -1);
			handleWrap(this.options.alignment_for_expressions_in_array_initializer, node);
		}
		if (!this.options.join_wrapped_lines
				&& !this.options.insert_new_line_before_closing_brace_in_array_initializer) {
			// if there is a line break before the closing brace, formatter should treat it as a valid wrap to preserve
			int closingBraceIndex = this.tm.lastIndexIn(node, TokenNameRBRACE);
			Token closingBrace = this.tm.get(closingBraceIndex);
			if (this.tm.countLineBreaksBetween(this.tm.get(closingBraceIndex - 1), closingBrace) == 1) {
				int openingBraceIndex = this.tm.firstIndexIn(node, TokenNameLBRACE);
				closingBrace.setWrapPolicy(
						new WrapPolicy(0, openingBraceIndex, this.currentDepth, 1, true, false, -1, false));
			}
		}
		return true;
	}

