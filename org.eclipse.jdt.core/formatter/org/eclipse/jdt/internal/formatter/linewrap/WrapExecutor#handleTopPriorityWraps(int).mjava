	/**
	 * @return index of the first token in the top priority group that given token belongs to or -1 if it doesn't belong
	 *         to any top priority.
	 */
	private int handleTopPriorityWraps(int wrapIndex) {
		// wrap all tokens in the same top priority group and jump back to the first one
		WrapPolicy wrapPolicy = this.tm.get(wrapIndex).getWrapPolicy();
		if (wrapPolicy == null || !wrapPolicy.isTopPriority() || this.usedTopPriorityWraps.contains(wrapPolicy))
			return -1;
		int firstTokenIndex = -1;
		int parentIndex = wrapPolicy.wrapParentIndex;
		for (int i = wrapIndex; i > parentIndex; i--) {
			Token token = this.tm.get(i);
			wrapPolicy = token.getWrapPolicy();
			if (wrapPolicy != null && wrapPolicy.wrapParentIndex == parentIndex) {
				if (wrapPolicy.isTopPriority()) {
					token.breakBefore();
					firstTokenIndex = i;
					this.usedTopPriorityWraps.add(wrapPolicy);
				}
				if (wrapPolicy.isFirstInGroup)
					break;
			}
		}
		boolean breakAfterPrevious = false;
		for (int i = wrapIndex + 1; i < this.tm.size(); i++) {
			Token token = this.tm.get(i);
			wrapPolicy = token.getWrapPolicy();
			if (wrapPolicy == null && (token.getLineBreaksBefore() > 0 || breakAfterPrevious)) {
				break;
			} else if (wrapPolicy != null && wrapPolicy.wrapParentIndex == parentIndex) {
				if (wrapPolicy.isFirstInGroup)
					break;
				if (wrapPolicy.isTopPriority()) {
					token.breakBefore();
					this.usedTopPriorityWraps.add(wrapPolicy);
				}
			}
			breakAfterPrevious = token.getLineBreaksAfter() > 0;
		}
		return firstTokenIndex;
	}

