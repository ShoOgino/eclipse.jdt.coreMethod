	private void preserveExistingLineBreaks() {
		// normally n empty lines = n+1 line breaks, but not at the file start and end
		Token first = this.tm.get(0);
		int startingBreaks = first.getLineBreaksBefore();
		first.clearLineBreaksBefore();
		first.putLineBreaksBefore(startingBreaks - 1);

		this.tm.traverse(0, new TokenTraverser() {
			DefaultCodeFormatterOptions options2 = WrapPreparator.this.options;

			@Override
			protected boolean token(Token token, int index) {
				int lineBreaks = getLineBreaksBetween(getPrevious(), token);
				if (index > WrapPreparator.this.importsStart && index < WrapPreparator.this.importsEnd) {
					lineBreaks = lineBreaks > 1 ? (this.options2.blank_lines_between_import_groups + 1) : 0;
				} else {
					lineBreaks = Math.min(lineBreaks, this.options2.number_of_empty_lines_to_preserve + 1);
				}
				if (lineBreaks <= getLineBreaksBefore())
					return true;

				if (!this.options2.join_wrapped_lines && token.isWrappable() && lineBreaks == 1) {
					token.breakBefore();
				} else if (lineBreaks > 1) {
					if (index == 0)
						lineBreaks--;
					token.putLineBreaksBefore(lineBreaks);
				}
				return true;
			}

			private int getLineBreaksBetween(Token token1, Token token2) {
				if (token1 != null) {
					List<Token> structure1 = token1.getInternalStructure();
					if (structure1 != null && !structure1.isEmpty())
						token1 = structure1.get(structure1.size() - 1);
				}
				List<Token> structure2 = token2.getInternalStructure();
				if (structure2 != null && !structure2.isEmpty())
					token2 = structure2.get(0);
				int lineBreaks = WrapPreparator.this.tm.countLineBreaksBetween(token1, token2);
				if (token1 == null)
					lineBreaks++;
				return lineBreaks;
			}
		});

		Token last = this.tm.get(this.tm.size() - 1);
		last.clearLineBreaksAfter();
		int endingBreaks = this.tm.countLineBreaksBetween(last, null);
		endingBreaks = Math.min(endingBreaks, this.options.number_of_empty_lines_to_preserve);
		if (endingBreaks > 0) {
			last.putLineBreaksAfter(endingBreaks);
		} else if ((this.kind & CodeFormatter.K_COMPILATION_UNIT) != 0
				&& this.options.insert_new_line_at_end_of_file_if_missing) {
			last.breakAfter();
		}
	}

