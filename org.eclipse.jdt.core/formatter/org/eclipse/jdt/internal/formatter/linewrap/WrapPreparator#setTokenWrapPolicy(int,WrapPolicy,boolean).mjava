	private void setTokenWrapPolicy(int index, WrapPolicy policy, boolean wrapPreceedingComments) {
		if (wrapPreceedingComments) {
			for (int i = index - 1; i >= 0; i--) {
				Token previous = this.tm.get(i);
				if (!previous.isComment())
					break;
				if (previous.getLineBreaksAfter() == 0 && i == index - 1)
					index = i;
				if (previous.getLineBreaksBefore() > 0)
					previous.setWrapPolicy(policy);
			}
		}

		Token token = this.tm.get(index);
		token.setWrapPolicy(policy);
		if (this.options.join_wrapped_lines
				&& (token.tokenType == TokenNameCOMMENT_BLOCK || token.tokenType == TokenNameCOMMENT_JAVADOC)) {
			// allow wrap preparator to decide if this comment should be wrapped
			token.clearLineBreaksBefore();
		}

		// extend this policy to a token that is in the next line because of comments
		for (int i = index + 1; i < this.tm.size(); i++) {
			Token next = this.tm.get(i);
			WrapPolicy policy2 = next.getWrapPolicy();
			if (policy2 != null && policy2.isForced && policy2.extraIndent == 0) {
				next.setWrapPolicy(policy);
			} else if (next.tokenType != TokenNameCOMMENT_LINE && next.tokenType != TokenNameCOMMENT_BLOCK) {
				break;
			}
		}
	}

