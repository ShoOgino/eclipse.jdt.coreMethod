	/**
	 * The main algorithm that looks for optimal places to wrap.
	 * Calls itself recursively to get results for wrapped sub-lines.  
	 */
	private WrapResult findWraps(int wrapTokenIndex, int indent) {
		final int lastIndex = this.lineAnalyzer.analyzeLine(wrapTokenIndex, indent);
		final boolean lineExceeded = this.lineAnalyzer.lineExceeded;
		final int lastPosition = this.lineAnalyzer.getLastPosition();
		int extraLines = this.lineAnalyzer.extraLines;
		final int firstPotentialWrap = this.lineAnalyzer.firstPotentialWrap;

		final int[] extraLinesPerComment = toArray(this.lineAnalyzer.extraLinesPerComment);
		int commentIndex = extraLinesPerComment.length;

		final int[] topPriorityGroupStarts = toArray(this.lineAnalyzer.topPriorityGroupStarts);
		int topPriorityIndex = topPriorityGroupStarts.length - 1;
		int nearestGroupEnd = topPriorityIndex == -1 ? 0
				: this.tm.get(topPriorityGroupStarts[topPriorityIndex]).getWrapPolicy().topPriorityGroupEnd;

		double bestTotalPenalty = getWrapPenalty(wrapTokenIndex, indent, lastIndex + 1, -1, WrapResult.NO_WRAP_NEEDED);
		int bestExtraLines = lineExceeded ? Integer.MAX_VALUE : extraLines; // if line is exceeded, accept every wrap
		int bestNextWrap = -1;
		int bestIndent = 0;

		if (!lineExceeded && (!this.options.join_wrapped_lines || !this.options.wrap_outer_expressions_when_nested))
			return new WrapResult(bestTotalPenalty, bestExtraLines, null);

		if ((!lineExceeded || firstPotentialWrap < 0) && lastIndex + 1 < this.tm.size()) {
			Token nextLineToken = this.tm.get(lastIndex + 1);
			if (nextLineToken.isWrappable() && (this.tm.get(lastIndex).isComment() || nextLineToken.isComment())) {
				// this might be a pre-existing wrap forced by a comment, calculate penalties as normal
				bestIndent = getWrapIndent(nextLineToken);
				bestNextWrap = lastIndex + 1;
				WrapResult wrapResult = findWrapsCached(bestNextWrap, bestIndent);
				bestTotalPenalty = getWrapPenalty(wrapTokenIndex, indent, bestNextWrap, bestIndent, wrapResult);
				bestExtraLines = extraLines + wrapResult.totalExtraLines;
			}
		}

		if (firstPotentialWrap < 0 && lineExceeded) {
			if (topPriorityGroupStarts.length > 0) {
				this.topPriorityWrapIndex = topPriorityGroupStarts[0];
				return WrapResult.TOP_PRIORITY_WRAP_MET;
			}

			// Report high number of extra lines to encourage the algorithm to look
			// for other wraps (maybe something will result in smaller indent and line will fit).
			// This should be achieved with penalty, but it's hard to choose a good penalty value here.
			if (bestExtraLines == Integer.MAX_VALUE)
				bestExtraLines = extraLines + lastPosition;
			else
				bestExtraLines += lastPosition;
		}

		for (int i = lastIndex; firstPotentialWrap >= 0 && i >= firstPotentialWrap; i--) {
			Token token = this.tm.get(i);
			if (commentIndex > 0
					&& (token.tokenType == TokenNameCOMMENT_BLOCK || token.tokenType == TokenNameCOMMENT_JAVADOC)) {
				extraLines -= extraLinesPerComment[--commentIndex];
			}
			if (topPriorityIndex >= 0 && i <= nearestGroupEnd) {
				if (i > topPriorityGroupStarts[topPriorityIndex])
					continue;
				assert i == topPriorityGroupStarts[topPriorityIndex];
				topPriorityIndex--;
				nearestGroupEnd = topPriorityIndex == -1 ? 0
						: this.tm.get(topPriorityGroupStarts[topPriorityIndex]).getWrapPolicy().topPriorityGroupEnd;
			}

			if (!token.isWrappable())
				continue;

			int nextWrapIndent = getWrapIndent(token);
			WrapResult nextWrapResult = findWrapsCached(i, nextWrapIndent);

			if (nextWrapResult == WrapResult.TOP_PRIORITY_WRAP_MET)
				continue;

			double totalPenalty = getWrapPenalty(wrapTokenIndex, indent, i, nextWrapIndent, nextWrapResult);
			int totalExtraLines = extraLines + nextWrapResult.totalExtraLines;
			boolean isBetter = totalExtraLines < bestExtraLines || bestExtraLines == Integer.MAX_VALUE;
			if (!isBetter && totalExtraLines == bestExtraLines)
				isBetter = totalPenalty < bestTotalPenalty || bestTotalPenalty == Double.MAX_VALUE;
			if (isBetter) {
				bestTotalPenalty = totalPenalty;
				bestExtraLines = totalExtraLines;
				bestNextWrap = i;
				bestIndent = nextWrapIndent;

				if (!this.options.wrap_outer_expressions_when_nested)
					break;
			}
		}

		if (bestNextWrap == -1 && lineExceeded && topPriorityGroupStarts.length > 0) {
			this.topPriorityWrapIndex = topPriorityGroupStarts[0];
			return WrapResult.TOP_PRIORITY_WRAP_MET;
		}

		return new WrapResult(bestTotalPenalty, bestExtraLines,
				bestNextWrap == -1 ? null : new WrapInfo(bestNextWrap, bestIndent));
	}

