	private int applyWraps(int index, int indent) throws WrapRestartThrowable {
		WrapInfo wrapInfo = findWrapsCached(index, indent).nextWrap;
		Token token = this.tm.get(index);
		index++;
		token.setIndent(indent);
		int groupEnd = token.getWrapPolicy() != null ? token.getWrapPolicy().groupEndIndex : -1;
		int separateLinesOnWrapFrom = -1;
		while (index < this.tm.size()) {
			token = this.tm.get(index);
			if (token.isNextLineOnWrap() && this.tm.get(this.tm.findFirstTokenInLine(index)).isWrappable()) {
				token.breakBefore();
				return index;
			}
			if (separateLinesOnWrapFrom >= 0
					&& token == this.tm.get(separateLinesOnWrapFrom).getSeparateLinesOnWrapUntil()) {
				separateLinesOnWrapFrom = -1;
			}
			if (separateLinesOnWrapFrom == -1 && token.getSeparateLinesOnWrapUntil() != null) {
				separateLinesOnWrapFrom = index;
			}
			while (wrapInfo != null && wrapInfo.wrapTokenIndex < index)
				wrapInfo = this.wrapSearchResults.get(wrapInfo).nextWrap;
			if (wrapInfo != null && wrapInfo.wrapTokenIndex == index) {
				checkSeparateLinesOnWrap(separateLinesOnWrapFrom);
				token.breakBefore();
				handleOnColumnIndent(index, token.getWrapPolicy());
				checkTopPriorityWraps(index);
				index = applyWraps(index, wrapInfo.indent);
				continue;
			}

			boolean isNewLine = this.tm.get(index - 1).getLineBreaksAfter() > 0 || token.getLineBreaksBefore() > 0;
			if (isNewLine) {
				if (token.getWrapPolicy() != null) {
					checkSeparateLinesOnWrap(separateLinesOnWrapFrom);
					handleOnColumnIndent(index, token.getWrapPolicy());
					checkTopPriorityWraps(index);
					int newIndent = getWrapIndent(token);
					if (newIndent < indent)
						return index;
					wrapInfo = findWrapsCached(index, newIndent).nextWrap;
					if (newIndent > indent) {
						index = applyWraps(index, newIndent);
						continue;
					}
				} else if (index > groupEnd) {
					return index;
				}
			} else {
				checkForceWrap(token, index, indent);
			}

			token.setIndent(indent);
			index++;
		}
		return index;
	}

