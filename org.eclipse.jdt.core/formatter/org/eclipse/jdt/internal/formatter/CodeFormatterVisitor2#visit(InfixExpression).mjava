	public boolean visit(InfixExpression node) {
		// active line wrapping
		final InfixExpressionWrappingBuilder builder = new InfixExpressionWrappingBuilder();
		node.accept(builder);
		final int fragmentsSize = builder.getFragmentsCounter();
		this.scribe.printComment();
		Alignment2 binaryExpressionAlignment = this.scribe.createAlignment("binaryExpressionAlignment", this.preferences.alignment_for_binary_expression, Alignment.R_OUTERMOST, fragmentsSize, this.scribe.scanner.currentPosition); //$NON-NLS-1$
		this.scribe.enterAlignment(binaryExpressionAlignment);
		boolean ok = false;
		List fragments = builder.fragments;
		int[] operators = builder.getOperators();
/*		do {
			try {
				final boolean alignAfterOperator = false;
				if (alignAfterOperator) {
					for (int i = 0; i < fragmentsSize - 1; i++) {
						this.scribe.alignFragment(binaryExpressionAlignment, i);
						((Expression) fragments.get(i)).accept(this);
						this.scribe.printTrailingComment();
						if (this.scribe.lastNumberOfNewLines == 1) {
							// a new line has been inserted by printTrailingComment()
							this.scribe.indentationLevel = binaryExpressionAlignment.breakIndentationLevel;
						}
						this.scribe.printNextToken(operators[i], this.preferences.insert_space_before_binary_operator);
						if (operators[i] == TerminalTokens.TokenNameMINUS && isNextToken(TerminalTokens.TokenNameMINUS)) {
							// the next character is a minus (unary operator)
							this.scribe.space();
						}
						if (this.preferences.insert_space_after_binary_operator) {
							this.scribe.space();
						}
					}
					this.scribe.alignFragment(binaryExpressionAlignment, fragmentsSize - 1);
					((Expression) fragments.get(fragmentsSize - 1)).accept(this);
					this.scribe.printTrailingComment();
				} else {
					this.scribe.alignFragment(binaryExpressionAlignment, 0);
					((Expression) fragments.get(0)).accept(this);
					this.scribe.printTrailingComment();
					if (this.scribe.lastNumberOfNewLines == 1) {
						if (binaryExpressionAlignment.couldBreak() && binaryExpressionAlignment.wasSplit) {
							binaryExpressionAlignment.performFragmentEffect();
						}
					}
					for (int i = 1; i < fragmentsSize - 1; i++) {
						this.scribe.alignFragment(binaryExpressionAlignment, i);
						this.scribe.printNextToken(operators[i - 1], this.preferences.insert_space_before_binary_operator);
						if (operators[i] == TerminalTokens.TokenNameMINUS && isNextToken(TerminalTokens.TokenNameMINUS)) {
							// the next character is a minus (unary operator)
							this.scribe.space();
						}
						if (this.preferences.insert_space_after_binary_operator) {
							this.scribe.space();
						}
						((Expression) fragments.get(i)).accept(this);
						this.scribe.printTrailingComment();
						if (this.scribe.lastNumberOfNewLines == 1) {
							if (binaryExpressionAlignment.couldBreak() && binaryExpressionAlignment.wasSplit) {
								binaryExpressionAlignment.performFragmentEffect();
							}
						}
					}
					this.scribe.alignFragment(binaryExpressionAlignment, fragmentsSize - 1);
					this.scribe.printNextToken(operators[fragmentsSize - 2], this.preferences.insert_space_before_binary_operator);
					if (operators[fragmentsSize - 2] == TerminalTokens.TokenNameMINUS && isNextToken(TerminalTokens.TokenNameMINUS)) {
						// the next character is a minus (unary operator)
						this.scribe.space();
					}
					if (this.preferences.insert_space_after_binary_operator) {
						this.scribe.space();
					}
					((Expression) fragments.get(fragmentsSize - 1)).accept(this);
					this.scribe.printTrailingComment();
					if (this.scribe.lastNumberOfNewLines == 1) {
						if (binaryExpressionAlignment.couldBreak() && binaryExpressionAlignment.wasSplit) {
							binaryExpressionAlignment.performFragmentEffect();
						}
					}
				}
				ok = true;
			} catch(AlignmentException e){
				this.scribe.redoAlignment(e);
			}
		} while (!ok);
		this.scribe.exitAlignment(binaryExpressionAlignment, true);*/
		do {
			try {
				for (int i = 0; i < fragmentsSize - 1; i++) {
					((Expression) fragments.get(i)).accept(this);
					this.scribe.printTrailingComment();
					if (this.scribe.lastNumberOfNewLines == 1) {
						if (binaryExpressionAlignment.couldBreak() && binaryExpressionAlignment.wasSplit) {
							binaryExpressionAlignment.performFragmentEffect();
						}
					}
					this.scribe.alignFragment(binaryExpressionAlignment, i);
					this.scribe.printNextToken(operators[i], this.preferences.insert_space_before_binary_operator);
					if ( this.preferences.insert_space_after_binary_operator
							|| (operators[i] == TerminalTokens.TokenNameMINUS && isNextToken(TerminalTokens.TokenNameMINUS))) {
						// the next character is a minus (unary operator) or the preference is set to true
						this.scribe.space();
					}
				}
				((Expression) fragments.get(fragmentsSize - 1)).accept(this);
				this.scribe.printTrailingComment();
				if (this.scribe.lastNumberOfNewLines == 1) {
					if (binaryExpressionAlignment.couldBreak() && binaryExpressionAlignment.wasSplit) {
						binaryExpressionAlignment.performFragmentEffect();
					}
				}
				ok = true;
			} catch(AlignmentException e){
				this.scribe.redoAlignment(e);
			}
		} while (!ok);		
		this.scribe.exitAlignment(binaryExpressionAlignment, true);		
/*			leftOperand.accept(this);
			final int operator = extractInfixExpressionOperator(node);
			this.scribe.printNextToken(operator, this.preferences.insert_space_before_binary_operator);
			if ( this.preferences.insert_space_after_binary_operator
					|| (operator == TerminalTokens.TokenNameMINUS && isNextToken(TerminalTokens.TokenNameMINUS))) {
				// the next character is a minus (unary operator) or the preference is set to true
				this.scribe.space();
			}
			rightOperand.accept(this);*/
		return false;
	}

