	private void printBlockComment(int currentTokenStartPosition, int currentTokenEndPosition) {


		// Compute indentation
		int maxColumn = this.formatter.preferences.comment_line_length + 1;
		int indentLevel = this.indentationLevel;
		int indentations = this.numberOfIndentations;
		this.indentationLevel = (this.column / this.tabLength) * this.tabLength;
		this.column = this.indentationLevel + 1;
		this.numberOfIndentations = this.indentationLevel / this.indentationSize;

		// Consume the comment prefix
		StringBuffer buffer = new StringBuffer();
		this.scanner.getNextChar();
		this.scanner.getNextChar();
		this.column += 2;
		this.scanner.skipComments = true;
		StringBuffer tokensBuffer = new StringBuffer();

		// Consume text token per token
		int previousToken = -1;
		boolean newLine = false;
		boolean multiLines = false;
		boolean hasMultiLines = false;
		boolean hasTokens = false;
		boolean bufferHasTokens = false;
		int hasTextOnFirstLine = 0;
		boolean firstWord = true;
		boolean clearBlankLines = this.formatter.preferences.comment_clear_blank_lines_in_block_comment;
		int scannerLine = Util.getLineNumber(this.scanner.currentPosition, this.lineEnds, 0, this.maxLines);
		int firstLine = scannerLine;
		int lineNumber = scannerLine;
		int lastTextLine = -1;
		boolean openedString = false;
		while (!this.scanner.atEnd()) {
			
			// Consume token
			int token;
			try {
				token = this.scanner.getNextToken();
			} catch (InvalidInputException iie) {
				String msg = iie.getMessage();
				boolean insertSpace = (previousToken == TerminalTokens.TokenNameWHITESPACE || newLine) && !firstWord;
				if (msg == Scanner.INVALID_CHARACTER_CONSTANT) {
					if (insertSpace) {
						tokensBuffer.append(' ');
					}
					tokensBuffer.append('\'');
				} else if (msg == Scanner.INVALID_CHAR_IN_STRING) {
					if (openedString) {
						openedString = false;
					} else {
						if (insertSpace) {
							tokensBuffer.append(' ');
						}
						openedString = true;
					}
					tokensBuffer.append('"');
				} else {
					// skip failure
				}
				// Need to retrieve correct position
				this.scanner.resetTo(this.scanner.startPosition, currentTokenEndPosition-1);
				this.scanner.getNextChar();
				previousToken = 2000;
				newLine = false;
				continue;
			}
			
			// Look at specific tokens
    		boolean insertSpace = (previousToken == TerminalTokens.TokenNameWHITESPACE) && (!firstWord || !hasTokens);
			switch (token) {
				case TerminalTokens.TokenNameWHITESPACE:
					if (tokensBuffer.length() > 0) {
						if (hasTextOnFirstLine == 1 && multiLines) {
							printBlockCommentHeaderLine(buffer);
							hasTextOnFirstLine = -1;
						}
						buffer.append(tokensBuffer);
						this.column += tokensBuffer.length();
						tokensBuffer.setLength(0);
						bufferHasTokens = true;
					}
					if (previousToken == -1) {
						// do not remember the first whitespace
						previousToken = -2;
					} else {
						previousToken = token;
					}
					lineNumber = Util.getLineNumber(this.scanner.getCurrentTokenEndPosition(), this.lineEnds, scannerLine>1 ? scannerLine-2 : 0, this.maxLines);
					if (lineNumber > scannerLine) {
						hasMultiLines = true;
						newLine = true;
					}
					scannerLine = lineNumber;
					continue;
				case TerminalTokens.TokenNameMULTIPLY:
					previousToken = token;
					lineNumber = Util.getLineNumber(this.scanner.getCurrentTokenEndPosition(), this.lineEnds, scannerLine>1 ? scannerLine-2 : 0, this.maxLines);
					if (this.scanner.currentCharacter == '/') {
						// Add remaining buffered tokens
						if (tokensBuffer.length() > 0) {
							buffer.append(tokensBuffer);
							this.column += tokensBuffer.length();
						}
						// end of comment
						if (multiLines || hasMultiLines) {
					    	buffer.append(this.lineSeparator);
					    	this.column = 1;
					    	printIndentationIfNecessary(buffer);
						}
						buffer.append(' ');
			    		buffer.append(BLOCK_FOOTER);
				    	this.column += BLOCK_FOOTER_LENGTH + 1;
				    	this.scanner.getNextChar(); // reach the end of scanner
				    	continue;
					}
					scannerLine = lineNumber;
					continue;
				case TerminalTokens.TokenNameMULTIPLY_EQUAL:
					if (newLine) {
						this.scanner.resetTo(this.scanner.startPosition, currentTokenEndPosition-1);
						this.scanner.getNextChar(); // consume the multiply
						previousToken = TerminalTokens.TokenNameMULTIPLY;
						scannerLine = Util.getLineNumber(this.scanner.getCurrentTokenEndPosition(), this.lineEnds, scannerLine>1 ? scannerLine-2 : 0, this.maxLines);
						continue;
					}
			}

			// Look at gap and insert corresponding lines if necessary
			int linesGap;
			int max;
			lineNumber = Util.getLineNumber(this.scanner.getCurrentTokenEndPosition(), this.lineEnds, scannerLine>1 ? scannerLine-2 : 0, this.maxLines);
			if (lastTextLine == -1) {
				linesGap = lineNumber - firstLine;
				max = 0;
			} else {
				linesGap = lineNumber - lastTextLine;
				if (token == TerminalTokens.TokenNameAT && linesGap ==1) {
					// insert one blank line before root tags
					linesGap = 2;
				}
				max = 1;
			}
			if (linesGap > max) {
				if (clearBlankLines) {
					// TODO (frederic) see if there's a bug for the unremoved blank line for root tags
					 if (token == TerminalTokens.TokenNameAT) {
						 linesGap = 1;
					 } else {
						linesGap = max==0 ? 1 : 0;
					 }
				}
				for (int i=0; i<linesGap; i++) {
					// Add remaining buffered tokens
					if (tokensBuffer.length() > 0) {
						if (hasTextOnFirstLine == 1) {
							printBlockCommentHeaderLine(buffer);
							hasTextOnFirstLine = -1;
						}
						buffer.append(tokensBuffer);
						tokensBuffer.setLength(0);
						bufferHasTokens = true;
					}
			    	buffer.append(this.lineSeparator);
			    	this.column = 1;
			    	printIndentationIfNecessary(buffer);
		    		buffer.append(BLOCK_LINE_PREFIX);
		    		this.column += BLOCK_LINE_PREFIX_LENGTH;
		    		firstWord = true;
					multiLines = true;
				}
				insertSpace = insertSpace && linesGap == 0;
			}

			// Increment column
			int tokenStart = this.scanner.getCurrentTokenStartPosition();
    		int tokenLength = (this.scanner.atEnd() ? this.scanner.eofPosition : this.scanner.currentPosition) - tokenStart;
    		hasTokens = true;
    		if (hasTextOnFirstLine == 0) {
    			if (firstLine == lineNumber) {
	    			hasTextOnFirstLine = 1;
	    			this.column++; // include first space
	    		} else {
	    			hasTextOnFirstLine = -1;
	    		}
    		}
    		int lastColumn = this.column + tokensBuffer.length() + tokenLength;
    		if (insertSpace) lastColumn++;

    		// Append next token inserting a new line if max line is reached
			if (!firstWord && lastColumn > maxColumn) {
		    	String tokensString = tokensBuffer.toString().trim();
				// not enough space on the line
				if (hasTextOnFirstLine == 1) {
					printBlockCommentHeaderLine(buffer);
				}
				if ((this.indentationLevel+tokensString.length()+tokenLength) > maxColumn) {
					// there won't be enough room even if we break the line before the buffered tokens
					// So add the buffered tokens now
					buffer.append(tokensString);
					this.column += tokensString.length();
					tokensBuffer.setLength(0);
				}
				if (bufferHasTokens) {
			    	buffer.append(this.lineSeparator);
			    	this.column = 1;
			    	printIndentationIfNecessary(buffer);
		    		buffer.append(BLOCK_LINE_PREFIX);
			    	this.column += BLOCK_LINE_PREFIX_LENGTH;
				}
		    	if (tokensBuffer.length() > 0) {
					buffer.append(tokensString);
					this.column += tokensString.length();
					tokensBuffer.setLength(0);
		    	}
				buffer.append(this.scanner.source, tokenStart, tokenLength);
				bufferHasTokens = true;
				this.column += tokenLength;
				multiLines = true;
				hasTextOnFirstLine = -1;
			} else {
				// append token to the line
				if (insertSpace)  {
					tokensBuffer.append(' ');
				}
				tokensBuffer.append(this.scanner.source, tokenStart, tokenLength);
			}
			previousToken = token;
			newLine = false;
    		firstWord = false;
			scannerLine = lineNumber;
			lastTextLine = lineNumber;
		}

		// Replace block comment text
		if (hasTokens || multiLines) {
			StringBuffer replacement = new StringBuffer(BLOCK_HEADER);
			if (hasTextOnFirstLine == 1) {
				if ((hasMultiLines || multiLines)) {
					int col = this.column;
					replacement.append(this.lineSeparator);
					this.column = 1;
					printIndentationIfNecessary(replacement);
					replacement.append(BLOCK_LINE_PREFIX);
			    	this.column = col;
				} else {
					replacement.append(' ');
				}
			}
			replacement.append(buffer);
			addReplaceEdit(currentTokenStartPosition, currentTokenEndPosition-1, replacement.toString());
		}

		// Reset
		this.indentationLevel = indentLevel;
		this.numberOfIndentations = indentations;
		this.lastNumberOfNewLines = 0;
		needSpace = false;
		this.scanner.resetTo(currentTokenEndPosition, this.scannerEndPosition - 1);
		this.scanner.skipComments = false;
	}

