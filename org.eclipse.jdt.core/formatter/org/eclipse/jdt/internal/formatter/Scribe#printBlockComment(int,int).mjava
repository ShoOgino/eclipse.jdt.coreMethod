	private void printBlockComment(int currentTokenStartPosition, int currentTokenEndPosition) {

		// Consume the comment prefix
		StringBuffer buffer = new StringBuffer();
		this.scanner.getNextChar();
		this.scanner.getNextChar();
		this.column += 2;
		this.scanner.skipComments = true;
		
		// Consume text token per token
		int maxColumn = this.formatter.preferences.comment_line_length + 1;
		int previousToken = -1;
		boolean newLine = false;
		boolean multiLines = false;
		boolean hasTokens = false;
		boolean hastTextOnFirstLine = false;
		boolean firstWord = true;
		boolean clearBlankLines = this.formatter.preferences.comment_clear_blank_lines_in_block_comment;
		int scannerLine = Util.getLineNumber(this.scanner.currentPosition, this.lineEnds, 0, this.maxLines);
		int firstLine = scannerLine;
		int lineNumber = scannerLine;
		int lastTextLine = -1;
		boolean openedString = false;
		boolean openedChar = false;
		while (!this.scanner.atEnd()) {
			
			// Consume token
			int token;
			try {
				token = this.scanner.getNextToken();
			} catch (InvalidInputException iie) {
				String msg = iie.getMessage();
				boolean insertSpace = (previousToken == TerminalTokens.TokenNameWHITESPACE || newLine) && !firstWord;
				if (msg == Scanner.INVALID_CHARACTER_CONSTANT) {
					if (openedChar) {
						openedChar = false;
					} else {
						if (insertSpace) {
							buffer.append(' ');
							this.column++;
						}
						openedChar = true;
					}
					buffer.append('\'');
					this.column++;
				} else if (msg == Scanner.INVALID_CHAR_IN_STRING) {
					if (openedString) {
						openedString = false;
					} else {
						if (insertSpace) {
							buffer.append(' ');
							this.column++;
						}
						openedString = true;
					}
					buffer.append('"');
					this.column++;
				} else {
					// skip failure
				}
				// Need to retrieve correct position
				this.scanner.resetTo(this.scanner.startPosition, currentTokenEndPosition-1);
				this.scanner.getNextChar();
				previousToken = 1;
				newLine = false;
				continue;
			}
			
			// Look at specific tokens
    		boolean insertSpace = (previousToken == TerminalTokens.TokenNameWHITESPACE || newLine) && !firstWord;
			switch (token) {
				case TerminalTokens.TokenNameWHITESPACE:
					previousToken = token;
					lineNumber = Util.getLineNumber(this.scanner.getCurrentTokenEndPosition(), this.lineEnds, scannerLine>1 ? scannerLine-2 : 0, this.maxLines);
					if (lineNumber > scannerLine) {
						multiLines = true;
						newLine = true;
					}
					scannerLine = lineNumber;
					continue;
				case TerminalTokens.TokenNameMULTIPLY:
					lineNumber = Util.getLineNumber(this.scanner.getCurrentTokenEndPosition(), this.lineEnds, scannerLine>1 ? scannerLine-2 : 0, this.maxLines);
					if (this.scanner.currentCharacter == '/') {
						// end of comment
						if (multiLines) {
					    	buffer.append(this.lineSeparator);
					    	this.column = 1;
					    	printIndentationIfNecessary(buffer);
						}
						buffer.append(' ');
			    		buffer.append(BLOCK_FOOTER);
				    	this.column += BLOCK_LINE_PREFIX_LENGTH + 1;
				    	this.scanner.getNextChar(); // reach the end of scanner
				    	continue;
					}
					scannerLine = lineNumber;
					continue;
				case TerminalTokens.TokenNameLESS:
					// We cannot break tags
					StringBuffer breakBuffer = new StringBuffer();
					int start = this.scanner.startPosition;
		    		int tokenLength = (this.scanner.atEnd() ? this.scanner.eofPosition : this.scanner.currentPosition) - this.scanner.startPosition;
					breakBuffer.append(this.scanner.source, this.scanner.startPosition, tokenLength);
					try {
						boolean closing = false;
						if ((token = this.scanner.getNextToken()) == TerminalTokens.TokenNameDIVIDE) {
			    			tokenLength = (this.scanner.atEnd() ? this.scanner.eofPosition : this.scanner.currentPosition) - this.scanner.startPosition;
							breakBuffer.append(this.scanner.source, this.scanner.startPosition, tokenLength);
							token = this.scanner.getNextToken();
							closing = true;
						}
						if (token == TerminalTokens.TokenNameIdentifier) {
			    			tokenLength = (this.scanner.atEnd() ? this.scanner.eofPosition : this.scanner.currentPosition) - this.scanner.startPosition;
							breakBuffer.append(this.scanner.source, this.scanner.startPosition, tokenLength);
							token = this.scanner.getNextToken();
							if (token == TerminalTokens.TokenNameGREATER) {
				    			tokenLength = (this.scanner.atEnd() ? this.scanner.eofPosition : this.scanner.currentPosition) - this.scanner.startPosition;
								breakBuffer.append(this.scanner.source, this.scanner.startPosition, tokenLength);
								if ((this.column + breakBuffer.length()) > maxColumn) {
							    	buffer.append(this.lineSeparator);
							    	this.column = 1;
							    	printIndentationIfNecessary(buffer);
						    		buffer.append(BLOCK_LINE_PREFIX);
							    	this.column += BLOCK_LINE_PREFIX_LENGTH;
									multiLines = true;
								} else if (!closing) {
									buffer.append(' ');
									this.column++;
								}
								buffer.append(breakBuffer);
								this.column += breakBuffer.length();
								previousToken = token;
								scannerLine = lineNumber;
								continue;
							}
						}
					}
					catch (InvalidInputException iie) {
						// forget as we're started after next token
					}
					// Need to retrieve correct position
					this.scanner.resetTo(start, currentTokenEndPosition-1);
					try {
	                    token = this.scanner.getNextToken();
                    } catch (InvalidInputException e) {
	                    // will not happen
                    }
					break;
			}

			// Look at gap and insert corresponding lines if necessary
			int linesGap;
			int max;
			if (lastTextLine == -1) {
				linesGap = lineNumber - firstLine;
				max = 0;
			} else {
				linesGap = lineNumber - lastTextLine;
				if (token == TerminalTokens.TokenNameAT && linesGap ==1) {
					// insert one blank line before root tags
					linesGap = 2;
				}
				max = 1;
			}
			if (linesGap > max) {
				if (clearBlankLines) {
					// TODO (frederic) see if there's a bug for the unremoved blank line for root tags
					 if (token == TerminalTokens.TokenNameAT) {
						 linesGap = 1;
					 } else {
						linesGap = max==0 ? 1 : 0;
					 }
				}
				for (int i=0; i<linesGap; i++) {
			    	buffer.append(this.lineSeparator);
			    	this.column = 1;
			    	printIndentationIfNecessary(buffer);
		    		buffer.append(BLOCK_LINE_PREFIX);
		    		this.column += BLOCK_LINE_PREFIX_LENGTH;
		    		firstWord = true;
					multiLines = true;
				}
				insertSpace = insertSpace && linesGap == 0;
			}
			scannerLine = lineNumber;
			lastTextLine = lineNumber;

			// Increment column
			int tokenStart = this.scanner.getCurrentTokenStartPosition();
    		int tokenLength = (this.scanner.atEnd() ? this.scanner.eofPosition : this.scanner.currentPosition) - tokenStart;
    		hasTokens = true;
    		if (scannerLine == firstLine) hastTextOnFirstLine = true;
			this.column += tokenLength;
    		if (previousToken == -1 || insertSpace) this.column++;
    		
    		// Append next token inserting a new line if max line is reached
			if (!firstWord && this.column > maxColumn) {
				// not enough space on the line
		    	buffer.append(this.lineSeparator);
		    	this.column = 1;
		    	printIndentationIfNecessary(buffer);
	    		buffer.append(BLOCK_LINE_PREFIX);
		    	this.column += BLOCK_LINE_PREFIX_LENGTH;
				buffer.append(this.scanner.source, tokenStart, tokenLength);
				this.column += tokenLength;
				multiLines = true;
			} else {
				// append token to the line
				if (insertSpace)  {
					if (buffer.length() > 0) buffer.append(' ');
				}
				buffer.append(this.scanner.source, tokenStart, tokenLength);
			}
			previousToken = token;
			newLine = false;
    		firstWord = false;
		}

		// Replace block comment text
		if (hasTokens || multiLines) {
			StringBuffer replacement = new StringBuffer(BLOCK_HEADER);
			if (multiLines) {
				if (/*clearBlankLines || */(hasTokens && hastTextOnFirstLine)) {
					int col = this.column;
					replacement.append(this.lineSeparator);
					this.column = 1;
					printIndentationIfNecessary(replacement);
					replacement.append(BLOCK_LINE_PREFIX);
			    	this.column = col;
				}
			} else {
				if (hasTokens) replacement.append(' ');
			}
			replacement.append(buffer);
			addReplaceEdit(currentTokenStartPosition, currentTokenEndPosition-1, replacement.toString());
		}

		// Reset
		this.lastNumberOfNewLines = 0;
		needSpace = false;
		this.scanner.resetTo(currentTokenEndPosition, this.scannerEndPosition - 1);
		this.scanner.skipComments = false;
	}

