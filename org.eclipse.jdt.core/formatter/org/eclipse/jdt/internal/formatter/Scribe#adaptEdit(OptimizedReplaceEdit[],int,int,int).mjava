	/*
     * Search whether a region overlap edit(s) at its start and/or at its end.
     * If so, modify the concerned edits to keep only the modifications which are
     * inside the given region.
     * 
     * The edit modification is done as follow:
     * 1) start it from the region start if it overlaps the region's start
     * 2) end it at the region end if it overlaps the region's end
     * 3) remove from the replacement string the number of lines which are outside
     * the region: before when overlapping region's start and after when overlapping
     * region's end. Note that the trailing indentation of the replacement string is not
     * kept when the region's end is overlapped because it's always outside the
     * region.
     */
    private int adaptEdit(OptimizedReplaceEdit[] sortedEdits, int start, int regionStart, int regionEnd) {
    	int initialStart = start==-1 ? 0 : start;
		int bottom = initialStart, top = sortedEdits.length - 1;
    	int topEnd = top;
    	int i = 0;
    	OptimizedReplaceEdit edit = null;
    	int overlapIndex = -1;

    	// Look for an edit overlapping the region start
    	while (bottom <= top) {
    		i = bottom + (top - bottom) /2;
    		edit = sortedEdits[i];
    		int editStart = edit.offset;
   			int editEnd = editStart + edit.length;
    		if (editStart > regionStart) {  // the edit starts after the region's start => no possible overlap of region's start
    			top = i-1;
    			if (editStart > regionEnd) { // the edit starts after the region's end => no possible overlap of region's end
    				topEnd = top;
    			}
    		} else {
    			if (editEnd < regionStart) { // the edit ends before the region's start => no possible overlap of region's start
	    			bottom = i+1;
				} else {
					// Count the lines of the edit which are outside the region
					int linesOutside = 0;
					StringBuffer spacesOutside = new StringBuffer();
					this.scanner.resetTo(editStart, editEnd-1);
					while (this.scanner.currentPosition < regionStart && !this.scanner.atEnd()) {
						char ch = (char) this.scanner.getNextChar();
						switch (ch) {
							case '\n':
								linesOutside++;
								spacesOutside.setLength(0);
								break;
							case '\r':
								break;
							default:
								spacesOutside.append(ch);
								break;
						}
					}

					// Restart the edit at the beginning of the line where the region start
					edit.offset = regionStart;
					int editLength = edit.length;
					edit.length -= edit.offset - editStart;

					// Cut replacement string if necessary
					int length = edit.replacement.length();
					if (length > 0) {

						// Count the lines in replacement string
						int linesReplaced = 0;
						for (int idx=0; idx < length; idx++) {
							if (edit.replacement.charAt(idx) == '\n') linesReplaced++;
						}

						// If the edit was a replacement but become an insertion due to the length reduction
						// and if the edit finishes just before the region starts and if there's no line to replace
						// then there's no replacement to do...
						if (editLength > 0 && edit.length == 0 && editEnd == regionStart && linesReplaced == 0 && linesOutside== 0) {
							edit.offset = -1;
						} else {

							// As the edit starts outside the region, remove first lines from edit string if any
							if (linesReplaced > 0) {
								int linesCount = linesOutside >= linesReplaced ? linesReplaced : linesOutside;
								if (linesCount > 0) {
									int idx = 0;
									loop: while (idx < length) {
										char ch = edit.replacement.charAt(idx);
										switch (ch) {
											case '\n':
												linesCount--;
												if (linesCount == 0) {
													idx++;
													break loop;
												}
												break;
											case '\r':
											case ' ':
											case '\t':
												break;
											default:
												break loop;
										}
										idx++;
									}
									// Compare spaces outside the region and the beginning
									// of the replacement string to remove the common part
									int spacesOutsideLength = spacesOutside.length();
									int replacementStart = idx;
									for (int o=0, r=0; o < spacesOutsideLength && r<(length-idx); o++) {
										char rch = edit.replacement.charAt(idx + r);
										char och = spacesOutside.charAt(o);
										if (rch == och) {
											replacementStart++;
											r++;
										} else if (rch == '\t' && (this.tabLength > 0 && och == ' ')) {
											if ((o+1)%this.tabLength == 0) {
												replacementStart++;
												r++;
											}
										} else {
											break;
										}
									}
									// Update the replacement string
									if (replacementStart > length || (replacementStart == length && spacesOutsideLength > 0)) {
										edit.offset = -1;
									} else if (spacesOutsideLength == 0 && replacementStart == length) {
										edit.replacement = ""; //$NON-NLS-1$
									} else {
										edit.replacement = edit.replacement.substring(replacementStart);
									}
								}
							}
						}
					}
					overlapIndex = i;
					break;
				}
			}
    	}
    	int validIndex = (overlapIndex != -1) ? overlapIndex : bottom;

    	// Look for an edit overlapping the region end
    	if (overlapIndex != -1) bottom = overlapIndex;
    	while (bottom <= topEnd) {
    		i = bottom + (topEnd - bottom) /2;
    		edit = sortedEdits[i];
    		int editStart = edit.offset;
   			int editEnd = editStart + edit.length;
   			if (regionEnd < editStart) {	// the edit starts after the region's end => no possible overlap of region's end
    			topEnd = i-1;
    		} else if (regionEnd == editStart) {	// special case when the edit starts just after the region's end...
    			// ...we got the last index of the edit inside the region
				topEnd = i - 1;
    			// this last edit is valid only if it's an insertion and if it has indentation
    			if (edit.length == 0) {
    				int nrLength = 0;
    				int rLength = edit.replacement.length();
    				if (nrLength < rLength) {
	    				int ch = edit.replacement.charAt(nrLength);
	    				loop: while (nrLength < rLength) {
		    				switch (ch) {
		    					case ' ':
		    					case '\t':
		    						nrLength++;
		    						break;
		    					default:
		    						break loop;
		    				}
	    				}
    				}
    				if (nrLength > 0) {
	    				topEnd++;
	    				if (nrLength < rLength) {
	    					edit.replacement = edit.replacement.substring(0, nrLength);
	    				}
    				}
    			}
    			break;
       		} else if (editEnd <= regionEnd) {	// the edit ends before the region's end => no possible overlap of region's end
    			bottom = i+1;
			} else {
				// Count the lines of the edit which are outside the region
				int linesOutside = 0;
				this.scanner.resetTo(editStart, editEnd-1);
				while (!this.scanner.atEnd()) {
					boolean after = this.scanner.currentPosition >= regionEnd;
                    char ch = (char) this.scanner.getNextChar();
                	if (ch == '\n' ) {
                		if (after) linesOutside++;
                	}
                }

				// Cut replacement string if necessary
				int length = edit.replacement.length();
				if (length > 0) {

					// Count the lines in replacement string
					int linesReplaced = 0;
					for (int idx=0; idx < length; idx++) {
						if (edit.replacement.charAt(idx) == '\n') linesReplaced++;
					}

					// Set the replacement string to the number of missing new lines
					// As the end of the edit is out of the region, the possible trailing
					// indentation should not be added...
					if (linesReplaced == 0) {
		    			edit.replacement = ""; //$NON-NLS-1$
					} else {
						int linesCount = linesReplaced > linesOutside ? linesReplaced - linesOutside : 0;
						if (linesCount == 0) {
			    			edit.replacement = ""; //$NON-NLS-1$
						} else {
							edit.replacement = getNewLineString(linesCount);
						}
					}
				}
				edit.length = regionEnd - editStart;

		    	// We got the last edit of the regions, give up
				topEnd = i;
				break;
			}
    	}

    	// Set invalid all edits outside the region
    	for (int e=initialStart; e<validIndex; e++) {
    		sortedEdits[e].offset = -1;
    	}
    	
    	// Return the index of next edit to look at
    	return topEnd+1;
    }

