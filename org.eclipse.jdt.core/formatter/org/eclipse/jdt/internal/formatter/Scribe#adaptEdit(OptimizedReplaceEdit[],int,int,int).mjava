	/*
     * Search whether a region overlap edit(s) at its start and/or at its end.
     * If so, modify the concerned edits to keep only the modifications which are
     * inside the given region.
     * 
     * The edit modification is done as follow:
     * 1) start it from the region start if it overlaps the region's start
     * 2) end it at the region end if it overlaps the region's end
     * 3) remove from the replacement string the number of lines which are outside
     * the region: before when overlapping region's start and after when overlapping
     * region's end. Note that the trailing indentation of the replacement string is not
     * kept when the region's end is overlapped because it's always outside the
     * region.
     */
    private int adaptEdit(OptimizedReplaceEdit[] sortedEdits, int start, int regionStart, int regionEnd) {
    	int bottom = start==-1?0:start, top = sortedEdits.length - 1;
    	int topEnd = top;
    	int i = 0;
    	OptimizedReplaceEdit edit = null;
    	int overlapIndex = -1;
        int linesOutside= -1;

    	// Look for an edit overlapping the region start
    	while (bottom <= top) {
    		i = bottom + (top - bottom) /2;
    		edit = sortedEdits[i];
    		int editStart = edit.offset;
   			int editEnd = editStart + edit.length;
    		if (regionStart < editStart) {  // the edit starts after the region's start => no possible overlap of region's start
    			top = i-1;
    			if (regionEnd < editStart) { // the edit starts after the region's end => no possible overlap of region's end
    				topEnd = top;
    			}
    		} else {
    			if (regionStart >= editEnd) { // the edit ends before the region's start => no possible overlap of region's start
	    			bottom = i+1;
				} else {
					// Count the lines of the edit which are outside the region
					linesOutside = 0;
					this.scanner.resetTo(editStart, editEnd-1);
					while (!this.scanner.atEnd()) {
						boolean before = this.scanner.currentPosition < regionStart;
	                    char ch = (char) this.scanner.getNextChar();
                    	if (ch == '\n' ) {
                    		if (before) linesOutside++;
                    	}
                    }

					// Restart the edit at the beginning of the line where the region start
					edit.offset = regionStart;
					edit.length -= edit.offset - editStart;

					// Cut replacement string if necessary
					int length = edit.replacement.length();
					if (length > 0) {

						// Count the lines in replacement string
						int linesReplaced = 0;
						for (int idx=0; idx < length; idx++) {
							if (edit.replacement.charAt(idx) == '\n') linesReplaced++;
						}

						// As the edit starts outside the region, remove first lines from edit string if any
						if (linesReplaced > 0) {
					    	int linesCount = linesOutside >= linesReplaced ? linesReplaced : linesOutside;
					    	if (linesCount > 0) {
					    		int idx=0;
					    		loop: while (idx < length) {
					    			char ch = edit.replacement.charAt(idx);
					    			switch (ch) {
					    				case '\n':
						    				linesCount--;
						    				if (linesCount == 0) {
						    					idx++;
						    					break loop;
						    				}
						    				break;
					    				case '\r':
					    				case ' ':
					    				case '\t':
					    					break;
					    				default:
					    					break loop;
					    			}
					    			idx++;
					    		}
					    		if (idx >= length) {
					    			edit.replacement = ""; //$NON-NLS-1$
					    		} else {
					    			edit.replacement = edit.replacement.substring(idx);
					    		}
					    	}
						}
					}
					overlapIndex = i;
					break;
				}
			}
    	}

    	// Look for an edit overlapping the region end
    	if (overlapIndex != -1) bottom = overlapIndex;
    	while (bottom <= topEnd) {
    		i = bottom + (topEnd - bottom) /2;
    		edit = sortedEdits[i];
    		int editStart = edit.offset;
   			int editEnd = editStart + edit.length;
    		if (regionEnd < editStart) {	// the edit starts after the region's end => no possible overlap of region's end
    			topEnd = i-1;
    		} else {
    			if (regionEnd >= editEnd) {	// the edit ends before the region's end => no possible overlap of region's end
	    			bottom = i+1;
				} else {
					// Count the lines of the edit which are outside the region
					linesOutside = 0;
					this.scanner.resetTo(editStart, editEnd-1);
					while (!this.scanner.atEnd()) {
						boolean after = this.scanner.currentPosition >= regionEnd;
	                    char ch = (char) this.scanner.getNextChar();
                    	if (ch == '\n' ) {
                    		if (after) linesOutside++;
                    	}
                    }

					// Cut replacement string if necessary
					int length = edit.replacement.length();
					if (length > 0) {

						// Count the lines in replacement string
						int linesReplaced = 0;
						for (int idx=0; idx < length; idx++) {
							if (edit.replacement.charAt(idx) == '\n') linesReplaced++;
						}

						// Set the replacement string to the number of missing new lines
						// As the end of the edit is out of the region, the possible trailing
						// indentation should not be added...
						if (linesReplaced == 0) {
			    			edit.replacement = ""; //$NON-NLS-1$
						} else {
							int linesCount = linesReplaced > linesOutside ? linesReplaced - linesOutside : 0;
							if (linesCount == 0) {
				    			edit.replacement = ""; //$NON-NLS-1$
							} else {
								StringBuffer buffer = new StringBuffer();
								for (int j=0; j<linesCount; j++) {
									buffer.append(this.lineSeparator);
								}
								edit.replacement = buffer.toString();
							}
						}
					}
					edit.length -= editEnd - regionEnd;
					return i;
				}
			}
    	}
    	return overlapIndex;
    }

