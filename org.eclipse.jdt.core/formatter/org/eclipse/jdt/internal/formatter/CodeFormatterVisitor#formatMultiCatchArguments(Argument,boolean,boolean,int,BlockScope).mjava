	private void formatMultiCatchArguments(Argument argument,
			boolean spaceBeforePipe,
			boolean spaceAfterPipe,
			int multiCatchAlignment,
			BlockScope scope) {
		UnionTypeReference unionType = (UnionTypeReference) argument.type;
		int length = unionType.typeReferences != null ? unionType.typeReferences.length : 0;
		if (length > 0) {
			Alignment argumentsAlignment = this.scribe.createAlignment(
					Alignment.MULTI_CATCH,
					multiCatchAlignment,
					length,
					this.scribe.scanner.currentPosition);
			this.scribe.enterAlignment(argumentsAlignment);
			boolean ok = false;
			do {
				switch (multiCatchAlignment & Alignment.SPLIT_MASK) {
					case Alignment.M_COMPACT_SPLIT:
					case Alignment.M_NEXT_PER_LINE_SPLIT:
						argumentsAlignment.startingColumn = this.scribe.column;
						break;
				}
				try {
					for (int i = 0; i < length; i++) {
						if (i > 0) {
							if (this.preferences.wrap_before_or_operator_multicatch) {
								this.scribe.alignFragment(argumentsAlignment, i);
							}
							this.scribe.printNextToken(TerminalTokens.TokenNameOR, spaceBeforePipe);
							this.scribe.printComment(CodeFormatter.K_UNKNOWN, Scribe.BASIC_TRAILING_COMMENT);
							if (this.scribe.lastNumberOfNewLines == 1) {
								// a new line has been inserted while printing the comment
								// hence we need to use the break indentation level before printing next token...
								this.scribe.indentationLevel = argumentsAlignment.breakIndentationLevel;
							}
							if (!this.preferences.wrap_before_or_operator_multicatch) {
								this.scribe.alignFragment(argumentsAlignment, i);
							}
						}
						if (i == 0) {
							this.scribe.alignFragment(argumentsAlignment, i);
							int fragmentIndentation = argumentsAlignment.fragmentIndentations[0];
							if ((argumentsAlignment.mode & Alignment.M_INDENT_ON_COLUMN) != 0 && fragmentIndentation > 0) {
								this.scribe.indentationLevel = fragmentIndentation;
							}
						} else if (spaceAfterPipe) {
							this.scribe.space();
						}
						unionType.typeReferences[i].traverse(this, scope);
						argumentsAlignment.startingColumn = -1;
					}
					ok = true;
				} catch (AlignmentException e) {
					this.scribe.redoAlignment(e);
				}
			} while (!ok);
			
			this.scribe.exitAlignment(argumentsAlignment, true);
		}
		
	}

