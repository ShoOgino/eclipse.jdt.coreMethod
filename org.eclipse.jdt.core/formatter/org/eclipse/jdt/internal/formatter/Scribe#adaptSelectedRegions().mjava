	/**
	 * This method will adapt the selected regions if needed.
	 * If a region should be adapted (see isAdaptableRegion(IRegion))
	 * retrieve correct upper and lower bounds and replace the region.
	 */
	private void adaptSelectedRegions() {
		for (int i = 0, max = this.regions.length; i < max; i++) {
			IRegion aRegion = this.regions[i];
			int offset = aRegion.getOffset();
			if (offset > 0) {
				int length = aRegion.getLength();
				if (isAdaptableRegion(offset, length)) {
					// if we have a selection, search for overlapping edits
					int upperBound = offset;
					int lowerBound = 0;
					boolean upperFound = false;
					int regionEnd = offset + length;
					for (int j = 0, max2 = this.editsIndex; j < max2; j++) {
						// search for lower bound
						int editOffset = this.edits[j].offset;
						if (upperFound) {
							int editLength = this.edits[j].length;
							if (lowerBound == 0  && editOffset + editLength < regionEnd) {
								continue;
							} else {
								lowerBound = editOffset + editLength;
								break; // found both bonds - leave the loop
							}
						// search for upper bound
						} else {
							if (this.edits[j+1].offset < offset) {
								continue;
							} else {
								upperBound = editOffset;
								upperFound = true;
							}
						}
					}
					if (lowerBound != 0) {
						// store result if any
						this.regions[i] = new Region(upperBound , lowerBound - upperBound);
					}
				}
			}
		}
	}

