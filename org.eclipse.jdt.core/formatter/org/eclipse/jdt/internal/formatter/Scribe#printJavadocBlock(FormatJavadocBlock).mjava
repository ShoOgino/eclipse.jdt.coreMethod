	private void printJavadocBlock(FormatJavadocBlock block) {
		if( block == null) return;

		// Init positions
		int previousEnd = block.tagEnd;
		int maxNodes = block.nodesPtr;

		// Compute indentation
		boolean headerLine = block.isHeaderLine() && this.lastNumberOfNewLines == 0;
		int maxColumn = this.formatter.preferences.comment_line_length + 1;
		if (headerLine) {
			maxColumn++;
		}

		// format tag section if necessary
		if (!block.isInlined()) {
			this.lastNumberOfNewLines = 0;
		}
		if (block.isDescription()) {
			if (!block.isInlined()) {
			    this.commentIndentation = null;
			}
		} else {
			int tagLength = previousEnd - block.sourceStart + 1;
			this.column += tagLength;
			if (!block.isInlined()) {
			    boolean indentRootTags = this.formatter.preferences.comment_indent_root_tags && !block.isInDescription();
			    int commentIndentationLevel = 0;
				if (indentRootTags) {
				    commentIndentationLevel = tagLength + 1;
					boolean indentParamTag = this.formatter.preferences.comment_indent_parameter_description && block.isInParamTag();
					if (indentParamTag) {
						commentIndentationLevel += this.indentationSize;
					}
				}
				if (commentIndentationLevel == 0) {
				    this.commentIndentation = null;
				} else {
		    		StringBuffer indentationBuffer = new StringBuffer();
		        	for (int i=0; i<commentIndentationLevel; i++) {
		    			indentationBuffer.append(' ');
		        	}
	        		this.commentIndentation = indentationBuffer.toString();
		    	}
			}
			FormatJavadocReference reference= block.reference;
			if (reference != null) {
				// format reference
				printJavadocBlockReference(block, reference);
				previousEnd = reference.sourceEnd;
			}

			// Nothing else to do if the tag has no node
			if (maxNodes < 0)  {
				if (block.isInlined()) {
					this.column++;
				}
				return;
			}
		}

		// tag section: iterate through the blocks composing this tag but the last one
		int previousLine = Util.getLineNumber(previousEnd, this.lineEnds, 0, this.maxLines);
		boolean clearBlankLines = this.formatter.preferences.comment_clear_blank_lines_in_javadoc_comment;
		boolean joinLines = this.formatter.preferences.join_lines_in_comments;
		for (int i=0; i<=maxNodes; i++) {
			FormatJavadocNode node = block.nodes[i];
			int nodeStart = node.sourceStart;

			// Print empty lines before the node
			int newLines;
			if (i == 0) {
				newLines = this.formatter.preferences.comment_insert_new_line_for_parameter && block.isParamTag() ? 1 : 0;
				if (nodeStart > (previousEnd+1)) {
					if (!clearBlankLines || !joinLines) {
						int startLine = Util.getLineNumber(nodeStart, this.lineEnds, previousLine-1, this.maxLines);
						int gapLine = previousLine;
						if (joinLines) gapLine++; // if not preserving line break then gap must be at least of one line
						if (startLine > gapLine) {
							newLines = startLine - previousLine;
						}
						if (clearBlankLines) {
							// clearing blank lines in this block means that break lines should be preserved, hence only keep one new line
							if (newLines > 0)  newLines = 1;
						}
					}
					if (newLines == 0 && (!node.isImmutable() || block.reference != null)) {
						newLines = printJavadocBlockNodesNewLines(block, node, previousEnd);
					}
					if (block.isImmutable()) {
						printJavadocGapLinesForImmutableBlock(block);
					} else {
						printJavadocGapLines(previousEnd+1, nodeStart-1, newLines, clearBlankLines, false, null);
					}
				} else {
					StringBuffer buffer = new StringBuffer();
					if (newLines > 0) {
						for (int j=0; j<newLines; j++) {
							printJavadocNewLine(buffer);
						}
						addInsertEdit(nodeStart, buffer.toString());
					}
				}
			} else {
				newLines = this.column > maxColumn ? 1 : 0;
				if (!clearBlankLines && node.lineStart > (previousLine+1)) newLines = node.lineStart - previousLine;
				if (newLines < node.linesBefore) newLines = node.linesBefore;
				if (newLines == 0) {
					newLines = printJavadocBlockNodesNewLines(block, node, previousEnd);
				}
				if (newLines > 0 || nodeStart > (previousEnd+1)) {
		   			printJavadocGapLines(previousEnd+1, nodeStart-1, newLines, clearBlankLines, false, null);
				}
			}
			if (headerLine && newLines > 0) {
				headerLine = false;
				maxColumn--;
			}

			// Print node
			if (node.isText()) {
				FormatJavadocText text = (FormatJavadocText) node;
				if (text.isImmutable()) {
					// Indent if new line was added
					if (text.isImmutableHtmlTag() && newLines > 0 && this.commentIndentation != null) {
				    	addInsertEdit(node.sourceStart, this.commentIndentation);
				    	this.column += this.commentIndentation.length();
					}
					printJavadocImmutableText(text, block, newLines > 0);
					this.column += getTextLength(block, text);
				} else if (text.isHtmlTag()) {
					printJavadocHtmlTag(text, block, newLines>0);
				} else {
					printJavadocText(text, block, newLines>0);
				}
			} else {
				if (newLines > 0 && this.commentIndentation != null) {
			    	addInsertEdit(node.sourceStart, this.commentIndentation);
			    	this.column += this.commentIndentation.length();
				}
				printJavadocBlock((FormatJavadocBlock)node);
			}

			// Print empty lines before the node
			previousEnd = node.sourceEnd;
			previousLine = Util.getLineNumber(previousEnd, this.lineEnds, node.lineStart > 1 ? node.lineStart-2 : 0, this.maxLines);
		}
		this.lastNumberOfNewLines = 0;
	}

