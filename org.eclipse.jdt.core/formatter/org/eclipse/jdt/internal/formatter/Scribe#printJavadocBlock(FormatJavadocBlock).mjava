	private void printJavadocBlock(FormatJavadocBlock block) {
		if( block == null) return;

		// Init positions
		int previousEnd = block.tagEnd;
		int maxNodes = block.nodesPtr;

		// format tag section if necessary
		int maxColumn = this.formatter.preferences.comment_line_length;
		boolean clearBlankLines = this.formatter.preferences.comment_clear_blank_lines_in_javadoc_comment;
		if (!block.isDescription()) {
			this.column += previousEnd - block.sourceStart + 1;
			if (block.isInlined()) 	{
				this.column++; // Add extra character for inline tag
			}
			FormatJavadocReference reference= block.reference;
			if (reference != null) {
				// format reference
				StringBuffer buffer = new StringBuffer();
				printJavadocBlockReference(buffer, reference, block);
			    addReplaceEdit(previousEnd+1, reference.sourceEnd, buffer.toString());
				previousEnd = reference.sourceEnd;
			}

			// Nothing else to do if the tag has no node
			if (maxNodes < 0)  return;
		}
		
		// tag section: iterate through the blocks composing this tag but the last one
		if (block.isHeaderLine()) maxColumn++;
		for (int i=0; i<=maxNodes; i++) {
			FormatJavadocNode node = block.nodes[i];
			int nodeStart = node.sourceStart;
			
			// Print empty lines before the node
			int textLength = -1;
			int newLines;
			if (i == 0) {
				newLines = this.formatter.preferences.comment_insert_new_line_for_parameter && !block.isInlined() && block.isParamTag() ? 1 : 0;
				if (nodeStart > (previousEnd+1)) {
			   		printJavadocGapLines(previousEnd+1, nodeStart-1, newLines, clearBlankLines, false, null);
				} else {
					StringBuffer buffer = new StringBuffer();
					if (newLines > 0) {
						for (int j=0; j<newLines; j++) {
							printJavadocNewLine(buffer);
						}
						addInsertEdit(nodeStart, buffer.toString());
					}
				}
			} else {
				newLines = this.column > this.formatter.preferences.comment_line_length ? 1 : 0;
				if (node.isText()) {
					// Need to verify if new line is necessary for immutable tag
					FormatJavadocText text = (FormatJavadocText) node;
					if (newLines < text.linesBefore) newLines = text.linesBefore;
					if (newLines == 0 && text.isImmutableHtmlTag()) {
						textLength = getTextLength(block, text);
						if ((this.column + textLength) > maxColumn) {
							newLines = 1;
						}
					}
				}
				if (!node.isText() || newLines > 0 || nodeStart > (previousEnd+1)) {
					if (newLines == 0 && node.isText()) {
						// Special case when two texts are consecutive (html tag->text or text->html tag)
						// If no line is to be inserted, then no space should not be inserted either
						// and column reset if the next token is over the max line length
						try {
							this.scanner.resetTo(nodeStart, block.sourceEnd);
							this.scanner.getNextToken();
				    		int tokenLength = (this.scanner.atEnd() ? this.scanner.eofPosition : this.scanner.currentPosition) - this.scanner.startPosition;
				    		if (((FormatJavadocText)node).isHtmlTag()) {
								// read the html tag
								if (this.scanner.getNextToken() == TerminalTokens.TokenNameDIVIDE) {
									tokenLength++;
									this.scanner.getNextToken();
								}
								tokenLength += (this.scanner.atEnd() ? this.scanner.eofPosition : this.scanner.currentPosition) - this.scanner.startPosition;
								this.scanner.getNextToken(); // '>'
								tokenLength++;
							}
							if (nodeStart > (previousEnd+1)) {
								tokenLength++; // include space between nodes
							}
							if ((this.column + tokenLength) > maxColumn) {
								// finally a new line will be inserted while printing next text
								newLines = 1;
								((FormatJavadocText)node).linesBefore = 1;
							}
				   			printJavadocGapLines(previousEnd+1, nodeStart-1, newLines, clearBlankLines, false, null);
						} catch (InvalidInputException iie) {
							// skip
						}
					} else {
			   			printJavadocGapLines(previousEnd+1, nodeStart-1, newLines, clearBlankLines, false, null);
					}
				}
			}

			// Print node
			if (node.isText()) {
				FormatJavadocText text = (FormatJavadocText) node;
				if (text.isHtmlTag()) {
					if (text.isImmutableHtmlTag()) {
						// Immutable tags are not formatted
						if (textLength == -1) {
							textLength = getTextLength(block, text);
						}
						// Indent if new line was added
						if (newLines > 0) {
							int col = this.column;
							StringBuffer buffer = new StringBuffer();
							int textEnd = text.separatorsPtr == -1 ? text.sourceEnd : (int) (text.separators[0] >>> 32);
							printJavadocTextLine(buffer, text.sourceStart, textEnd, block, true, true, true);
							addReplaceEdit(text.sourceStart, textEnd, buffer.toString());
							textLength -= this.column - col;
						}
						this.column += textLength;
					} else {
						printJavadocHtmlTag(text, block);
					}
				} else {
					printJavadocText(text, block);
				}
			} else {
				printJavadocBlock((FormatJavadocBlock)node);
			}

			// Print empty lines before the node
			previousEnd = node.sourceEnd;
		}
	}

