	private void handleHtml(TagElement node) {
		if (!this.options.comment_format_html && !this.options.comment_format_source)
			return;
		String text = this.tm.toString(node);
		Matcher matcher = HTML_TAG_PATTERN.matcher(text);
		while (matcher.find()) {
			int startPos = matcher.start() + node.getStartPosition();
			int endPos = matcher.end() - 1 + node.getStartPosition();
			boolean isOpeningTag = (matcher.start(1) == matcher.end(1));

			int firstTokenIndex = 0, lastTokenIndex = 0;
			if (this.options.comment_format_html) {
				// make sure tokens inside the tag are wrapped only as a substitute
				firstTokenIndex = tokenStartingAt(startPos);
				lastTokenIndex = tokenEndingAt(endPos);
				Token startToken = this.ctm.get(firstTokenIndex);
				if (!isOpeningTag && startToken.getWrapPolicy() == null)
					startToken.setWrapPolicy(WrapPolicy.SUBSTITUTE_ONLY);
				for (int i = firstTokenIndex + 1; i <= lastTokenIndex; i++) {
					Token token = this.ctm.get(i);
					if (token.getWrapPolicy() == null)
						token.setWrapPolicy(WrapPolicy.SUBSTITUTE_ONLY);
				}
				Token nextToken = this.ctm.get(lastTokenIndex + 1);
				if (isOpeningTag && nextToken.getWrapPolicy() == null)
					nextToken.setWrapPolicy(WrapPolicy.SUBSTITUTE_ONLY);

				// never break tags on special characters
				noSubstituteWrapping(startPos, endPos - 1);
				// ... except for equals sign in attributes
				String attributesText = matcher.group(8);
				Matcher attrMatcher = HTML_ATTRIBUTE_PATTERN.matcher(attributesText);
				final int commentStart = this.ctm.get(0).originalStart;
				while (attrMatcher.find()) {
					int equalPos = node.getStartPosition() + matcher.start(8) + attrMatcher.start(1);
					assert this.tm.charAt(equalPos) == '=';
					this.noSubstituteWrapping[equalPos - commentStart] = false;
				}
			}

			int matchedGroups = 0;
			for (int i = 2; i <= 7; i++)
				if (matcher.start(i) < matcher.end(i))
					matchedGroups++;
			if (matchedGroups != 1)
				continue;

			if (matcher.start(2) < matcher.end(2)) {
				handleFormatCodeTag(startPos, endPos, isOpeningTag);
			}
			if (this.options.comment_format_html) {
				if (matcher.start(3) < matcher.end(3)) {
					handleSeparateLineTag(startPos, endPos);
				} else if (matcher.start(4) < matcher.end(4)) {
					handleBreakBeforeTag(startPos, endPos, isOpeningTag);
				} else if (matcher.start(5) < matcher.end(5)) {
					handleBreakAfterTag(startPos, endPos);
				} else if (matcher.start(6) < matcher.end(6)) {
					handleNoFormatTag(startPos, endPos, isOpeningTag);
				}
			}
		}
	}

