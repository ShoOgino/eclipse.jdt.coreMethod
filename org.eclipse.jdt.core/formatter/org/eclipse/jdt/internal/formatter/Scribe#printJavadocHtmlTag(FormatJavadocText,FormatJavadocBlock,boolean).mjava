	private int printJavadocHtmlTag(FormatJavadocText text, FormatJavadocBlock block, boolean textOnNewLine) {

		// Compute indentation if necessary
		boolean clearBlankLines = this.formatter.preferences.comment_clear_blank_lines_in_javadoc_comment;
		boolean headerLine = block.isHeaderLine() && this.lastNumberOfNewLines == 0;
		int firstColumn = 1 + this.indentationLevel + BLOCK_LINE_PREFIX_LENGTH;
		if (headerLine) firstColumn++;
		StringBuffer indentationBuffer = printJavadocIndentationBuffer(block, firstColumn);

		// Local variables init
		int textStart = text.sourceStart;
		int nextStart = textStart;
		int startLine = Util.getLineNumber(textStart, this.lineEnds, 0, this.maxLines);
	    int htmlTagID = text.getHtmlTagID();
	    StringBuffer buffer = new StringBuffer();

	    // New line will be added before next node
	    int max = text.separatorsPtr;
		int linesAfter = 0;
		int previousEnd = -1;
	    boolean isBreak = htmlTagID == JAVADOC_SINGLE_BREAK_TAG_ID;
		if (!isBreak) {

			// Iterate on text line separators
			boolean isCode = htmlTagID == JAVADOC_CODE_TAGS_ID;
			for (int idx=0, ptr=0; idx<=max || (text.htmlNodesPtr != -1 && ptr <= text.htmlNodesPtr); idx++) {
	
				// append text to buffer realigning with the line length
				int end = (idx > max) ? text.sourceEnd : (int) (text.separators[idx] >>> 32);
				int nodeKind = 0; // text break
				if (text.htmlNodesPtr >= 0 && ptr <= text.htmlNodesPtr && end > text.htmlNodes[ptr].sourceStart) {
					FormatJavadocNode node = text.htmlNodes[ptr];
					FormatJavadocText htmlTag = node.isText() ? (FormatJavadocText) node : null;
					int newLines = htmlTag == null ? 0 : htmlTag.linesBefore;
					if (linesAfter > newLines) {
						newLines = linesAfter;
						if (newLines > 1 && clearBlankLines) newLines = 1;
					}
					if (textStart < previousEnd) {
						addReplaceEdit(textStart, previousEnd, buffer.toString());
					}
					boolean immutable = htmlTag == null ? false : htmlTag.isImmutableHtmlTag();
					boolean overEndLine = false;
					if (immutable) {
						overEndLine = (this.column + htmlTag.getLength()) > this.formatter.preferences.comment_line_length;
						if (overEndLine) {
							if (newLines < 1) newLines = 1;
						}
					}
					if (newLines == 0) {
						newLines = printJavadocBlockNodesNewLines(block, node, previousEnd);
					}
					printJavadocGapLines(previousEnd+1, node.sourceStart-1, newLines, clearBlankLines, false, null);
					if (newLines > 0) textOnNewLine = true;
					buffer = new StringBuffer();
					if (node.isText()) {
						if (immutable) {
							// do not change immutable tags, just increment column
							this.column += getTextLength(block, htmlTag);
							linesAfter = 0;
							if (overEndLine) {
								// need to indent
								if (indentationBuffer != null) {
									addInsertEdit(node.sourceStart, indentationBuffer.toString());
								}
							}
						} else {
							linesAfter = printJavadocHtmlTag(htmlTag, block, textOnNewLine);
						}
						nodeKind = 1; // text
					} else {
						printJavadocBlock((FormatJavadocBlock)node);
						linesAfter = 0;
						nodeKind = 2; // block
					}
					textStart = node.sourceEnd+1;
					ptr++;
					if (idx > max)  {
						return linesAfter;
					}
				} else {
					if (idx > 0 && linesAfter > 0) {
						printJavadocGapLines(previousEnd+1, nextStart, linesAfter, clearBlankLines, false, buffer);
						textOnNewLine = true;
					}
					boolean needIndentation = textOnNewLine;
					if (idx > 0) {
						if (!needIndentation && (text.htmlIndexes[idx-1] & JAVADOC_TAGS_ID_MASK) == JAVADOC_SEPARATOR_TAGS_ID) {
							needIndentation = true;
						}
					}
					printJavadocTextLine(buffer, nextStart, end, block, idx==1/*first text?*/, needIndentation, idx==0/* opening html tag?*/ || text.htmlIndexes[idx-1] != -1);
					linesAfter = 0;
				    if (idx==0) {
				    	if (htmlTagID == JAVADOC_SEPARATOR_TAGS_ID) {
					    	linesAfter = 1;
					    }
					} else if (text.htmlIndexes[idx-1] == JAVADOC_SINGLE_BREAK_TAG_ID) {
				    	linesAfter = 1;
				    }
				}

				// Replace with current buffer if there are several empty lines between text lines
				nextStart = (int) text.separators[idx];
				int endLine = Util.getLineNumber(end, this.lineEnds, startLine-1, this.maxLines);
				startLine = Util.getLineNumber(nextStart, this.lineEnds, endLine-1, this.maxLines);
				int linesGap = startLine - endLine;
				if (linesGap > 0) {
					if (clearBlankLines && linesGap > 1) {
						// keep previously computed lines after
					} else {
						if (idx==0 || (idx==max && ((text.htmlIndexes[max] & JAVADOC_TAGS_ID_MASK) == htmlTagID)) || (idx < max && nodeKind==1 && (text.htmlIndexes[idx-1] & JAVADOC_TAGS_ID_MASK) != JAVADOC_IMMUTABLE_TAGS_ID)) {
							if (linesAfter < linesGap) {
								linesAfter = linesGap;
							}
						}
					}
				}
				textOnNewLine = linesAfter > 0;

				// print <pre> tag
				if (isCode) {
	    			int codeEnd = (int) (text.separators[max] >>> 32);
	    			if (codeEnd > end) {
	    				if (this.formatter.preferences.comment_format_source) {
							if (textStart < end) addReplaceEdit(textStart, end, buffer.toString());
			    			printJavadocGapLines(end+1, nextStart-1, 1, false/* never clear blank lines inside <pre> tag*/, false, null);
							printCodeSnippet(nextStart, codeEnd);
							nextStart = (int) text.separators[max];
		    				printJavadocGapLines(codeEnd+1, nextStart-1, 1, false/* never clear blank lines inside <pre> tag*/, false, null);
		    				return 2;
	    				}
	    			} else {
						nextStart = (int) text.separators[max];
						if ((nextStart-1) > (end+1)) {
							int line1 = Util.getLineNumber(end+1, this.lineEnds, startLine-1, this.maxLines);
							int line2 = Util.getLineNumber(nextStart-1, this.lineEnds, line1-1, this.maxLines);
		    				int gapLines = line2-line1-1;
							printJavadocGapLines(end+1, nextStart-1, gapLines, false/* never clear blank lines inside <pre> tag*/, false, null);
							if (gapLines > 0) textOnNewLine = true;
						}
	    			}
    				return 1;
				}
				
				// store previous end
				previousEnd = end;
			}
	    }
		
		// Insert last gap
	    boolean closingTag = isBreak || (text.htmlIndexes != null && (text.htmlIndexes[max] & JAVADOC_TAGS_ID_MASK) == htmlTagID);
		if (previousEnd != -1) {
		    if (max > 0 && htmlTagID == JAVADOC_SEPARATOR_TAGS_ID && closingTag) {
				if (linesAfter == 0) linesAfter = 1;
			}
			if (linesAfter > 0) {
				printJavadocGapLines(previousEnd+1, nextStart-1, linesAfter, clearBlankLines, false, buffer);
				textOnNewLine = true;
			}
		}
	    
	    // Print closing tag
		boolean needIndentation = textOnNewLine;
		if (!needIndentation && !isBreak && text.htmlIndexes != null && (text.htmlIndexes[max] & JAVADOC_TAGS_ID_MASK) == JAVADOC_SEPARATOR_TAGS_ID) {
			needIndentation = true;
		}
		printJavadocTextLine(buffer, nextStart, text.sourceEnd, block, max<=0 /*not the first text*/, needIndentation, closingTag/* closing html tag*/);
		if (textStart < text.sourceEnd) {
			addReplaceEdit(textStart, text.sourceEnd, buffer.toString());
		}

		// Reset
		needSpace = false;
		this.scanner.resetTo(text.sourceEnd+1, this.scannerEndPosition - 1);
		
		// Return the new lines to insert after
	    if (max > 0 && htmlTagID == JAVADOC_SEPARATOR_TAGS_ID) {
			return 1;
		}
	    return 0;
	}

