	/*
	 * Print new lines characters when the edits are disabled. In this case, only
	 * the line separator is replaced if necessary, the other white spaces are untouched.
	 */
	private boolean printNewLinesCharacters(int offset, int length) {
		boolean foundNewLine = false;
		int scannerStartPosition = this.scanner.startPosition;
		int scannerEofPosition = this.scanner.eofPosition;
		int scannerCurrentPosition = this.scanner.currentPosition;
		char scannerCurrentChar = this.scanner.currentCharacter;
		this.scanner.resetTo(offset, offset+length-1);
		try {
			while (!this.scanner.atEnd()) {
				int start = this.scanner.currentPosition;
				char ch = (char) this.scanner.getNextChar();
				boolean needReplace = ch != this.firstLS;
				switch (ch) {
					case '\r':
						if (this.scanner.atEnd()) break;
						ch = (char) this.scanner.getNextChar();
						if (ch != '\n') break;
						needReplace = needReplace || this.lsLength != 2;
						//$FALL-THROUGH$
					case '\n':
						if (needReplace) {
							if (this.editsIndex == 0 || this.edits[this.editsIndex-1].offset != start) {
								this.edits[this.editsIndex++] = new OptimizedReplaceEdit(start, this.scanner.currentPosition-start, this.lineSeparator);
							}
						}
						foundNewLine = true;
						break;
				}
			}
		}
		finally {
			this.scanner.startPosition = scannerStartPosition;
			this.scanner.eofPosition = scannerEofPosition;
			this.scanner.currentPosition = scannerCurrentPosition;
			this.scanner.currentCharacter = scannerCurrentChar;
		}
		return foundNewLine;		
	}

