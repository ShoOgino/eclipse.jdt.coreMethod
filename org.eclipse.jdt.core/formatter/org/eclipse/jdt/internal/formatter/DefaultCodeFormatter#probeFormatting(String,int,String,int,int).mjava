	private TextEdit probeFormatting(String source, int indentationLevel, String lineSeparator, int offset, int length) {
		if (ProbingScanner == null) {
			// scanner use to check if the kind could be K_JAVA_DOC, K_MULTI_LINE_COMMENT or K_SINGLE_LINE_COMMENT 
			ProbingScanner = new Scanner(true, true, false/*nls*/, ClassFileConstants.JDK1_3, ClassFileConstants.JDK1_3, null/*taskTags*/, null/*taskPriorities*/, true/*taskCaseSensitive*/);
		}
		ProbingScanner.setSource(source.toCharArray());
		ProbingScanner.resetTo(offset, offset + length);
		try {
			switch(ProbingScanner.getNextToken()) {
				case ITerminalSymbols.TokenNameCOMMENT_BLOCK :
					if (ProbingScanner.getCurrentTokenEndPosition() == offset + length - 1) {
						return formatComment(K_MULTI_LINE_COMMENT, source, indentationLevel, lineSeparator, offset, length);
					}
					break;
				case ITerminalSymbols.TokenNameCOMMENT_LINE :
					if (ProbingScanner.getCurrentTokenEndPosition() == offset + length - 1) {
						return formatComment(K_SINGLE_LINE_COMMENT, source, indentationLevel, lineSeparator, offset, length);
					}
					break;
				case ITerminalSymbols.TokenNameCOMMENT_JAVADOC :
					if (ProbingScanner.getCurrentTokenEndPosition() == offset + length - 1) {
						return formatComment(K_JAVA_DOC, source, indentationLevel, lineSeparator, offset, length);
					}
			}
		} catch (InvalidInputException e) {
			// ignore
		}
		ProbingScanner.setSource((char[]) null);

		// probe for expression
		Expression expression = this.codeSnippetParsingUtil.parseExpression(source.toCharArray(), getDefaultCompilerOptions(), true);
		if (expression != null) {
			if (USE_NEW_FORMATTER) {
				ASTParser parser = ASTParser.newParser(AST.JLS3);
				parser.setSource(source.toCharArray());
				parser.setKind(ASTParser.K_EXPRESSION);
				parser.setCompilerOptions(getDefaultCompilerOptions());
				parser.setResolveBindings(false);
				parser.setUnitName(""); //$NON-NLS-1$
				org.eclipse.jdt.core.dom.ASTNode node = parser.createAST(null);
				if (node.getNodeType() == org.eclipse.jdt.core.dom.ASTNode.COMPILATION_UNIT) return null;
				if (lineSeparator != null) {
					this.preferences.line_separator = lineSeparator;
				} else {
					this.preferences.line_separator = System.getProperty("line.separator"); //$NON-NLS-1$
				}
				this.preferences.initial_indentation_level = indentationLevel;

				this.newCodeFormatter2 = new CodeFormatterVisitor2(this.preferences, this.options, offset, length, (CompilationUnit) node.getRoot());
				
				TextEdit textEdit = this.newCodeFormatter2.format(source, (org.eclipse.jdt.core.dom.Expression) node);
				return textEdit;
			}			
			return internalFormatExpression(source, indentationLevel, lineSeparator, expression, offset, length);
		}

		// probe for body declarations (fields, methods, constructors)
		ASTNode[] bodyDeclarations = this.codeSnippetParsingUtil.parseClassBodyDeclarations(source.toCharArray(), getDefaultCompilerOptions(), true);
		if (bodyDeclarations != null) {
			if (USE_NEW_FORMATTER) {
				ASTParser parser = ASTParser.newParser(AST.JLS3);
				parser.setSource(source.toCharArray());
				parser.setKind(ASTParser.K_CLASS_BODY_DECLARATIONS);
				parser.setCompilerOptions(getDefaultCompilerOptions());
				parser.setResolveBindings(false);
				parser.setUnitName(""); //$NON-NLS-1$
				org.eclipse.jdt.core.dom.ASTNode node = parser.createAST(null);
				if (lineSeparator != null) {
					this.preferences.line_separator = lineSeparator;
				} else {
					this.preferences.line_separator = System.getProperty("line.separator"); //$NON-NLS-1$
				}
				this.preferences.initial_indentation_level = indentationLevel;

				this.newCodeFormatter2 = new CodeFormatterVisitor2(this.preferences, this.options, offset, length, (CompilationUnit) node.getRoot());
				return this.newCodeFormatter2.format(source, (AbstractTypeDeclaration) node);
			}
			return internalFormatClassBodyDeclarations(source, indentationLevel, lineSeparator, bodyDeclarations, offset, length);
		}

		// probe for statements
		ConstructorDeclaration constructorDeclaration = this.codeSnippetParsingUtil.parseStatements(source.toCharArray(), getDefaultCompilerOptions(), true, false);
		if (constructorDeclaration.statements != null) {
			if (USE_NEW_FORMATTER) {
				ASTParser parser = ASTParser.newParser(AST.JLS3);
				parser.setSource(source.toCharArray());
				parser.setKind(ASTParser.K_STATEMENTS);
				parser.setCompilerOptions(getDefaultCompilerOptions());
				parser.setResolveBindings(false);
				parser.setUnitName(""); //$NON-NLS-1$
				org.eclipse.jdt.core.dom.ASTNode node = parser.createAST(null);
				if (lineSeparator != null) {
					this.preferences.line_separator = lineSeparator;
				} else {
					this.preferences.line_separator = System.getProperty("line.separator"); //$NON-NLS-1$
				}
				this.preferences.initial_indentation_level = indentationLevel;

				this.newCodeFormatter2 = new CodeFormatterVisitor2(this.preferences, this.options, offset, length, (CompilationUnit) node.getRoot());
				
				return this.newCodeFormatter2.format(source, (Block) node);
			}
			return internalFormatStatements(source, indentationLevel, lineSeparator, constructorDeclaration, offset, length);
		}

		if (USE_NEW_FORMATTER) {
			ASTParser parser = ASTParser.newParser(AST.JLS3);
			parser.setSource(source.toCharArray());
			parser.setKind(ASTParser.K_COMPILATION_UNIT);
			parser.setCompilerOptions(getDefaultCompilerOptions());
			parser.setResolveBindings(false);
			parser.setUnitName(""); //$NON-NLS-1$
			org.eclipse.jdt.core.dom.ASTNode node = parser.createAST(null);
			if (lineSeparator != null) {
				this.preferences.line_separator = lineSeparator;
			} else {
				this.preferences.line_separator = System.getProperty("line.separator"); //$NON-NLS-1$
			}
			this.preferences.initial_indentation_level = indentationLevel;

			this.newCodeFormatter2 = new CodeFormatterVisitor2(this.preferences, this.options, offset, length, (CompilationUnit) node.getRoot());
			return this.newCodeFormatter2.format(source, (CompilationUnit) node);
		}
		// this has to be a compilation unit
		return formatCompilationUnit(source, indentationLevel, lineSeparator, offset, length);
	}

