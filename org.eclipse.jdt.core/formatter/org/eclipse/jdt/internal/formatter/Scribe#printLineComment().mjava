	private void printLineComment() {
    	int currentTokenStartPosition = this.scanner.getCurrentTokenStartPosition();
    	int currentTokenEndPosition = this.scanner.getCurrentTokenEndPosition() + 1;
    	boolean includesLineComments = includesLineComments();
    	boolean isNlsTag = false;
    	if (CharOperation.indexOf(Scanner.TAG_PREFIX, this.scanner.source, true, currentTokenStartPosition, currentTokenEndPosition) != -1) {
    		this.nlsTagCounter = 0;
    		isNlsTag = true;
    	}
    	this.scanner.resetTo(currentTokenStartPosition, currentTokenEndPosition - 1);
    	int currentCharacter;
    	int start = currentTokenStartPosition;
    	int nextCharacterStart = currentTokenStartPosition;

    	// Print comment line indentation
    	int commentIndentationLevel;
   		boolean onFirstColumn = isOnFirstColumn(start);
    	if (this.indentationLevel == 0) {
    		commentIndentationLevel = this.column - 1;
    	} else {
			if (onFirstColumn &&
					((includesLineComments && !this.formatter.preferences.comment_format_line_comment_starting_on_first_column) ||
					 this.formatter.preferences.never_indent_line_comments_on_first_column)
    			) {
	   			commentIndentationLevel = this.column - 1;
    		} else {
    			// Indentation may be specific for contiguous comment
    			// see bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=293300
				if (this.lastLineComment.contiguous) {
					// The leading spaces have been set while looping in the printComment(int) method
					int currentCommentIndentation = getCurrentIndentation(this.lastLineComment.leadingSpaces, 0);
					// Keep the current comment indentation when over the previous contiguous line comment
					// and the previous comment has not been reindented
					int relativeIndentation = currentCommentIndentation - this.lastLineComment.currentIndentation;
					boolean similarCommentsIndentation = false;
					if (this.tabLength == 0) {
						similarCommentsIndentation = relativeIndentation == 0;
					} else if (relativeIndentation > -this.tabLength) {
						similarCommentsIndentation = relativeIndentation == 0 || currentCommentIndentation != 0 && this.lastLineComment.currentIndentation != 0;
					}
					if (similarCommentsIndentation && this.lastLineComment.indentation != this.indentationLevel) {
						int currentIndentationLevel = this.indentationLevel;
						this.indentationLevel = this.lastLineComment.indentation ;
						printIndentationIfNecessary();
						this.indentationLevel = currentIndentationLevel;
			   			commentIndentationLevel = this.lastLineComment.indentation ;
					} else {
						printIndentationIfNecessary();
			   			commentIndentationLevel = this.column - 1;
					}
				} else {
					if (this.currentAlignment != null && this.currentAlignment.kind == Alignment.ARRAY_INITIALIZER &&
						this.currentAlignment.fragmentCount > 0 &&
						this.indentationLevel < this.currentAlignment.breakIndentationLevel &&
						this.lastLineComment.lines > 0)
					{
						int currentIndentationLevel = this.indentationLevel;
						this.indentationLevel = this.currentAlignment.breakIndentationLevel;
		    			printIndentationIfNecessary();
						this.indentationLevel = currentIndentationLevel;
			   			commentIndentationLevel = this.currentAlignment.breakIndentationLevel;
					} else {
		    			printIndentationIfNecessary();
			   			commentIndentationLevel = this.column - 1;
					}
				}
    		}
    	}
    	
    	// Store line comment information
   		this.lastLineComment.contiguous = true;
		this.lastLineComment.currentIndentation = getCurrentCommentIndentation(currentTokenStartPosition);
		this.lastLineComment.indentation = commentIndentationLevel;
		
		// Add pending space if necessary
    	if (this.pendingSpace) {
    		if (this.formatter.preferences.comment_preserve_white_space_between_code_and_line_comments) {
    			addInsertEdit(currentTokenStartPosition, new String(this.lastLineComment.leadingSpaces));
    		} else {
    			addInsertEdit(currentTokenStartPosition, " "); //$NON-NLS-1$
    		}
    	}
    	this.needSpace = false;
    	this.pendingSpace = false;
    	int previousStart = currentTokenStartPosition;

		if (!isNlsTag && includesLineComments && (!onFirstColumn || this.formatter.preferences.comment_format_line_comment_starting_on_first_column)) {
			printLineComment(currentTokenStartPosition, currentTokenEndPosition-1);
		} else {
			// do nothing!?
	    	loop: while (nextCharacterStart <= currentTokenEndPosition && (currentCharacter = this.scanner.getNextChar()) != -1) {
	    		nextCharacterStart = this.scanner.currentPosition;

	    		switch(currentCharacter) {
	    			case '\r' :
	    				start = previousStart;
	    				break loop;
	    			case '\n' :
	    				start = previousStart;
	    				break loop;
	    		}
	    		previousStart = nextCharacterStart;
	    	}
	    	if (start != currentTokenStartPosition) {
	    		// this means that the line comment doesn't end the file
	    		addReplaceEdit(start, currentTokenEndPosition - 1, this.lineSeparator);
	    		this.line++;
	    		this.column = 1;
	    		this.lastNumberOfNewLines = 1;
	    	}
		}
    	this.needSpace = false;
    	this.pendingSpace = false;
    	// realign to the proper value
    	if (this.currentAlignment != null) {
    		if (this.memberAlignment != null) {
    			// select the last alignment
    			if (this.currentAlignment.location.inputOffset > this.memberAlignment.location.inputOffset) {
    				if (this.currentAlignment.couldBreak() && this.currentAlignment.wasSplit) {
    					this.currentAlignment.performFragmentEffect();
    				}
    			} else {
    				this.indentationLevel = Math.max(this.indentationLevel, this.memberAlignment.breakIndentationLevel);
    			}
    		} else if (this.currentAlignment.couldBreak() && this.currentAlignment.wasSplit) {
    			this.currentAlignment.performFragmentEffect();
    		}
    		if (this.currentAlignment.kind == Alignment.BINARY_EXPRESSION &&
    			this.currentAlignment.enclosing != null &&
    			this.currentAlignment.enclosing.kind == Alignment.BINARY_EXPRESSION &&
    			this.indentationLevel < this.currentAlignment.breakIndentationLevel)
    		{
    			this.indentationLevel = this.currentAlignment.breakIndentationLevel;
    		}
    	}
    	this.scanner.resetTo(currentTokenEndPosition, this.scannerEndPosition - 1);
    }

