	private void format(TypeDeclaration typeDeclaration){
		/*
		 * Print comments to get proper line number
		 */
		this.scribe.printComment();
		int line = this.scribe.line;

		this.scribe.printModifiers(typeDeclaration.annotations, this, ICodeFormatterConstants.ANNOTATION_ON_MEMBER);

		if (this.scribe.line > line) {
			// annotations introduced new line, but this is not a line wrapping
			// see 158267
			line = this.scribe.line;
		}

		/*
		 * Type name
		 */
		switch(TypeDeclaration.kind(typeDeclaration.modifiers)) {
			case TypeDeclaration.CLASS_DECL :
				this.scribe.printNextToken(TerminalTokens.TokenNameclass, true);
				break;
			case TypeDeclaration.INTERFACE_DECL :
				this.scribe.printNextToken(TerminalTokens.TokenNameinterface, true);
				break;
			case TypeDeclaration.ENUM_DECL :
				this.scribe.printNextToken(TerminalTokens.TokenNameenum, true);
				break;
			case TypeDeclaration.ANNOTATION_TYPE_DECL :
				this.scribe.printNextToken(TerminalTokens.TokenNameAT, this.preferences.insert_space_before_at_in_annotation_type_declaration);
				this.scribe.printNextToken(TerminalTokens.TokenNameinterface, this.preferences.insert_space_after_at_in_annotation_type_declaration);
				break;
		}
		this.scribe.printNextToken(TerminalTokens.TokenNameIdentifier, true);

		TypeParameter[] typeParameters = typeDeclaration.typeParameters;
		if (typeParameters != null) {
			this.scribe.printNextToken(TerminalTokens.TokenNameLESS, this.preferences.insert_space_before_opening_angle_bracket_in_type_parameters);
			if (this.preferences.insert_space_after_opening_angle_bracket_in_type_parameters) {
				this.scribe.space();
			}
			int length = typeParameters.length;
			for (int i = 0; i < length - 1; i++) {
				typeParameters[i].traverse(this, typeDeclaration.scope);
				this.scribe.printNextToken(TerminalTokens.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_type_parameters);
				if (this.preferences.insert_space_after_comma_in_type_parameters) {
					this.scribe.space();
				}
			}
			typeParameters[length - 1].traverse(this, typeDeclaration.scope);
			if (isClosingGenericToken()) {
				this.scribe.printNextToken(CLOSING_GENERICS_EXPECTEDTOKENS, this.preferences.insert_space_before_closing_angle_bracket_in_type_parameters);
			}
			if (this.preferences.insert_space_after_closing_angle_bracket_in_type_parameters) {
				this.scribe.space();
			}
		}
		/*
		 * Superclass
		 */
		final TypeReference superclass = typeDeclaration.superclass;
		if (superclass != null) {
			Alignment superclassAlignment =this.scribe.createAlignment(
					Alignment.SUPER_CLASS,
					this.preferences.alignment_for_superclass_in_type_declaration,
					2,
					this.scribe.scanner.currentPosition);
			this.scribe.enterAlignment(superclassAlignment);
			boolean ok = false;
			do {
				try {
					this.scribe.alignFragment(superclassAlignment, 0);
					this.scribe.printNextToken(TerminalTokens.TokenNameextends, true);
					this.scribe.alignFragment(superclassAlignment, 1);
					this.scribe.space();
					superclass.traverse(this, typeDeclaration.scope);
					ok = true;
				} catch (AlignmentException e) {
					this.scribe.redoAlignment(e);
				}
			} while (!ok);
			this.scribe.exitAlignment(superclassAlignment, true);
		}

		/*
		 * Super Interfaces
		 */
		final TypeReference[] superInterfaces = typeDeclaration.superInterfaces;
		if (superInterfaces != null) {
			int alignment_for_superinterfaces;
			int kind = TypeDeclaration.kind(typeDeclaration.modifiers);
			switch(kind) {
				case TypeDeclaration.ENUM_DECL :
					alignment_for_superinterfaces = this.preferences.alignment_for_superinterfaces_in_enum_declaration;
					break;
				default:
					alignment_for_superinterfaces = this.preferences.alignment_for_superinterfaces_in_type_declaration;
					break;
			}
			int superInterfaceLength = superInterfaces.length;
			Alignment interfaceAlignment =this.scribe.createAlignment(
					Alignment.SUPER_INTERFACES,
					alignment_for_superinterfaces,
					superInterfaceLength+1,  // implements token is first fragment
					this.scribe.scanner.currentPosition);
			this.scribe.enterAlignment(interfaceAlignment);
			boolean ok = false;
			do {
				try {
					this.scribe.alignFragment(interfaceAlignment, 0);
					if (kind == TypeDeclaration.INTERFACE_DECL) {
						this.scribe.printNextToken(TerminalTokens.TokenNameextends, true);
					} else  {
						this.scribe.printNextToken(TerminalTokens.TokenNameimplements, true);
					}
					for (int i = 0; i < superInterfaceLength; i++) {
						if (i > 0) {
							this.scribe.printNextToken(TerminalTokens.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_superinterfaces);
							this.scribe.printComment(CodeFormatter.K_UNKNOWN, Scribe.BASIC_TRAILING_COMMENT);
							this.scribe.alignFragment(interfaceAlignment, i+1);
							if (this.preferences.insert_space_after_comma_in_superinterfaces) {
								this.scribe.space();
							}
							superInterfaces[i].traverse(this, typeDeclaration.scope);
						} else {
							this.scribe.alignFragment(interfaceAlignment, i+1);
							this.scribe.space();
							superInterfaces[i].traverse(this, typeDeclaration.scope);
						}
					}
					ok = true;
				} catch (AlignmentException e) {
					this.scribe.redoAlignment(e);
				}
			} while (!ok);
			this.scribe.exitAlignment(interfaceAlignment, true);
		}

		/*
		 * Type body
		 */
		String class_declaration_brace;
		boolean space_before_opening_brace;
		int kind = TypeDeclaration.kind(typeDeclaration.modifiers);
		switch(kind) {
			case TypeDeclaration.ENUM_DECL :
				class_declaration_brace = this.preferences.brace_position_for_enum_declaration;
				space_before_opening_brace = this.preferences.insert_space_before_opening_brace_in_enum_declaration;
				break;
			case TypeDeclaration.ANNOTATION_TYPE_DECL :
				class_declaration_brace = this.preferences.brace_position_for_annotation_type_declaration;
				space_before_opening_brace =  this.preferences.insert_space_before_opening_brace_in_annotation_type_declaration;
				break;
			default:
				class_declaration_brace = this.preferences.brace_position_for_type_declaration;
				space_before_opening_brace = this.preferences.insert_space_before_opening_brace_in_type_declaration;
				break;
		}
		formatLeftCurlyBrace(line, class_declaration_brace);
		formatTypeOpeningBrace(class_declaration_brace, space_before_opening_brace, typeDeclaration);

		boolean indent_body_declarations_compare_to_header;
		switch(kind) {
			case TypeDeclaration.ENUM_DECL :
				indent_body_declarations_compare_to_header = this.preferences.indent_body_declarations_compare_to_enum_declaration_header;
				break;
			case TypeDeclaration.ANNOTATION_TYPE_DECL :
				indent_body_declarations_compare_to_header = this.preferences.indent_body_declarations_compare_to_annotation_declaration_header;
				break;
			default:
				indent_body_declarations_compare_to_header = this.preferences.indent_body_declarations_compare_to_type_header;
				break;
		}
		if (indent_body_declarations_compare_to_header) {
			this.scribe.indent();
		}

		if (kind == TypeDeclaration.ENUM_DECL) {
			FieldDeclaration[] fieldDeclarations = typeDeclaration.fields;
			boolean hasConstants = false;
			int length = fieldDeclarations != null ? fieldDeclarations.length : 0;
			int enumConstantsLength = 0;
			if (fieldDeclarations != null) {
				for (int i = 0; i < length; i++) {
					FieldDeclaration fieldDeclaration = fieldDeclarations[i];
					if (fieldDeclaration.getKind() == AbstractVariableDeclaration.ENUM_CONSTANT) {
						enumConstantsLength++;
					} else {
						break;
					}
				}
				hasConstants = enumConstantsLength != 0;
				if (enumConstantsLength > 1) {
					Alignment enumConstantsAlignment = this.scribe.createAlignment(
							Alignment.ENUM_CONSTANTS,
							this.preferences.alignment_for_enum_constants,
							enumConstantsLength,
							this.scribe.scanner.currentPosition,
							0, // we don't want to indent enum constants when splitting to a new line
							false);
					this.scribe.enterAlignment(enumConstantsAlignment);
					boolean ok = false;
					do {
						try {
							for (int i = 0; i < enumConstantsLength; i++) {
								this.scribe.alignFragment(enumConstantsAlignment, i);
								FieldDeclaration fieldDeclaration = fieldDeclarations[i];
								fieldDeclaration.traverse(this, typeDeclaration.initializerScope);
								if (isNextToken(TerminalTokens.TokenNameCOMMA)) {
									this.scribe.printNextToken(TerminalTokens.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_enum_declarations);
									if (this.preferences.insert_space_after_comma_in_enum_declarations) {
										this.scribe.space();
									}
									this.scribe.printComment(CodeFormatter.K_UNKNOWN, Scribe.BASIC_TRAILING_COMMENT);
									if (fieldDeclaration.initialization instanceof QualifiedAllocationExpression) {
										this.scribe.printNewLine();
									}
								}
							}
							ok = true;
						} catch (AlignmentException e) {
							this.scribe.redoAlignment(e);
						}
					} while (!ok);
					this.scribe.exitAlignment(enumConstantsAlignment, true);
				} else if (hasConstants) {
					// only one enum constant
					FieldDeclaration fieldDeclaration = fieldDeclarations[0];
					fieldDeclaration.traverse(this, typeDeclaration.initializerScope);
					if (isNextToken(TerminalTokens.TokenNameCOMMA)) {
						this.scribe.printNextToken(TerminalTokens.TokenNameCOMMA, this.preferences.insert_space_before_comma_in_enum_declarations);
						if (this.preferences.insert_space_after_comma_in_enum_declarations) {
							this.scribe.space();
						}
						this.scribe.printComment(CodeFormatter.K_UNKNOWN, Scribe.BASIC_TRAILING_COMMENT);
						if (fieldDeclaration.initialization instanceof QualifiedAllocationExpression) {
							this.scribe.printNewLine();
						}
					}
				}
			}
			if (isNextToken(TerminalTokens.TokenNameSEMICOLON)) {
				this.scribe.printNextToken(TerminalTokens.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);
				this.scribe.printComment(CodeFormatter.K_UNKNOWN, Scribe.BASIC_TRAILING_COMMENT);
				if (hasConstants
						|| ((enumConstantsLength - length) != 0)
						|| typeDeclaration.methods != null
						|| typeDeclaration.memberTypes != null) {
					// make sure that empty enums don't get a new line
					this.scribe.printNewLine();
				}
			} else if (hasConstants) {
				// only had a new line if there is at least one enum constant
				this.scribe.printNewLine();
			}
		}

		formatTypeMembers(typeDeclaration);

		if (indent_body_declarations_compare_to_header) {
			this.scribe.unIndent();
		}

		switch(kind) {
			case TypeDeclaration.ENUM_DECL :
				if (this.preferences.insert_new_line_in_empty_enum_declaration) {
					this.scribe.printNewLine();
				}
				break;
			case TypeDeclaration.ANNOTATION_TYPE_DECL :
				if (this.preferences.insert_new_line_in_empty_annotation_declaration) {
					this.scribe.printNewLine();
				}
				break;
			default :
				if (this.preferences.insert_new_line_in_empty_type_declaration) {
					this.scribe.printNewLine();
				}
		}
		this.scribe.printNextToken(TerminalTokens.TokenNameRBRACE);
		this.scribe.printComment(CodeFormatter.K_UNKNOWN, Scribe.BASIC_TRAILING_COMMENT);
		if (class_declaration_brace.equals(DefaultCodeFormatterConstants.NEXT_LINE_SHIFTED)) {
			this.scribe.unIndent();
		}
		if (hasComments()) {
			this.scribe.printNewLine();
		}
	}

