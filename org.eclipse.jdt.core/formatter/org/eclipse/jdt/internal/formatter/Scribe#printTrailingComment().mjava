	public void printTrailingComment() {
		try {
			// if we have a space between two tokens we ensure it will be dumped in the formatted string
			int currentTokenStartPosition = this.scanner.currentPosition;
			boolean hasCommentLine = false;
			while (!hasCommentLine && (this.currentToken = this.scanner.getNextToken()) != ITerminalSymbols.TokenNameEOF) {
				switch(this.currentToken) {
					case ITerminalSymbols.TokenNameWHITESPACE :
						int count = 0;
						char[] whiteSpaces = this.scanner.getCurrentTokenSource();
						for (int i = 0, max = whiteSpaces.length; i < max; i++) {
							switch(whiteSpaces[i]) {
								case '\r' :
									if ((i + 1) < max) {
										if (whiteSpaces[i + 1] == '\n') {
											i++;
											count++;
										}
									} else {
										count++;
									}
									break;
								case '\n' :
									count++;
							}
						}
						currentTokenStartPosition = this.scanner.currentPosition;
						if (count > 0) {
							if (!hasCommentLine) {
								preserveEmptyLines(count);
								this.printNewLine();
							}
							this.scanner.resetTo(currentTokenStartPosition, this.scannerEndPosition);
							return;
						}
						break;
					case ITerminalSymbols.TokenNameCOMMENT_LINE :
						this.printCommentLine(this.scanner.getCurrentTokenSource(), this.scanner.getCurrentTokenStartPosition());
						currentTokenStartPosition = this.scanner.currentPosition;
						hasCommentLine = true;
						break;
					case ITerminalSymbols.TokenNameCOMMENT_BLOCK :
					case ITerminalSymbols.TokenNameCOMMENT_JAVADOC :
						this.printBlockComment(this.scanner.getRawTokenSource(), this.scanner.getCurrentTokenStartPosition());
						currentTokenStartPosition = this.scanner.currentPosition;
						break;
					default :
						if (!hasCommentLine) {
							this.printNewLine();
						}
						this.scanner.resetTo(currentTokenStartPosition, this.scannerEndPosition);
						return;
				}
			}
		} catch (InvalidInputException e) {
			throw new AbortFormatting(e);
		}
	}

