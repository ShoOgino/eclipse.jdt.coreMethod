	/**
	 * Outputs <code>currentString</code>:<br>
	 * <ul><li>If its length is < maxLineLength, output
	 * <li>Otherwise it is split.</ul>
	 * @param currentString string to output
	 * @param preIndented whether the string to output was pre-indented
	 * @param depth number of indentation to put in front of <code>currentString</code>
	 * @param operator value of the operator belonging to <code>currentString</code>.
	 */
	private void outputLine(
		String currentString,
		boolean preIndented,
		int depth,
		int operator,
		int substringIndex,
		int[] startSubstringIndexes,
		int offsetInGlobalLine) {

		boolean emptyFirstSubString = false;
		String operatorString = operatorString(operator);
		boolean placeOperatorBehind = !breakLineBeforeOperator(operator);
		boolean placeOperatorAhead = !placeOperatorBehind;

		// dump prefix operator?
		if (placeOperatorAhead) {
			if (!preIndented) {
				dumpTab(depth);
				preIndented = true;
			}
			if (operator != 0) {
				if (insertSpaceBefore(operator)) {
					formattedSource.append(' ');
					increaseSplitDelta(1);
				}
				formattedSource.append(operatorString);
				increaseSplitDelta(operatorString.length());

				if (insertSpaceAfter(operator)
					&& operator != TokenNameimplements
					&& operator != TokenNameextends
					&& operator != TokenNamethrows) {
					formattedSource.append(' ');
					increaseSplitDelta(1);
				}
			}
		}
		SplitLine splitLine = null;
		if (options.maxLineLength == 0
			|| currentString.length() < options.maxLineLength
			|| (splitLine = split(currentString, offsetInGlobalLine)) == null) {

			// depending on the type of operator, outputs new line before of after dumping it
			// indent before postfix operator
			// indent also when the line cannot be split
			if (operator == TokenNameextends
				|| operator == TokenNameimplements
				|| operator == TokenNamethrows) {
				formattedSource.append(' ');
				increaseSplitDelta(1);
			}
			if (placeOperatorBehind) {
				if (!preIndented) {
					dumpTab(depth);
				}
			}
			int numberOfSpaces = 0;
			int max = currentString.length();
			if (multipleLineCommentCounter != 0) {
				try {
					BufferedReader reader = new BufferedReader(new StringReader(currentString));
					String line = reader.readLine();
					while (line != null) {
						updateMappedPositionsWhileSplitting(
							beginningOfLineIndex,
							beginningOfLineIndex + line.length() + options.lineSeparatorSequence.length);
						formattedSource.append(line);
						beginningOfLineIndex = beginningOfLineIndex + line.length();
						if ((line = reader.readLine()) != null) {
							formattedSource.append(options.lineSeparatorSequence);
							beginningOfLineIndex += options.lineSeparatorSequence.length;
							dumpTab(currentLineIndentationLevel);
						}
					}
					reader.close();
				} catch(IOException e) {
					e.printStackTrace();
				}
			} else {
				updateMappedPositionsWhileSplitting(
					beginningOfLineIndex,
					beginningOfLineIndex + max);
				int currentMultipleLineNumber = 0;
				int previousMultipleLineNumber = -1;
				int currentPositionInCurrentLineBuffer = 0;
				int numberOfLineBreaksInCurrentMultipleLineComment = 0;
				for (int i = 0; i < max; i++) {
					char currentChar = currentString.charAt(i);
					switch (currentChar) {
						case '\r' :
							break;
						case '\n' :
							if (i != max - 1) {
								// fix for 1FFYL5C: LFCOM:ALL - Incorrect indentation when split with a comment inside a condition
								// a substring cannot end with a lineSeparatorSequence,
								// except if it has been added by format() after a one-line comment
								formattedSource.append(options.lineSeparatorSequence);
	
								// 1FGDDV6: LFCOM:WIN98 - Weird splitting on message expression
								dumpTab(depth - 1);
							}
							break;
						default :
							formattedSource.append(currentChar);
					}
				}
			}
			// update positions inside the mappedPositions table
			if (substringIndex != -1) {
				if (multipleLineCommentCounter == 0) {
					int startPosition =
						beginningOfLineIndex + startSubstringIndexes[substringIndex];
					updateMappedPositionsWhileSplitting(startPosition, startPosition + max);
				}

				// compute the splitDelta resulting with the operator and blank removal
				if (substringIndex + 1 != startSubstringIndexes.length) {
					increaseSplitDelta(
						startSubstringIndexes[substringIndex]
							+ max
							- startSubstringIndexes[substringIndex + 1]);
				}
			}
			// dump postfix operator?
			if (placeOperatorBehind) {
				if (insertSpaceBefore(operator)) {
					formattedSource.append(' ');
					if (operator != 0) {
						increaseSplitDelta(1);
					}
				}
				formattedSource.append(operatorString);
				if (operator != 0) {
					increaseSplitDelta(operatorString.length());
				}
			}
			return;
		}
		// fix for 1FG0BA3: LFCOM:WIN98 - Weird splitting on interfaces
		// extends has to stand alone on a line when currentString has been split.
		if (options.maxLineLength != 0
			&& splitLine != null
			&& (operator == TokenNameextends
				|| operator == TokenNameimplements
				|| operator == TokenNamethrows)) {
			formattedSource.append(options.lineSeparatorSequence);
			increaseSplitDelta(options.lineSeparatorSequence.length);
			dumpTab(depth + 1);
		} else {
			if (operator == TokenNameextends
				|| operator == TokenNameimplements
				|| operator == TokenNamethrows) {
				formattedSource.append(' ');
				increaseSplitDelta(1);
			}
		}
		// perform actual splitting
		String result[] = splitLine.substrings;
		int[] splitOperators = splitLine.operators;
		int[] splitLineStartIndexes = splitLine.startSubstringsIndexes;

		if (result[0].length() == 0) {
			// when the substring 0 is null, the substring 1 is correctly indented.
			depth--;
			emptyFirstSubString = true;
		}
		// the operator going in front of the result[0] string is the operator parameter
		for (int i = 0, max = result.length; i < max; i++) {
			// the new depth is the current one if this is the first substring,
			// the current one + 1 otherwise.
			// if the substring is a comment, use the current indentation Level instead of the depth
			// (-1 because the ouputline increases depth).
			// (fix for 1FFC72R: LFCOM:ALL - Incorrect line split in presence of line comments)
			String currentResult = result[i];

			if (currentResult.length() != 0 || splitOperators[i] != 0) {
					int newDepth =
						(currentResult.startsWith("/*") //$NON-NLS-1$
							|| currentResult.startsWith("//")) //$NON-NLS-1$ 
								? indentationLevel - 1 : depth;
				outputLine(
					currentResult,
					i == 0 || (i == 1 && emptyFirstSubString) ? preIndented : false,
					i == 0 ? newDepth : newDepth + 1,
					splitOperators[i],
					i,
					splitLine.startSubstringsIndexes,
					currentString.indexOf(currentResult));
				if (i != max - 1) {
					formattedSource.append(options.lineSeparatorSequence);
					increaseSplitDelta(options.lineSeparatorSequence.length);
				}
			}
		}
		if (result.length == splitOperators.length - 1) {
			int lastOperator = splitOperators[result.length];
			String lastOperatorString = operatorString(lastOperator);
			formattedSource.append(options.lineSeparatorSequence);
			increaseSplitDelta(options.lineSeparatorSequence.length);

			if (breakLineBeforeOperator(lastOperator)) {
				dumpTab(depth + 1);
				if (lastOperator != 0) {
					if (insertSpaceBefore(lastOperator)) {
						formattedSource.append(' ');
						increaseSplitDelta(1);
					}
					formattedSource.append(lastOperatorString);
					increaseSplitDelta(lastOperatorString.length());

					if (insertSpaceAfter(lastOperator)
						&& lastOperator != TokenNameimplements
						&& lastOperator != TokenNameextends
						&& lastOperator != TokenNamethrows) {
						formattedSource.append(' ');
						increaseSplitDelta(1);
					}
				}
			}
		}
		if (placeOperatorBehind) {
			if (insertSpaceBefore(operator)) {
				formattedSource.append(' ');
				increaseSplitDelta(1);
			}
			formattedSource.append(operatorString);
			//increaseSplitDelta(operatorString.length());
		}
	}

