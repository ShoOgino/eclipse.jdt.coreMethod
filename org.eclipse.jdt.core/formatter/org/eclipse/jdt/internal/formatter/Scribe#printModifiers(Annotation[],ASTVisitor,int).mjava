	public void printModifiers(Annotation[] annotations, ASTVisitor visitor, int annotationSourceKind) {
		try {
			int annotationsLength = annotations != null ? annotations.length : 0;
			int annotationsIndex = 0;
			boolean isFirstModifier = true;
			int currentTokenStartPosition = this.scanner.currentPosition;
			boolean hasComment = false;
			boolean hasModifiers = false;
			while ((this.currentToken = this.scanner.getNextToken()) != TerminalTokens.TokenNameEOF) {
				int foundTaskCount = this.scanner.foundTaskCount;
				int tokenStartPosition = this.scanner.getCurrentTokenStartPosition();
				int tokenEndPosition = this.scanner.getCurrentTokenEndPosition();
				switch(this.currentToken) {
					case TerminalTokens.TokenNamepublic :
					case TerminalTokens.TokenNameprotected :
					case TerminalTokens.TokenNameprivate :
					case TerminalTokens.TokenNamestatic :
					case TerminalTokens.TokenNameabstract :
					case TerminalTokens.TokenNamefinal :
					case TerminalTokens.TokenNamenative :
					case TerminalTokens.TokenNamesynchronized :
					case TerminalTokens.TokenNametransient :
					case TerminalTokens.TokenNamevolatile :
					case TerminalTokens.TokenNamestrictfp :
						hasModifiers = true;
						print(this.scanner.currentPosition - this.scanner.startPosition, !isFirstModifier);
						isFirstModifier = false;
						currentTokenStartPosition = this.scanner.currentPosition;
						break;
					case TerminalTokens.TokenNameAT :
						hasModifiers = true;
						if (!isFirstModifier) {
							space();
						}
						this.scanner.resetTo(this.scanner.getCurrentTokenStartPosition(), this.scannerEndPosition - 1);
						if (annotationsIndex < annotationsLength) {
							boolean insertSpaceBeforeBrace = this.formatter.preferences.insert_space_before_opening_brace_in_array_initializer;
							this.formatter.preferences.insert_space_before_opening_brace_in_array_initializer = false;
							try {
								annotations[annotationsIndex++].traverse(visitor, (BlockScope) null);
							}
							finally {
								this.formatter.preferences.insert_space_before_opening_brace_in_array_initializer = insertSpaceBeforeBrace;
							}
							// https://bugs.eclipse.org/bugs/show_bug.cgi?id=122247
							boolean shouldAddNewLine = false;
							switch (annotationSourceKind) {
								case ICodeFormatterConstants.ANNOTATION_ON_TYPE :
									if (this.formatter.preferences.insert_new_line_after_annotation_on_type) {
										shouldAddNewLine = true;
									}
									break;
								case ICodeFormatterConstants.ANNOTATION_ON_FIELD :
									if (this.formatter.preferences.insert_new_line_after_annotation_on_field) {
										shouldAddNewLine = true;
									}
									break;
								case ICodeFormatterConstants.ANNOTATION_ON_METHOD :
									if (this.formatter.preferences.insert_new_line_after_annotation_on_method) {
										shouldAddNewLine = true;
									}
									break;
								case ICodeFormatterConstants.ANNOTATION_ON_PACKAGE :
									if (this.formatter.preferences.insert_new_line_after_annotation_on_package) {
										shouldAddNewLine = true;
									}
									break;
								case ICodeFormatterConstants.ANNOTATION_ON_PARAMETER :
									if (this.formatter.preferences.insert_new_line_after_annotation_on_parameter) {
										shouldAddNewLine = true;
									}
									break;
								case ICodeFormatterConstants.ANNOTATION_ON_LOCAL_VARIABLE :
									if (this.formatter.preferences.insert_new_line_after_annotation_on_local_variable) {
										shouldAddNewLine = true;
									}
									break;
								default:
									// do nothing when no annotation formatting option specified
							}
							if (shouldAddNewLine) {
								this.printNewLine();
							}
						} else {
							return;
						}
						isFirstModifier = false;
						currentTokenStartPosition = this.scanner.currentPosition;
						break;
					case TerminalTokens.TokenNameCOMMENT_BLOCK :
					case TerminalTokens.TokenNameCOMMENT_JAVADOC :
						if (this.useTags && this.editsEnabled) {
							boolean turnOff = false;
							if (foundTaskCount > 0) {
								setEditsEnabled(foundTaskCount);
								turnOff = true;
							} else if (this.tagsKind == this.currentToken
								&& CharOperation.equals(this.disablingTag, this.scanner.source, tokenStartPosition, tokenEndPosition+1)) {
    							this.editsEnabled = false;
								turnOff = true;
					    	}
							if (turnOff) {
								if (!this.editsEnabled && this.editsIndex > 1) {
									OptimizedReplaceEdit currentEdit = this.edits[this.editsIndex-1];
									if (this.scanner.startPosition == currentEdit.offset+currentEdit.length) {
										printNewLinesBeforeDisablingComment();
									}
								}
							}
						}
						printBlockComment(this.currentToken == TerminalTokens.TokenNameCOMMENT_JAVADOC);
						if (this.useTags && !this.editsEnabled) {
							if (foundTaskCount > 0) {
								setEditsEnabled(foundTaskCount);
							} else if (this.tagsKind == this.currentToken) {
	    						this.editsEnabled = CharOperation.equals(this.enablingTag, this.scanner.source, tokenStartPosition, tokenEndPosition+1);
					    	}
						}
						currentTokenStartPosition = this.scanner.currentPosition;
						hasComment = true;
						break;
					case TerminalTokens.TokenNameCOMMENT_LINE :
						tokenEndPosition = -this.scanner.commentStops[this.scanner.commentPtr];
						if (this.useTags && this.editsEnabled) {
							boolean turnOff = false;
							if (foundTaskCount > 0) {
								setEditsEnabled(foundTaskCount);
								turnOff = true;
							} else if (this.tagsKind == this.currentToken
								&& CharOperation.equals(this.disablingTag, this.scanner.source, tokenStartPosition, tokenEndPosition)) {
    							this.editsEnabled = false;
								turnOff = true;
					    	}
							if (turnOff) {
								if (!this.editsEnabled && this.editsIndex > 1) {
									OptimizedReplaceEdit currentEdit = this.edits[this.editsIndex-1];
									if (this.scanner.startPosition == currentEdit.offset+currentEdit.length) {
										printNewLinesBeforeDisablingComment();
									}
								}
							}
						}
						printLineComment();
						if (this.useTags && !this.editsEnabled) {
							if (foundTaskCount > 0) {
								setEditsEnabled(foundTaskCount);
							} else if (this.tagsKind == this.currentToken) {
	    						this.editsEnabled = CharOperation.equals(this.enablingTag, this.scanner.source, tokenStartPosition, tokenEndPosition);
					    	}
						}
						currentTokenStartPosition = this.scanner.currentPosition;
						break;
					case TerminalTokens.TokenNameWHITESPACE :
						addDeleteEdit(this.scanner.getCurrentTokenStartPosition(), this.scanner.getCurrentTokenEndPosition());
						int count = 0;
						char[] whiteSpaces = this.scanner.getCurrentTokenSource();
						for (int i = 0, max = whiteSpaces.length; i < max; i++) {
							switch(whiteSpaces[i]) {
								case '\r' :
									if ((i + 1) < max) {
										if (whiteSpaces[i + 1] == '\n') {
											i++;
										}
									}
									count++;
									break;
								case '\n' :
									count++;
							}
						}
						if (count >= 1 && hasComment) {
							printNewLine();
						}
						currentTokenStartPosition = this.scanner.currentPosition;
						hasComment = false;
						break;
					default:
						if (hasModifiers) {
							space();
						}
						// step back one token
						this.scanner.resetTo(currentTokenStartPosition, this.scannerEndPosition - 1);
						return;
				}
			}
		} catch (InvalidInputException e) {
			throw new AbortFormatting(e);
		}
	}

