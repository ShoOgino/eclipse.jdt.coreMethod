	public boolean visit(CompilationUnit node) {
		// fake new line to handle empty lines before package declaration or import declarations
		this.scribe.lastNumberOfNewLines = 1;
		/* 
		 * Package declaration
		 */
		final PackageDeclaration packageDeclaration = node.getPackage();
		final boolean hasPackage = packageDeclaration != null;
		if (hasPackage) {
			if (hasComments()) {
				this.scribe.printComment();
			}
			int blankLinesBeforePackage = this.preferences.blank_lines_before_package;
			if (blankLinesBeforePackage > 0) {
				this.scribe.printEmptyLines(blankLinesBeforePackage);
			}

			final List annotations = packageDeclaration.annotations();
			if (annotations.size() != 0) {
				this.scribe.printModifiers(annotations, this);
				this.scribe.space();
			}
			// dump the package keyword
			this.scribe.printNextToken(TerminalTokens.TokenNamepackage);
			this.scribe.space();
			packageDeclaration.getName().accept(this);
			this.scribe.printNextToken(TerminalTokens.TokenNameSEMICOLON, this.preferences.insert_space_before_semicolon);
			this.scribe.printTrailingComment();
			int blankLinesAfterPackage = this.preferences.blank_lines_after_package;
			if (blankLinesAfterPackage > 0) {
				this.scribe.printEmptyLines(blankLinesAfterPackage);
			} else {
				this.scribe.printNewLine();
			}			
		} else {
			this.scribe.printComment();
		}
		
		/*
		 * Import statements
		 */
		final List imports = node.imports();
		final int importsLength = imports.size();
		if (importsLength != 0) {
			if (hasPackage) {
				int blankLinesBeforeImports = this.preferences.blank_lines_before_imports;
				if (blankLinesBeforeImports > 0) {
					this.scribe.printEmptyLines(blankLinesBeforeImports);
				}
			}
			for (int i = 0; i < importsLength; i++) {
				((ImportDeclaration) imports.get(i)).accept(this);
			}			
			
			int blankLinesAfterImports = this.preferences.blank_lines_after_imports;
			if (blankLinesAfterImports > 0) {
				this.scribe.printEmptyLines(blankLinesAfterImports);
			}
		}

		formatEmptyTypeDeclaration(true);
		
		int blankLineBetweenTypeDeclarations = this.preferences.blank_lines_between_type_declarations;
		/*
		 * Type declarations
		 */
		final List types = node.types();
		final int typesLength = types.size();
		if (typesLength != 0) {
			for (int i = 0; i < typesLength - 1; i++) {
				((AbstractTypeDeclaration) types.get(i)).accept(this);
				formatEmptyTypeDeclaration(false);
				if (blankLineBetweenTypeDeclarations != 0) {
					this.scribe.printEmptyLines(blankLineBetweenTypeDeclarations);
				} else {
					this.scribe.printNewLine();
				}
			}
			((AbstractTypeDeclaration) types.get(typesLength - 1)).accept(this);
		}
		this.scribe.printEndOfCompilationUnit();
		return false;
	}

