	/** 
	 * Appends <code>token</code> to the formatted output.<br>
	 * If it contains <code>\n</code>, append a LINE_SEPARATOR and indent after it.
	 */
	private void outputCurrentToken(int token) {
		char[] source = scanner.source;
		int startPosition = scanner.startPosition;

		switch (token) {
			case Scanner.TokenNameCOMMENT_JAVADOC :
			case Scanner.TokenNameCOMMENT_BLOCK :
			case Scanner.TokenNameCOMMENT_LINE :
				boolean endOfLine = false;
				int commentOffset = getCurrentCommentOffset();
				int beginningOfLineSpaces = 0;
				endOfLine = false;
				commentOffset = getCurrentCommentOffset();
				beginningOfLineSpaces = 0;
				boolean pendingCarriageReturn = false;
				for (int i = startPosition, max = scanner.currentPosition; i < max; i++) {
					char currentCharacter = source[i];
					updateMappedPositions(i);
					switch (currentCharacter) {
						case '\r' :
							pendingCarriageReturn = true;
							endOfLine = true;
							break;
						case '\n' :
							if (pendingCarriageReturn) {
								increaseGlobalDelta(options.lineSeparatorSequence.length - 2);
							} else {
								increaseGlobalDelta(options.lineSeparatorSequence.length - 1);
							}
							pendingCarriageReturn = false;
							currentLineBuffer.append(options.lineSeparatorSequence);
							beginningOfLineSpaces = 0;
							endOfLine = true;
							break;
						case '\t' :
							if (pendingCarriageReturn) {
								pendingCarriageReturn = false;
								increaseGlobalDelta(options.lineSeparatorSequence.length - 1);
								currentLineBuffer.append(options.lineSeparatorSequence);
								beginningOfLineSpaces = 0;
								endOfLine = true;
							}
							if (endOfLine) {
								// we remove a maximum of currentCommentOffset characters (tabs are converted to space numbers).
								beginningOfLineSpaces += options.tabSize;
								if (beginningOfLineSpaces > commentOffset) {
									currentLineBuffer.append(currentCharacter);
								} else {
									increaseGlobalDelta(-1);
								}
							} else {
								currentLineBuffer.append(currentCharacter);
							}
							break;
						case ' ' :
							if (pendingCarriageReturn) {
								pendingCarriageReturn = false;
								increaseGlobalDelta(options.lineSeparatorSequence.length - 1);
								currentLineBuffer.append(options.lineSeparatorSequence);
								beginningOfLineSpaces = 0;
								endOfLine = true;
							}
							if (endOfLine) {
								// we remove a maximum of currentCommentOffset characters (tabs are converted to space numbers).
								beginningOfLineSpaces++;
								if (beginningOfLineSpaces > commentOffset) {
									currentLineBuffer.append(currentCharacter);
								} else {
									increaseGlobalDelta(-1);
								}
							} else {
								currentLineBuffer.append(currentCharacter);
							}
							break;
						default :
							if (pendingCarriageReturn) {
								pendingCarriageReturn = false;
								increaseGlobalDelta(options.lineSeparatorSequence.length - 1);
								currentLineBuffer.append(options.lineSeparatorSequence);
								beginningOfLineSpaces = 0;
								endOfLine = true;
							} else {
								beginningOfLineSpaces = 0;
								currentLineBuffer.append(currentCharacter);
								endOfLine = false;								
							}
					}
				}
				updateMappedPositions(scanner.currentPosition - 1);
				multipleLineCommentCounter++;
				break;
			default :
				for (int i = startPosition, max = scanner.currentPosition; i < max; i++) {
					char currentCharacter = source[i];
					updateMappedPositions(i);
					currentLineBuffer.append(currentCharacter);
				}
		}
	}

