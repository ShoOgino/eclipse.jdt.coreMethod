	private void processPathEntries(final int defaultSize, final ArrayList paths, final String currentPath, String customEncoding, boolean isSource) {
		String currentClasspathName = null;
		ArrayList currentRuleSpecs = new ArrayList(defaultSize);
		StringTokenizer tokenizer = new StringTokenizer(currentPath,
				File.pathSeparator + "[]", true); //$NON-NLS-1$
		// state machine
		final int start = 0; 
		final int readyToClose = 1;
		// 'path' 'path1[rule];path2'
		final int readyToCloseEndingWithRules = 2;
		// 'path[rule]' 'path1;path2[rule]'
		final int readyToCloseOrOtherEntry = 3;
		// 'path[rule];' 'path;' 'path1;path2;'
		final int rulesNeedAnotherRule = 4;
		// 'path[rule1;'
		final int rulesStart = 5;
		// 'path[' 'path1;path2['
		final int rulesReadyToClose = 6;
		// 'path[rule' 'path[rule1;rule2'
		final int error = 99;
		int state = start;
		String token = null;
		while (tokenizer.hasMoreTokens()) {
			token = tokenizer.nextToken();
			if (token.equals(File.pathSeparator)) {
				switch (state) {
				case start:
					break;
				case readyToClose:
				case readyToCloseEndingWithRules:
				case readyToCloseOrOtherEntry:
					state = readyToCloseOrOtherEntry;
					addNewEntry(paths, currentClasspathName, currentRuleSpecs, customEncoding, isSource);
					currentRuleSpecs.clear();
					break;
				case rulesReadyToClose:
					state = rulesNeedAnotherRule;
					break;
				default:
					state = error;
				}
			} else if (token.equals("[")) { //$NON-NLS-1$
				switch (state) {
				case readyToClose:
					state = rulesStart;
					break;
				default:
					state = error;
				}
			} else if (token.equals("]")) { //$NON-NLS-1$
				switch (state) {
				case rulesReadyToClose:
					state = readyToCloseEndingWithRules;
					break;
				default:
					state = error;
				}

			} else {
				// regular word
				switch (state) {
				case start:
				case readyToCloseOrOtherEntry:
					state = readyToClose;
					currentClasspathName = token;
					break;
				case rulesNeedAnotherRule:
				case rulesStart:
					state = rulesReadyToClose;
					currentRuleSpecs.add(token);
					break;
				default:
					state = error;
				}
			}
		}
		switch(state) {
			case readyToClose :
			case readyToCloseEndingWithRules :
			case readyToCloseOrOtherEntry :
				addNewEntry(paths, currentClasspathName, currentRuleSpecs, customEncoding, isSource);
				break;
			default :
				// we go on anyway
				this.logger.logIncorrectClasspath(currentPath);
		}
	}

