private NameEnvironmentAnswer internalFindClass(String qualifiedTypeName, char[] typeName, boolean asBinaryOnly, /*NonNull*/char[] moduleName) {
	if (this.knownFileNames.contains(qualifiedTypeName)) return null; // looking for a file which we know was provided at the beginning of the compilation

	String qualifiedBinaryFileName = qualifiedTypeName + SUFFIX_STRING_class;
	String qualifiedPackageName =
		qualifiedTypeName.length() == typeName.length
			? Util.EMPTY_STRING
			: qualifiedBinaryFileName.substring(0, qualifiedTypeName.length() - typeName.length - 1);

	if (moduleName == ModuleBinding.ANY) {
		// TODO(SHMOD): revert to Java 8 version?
		return Stream.of(this.classpaths)
				.map(p -> p.getLookupEnvironment().typeLookup())
				.reduce(ITypeLookup::chain)
				.map(t -> t.findClass(typeName, qualifiedPackageName, null, qualifiedBinaryFileName, asBinaryOnly)).orElse(null);
	}
	String moduleNameString = String.valueOf(moduleName);
	Classpath classpath = this.moduleLocations.get(moduleNameString);
	if (classpath != null) {
		return classpath.findClass(typeName, qualifiedPackageName, moduleNameString, qualifiedBinaryFileName);
	}
	return null;
}

