	private void addNewEntry(final int InsideClasspath, final int InsideSourcepath, ArrayList bootclasspaths, ArrayList classpaths,ArrayList sourcepathClasspaths, String currentClasspathName, ArrayList currentRuleSpecs, int mode, String customEncoding) {
		AccessRule[] accessRules = new AccessRule[currentRuleSpecs
				.size()];
		boolean rulesOK = true;
		Iterator i = currentRuleSpecs.iterator();
		int j = 0;
		while (i.hasNext()) {
			String ruleSpec = (String) i.next();
			char key = ruleSpec.charAt(0);
			String pattern = ruleSpec.substring(1);
			if (pattern.length() > 0) {
				switch (key) {
				case '+':
					accessRules[j++] = new AccessRule(pattern
							.toCharArray(), -1);
					break;
				case '~':
					accessRules[j++] = new AccessRule(pattern
							.toCharArray(),
							IProblem.DiscouragedReference);
					break;
				case '-':
					accessRules[j++] = new AccessRule(pattern
							.toCharArray(),
							IProblem.ForbiddenReference);
					break;
				default:
					rulesOK = false;
				}
			} else {
				rulesOK = false;
			}
		}
		if (rulesOK) {
			AccessRuleSet accessRuleSet = new AccessRuleSet(accessRules);
			FileSystem.Classpath currentClasspath = FileSystem
					.getClasspath(currentClasspathName,
							customEncoding, 0, accessRuleSet);
			if (currentClasspath != null) {
				if (mode == InsideClasspath) {
					classpaths.add(currentClasspath);
				} else if (mode == InsideSourcepath) {
					if (currentClasspath instanceof ClasspathDirectory) {
						((ClasspathDirectory) currentClasspath).mode = 
							ClasspathDirectory.SOURCE; 
						// TODO may consider adding this attribute to other classpath natures
					}
					sourcepathClasspaths.add(currentClasspath);
				} else { // inside bootclasspath
					bootclasspaths.add(currentClasspath);
				}
			} else {
				this.logger.logIncorrectClasspath(currentClasspathName);
				// we go on anyway
			}
		} else {
			this.logger.logIncorrectClasspath(currentClasspathName);
			// we go on anyway
		}
	}

