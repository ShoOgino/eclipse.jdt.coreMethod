/*
Decode the command line arguments 
 */
private void configure(String[] argv) throws InvalidInputException {
	if ((argv == null) || (argv.length == 0))
		throw new InvalidInputException(Main.bind("configure.noSourceFile")); //$NON-NLS-1$
	final int InsideClasspath = 1;
	final int InsideDestinationPath = 2;
	final int TargetSetting = 4;
	final int InsideLog = 8;
	final int InsideRepetition = 16;
	final int InsideSource = 32;
	final int Default = 0;
	int DEFAULT_SIZE_CLASSPATH = 4;
	boolean warnOptionInUsed = false;
	boolean noWarnOptionInUsed = false;
	int pathCount = 0;
	int index = -1, filesCount = 0, argCount = argv.length;
	int mode = Default;
	repetitions = 0;
	boolean versionIDRequired = false;
	boolean printUsageRequired = false;

	boolean didSpecifyCompliance = false;
	boolean didSpecifySourceLevel = false;
			
	while (++index < argCount) {
		String currentArg = argv[index].trim();
		if (currentArg.endsWith(".java")) { //$NON-NLS-1$
			if (filenames == null) {
				filenames = new String[argCount - index];
			} else if (filesCount == filenames.length) {
				int length = filenames.length;
				System.arraycopy(filenames, 0, (filenames = new String[length + argCount - index]), 0, length);
			}
			filenames[filesCount++] = currentArg;
			mode = Default;
			continue;
		}
		if (currentArg.equals("-log")) { //$NON-NLS-1$
			if (log != null)
				throw new InvalidInputException(Main.bind("configure.duplicateLog",currentArg)); //$NON-NLS-1$
			mode = InsideLog;
			continue;
		}
		if (currentArg.equals("-repeat")) { //$NON-NLS-1$
			if (repetitions > 0)
				throw new InvalidInputException(Main.bind("configure.duplicateRepeat",currentArg)); //$NON-NLS-1$
			mode = InsideRepetition;
			continue;
		}
		if (currentArg.equals("-source")) { //$NON-NLS-1$
			mode = InsideSource;
			didSpecifySourceLevel = true;
			continue;
		}
		if (currentArg.equals("-1.3")) { //$NON-NLS-1$
			if (didSpecifyCompliance) {
				throw new InvalidInputException(Main.bind("configure.duplicateCompliance",currentArg)); //$NON-NLS-1$
			}
			didSpecifyCompliance = true;
			options.put(CompilerOptions.OPTION_Compliance, CompilerOptions.VERSION_1_3);
			if (!didSpecifySourceLevel){
				options.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_3);
			}
			mode = Default;
			continue;
		}
		if (currentArg.equals("-1.4")) { //$NON-NLS-1$
			if (didSpecifyCompliance) {
				throw new InvalidInputException(Main.bind("configure.duplicateCompliance",currentArg)); //$NON-NLS-1$
			}
			didSpecifyCompliance = true;
			options.put(CompilerOptions.OPTION_Compliance, CompilerOptions.VERSION_1_4);
			if (!didSpecifySourceLevel){
				options.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_4);
			}
			mode = Default;
			continue;
		}
		if (currentArg.equals("-d")) { //$NON-NLS-1$
			if (destinationPath != null)
				throw new InvalidInputException(Main.bind("configure.duplicateOutputPath",currentArg)); //$NON-NLS-1$
			mode = InsideDestinationPath;
			generatePackagesStructure = true;
			continue;
		}
		if (currentArg.equals("-classpath") || currentArg.equals("-cp")) { //$NON-NLS-1$
			if (pathCount > 0)
				throw new InvalidInputException(Main.bind("configure.duplicateClasspath",currentArg)); //$NON-NLS-1$
			classpaths = new String[DEFAULT_SIZE_CLASSPATH];
			mode = InsideClasspath;
			continue;
		}
		if (currentArg.equals("-progress")) { //$NON-NLS-1$
			mode = Default;
			showProgress = true;
			continue;
		}
		if (currentArg.equals("-proceedOnError")) { //$NON-NLS-1$
			mode = Default;
			proceedOnError = true;
			continue;
		}
		if (currentArg.equals("-time")) { //$NON-NLS-1$
			mode = Default;
			timer = true;
			continue;
		}
		if (currentArg.equals("-version") || currentArg.equals("-v")) { //$NON-NLS-1$ //$NON-NLS-2$
			versionIDRequired = true;
			continue;
		}
		if (currentArg.equals("-help")) { //$NON-NLS-1$
			printUsageRequired = true;
			continue;
		}		
		if (currentArg.equals("-noImportError")) { //$NON-NLS-1$
			mode = Default;
			options.put(CompilerOptions.OPTION_ReportInvalidImport, CompilerOptions.WARNING);
			continue;
		}
		if (currentArg.equals("-noExit")) { //$NON-NLS-1$
			mode = Default;
			systemExitWhenFinished = false;
			continue;
		}		
		if (currentArg.equals("-verbose")) { //$NON-NLS-1$
			mode = Default;
			verbose = true;
			continue;
		}
		if (currentArg.equals("-referenceInfo")) { //$NON-NLS-1$
			mode = Default;
			produceRefInfo = true;
			continue;
		}
		if (currentArg.startsWith("-g")) { //$NON-NLS-1$
			mode = Default;
			String debugOption = currentArg;
			int length = currentArg.length();
			if (length == 2) {
				options.put(CompilerOptions.OPTION_LocalVariableAttribute, CompilerOptions.GENERATE);
				options.put(CompilerOptions.OPTION_LineNumberAttribute, CompilerOptions.GENERATE);
				options.put(CompilerOptions.OPTION_SourceFileAttribute, CompilerOptions.GENERATE);
				continue;
			}
			if (length > 3) {
				options.put(CompilerOptions.OPTION_LocalVariableAttribute, CompilerOptions.DO_NOT_GENERATE);
				options.put(CompilerOptions.OPTION_LineNumberAttribute, CompilerOptions.DO_NOT_GENERATE);
				options.put(CompilerOptions.OPTION_SourceFileAttribute, CompilerOptions.DO_NOT_GENERATE);
				if (length == 7 && debugOption.equals("-g:none")) //$NON-NLS-1$
					continue;
				StringTokenizer tokenizer = new StringTokenizer(debugOption.substring(3, debugOption.length()), ","); //$NON-NLS-1$
				while (tokenizer.hasMoreTokens()) {
					String token = tokenizer.nextToken();
					if (token.equals("vars")) { //$NON-NLS-1$
						options.put(CompilerOptions.OPTION_LocalVariableAttribute, CompilerOptions.GENERATE);
					} else if (token.equals("lines")) { //$NON-NLS-1$
						options.put(CompilerOptions.OPTION_LineNumberAttribute, CompilerOptions.GENERATE);
					} else if (token.equals("source")) { //$NON-NLS-1$
						options.put(CompilerOptions.OPTION_SourceFileAttribute, CompilerOptions.GENERATE);
					} else {
						throw new InvalidInputException(Main.bind("configure.invalidDebugOption",debugOption)); //$NON-NLS-1$
					}
				}
				continue;
			}
			throw new InvalidInputException(Main.bind("configure.invalidDebugOption",debugOption)); //$NON-NLS-1$
		}
		if (currentArg.startsWith("-nowarn")) { //$NON-NLS-1$
			noWarnOptionInUsed = true;
			noWarn = true;
			if (warnOptionInUsed)
				throw new InvalidInputException(Main.bind("configure.duplicateWarningConfiguration")); //$NON-NLS-1$
			mode = Default;		
			continue;
		}
		if (currentArg.startsWith("-warn")) { //$NON-NLS-1$
			warnOptionInUsed = true;
			if (noWarnOptionInUsed)
				throw new InvalidInputException(Main.bind("configure.duplicateWarningConfiguration")); //$NON-NLS-1$
			mode = Default;
			String warningOption = currentArg;
			int length = currentArg.length();
			if (length == 10 && warningOption.equals("-warn:none")) { //$NON-NLS-1$
				noWarn = true;
				continue;
			}
			if (length < 6)
				throw new InvalidInputException(Main.bind("configure.invalidWarningConfiguration",warningOption)); //$NON-NLS-1$
			StringTokenizer tokenizer = new StringTokenizer(warningOption.substring(6, warningOption.length()), ","); //$NON-NLS-1$
			int tokenCounter = 0;

			options.put(CompilerOptions.OPTION_ReportOverridingPackageDefaultMethod, CompilerOptions.IGNORE);
			options.put(CompilerOptions.OPTION_ReportMethodWithConstructorName, CompilerOptions.IGNORE);
			options.put(CompilerOptions.OPTION_ReportDeprecation, CompilerOptions.IGNORE);
			options.put(CompilerOptions.OPTION_ReportHiddenCatchBlock, CompilerOptions.IGNORE);
			options.put(CompilerOptions.OPTION_ReportUnusedLocal, CompilerOptions.IGNORE);
			options.put(CompilerOptions.OPTION_ReportUnusedParameter, CompilerOptions.IGNORE);
			options.put(CompilerOptions.OPTION_ReportSyntheticAccessEmulation, CompilerOptions.IGNORE);
			options.put(CompilerOptions.OPTION_ReportNonExternalizedStringLiteral, CompilerOptions.IGNORE);
			options.put(CompilerOptions.OPTION_ReportAssertIdentifier, CompilerOptions.IGNORE);

			while (tokenizer.hasMoreTokens()) {
				String token = tokenizer.nextToken();
				tokenCounter++;
				if (token.equals("constructorName")) { //$NON-NLS-1$
					options.put(CompilerOptions.OPTION_ReportMethodWithConstructorName, CompilerOptions.WARNING);
				} else if (token.equals("packageDefaultMethod")) { //$NON-NLS-1$
					options.put(CompilerOptions.OPTION_ReportOverridingPackageDefaultMethod, CompilerOptions.WARNING);
				} else if (token.equals("maskedCatchBlocks")) { //$NON-NLS-1$
					options.put(CompilerOptions.OPTION_ReportHiddenCatchBlock, CompilerOptions.WARNING);
				} else if (token.equals("deprecation")) { //$NON-NLS-1$
					options.put(CompilerOptions.OPTION_ReportDeprecation, CompilerOptions.WARNING);
				} else if (token.equals("unusedLocals")) { //$NON-NLS-1$
					options.put(CompilerOptions.OPTION_ReportUnusedLocal, CompilerOptions.WARNING);
				} else if (token.equals("unusedArguments")) { //$NON-NLS-1$
					options.put(CompilerOptions.OPTION_ReportUnusedParameter, CompilerOptions.WARNING);
				} else if (token.equals("syntheticAccess")){ //$NON-NLS-1$
					options.put(CompilerOptions.OPTION_ReportSyntheticAccessEmulation, CompilerOptions.WARNING);
				} else if (token.equals("nls")){ //$NON-NLS-1$
					options.put(CompilerOptions.OPTION_ReportNonExternalizedStringLiteral, CompilerOptions.WARNING);
				} else if (token.equals("assertIdentifier")){ //$NON-NLS-1$
					options.put(CompilerOptions.OPTION_ReportAssertIdentifier, CompilerOptions.WARNING);
				} else {
					throw new InvalidInputException(Main.bind("configure.invalidWarning",token)); //$NON-NLS-1$
				}
			}
			if (tokenCounter == 0)
				throw new InvalidInputException(Main.bind("configure.invalidWarningOption",currentArg)); //$NON-NLS-1$
			continue;
		}
		if (currentArg.equals("-target")) { //$NON-NLS-1$
			mode = TargetSetting;
			continue;
		}
		if (currentArg.equals("-preserveAllLocals")) { //$NON-NLS-1$
			options.put(CompilerOptions.OPTION_PreserveUnusedLocal, CompilerOptions.PRESERVE);
			continue;
		}
		if (mode == TargetSetting) {
			if (currentArg.equals("1.1")) { //$NON-NLS-1$
				options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_1);
			} else if (currentArg.equals("1.2")) { //$NON-NLS-1$
				options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_2);
			} else {
				throw new InvalidInputException(Main.bind("configure.targetJDK",currentArg)); //$NON-NLS-1$
			}
			mode = Default;
			continue;
		}
		if (mode == InsideLog){
			log = currentArg;
			mode = Default;
			continue;
		}
		if (mode == InsideRepetition){
			try {
				repetitions = Integer.parseInt(currentArg);
				if (repetitions <= 0){
					throw new InvalidInputException(Main.bind("configure.repetition",currentArg)); //$NON-NLS-1$
				}
			} catch(NumberFormatException e){
				throw new InvalidInputException(Main.bind("configure.repetition",currentArg)); //$NON-NLS-1$
			}
			mode = Default;
			continue;
		}
		if (mode == InsideSource){
			if (currentArg.equals("1.3")) { //$NON-NLS-1$
				options.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_3);
			} else if (currentArg.equals("1.4")) { //$NON-NLS-1$
				options.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_4);
			} else {
				throw new InvalidInputException(Main.bind("configure.source",currentArg)); //$NON-NLS-1$
			}
			mode = Default;
			continue;
		}
		if (mode == InsideDestinationPath) {
			destinationPath = currentArg;
			mode = Default;
			continue;
		}
		if (mode == InsideClasspath) {
			StringTokenizer tokenizer = new StringTokenizer(currentArg, File.pathSeparator);
			while (tokenizer.hasMoreTokens()) {
				int length;
				if ((length = classpaths.length) <= pathCount) {
					System.arraycopy(classpaths, 0, (classpaths = new String[length * 2]), 0, length);
				}
				classpaths[pathCount++] = tokenizer.nextToken();
			}
			mode = Default;
			continue;
		}
		//default is input directory
		currentArg = currentArg.replace('/', File.separatorChar);
		if (currentArg.endsWith(File.separator))
			currentArg = currentArg.substring(0, currentArg.length() - File.separator.length());
		File dir = new File(currentArg);
		if (!dir.isDirectory())
			throw new InvalidInputException(Main.bind("configure.directoryNotExist",currentArg)); //$NON-NLS-1$
		FileFinder finder = new FileFinder();
		try{
			finder.find(dir, ".JAVA", verbose); //$NON-NLS-1$
		} catch(Exception e){
			throw new InvalidInputException(Main.bind("configure.IOError",currentArg));		 //$NON-NLS-1$
		}
		if (filenames != null) {
			// some source files were specified explicitly
			String results[] = finder.resultFiles;
			int length = results.length;
			System.arraycopy(filenames, 0, (filenames = new String[length + filesCount]), 0, filesCount);
			System.arraycopy(results, 0, filenames, filesCount, length);
			filesCount += length;
		} else {
			filenames = finder.resultFiles;
			filesCount = filenames.length;
		}
		mode = Default;
		continue;
	}

	if(noWarn){
		// filter options which are related to the assist component
		Object[] entries = options.entrySet().toArray();
		for (int i = 0, max = entries.length; i < max; i++){
			Map.Entry entry = (Map.Entry)entries[i];
			if (!(entry.getKey() instanceof String)) continue;
			if (!(entry.getValue() instanceof String)) continue;
			if (((String) entry.getValue()).equals(CompilerOptions.WARNING)){
				options.put((String) entry.getKey(), CompilerOptions.IGNORE);
			}
		}
	}
	/*
	 * Standalone options
	 */
	if (versionIDRequired) {
		out.println(Main.bind("configure.version",Main.bind("compiler.version"))); //$NON-NLS-1$ //$NON-NLS-2$
		out.println();
		proceed = false;
		return;
	}
		
	if (printUsageRequired) {
		printUsage();
		proceed = false;
		return;
	}	
	
	if (filesCount != 0)
		System.arraycopy(filenames, 0, (filenames = new String[filesCount]), 0, filesCount);
	if (pathCount == 0) {
		String classProp = System.getProperty("DEFAULT_CLASSPATH"); //$NON-NLS-1$
		if ((classProp == null) || (classProp.length() == 0)) {
			out.println(Main.bind("configure.noClasspath")); //$NON-NLS-1$
			classProp = "."; //$NON-NLS-1$
		}
		StringTokenizer tokenizer = new StringTokenizer(classProp, File.pathSeparator);
		classpaths = new String[tokenizer.countTokens()];
		while (tokenizer.hasMoreTokens()) {
			classpaths[pathCount++] = tokenizer.nextToken();
		}
	}

	if (classpaths == null)
		classpaths = new String[0];
	System.arraycopy(classpaths, 0, (classpaths = new String[pathCount]), 0, pathCount);
	for (int i = 0, max = classpaths.length; i < max; i++) {
		File file = new File(classpaths[i]);
		if (!file.exists()) // signal missing classpath entry file
			out.println(Main.bind("configure.incorrectClasspath",classpaths[i])); //$NON-NLS-1$
	}
	if (destinationPath == null) {
		destinationPath = System.getProperty("user.dir"); //$NON-NLS-1$
		generatePackagesStructure = false;
	} else if ("none".equals(destinationPath)) { //$NON-NLS-1$
		destinationPath = null;
	}
		
	if (filenames == null)
		throw new InvalidInputException(Main.bind("configure.noSource")); //$NON-NLS-1$

	if (log != null){
		try {
			out = new PrintWriter(new FileOutputStream(log, false));
		} catch(IOException e){
			throw new InvalidInputException(Main.bind("configure.cannotOpenLog")); //$NON-NLS-1$
		}
	} else {
		showProgress = false;
	}

	if (repetitions == 0) {
		repetitions = 1;
	}
}

