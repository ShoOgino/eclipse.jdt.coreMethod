/*
Decode the command line arguments 
 */
private void configure(String[] argv) throws InvalidInputException {
	if ((argv == null) || (argv.length == 0))
		throw new InvalidInputException(Main.bind("configure.noSourceFile"/*nonNLS*/));
	final int InsideClasspath = 1;
	final int InsideDestinationPath = 2;
	final int TargetSetting = 4;
	final int InsideLog = 8;
	final int InsideRepetition = 16;
	final int Default = 0;
	final int SourceOption = 32;
	int DEFAULT_SIZE_CLASSPATH = 4;
	boolean noWarnOptionInUsed = false;
	boolean warnOptionInUsed = false;
	int pathCount = 0;
	int index = -1, filesCount = 0, argCount = argv.length;
	int mode = Default;
	repetitions = 0;
	boolean versionIDRequired = false;
	boolean printUsageRequired = false;
	
	while (++index < argCount) {
		String currentArg = argv[index].trim();
		if (currentArg.endsWith(".java"/*nonNLS*/)) {
			if (filenames == null) {
				filenames = new String[argCount - index];
			} else if (filesCount == filenames.length) {
				int length = filenames.length;
				System.arraycopy(filenames, 0, (filenames = new String[length + argCount - index]), 0, length);
			}
			filenames[filesCount++] = currentArg;
			mode = Default;
			continue;
		}
		if (currentArg.equals("-log"/*nonNLS*/)) {
			if (log != null)
				throw new InvalidInputException(Main.bind("configure.duplicateLog"/*nonNLS*/,currentArg));
			mode = InsideLog;
			continue;
		}
		if (currentArg.equals("-repeat"/*nonNLS*/)) {
			if (repetitions > 0)
				throw new InvalidInputException(Main.bind("configure.duplicateRepeat"/*nonNLS*/,currentArg));
			mode = InsideRepetition;
			continue;
		}
		if (currentArg.equals("-d"/*nonNLS*/)) {
			if (destinationPath != null)
				throw new InvalidInputException(Main.bind("configure.duplicateOutputPath"/*nonNLS*/,currentArg));
			mode = InsideDestinationPath;
			continue;
		}
		if (currentArg.equals("-classpath"/*nonNLS*/)) {
			if (pathCount > 0)
				throw new InvalidInputException(Main.bind("configure.duplicateClasspath"/*nonNLS*/,currentArg));
			classpaths = new String[DEFAULT_SIZE_CLASSPATH];
			mode = InsideClasspath;
			continue;
		}
		if (currentArg.equals("-progress"/*nonNLS*/)) {
			mode = Default;
			showProgress = true;
			continue;
		}
		if (currentArg.equals("-proceedOnError"/*nonNLS*/)) {
			mode = Default;
			proceedOnError = true;
			continue;
		}
		if (currentArg.equals("-time"/*nonNLS*/)) {
			mode = Default;
			timer = true;
			continue;
		}
		if (currentArg.equals("-version"/*nonNLS*/) || currentArg.equals("-v"/*nonNLS*/)) {
			versionIDRequired = true;
			continue;
		}
		if (currentArg.equals("-help"/*nonNLS*/)) {
			printUsageRequired = true;
			continue;
		}		
		if (currentArg.equals("-noImportError"/*nonNLS*/)) {
			mode = Default;
			importProblemIsError = false;
			continue;
		}
		if (currentArg.equals("-noExit"/*nonNLS*/)) {
			mode = Default;
			systemExitWhenFinished = false;
			continue;
		}		
		if (currentArg.equals("-verbose"/*nonNLS*/)) {
			mode = Default;
			verbose = true;
			continue;
		}
		if (currentArg.equals("-referenceInfo"/*nonNLS*/)) {
			mode = Default;
			produceRefInfo = true;
			continue;
		}
		if (currentArg.startsWith("-g"/*nonNLS*/)) {
			mode = Default;
			debugMask = 0; // reinitialize the default value
			String debugOption = currentArg;
			int length = currentArg.length();
			if (length == 2) {
				debugMask = CompilerOptions.Lines | CompilerOptions.Vars | CompilerOptions.Source;
				continue;
			}
			if (length > 3) {
				if (length == 7 && debugOption.equals("-g:none"/*nonNLS*/))
					continue;
				StringTokenizer tokenizer = new StringTokenizer(debugOption.substring(3, debugOption.length()), ","/*nonNLS*/);
				while (tokenizer.hasMoreTokens()) {
					String token = tokenizer.nextToken();
					if (token.equals("vars"/*nonNLS*/)) {
						debugMask |= CompilerOptions.Vars;
					} else if (token.equals("lines"/*nonNLS*/)) {
						debugMask |= CompilerOptions.Lines;
					} else if (token.equals("source"/*nonNLS*/)) {
						debugMask |= CompilerOptions.Source;
					} else {
						throw new InvalidInputException(Main.bind("configure.invalidDebugOption"/*nonNLS*/,debugOption));
					}
				}
				continue;
			}
			throw new InvalidInputException(Main.bind("configure.invalidDebugOption"/*nonNLS*/,debugOption));
		}
		if (currentArg.startsWith("-nowarn"/*nonNLS*/)) {
			noWarnOptionInUsed = true;
			if (warnOptionInUsed)
				throw new InvalidInputException(Main.bind("configure.duplicateWarningConfiguration"/*nonNLS*/));
			mode = Default;
			warningMask = TemporaryWarning; // reinitialize the default value (still see TemporaryWarning)		
			continue;
		}
		if (currentArg.startsWith("-warn"/*nonNLS*/)) {
			warnOptionInUsed = true;
			if (noWarnOptionInUsed)
				throw new InvalidInputException(Main.bind("configure.duplicateWarningConfiguration"/*nonNLS*/));
			mode = Default;
			String warningOption = currentArg;
			int length = currentArg.length();
			if (length == 10 && warningOption.equals("-warn:none"/*nonNLS*/)) {
				warningMask = TemporaryWarning; // reinitialize the default value (still see TemporaryWarning)
				continue;
			}
			if (length < 6)
				throw new InvalidInputException(Main.bind("configure.invalidWarningConfiguration"/*nonNLS*/,warningOption));
			StringTokenizer tokenizer = new StringTokenizer(warningOption.substring(6, warningOption.length()), ","/*nonNLS*/);
			int tokenCounter = 0;
			warningMask = 0; // reinitialize the default value				
			while (tokenizer.hasMoreTokens()) {
				String token = tokenizer.nextToken();
				tokenCounter++;
				if (token.equals("constructorName"/*nonNLS*/)) {
					warningMask |= CompilerOptions.MethodWithConstructorName;
				} else if (token.equals("packageDefaultMethod"/*nonNLS*/)) {
					warningMask |= CompilerOptions.OverriddenPackageDefaultMethod;
				} else if (token.equals("maskedCatchBlocks"/*nonNLS*/)) {
					warningMask |= CompilerOptions.MaskedCatchBlock;
				} else if (token.equals("deprecation"/*nonNLS*/)) {
					warningMask |= CompilerOptions.UsingDeprecatedAPI;
				} else if (token.equals("unusedLocals"/*nonNLS*/)) {
					warningMask |= CompilerOptions.UnusedLocalVariable;
				} else if (token.equals("unusedArguments"/*nonNLS*/)) {
					warningMask |= CompilerOptions.UnusedArgument;
				} else if (token.equals("syntheticAccess"/*nonNLS*/)){
					warningMask |= CompilerOptions.AccessEmulation;
				} else if (token.equals("nls"/*nonNLS*/)){
					warningMask |= CompilerOptions.NonExternalizedString;
				} else if (token.equals("assertIdentifier"/*nonNLS*/)){
					warningMask |= CompilerOptions.AssertUsedAsAnIdentifier;
				} else {
					throw new InvalidInputException(Main.bind("configure.invalidWarning"/*nonNLS*/,token));
				}
			}
			if (tokenCounter == 0)
				throw new InvalidInputException(Main.bind("configure.invalidWarningOption"/*nonNLS*/,currentArg));
			continue;
		}
		if (currentArg.equals("-target"/*nonNLS*/)) {
			mode = TargetSetting;
			continue;
		}
		if (currentArg.equals("-preserveAllLocals"/*nonNLS*/)) {
			preserveAllLocalVariables = true;
			continue;
		}
		if (currentArg.equals("-source"/*nonNLS*/)) {
			mode = SourceOption;
			continue;
		}
		
		if (mode == SourceOption) {
			if (currentArg.equals("1.4"/*nonNLS*/)) {
				assertMode = true;
			} else if (currentArg.equals("1.3"/*nonNLS*/)) {
				assertMode = false;
			} else {
				throw new InvalidInputException(Main.bind("configure.sourceOption"/*nonNLS*/,currentArg));
			}
			mode = Default;			
			continue;
		}		
		if (mode == TargetSetting) {
			if (currentArg.equals("1.1"/*nonNLS*/)) {
				targetJDK = CompilerOptions.JDK1_1;
			} else if (currentArg.equals("1.2"/*nonNLS*/)) {
				targetJDK = CompilerOptions.JDK1_2;
			} else {
				throw new InvalidInputException(Main.bind("configure.targetJDK"/*nonNLS*/,currentArg));
			}
			mode = Default;
			continue;
		}
		if (mode == InsideLog){
			log = currentArg;
			mode = Default;
			continue;
		}
		if (mode == InsideRepetition){
			try {
				repetitions = Integer.parseInt(currentArg);
				if (repetitions <= 0){
					throw new InvalidInputException(Main.bind("configure.repetition"/*nonNLS*/,currentArg));
				}
			} catch(NumberFormatException e){
				throw new InvalidInputException(Main.bind("configure.repetition"/*nonNLS*/,currentArg));
			}
			mode = Default;
			continue;
		}
		if (mode == InsideDestinationPath) {
			destinationPath = currentArg;
			mode = Default;
			continue;
		}
		if (mode == InsideClasspath) {
			StringTokenizer tokenizer = new StringTokenizer(currentArg, File.pathSeparator);
			while (tokenizer.hasMoreTokens()) {
				int length;
				if ((length = classpaths.length) <= pathCount) {
					System.arraycopy(classpaths, 0, (classpaths = new String[length * 2]), 0, length);
				}
				classpaths[pathCount++] = tokenizer.nextToken();
			}
			mode = Default;
			continue;
		}
		//default is input directory
		currentArg = currentArg.replace('/', File.separatorChar);
		if (currentArg.endsWith(File.separator))
			currentArg = currentArg.substring(0, currentArg.length() - File.separator.length());
		File dir = new File(currentArg);
		if (!dir.isDirectory())
			throw new InvalidInputException(Main.bind("configure.directoryNotExist"/*nonNLS*/,currentArg));
		FileFinder finder = new FileFinder();
		try{
			finder.find(dir, ".JAVA"/*nonNLS*/, verbose);
		} catch(Exception e){
			throw new InvalidInputException(Main.bind("configure.IOError"/*nonNLS*/,currentArg));		
		}
		if (filenames != null) {
			// some source files were specified explicitly
			String results[] = finder.resultFiles;
			int length = results.length;
			System.arraycopy(filenames, 0, (filenames = new String[length + filesCount]), 0, filesCount);
			System.arraycopy(results, 0, filenames, filesCount, length);
			filesCount += length;
		} else {
			filenames = finder.resultFiles;
			filesCount = filenames.length;
		}
		mode = Default;
		continue;
	}

	/*
	 * Standalone options
	 */
	if (versionIDRequired) {
		out.println(Main.bind("configure.version"/*nonNLS*/,this.versionID));
		out.println();
		proceed = false;
		return;
	}
		
	if (printUsageRequired) {
		printUsage();
		proceed = false;
		return;
	}	
	
	if (filesCount != 0)
		System.arraycopy(filenames, 0, (filenames = new String[filesCount]), 0, filesCount);
	if (pathCount == 0) {
		String classProp = System.getProperty("LFclasspath"/*nonNLS*/);
		if ((classProp == null) || (classProp.length() == 0)) {
			out.println(Main.bind("configure.noClasspath"/*nonNLS*/));
			classProp = "."/*nonNLS*/;
		}
		StringTokenizer tokenizer = new StringTokenizer(classProp, File.pathSeparator);
		classpaths = new String[tokenizer.countTokens()];
		while (tokenizer.hasMoreTokens()) {
			classpaths[pathCount++] = tokenizer.nextToken();
		}
	}

	if (classpaths == null)
		classpaths = new String[0];
	System.arraycopy(classpaths, 0, (classpaths = new String[pathCount]), 0, pathCount);
	for (int i = 0, max = classpaths.length; i < max; i++) {
		File file = new File(classpaths[i]);
		if (!file.exists())
			throw new InvalidInputException(Main.bind("configure.incorrectClasspath"/*nonNLS*/,classpaths[i]));
	}
	if (destinationPath == null) {
		destinationPath = System.getProperty("user.dir"/*nonNLS*/);
	} else if ("none"/*nonNLS*/.equals(destinationPath)) {
		destinationPath = null;
	}
		
	if (filenames == null)
		throw new InvalidInputException(Main.bind("configure.noSource"/*nonNLS*/));

	if (log != null){
		try {
			out = new PrintWriter(new FileOutputStream(log, false));
		} catch(IOException e){
			throw new InvalidInputException(Main.bind("configure.cannotOpenLog"/*nonNLS*/));
		}
	} else {
		showProgress = false;
	}

	if (repetitions == 0) {
		repetitions = 1;
	}
}

