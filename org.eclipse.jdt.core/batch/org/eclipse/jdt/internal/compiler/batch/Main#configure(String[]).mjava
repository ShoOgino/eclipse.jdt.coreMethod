/*
Decode the command line arguments 
 */
public void configure(String[] argv) throws InvalidInputException {
	
	if ((argv == null) || (argv.length == 0)) {
		printUsage();
		return;
	}
	final int INSIDE_CLASSPATH = 1;
	final int INSIDE_DESTINATION_PATH = 2;
	final int INSIDE_TARGET = 3;
	final int INSIDE_LOG = 4;
	final int INSIDE_REPETITION = 5;
	final int INSIDE_SOURCE = 6;
	final int INSIDE_DEFAULT_ENCODING = 7;
	final int INSIDE_BOOTCLASSPATH = 8;
	final int INSIDE_MAX_PROBLEMS = 9;
	final int INSIDE_EXT_DIRS = 10;
	final int INSIDE_SOURCE_PATH = 11;
	final int INSIDE_ENDORSED_DIRS = 12;

	final int DEFAULT = 0;
	final int DEFAULT_SIZE_CLASSPATH = 4;
	ArrayList bootclasspaths = new ArrayList(DEFAULT_SIZE_CLASSPATH);
	ArrayList sourcepathClasspaths = new ArrayList(DEFAULT_SIZE_CLASSPATH);
	ArrayList classpaths = new ArrayList(DEFAULT_SIZE_CLASSPATH);
	ArrayList extdirsClasspaths = null;
	ArrayList endorsedDirClasspath = null;
	
	int index = -1, filesCount = 0, argCount = argv.length;
	int mode = DEFAULT;
	this.repetitions = 0;
	boolean printUsageRequired = false;
	boolean printVersionRequired = false;
	
	boolean didSpecifyDefaultEncoding = false;
	boolean didSpecifyDeprecation = false;
	boolean didSpecifyWarnings = false;
	boolean useEnableJavadoc = false;
	boolean didSpecifyCompliance = false;	

	String customEncoding = null;
	String currentArg = ""; //$NON-NLS-1$

	// expand the command line if necessary
	boolean needExpansion = false;
	loop: for (int i = 0; i < argCount; i++) {
			if (argv[i].startsWith("@")) { //$NON-NLS-1$
				needExpansion = true;
				break loop;
			}
	}

	String[] newCommandLineArgs = null;
	if (needExpansion) {
		newCommandLineArgs = new String[argCount];
		index = 0;
		for (int i = 0; i < argCount; i++) {
			String[] newArgs = null;
			String arg = argv[i].trim();
			if (arg.startsWith("@")) { //$NON-NLS-1$
				try {
					LineNumberReader reader = new LineNumberReader(new StringReader(new String(Util.getFileCharContent(new File(arg.substring(1)), null))));
					StringBuffer buffer = new StringBuffer();
					String line;
					while((line = reader.readLine()) != null) {
						line = line.trim();
						if (!line.startsWith("#")) { //$NON-NLS-1$
							buffer.append(line).append(" "); //$NON-NLS-1$
						}
					}
					newArgs = tokenize(buffer.toString());
				} catch(IOException e) {
					throw new InvalidInputException(
						Main.bind("configure.invalidexpansionargumentname", arg)); //$NON-NLS-1$
				}
			}
			if (newArgs != null) {
				int newCommandLineArgsLength = newCommandLineArgs.length;
				int newArgsLength = newArgs.length;
				System.arraycopy(newCommandLineArgs, 0, (newCommandLineArgs = new String[newCommandLineArgsLength + newArgsLength - 1]), 0, index);
				System.arraycopy(newArgs, 0, newCommandLineArgs, index, newArgsLength);
				index += newArgsLength;
			} else {
				newCommandLineArgs[index++] = arg;
			}
		}
		index = -1;
	} else {
		newCommandLineArgs = argv;
		for (int i = 0; i < argCount; i++) {
			newCommandLineArgs[i] = newCommandLineArgs[i].trim();
		}
	}
	argCount = newCommandLineArgs.length;
	while (++index < argCount) {

		if (customEncoding != null) {
			throw new InvalidInputException(
				Main.bind("configure.unexpectedCustomEncoding", currentArg, customEncoding)); //$NON-NLS-1$
		}

		currentArg = newCommandLineArgs[index];

		switch(mode) {
			case DEFAULT :
				customEncoding = null;
				if (currentArg.endsWith("]") && !(mode == INSIDE_BOOTCLASSPATH || mode == INSIDE_CLASSPATH || //$NON-NLS-1$ 
						mode == INSIDE_SOURCE_PATH) ) {
					// look for encoding specification
					int encodingStart = currentArg.indexOf('[') + 1;
					int encodingEnd = currentArg.length() - 1;
					if (encodingStart >= 1) {
						if (encodingStart < encodingEnd) {
							customEncoding = currentArg.substring(encodingStart, encodingEnd);
							try { // ensure encoding is supported
								new InputStreamReader(new ByteArrayInputStream(new byte[0]), customEncoding);
							} catch (UnsupportedEncodingException e) {
								throw new InvalidInputException(
									Main.bind("configure.unsupportedEncoding", customEncoding)); //$NON-NLS-1$
							}
						}
						currentArg = currentArg.substring(0, encodingStart - 1);
					}
				}
	
				if (currentArg.endsWith(SuffixConstants.SUFFIX_STRING_java)) {
					if (this.filenames == null) {
						this.filenames = new String[argCount - index];
						this.encodings = new String[argCount - index];
					} else if (filesCount == this.filenames.length) {
						int length = this.filenames.length;
						System.arraycopy(
							this.filenames,
							0,
							(this.filenames = new String[length + argCount - index]),
							0,
							length);
						System.arraycopy(
							this.encodings,
							0,
							(this.encodings = new String[length + argCount - index]),
							0,
							length);
					}
					this.filenames[filesCount] = currentArg;
					this.encodings[filesCount++] = customEncoding;
					customEncoding = null;
					mode = DEFAULT;
					continue;
				}
				if (currentArg.equals("-log")) { //$NON-NLS-1$
					if (this.log != null)
						throw new InvalidInputException(
							Main.bind("configure.duplicateLog", currentArg)); //$NON-NLS-1$
					mode = INSIDE_LOG;
					continue;
				}
				if (currentArg.equals("-repeat")) { //$NON-NLS-1$
					if (this.repetitions > 0)
						throw new InvalidInputException(
							Main.bind("configure.duplicateRepeat", currentArg)); //$NON-NLS-1$
					mode = INSIDE_REPETITION;
					continue;
				}
				if (currentArg.equals("-maxProblems")) { //$NON-NLS-1$
					if (this.maxProblems > 0)
						throw new InvalidInputException(
							Main.bind("configure.duplicateMaxProblems", currentArg)); //$NON-NLS-1$
					mode = INSIDE_MAX_PROBLEMS;
					continue;
				}
				if (currentArg.equals("-source")) { //$NON-NLS-1$
					mode = INSIDE_SOURCE;
					continue;
				}
				if (currentArg.equals("-encoding")) { //$NON-NLS-1$
					mode = INSIDE_DEFAULT_ENCODING;
					continue;
				}
				if (currentArg.equals("-1.3")) { //$NON-NLS-1$
					if (didSpecifyCompliance) {
						throw new InvalidInputException(
							Main.bind("configure.duplicateCompliance", currentArg));//$NON-NLS-1$
					}
					didSpecifyCompliance = true;
					this.options.put(CompilerOptions.OPTION_Compliance, CompilerOptions.VERSION_1_3);
					mode = DEFAULT;
					continue;
				}
				if (currentArg.equals("-1.4")) { //$NON-NLS-1$
					if (didSpecifyCompliance) {
						throw new InvalidInputException(
							Main.bind("configure.duplicateCompliance", currentArg)); //$NON-NLS-1$
					}
					didSpecifyCompliance = true;
					this.options.put(CompilerOptions.OPTION_Compliance, CompilerOptions.VERSION_1_4);
					mode = DEFAULT;
					continue;
				}
				if (currentArg.equals("-1.5") || currentArg.equals("-5") || currentArg.equals("-5.0")) { //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
					if (didSpecifyCompliance) {
						throw new InvalidInputException(
							Main.bind("configure.duplicateCompliance", currentArg)); //$NON-NLS-1$
					}
					didSpecifyCompliance = true;
					this.options.put(CompilerOptions.OPTION_Compliance, CompilerOptions.VERSION_1_5);
					mode = DEFAULT;
					continue;
				}
				if (currentArg.equals("-1.6") || currentArg.equals("-6") || currentArg.equals("-6.0")) { //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
					if (didSpecifyCompliance) {
						throw new InvalidInputException(
							Main.bind("configure.duplicateCompliance", currentArg)); //$NON-NLS-1$
					}
					didSpecifyCompliance = true;
					this.options.put(CompilerOptions.OPTION_Compliance, CompilerOptions.VERSION_1_6);
					mode = DEFAULT;
					continue;
				}
				if (currentArg.equals("-d")) { //$NON-NLS-1$
					if (this.destinationPath != null) {
						StringBuffer errorMessage = new StringBuffer();
						errorMessage.append(currentArg);
						if ((index + 1) < argCount) {
							errorMessage.append(' ');
							errorMessage.append(newCommandLineArgs[index + 1]);
						}
						throw new InvalidInputException(
							Main.bind("configure.duplicateOutputPath", errorMessage.toString())); //$NON-NLS-1$
					}
					mode = INSIDE_DESTINATION_PATH;
					this.generatePackagesStructure = true;
					continue;
				}
				if (currentArg.equals("-classpath") //$NON-NLS-1$
					|| currentArg.equals("-cp")) { //$NON-NLS-1$
					mode = INSIDE_CLASSPATH;
					continue;
				}
				if (currentArg.equals("-bootclasspath")) {//$NON-NLS-1$
					if (bootclasspaths.size() > 0) {
						StringBuffer errorMessage = new StringBuffer();
						errorMessage.append(currentArg);
						if ((index + 1) < argCount) {
							errorMessage.append(' ');
							errorMessage.append(newCommandLineArgs[index + 1]);
						}
						throw new InvalidInputException(
							Main.bind("configure.duplicateBootClasspath", errorMessage.toString())); //$NON-NLS-1$
					}
					mode = INSIDE_BOOTCLASSPATH;
					continue;
				}
				if (currentArg.equals("-sourcepath")) {//$NON-NLS-1$
					if (sourcepathClasspaths.size() > 0) {
						StringBuffer errorMessage = new StringBuffer();
						errorMessage.append(currentArg);
						if ((index + 1) < argCount) {
							errorMessage.append(' ');
							errorMessage.append(newCommandLineArgs[index + 1]);
						}
						throw new InvalidInputException(
							Main.bind("configure.duplicateSourcepath", errorMessage.toString())); //$NON-NLS-1$
					}
					mode = INSIDE_SOURCE_PATH;
					continue;
				}
				if (currentArg.equals("-extdirs")) {//$NON-NLS-1$
					if (extdirsClasspaths != null) {
						StringBuffer errorMessage = new StringBuffer();
						errorMessage.append(currentArg);
						if ((index + 1) < argCount) {
							errorMessage.append(' ');
							errorMessage.append(newCommandLineArgs[index + 1]);
						}
						throw new InvalidInputException(
							Main.bind("configure.duplicateExtDirs", errorMessage.toString())); //$NON-NLS-1$
					}
					mode = INSIDE_EXT_DIRS;
					continue;
				}
				if (currentArg.equals("-endorseddirs")) { //$NON-NLS-1$
					if (endorsedDirClasspath != null) {
						StringBuffer errorMessage = new StringBuffer();
						errorMessage.append(currentArg);
						if ((index + 1) < argCount) {
							errorMessage.append(' ');
							errorMessage.append(newCommandLineArgs[index + 1]);
						}
						throw new InvalidInputException(
							Main.bind("configure.duplicateEndorsedDirs", errorMessage.toString())); //$NON-NLS-1$
					}
					mode = INSIDE_ENDORSED_DIRS;
					continue;
				}
				if (currentArg.equals("-progress")) { //$NON-NLS-1$
					mode = DEFAULT;
					this.showProgress = true;
					continue;
				}
				if (currentArg.equals("-proceedOnError")) { //$NON-NLS-1$
					mode = DEFAULT;
					this.proceedOnError = true;
					continue;
				}
				if (currentArg.equals("-time")) { //$NON-NLS-1$
					mode = DEFAULT;
					this.timing = true;
					continue;
				}
				if (currentArg.equals("-version") //$NON-NLS-1$
						|| currentArg.equals("-v")) { //$NON-NLS-1$
					this.logger.logVersion(true);
					this.proceed = false;
					return;
				}
				if (currentArg.equals("-showversion")) { //$NON-NLS-1$
					printVersionRequired = true;
					mode = DEFAULT;
					continue;
				}			
				if ("-deprecation".equals(currentArg)) { //$NON-NLS-1$
					didSpecifyDeprecation = true;
					this.options.put(CompilerOptions.OPTION_ReportDeprecation, CompilerOptions.WARNING);
					mode = DEFAULT;
					continue;
				}
				if (currentArg.equals("-help") || currentArg.equals("-?")) { //$NON-NLS-1$ //$NON-NLS-2$
					printUsageRequired = true;
					mode = DEFAULT;
					continue;
				}
				if (currentArg.equals("-noExit")) { //$NON-NLS-1$
					this.systemExitWhenFinished = false;
					mode = DEFAULT;
					continue;
				}
				if (currentArg.equals("-verbose")) { //$NON-NLS-1$
					this.verbose = true;
					mode = DEFAULT;
					continue;
				}
				if (currentArg.equals("-referenceInfo")) { //$NON-NLS-1$
					this.produceRefInfo = true;
					mode = DEFAULT;
					continue;
				}
				if (currentArg.equals("-inlineJSR")) { //$NON-NLS-1$
				    mode = DEFAULT;
					this.options.put(
							CompilerOptions.OPTION_InlineJsr,
							CompilerOptions.ENABLED);
				    continue;
				}
				if (currentArg.startsWith("-g")) { //$NON-NLS-1$
					mode = DEFAULT;
					String debugOption = currentArg;
					int length = currentArg.length();
					if (length == 2) {
						this.options.put(
							CompilerOptions.OPTION_LocalVariableAttribute,
							CompilerOptions.GENERATE);
						this.options.put(
							CompilerOptions.OPTION_LineNumberAttribute,
							CompilerOptions.GENERATE);
						this.options.put(
							CompilerOptions.OPTION_SourceFileAttribute,
							CompilerOptions.GENERATE);
						continue;
					}
					if (length > 3) {
						this.options.put(
							CompilerOptions.OPTION_LocalVariableAttribute,
							CompilerOptions.DO_NOT_GENERATE);
						this.options.put(
							CompilerOptions.OPTION_LineNumberAttribute,
							CompilerOptions.DO_NOT_GENERATE);
						this.options.put(
							CompilerOptions.OPTION_SourceFileAttribute,
							CompilerOptions.DO_NOT_GENERATE);
						if (length == 7 && debugOption.equals("-g:none")) //$NON-NLS-1$
							continue;
						StringTokenizer tokenizer =
							new StringTokenizer(debugOption.substring(3, debugOption.length()), ","); //$NON-NLS-1$
						while (tokenizer.hasMoreTokens()) {
							String token = tokenizer.nextToken();
							if (token.equals("vars")) { //$NON-NLS-1$
								this.options.put(
									CompilerOptions.OPTION_LocalVariableAttribute,
									CompilerOptions.GENERATE);
							} else if (token.equals("lines")) { //$NON-NLS-1$
								this.options.put(
									CompilerOptions.OPTION_LineNumberAttribute,
									CompilerOptions.GENERATE);
							} else if (token.equals("source")) { //$NON-NLS-1$
								this.options.put(
									CompilerOptions.OPTION_SourceFileAttribute,
									CompilerOptions.GENERATE);
							} else {
								throw new InvalidInputException(
									Main.bind("configure.invalidDebugOption", debugOption)); //$NON-NLS-1$
							}
						}
						continue;
					}
					throw new InvalidInputException(
						Main.bind("configure.invalidDebugOption", debugOption)); //$NON-NLS-1$
				}
				if (currentArg.startsWith("-nowarn")) { //$NON-NLS-1$
					disableWarnings();
					mode = DEFAULT;
					continue;
				}
				if (currentArg.startsWith("-warn")) { //$NON-NLS-1$
					mode = DEFAULT;
					String warningOption = currentArg;
					int length = currentArg.length();
					if (length == 10 && warningOption.equals("-warn:none")) { //$NON-NLS-1$
						disableWarnings();
						continue;
					}
					if (length <= 6) {
						throw new InvalidInputException(
							Main.bind("configure.invalidWarningConfiguration", warningOption)); //$NON-NLS-1$
					}
					int warnTokenStart;
					boolean isEnabling;
					switch (warningOption.charAt(6)) {
						case '+' : 
							warnTokenStart = 7;
							isEnabling = true;
							break;
						case '-' :
							warnTokenStart = 7;
							isEnabling = false; // mentionned warnings are disabled
							break;
						default:
							warnTokenStart = 6;
							// clear default warning level
							// but allow multiple warning option on the command line
							if (!didSpecifyWarnings) disableWarnings();
							isEnabling = true;
					}
				
					StringTokenizer tokenizer =
						new StringTokenizer(warningOption.substring(warnTokenStart, warningOption.length()), ","); //$NON-NLS-1$
					int tokenCounter = 0;
	
					if (didSpecifyDeprecation) {  // deprecation could have also been set through -deprecation option
						this.options.put(CompilerOptions.OPTION_ReportDeprecation, CompilerOptions.WARNING);
					}
					
					while (tokenizer.hasMoreTokens()) {
						String token = tokenizer.nextToken();
						tokenCounter++;
						if (token.equals("constructorName")) { //$NON-NLS-1$
							this.options.put(
								CompilerOptions.OPTION_ReportMethodWithConstructorName,
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);
						} else if (token.equals("pkgDefaultMethod") || token.equals("packageDefaultMethod")/*backward compatible*/ ) { //$NON-NLS-1$ //$NON-NLS-2$
							this.options.put(
								CompilerOptions.OPTION_ReportOverridingPackageDefaultMethod,
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);
						} else if (token.equals("maskedCatchBlock") || token.equals("maskedCatchBlocks")/*backward compatible*/) { //$NON-NLS-1$ //$NON-NLS-2$
							this.options.put(
								CompilerOptions.OPTION_ReportHiddenCatchBlock,
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);
						} else if (token.equals("deprecation")) { //$NON-NLS-1$
							this.options.put(
								CompilerOptions.OPTION_ReportDeprecation, 
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);
							this.options.put(
								CompilerOptions.OPTION_ReportDeprecationInDeprecatedCode, 
								CompilerOptions.DISABLED);
							this.options.put(
								CompilerOptions.OPTION_ReportDeprecationWhenOverridingDeprecatedMethod, 
								CompilerOptions.DISABLED);						
						} else if (token.equals("allDeprecation")) { //$NON-NLS-1$
							this.options.put(
								CompilerOptions.OPTION_ReportDeprecation, 
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);
							this.options.put(
								CompilerOptions.OPTION_ReportDeprecationInDeprecatedCode, 
								isEnabling ? CompilerOptions.ENABLED : CompilerOptions.DISABLED);
							this.options.put(
								CompilerOptions.OPTION_ReportDeprecationWhenOverridingDeprecatedMethod, 
								isEnabling ? CompilerOptions.ENABLED : CompilerOptions.DISABLED);
						} else if (token.equals("unusedLocal") || token.equals("unusedLocals")/*backward compatible*/) { //$NON-NLS-1$ //$NON-NLS-2$
							this.options.put(
								CompilerOptions.OPTION_ReportUnusedLocal, 
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);
						} else if (token.equals("unusedArgument") || token.equals("unusedArguments")/*backward compatible*/) { //$NON-NLS-1$ //$NON-NLS-2$
							this.options.put(
								CompilerOptions.OPTION_ReportUnusedParameter,
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);
						} else if (token.equals("unusedImport") || token.equals("unusedImports")/*backward compatible*/) { //$NON-NLS-1$ //$NON-NLS-2$
							this.options.put(
								CompilerOptions.OPTION_ReportUnusedImport,
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);
						} else if (token.equals("unusedPrivate")) { //$NON-NLS-1$
							this.options.put(
								CompilerOptions.OPTION_ReportUnusedPrivateMember,
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);
						} else if (token.equals("unusedLabel")) { //$NON-NLS-1$
							this.options.put(
								CompilerOptions.OPTION_ReportUnusedLabel,
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);
						} else if (token.equals("localHiding")) { //$NON-NLS-1$
							this.options.put(
								CompilerOptions.OPTION_ReportLocalVariableHiding,
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);
						} else if (token.equals("fieldHiding")) { //$NON-NLS-1$
							this.options.put(
								CompilerOptions.OPTION_ReportFieldHiding,
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);
						} else if (token.equals("specialParamHiding")) { //$NON-NLS-1$
							this.options.put(
								CompilerOptions.OPTION_ReportSpecialParameterHidingField,
								isEnabling ? CompilerOptions.ENABLED : CompilerOptions.DISABLED);
						} else if (token.equals("conditionAssign")) { //$NON-NLS-1$
							this.options.put(
								CompilerOptions.OPTION_ReportPossibleAccidentalBooleanAssignment,
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);
	   					} else if (token.equals("syntheticAccess") //$NON-NLS-1$
	   							|| token.equals("synthetic-access")) { //$NON-NLS-1$
							this.options.put(
								CompilerOptions.OPTION_ReportSyntheticAccessEmulation,
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);
						} else if (token.equals("nls")) { //$NON-NLS-1$
							this.options.put(
								CompilerOptions.OPTION_ReportNonExternalizedStringLiteral,
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);
						} else if (token.equals("staticReceiver")) { //$NON-NLS-1$
							this.options.put(
								CompilerOptions.OPTION_ReportNonStaticAccessToStatic,
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);
						} else if (token.equals("indirectStatic")) { //$NON-NLS-1$
							this.options.put(
								CompilerOptions.OPTION_ReportIndirectStaticAccess,
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);
						} else if (token.equals("noEffectAssign")) { //$NON-NLS-1$
							this.options.put(
								CompilerOptions.OPTION_ReportNoEffectAssignment,
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);
						} else if (token.equals("intfNonInherited") || token.equals("interfaceNonInherited")/*backward compatible*/) { //$NON-NLS-1$ //$NON-NLS-2$
							this.options.put(
								CompilerOptions.OPTION_ReportIncompatibleNonInheritedInterfaceMethod,
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);
						} else if (token.equals("charConcat") || token.equals("noImplicitStringConversion")/*backward compatible*/) {//$NON-NLS-1$ //$NON-NLS-2$
							this.options.put(
								CompilerOptions.OPTION_ReportNoImplicitStringConversion,
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);
						} else if (token.equals("semicolon")) {//$NON-NLS-1$ 
							this.options.put(
								CompilerOptions.OPTION_ReportEmptyStatement,
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);
						} else if (token.equals("serial")) {//$NON-NLS-1$ 
							this.options.put(
								CompilerOptions.OPTION_ReportMissingSerialVersion,
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);
						} else if (token.equals("emptyBlock")) {//$NON-NLS-1$ 
							this.options.put(
								CompilerOptions.OPTION_ReportUndocumentedEmptyBlock,
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);
						} else if (token.equals("uselessTypeCheck")) {//$NON-NLS-1$ 
							this.options.put(
								CompilerOptions.OPTION_ReportUnnecessaryTypeCheck,
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);
						} else if (token.equals("unchecked") || token.equals("unsafe")) {//$NON-NLS-1$ //$NON-NLS-2$ 
							this.options.put(
								CompilerOptions.OPTION_ReportUncheckedTypeOperation,
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);
						} else if (token.equals("raw")) {//$NON-NLS-1$
							this.options.put(
								CompilerOptions.OPTION_ReportRawTypeReference,
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);						
						} else if (token.equals("finalBound")) {//$NON-NLS-1$ 
							this.options.put(
								CompilerOptions.OPTION_ReportFinalParameterBound,
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);
						} else if (token.equals("suppress")) {//$NON-NLS-1$ 
							this.options.put(
								CompilerOptions.OPTION_SuppressWarnings,
								isEnabling ? CompilerOptions.ENABLED : CompilerOptions.DISABLED);
						} else if (token.equals("warningToken")) {//$NON-NLS-1$ 
							this.options.put(
								CompilerOptions.OPTION_ReportUnhandledWarningToken,
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);
						} else if (token.equals("unnecessaryElse")) {//$NON-NLS-1$ 
							this.options.put(
								CompilerOptions.OPTION_ReportUnnecessaryElse,
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);
						} else if (token.equals("javadoc")) {//$NON-NLS-1$ 
							if (!useEnableJavadoc) {
								this.options.put(
									CompilerOptions.OPTION_DocCommentSupport,
									isEnabling ? CompilerOptions.ENABLED: CompilerOptions.DISABLED);
							}
							// if disabling then it's not necessary to set other javadoc options
							if (isEnabling) {
								this.options.put(
									CompilerOptions.OPTION_ReportInvalidJavadoc,
									CompilerOptions.WARNING);
								this.options.put(
									CompilerOptions.OPTION_ReportInvalidJavadocTags,
									CompilerOptions.ENABLED);
								this.options.put(
									CompilerOptions.OPTION_ReportInvalidJavadocTagsDeprecatedRef,
									CompilerOptions.DISABLED);
								this.options.put(
									CompilerOptions.OPTION_ReportInvalidJavadocTagsNotVisibleRef,
									CompilerOptions.DISABLED);
								this.options.put(
									CompilerOptions.OPTION_ReportInvalidJavadocTagsVisibility,
									CompilerOptions.PRIVATE);
								this.options.put(
									CompilerOptions.OPTION_ReportMissingJavadocTags,
									CompilerOptions.WARNING);
								this.options.put(
									CompilerOptions.OPTION_ReportMissingJavadocTagsVisibility,
									CompilerOptions.PRIVATE);
							}
						} else if (token.equals("allJavadoc")) { //$NON-NLS-1$
							if (!useEnableJavadoc) {
								this.options.put(
									CompilerOptions.OPTION_DocCommentSupport,
									isEnabling ? CompilerOptions.ENABLED: CompilerOptions.DISABLED);
							}
							// if disabling then it's not necessary to set other javadoc options
							if (isEnabling) {
								this.options.put(
								CompilerOptions.OPTION_ReportInvalidJavadoc,
								CompilerOptions.WARNING);
								this.options.put(
									CompilerOptions.OPTION_ReportInvalidJavadocTags,
									CompilerOptions.ENABLED);
								this.options.put(
									CompilerOptions.OPTION_ReportInvalidJavadocTagsVisibility,
									CompilerOptions.PRIVATE);
								this.options.put(
									CompilerOptions.OPTION_ReportMissingJavadocTags,
									CompilerOptions.WARNING);
								this.options.put(
									CompilerOptions.OPTION_ReportMissingJavadocTagsVisibility,
									CompilerOptions.PRIVATE);
								this.options.put(
									CompilerOptions.OPTION_ReportMissingJavadocComments,
									CompilerOptions.WARNING);
							}
						} else if (token.startsWith("tasks")) { //$NON-NLS-1$
							String taskTags = ""; //$NON-NLS-1$
							int start = token.indexOf('(');
							int end = token.indexOf(')');
							if (start >= 0 && end >= 0 && start < end){
								taskTags = token.substring(start+1, end).trim();
								taskTags = taskTags.replace('|',',');
							}
							if (taskTags.length() == 0){
								throw new InvalidInputException(Main.bind("configure.invalidTaskTag", token)); //$NON-NLS-1$
							}
							this.options.put(
								CompilerOptions.OPTION_TaskTags,
								isEnabling ? taskTags : "");  //$NON-NLS-1$
						} else if (token.equals("assertIdentifier")) { //$NON-NLS-1$
							this.options.put(
								CompilerOptions.OPTION_ReportAssertIdentifier,
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);
						} else if (token.equals("enumIdentifier")) { //$NON-NLS-1$
							this.options.put(
									CompilerOptions.OPTION_ReportEnumIdentifier,
									isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);
						} else if (token.equals("finally")) { //$NON-NLS-1$
							this.options.put(
								CompilerOptions.OPTION_ReportFinallyBlockNotCompletingNormally,
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);
						} else if (token.equals("unusedThrown")) { //$NON-NLS-1$
							this.options.put(
								CompilerOptions.OPTION_ReportUnusedDeclaredThrownException,
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);
						} else if (token.equals("unqualifiedField") //$NON-NLS-1$
								|| token.equals("unqualified-field-access")) { //$NON-NLS-1$
							this.options.put(
								CompilerOptions.OPTION_ReportUnqualifiedFieldAccess,
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);
						} else if (token.equals("typeHiding")) { //$NON-NLS-1$
							this.options.put(
								CompilerOptions.OPTION_ReportTypeParameterHiding,
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);
						} else if (token.equals("varargsCast")) { //$NON-NLS-1$
							this.options.put(
								CompilerOptions.OPTION_ReportVarargsArgumentNeedCast,
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);						
						} else if (token.equals("null")) { //$NON-NLS-1$
							this.options.put(
								CompilerOptions.OPTION_ReportNullReference,
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);						
						} else if (token.equals("boxing")) { //$NON-NLS-1$
							this.options.put(
								CompilerOptions.OPTION_ReportAutoboxing,
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);						
						} else if (token.equals("over-ann")) { //$NON-NLS-1$
							this.options.put(
								CompilerOptions.OPTION_ReportMissingOverrideAnnotation,
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);						
						} else if (token.equals("dep-ann")) { //$NON-NLS-1$
							this.options.put(
								CompilerOptions.OPTION_ReportMissingDeprecatedAnnotation,
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);						
						} else if (token.equals("intfAnnotation")) { //$NON-NLS-1$
							this.options.put(
								CompilerOptions.OPTION_ReportAnnotationSuperInterface,
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);						
						} else if (token.equals("enumSwitch") //$NON-NLS-1$
								|| token.equals("incomplete-switch")) { //$NON-NLS-1$
							this.options.put(
								CompilerOptions.OPTION_ReportIncompleteEnumSwitch,
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);						
						} else if (token.equals("hiding")) { //$NON-NLS-1$
							this.options.put(
								CompilerOptions.OPTION_ReportHiddenCatchBlock,
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);
							this.options.put(
								CompilerOptions.OPTION_ReportLocalVariableHiding,
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);
							this.options.put(
								CompilerOptions.OPTION_ReportFieldHiding,
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);
							this.options.put(
								CompilerOptions.OPTION_ReportTypeParameterHiding,
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);
						} else if (token.equals("static-access")) { //$NON-NLS-1$
							this.options.put(
								CompilerOptions.OPTION_ReportNonStaticAccessToStatic,
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);
							this.options.put(
								CompilerOptions.OPTION_ReportIndirectStaticAccess,
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);
						} else if (token.equals("unused")) { //$NON-NLS-1$
							this.options.put(
								CompilerOptions.OPTION_ReportUnusedLocal, 
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);
							this.options.put(
								CompilerOptions.OPTION_ReportUnusedParameter,
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);
							this.options.put(
								CompilerOptions.OPTION_ReportUnusedImport,
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);
							this.options.put(
								CompilerOptions.OPTION_ReportUnusedPrivateMember,
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);
							this.options.put(
								CompilerOptions.OPTION_ReportUnusedDeclaredThrownException,
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);
							this.options.put(
									CompilerOptions.OPTION_ReportUnusedLabel,
									isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);
						} else if (token.equals("paramAssign")) { //$NON-NLS-1$
							this.options.put(
								CompilerOptions.OPTION_ReportParameterAssignment,
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);
						} else if (token.equals("discouraged")) { //$NON-NLS-1$
							this.options.put(
								CompilerOptions.OPTION_ReportDiscouragedReference,
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);
						} else if (token.equals("forbidden")) { //$NON-NLS-1$
							this.options.put(
								CompilerOptions.OPTION_ReportForbiddenReference,
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);
						} else if (token.equals("fallthrough")) { //$NON-NLS-1$
							this.options.put(
								CompilerOptions.OPTION_ReportFallthroughCase,
								isEnabling ? CompilerOptions.WARNING : CompilerOptions.IGNORE);
						} else {
							throw new InvalidInputException(Main.bind("configure.invalidWarning", token)); //$NON-NLS-1$
						}
					}
					if (tokenCounter == 0)
						throw new InvalidInputException(
							Main.bind("configure.invalidWarningOption", currentArg)); //$NON-NLS-1$
					didSpecifyWarnings = true;
					continue;
				}
				if (currentArg.equals("-target")) { //$NON-NLS-1$
					mode = INSIDE_TARGET;
					continue;
				}
				if (currentArg.equals("-preserveAllLocals")) { //$NON-NLS-1$
					this.options.put(
						CompilerOptions.OPTION_PreserveUnusedLocal,
						CompilerOptions.PRESERVE);
				    mode = DEFAULT;
					continue;
				}
				if (currentArg.equals("-enableJavadoc")) {//$NON-NLS-1$
				    mode = DEFAULT;
					this.options.put(
						CompilerOptions.OPTION_DocCommentSupport,
						CompilerOptions.ENABLED);
					useEnableJavadoc = true;
					continue;
				}
				if (currentArg.equals("-Xemacs")) { //$NON-NLS-1$
					mode = DEFAULT;
					this.logger.setEmacs();
					continue;
				}
				// tolerated javac options - quietly filtered out
				if (currentArg.startsWith("-X")) { //$NON-NLS-1$
					mode = DEFAULT;
					continue;
				}
				if (currentArg.startsWith("-J")) { //$NON-NLS-1$
					mode = DEFAULT;
					continue;
				}
				if (currentArg.equals("-O")) { //$NON-NLS-1$
					mode = DEFAULT;
					continue;
				}
				break;
			case INSIDE_TARGET :
				if (this.didSpecifyTarget) {
					throw new InvalidInputException(
						Main.bind("configure.duplicateTarget", currentArg));//$NON-NLS-1$
				}				
				this.didSpecifyTarget = true;
				if (currentArg.equals("1.1")) { //$NON-NLS-1$
					this.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_1);
				} else if (currentArg.equals("1.2")) { //$NON-NLS-1$
					this.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_2);
				} else if (currentArg.equals("1.3")) { //$NON-NLS-1$
					this.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_3);
				} else if (currentArg.equals("1.4")) { //$NON-NLS-1$
					this.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_4);
				} else if (currentArg.equals("1.5") || currentArg.equals("5") || currentArg.equals("5.0")) { //$NON-NLS-1$//$NON-NLS-2$ //$NON-NLS-3$
					this.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_5);
				} else if (currentArg.equals("1.6") || currentArg.equals("6") || currentArg.equals("6.0")) { //$NON-NLS-1$//$NON-NLS-2$ //$NON-NLS-3$
					this.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_6);
				} else if (currentArg.equals("jsr14")) { //$NON-NLS-1$
					this.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_JSR14);
				} else {
					throw new InvalidInputException(Main.bind("configure.targetJDK", currentArg)); //$NON-NLS-1$
				}
				mode = DEFAULT;
				continue;
			case INSIDE_LOG :
				this.log = currentArg;
				mode = DEFAULT;
				continue;
			case INSIDE_REPETITION :
				try {
					this.repetitions = Integer.parseInt(currentArg);
					if (this.repetitions <= 0) {
						throw new InvalidInputException(Main.bind("configure.repetition", currentArg)); //$NON-NLS-1$
					}
				} catch (NumberFormatException e) {
					throw new InvalidInputException(Main.bind("configure.repetition", currentArg)); //$NON-NLS-1$
				}
				mode = DEFAULT;
				continue;
			case INSIDE_MAX_PROBLEMS :
				try {
					this.maxProblems = Integer.parseInt(currentArg);
					if (this.maxProblems <= 0) {
						throw new InvalidInputException(Main.bind("configure.maxProblems", currentArg)); //$NON-NLS-1$
					}
					this.options.put(CompilerOptions.OPTION_MaxProblemPerUnit, currentArg);
				} catch (NumberFormatException e) {
					throw new InvalidInputException(Main.bind("configure.maxProblems", currentArg)); //$NON-NLS-1$
				}
				mode = DEFAULT;
				continue;
			case INSIDE_SOURCE :
				if (this.didSpecifySource) {
					throw new InvalidInputException(
						Main.bind("configure.duplicateSource", currentArg));//$NON-NLS-1$
				}				
				this.didSpecifySource = true;
				if (currentArg.equals("1.3")) { //$NON-NLS-1$
					this.options.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_3);
				} else if (currentArg.equals("1.4")) { //$NON-NLS-1$
					this.options.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_4);
				} else if (currentArg.equals("1.5") || currentArg.equals("5") || currentArg.equals("5.0")) { //$NON-NLS-1$//$NON-NLS-2$ //$NON-NLS-3$
					this.options.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_5);
				} else if (currentArg.equals("1.6") || currentArg.equals("6") || currentArg.equals("6.0")) { //$NON-NLS-1$//$NON-NLS-2$ //$NON-NLS-3$
					this.options.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_6);
				} else {
					throw new InvalidInputException(Main.bind("configure.source", currentArg)); //$NON-NLS-1$
				}
				mode = DEFAULT;
				continue;
			case INSIDE_DEFAULT_ENCODING :
				if (didSpecifyDefaultEncoding) {
					throw new InvalidInputException(
						Main.bind("configure.duplicateDefaultEncoding", currentArg)); //$NON-NLS-1$
				}
				try { // ensure encoding is supported
					new InputStreamReader(new ByteArrayInputStream(new byte[0]), currentArg);
				} catch (UnsupportedEncodingException e) {
					throw new InvalidInputException(
						Main.bind("configure.unsupportedEncoding", currentArg)); //$NON-NLS-1$
				}
				this.options.put(CompilerOptions.OPTION_Encoding, currentArg);
				didSpecifyDefaultEncoding = true;
				mode = DEFAULT;
				continue;
			case INSIDE_DESTINATION_PATH :
				this.destinationPath = currentArg;
				mode = DEFAULT;
				continue;
			case INSIDE_CLASSPATH:
				classpaths.add(currentArg);
				mode = DEFAULT;
				continue;
			case INSIDE_BOOTCLASSPATH:
				bootclasspaths.add(currentArg);
				mode = DEFAULT;
				continue;
			case INSIDE_SOURCE_PATH :
				sourcepathClasspaths.add(currentArg);
				mode = DEFAULT;
				continue;
			case INSIDE_EXT_DIRS :
				StringTokenizer tokenizer = new StringTokenizer(currentArg,	File.pathSeparator, false);
				extdirsClasspaths = new ArrayList(DEFAULT_SIZE_CLASSPATH);
				while (tokenizer.hasMoreTokens())
					extdirsClasspaths.add(tokenizer.nextToken());
				mode = DEFAULT;
				continue;
			case INSIDE_ENDORSED_DIRS :
				tokenizer = new StringTokenizer(currentArg,	File.pathSeparator, false);
				endorsedDirClasspath = new ArrayList(DEFAULT_SIZE_CLASSPATH);
				while (tokenizer.hasMoreTokens())
					endorsedDirClasspath.add(tokenizer.nextToken());
				mode = DEFAULT;
				continue;
		}

		//default is input directory
		currentArg = currentArg.replace('/', File.separatorChar);
		if (currentArg.endsWith(File.separator))
			currentArg =
				currentArg.substring(0, currentArg.length() - File.separator.length());
		File dir = new File(currentArg);
		if (!dir.isDirectory())
			throw new InvalidInputException(
				Main.bind("configure.directoryNotExist", currentArg)); //$NON-NLS-1$
		FileFinder finder = new FileFinder();
		try {
			finder.find(dir, SuffixConstants.SUFFIX_STRING_JAVA, this.verbose);
		} catch (Exception e) {
			throw new InvalidInputException(Main.bind("configure.IOError", currentArg)); //$NON-NLS-1$
		}
		if (this.filenames != null) {
			// some source files were specified explicitly
			String results[] = finder.resultFiles;
			int length = results.length;
			System.arraycopy(
				this.filenames,
				0,
				(this.filenames = new String[length + filesCount]),
				0,
				filesCount);
			System.arraycopy(
				this.encodings,
				0,
				(this.encodings = new String[length + filesCount]),
				0,
				filesCount);
			System.arraycopy(results, 0, this.filenames, filesCount, length);
			for (int i = 0; i < length; i++) {
				this.encodings[filesCount + i] = customEncoding;
			}
			filesCount += length;
			customEncoding = null;
		} else {
			this.filenames = finder.resultFiles;
			filesCount = this.filenames.length;
			this.encodings = new String[filesCount];
			for (int i = 0; i < filesCount; i++) {
				this.encodings[i] = customEncoding;
			}
			customEncoding = null;
		}
		mode = DEFAULT;
		continue;
	}

	if (this.log != null) {
		this.logger.setLog(this.log);
	} else {
		this.showProgress = false;
	}
	this.logger.logVersion(printVersionRequired);
	
	if (printUsageRequired || filesCount == 0) {
		printUsage();
		this.proceed = false;
		return;
	}

	// process bootclasspath, classpath and sourcepaths
 	final File javaHome = getJavaHome();
 	final int bootclasspathsSize = bootclasspaths.size();
	if (bootclasspathsSize != 0) {
		String[] paths = new String[bootclasspathsSize];
		bootclasspaths.toArray(paths);
		bootclasspaths.clear();
		for (int i = 0; i < bootclasspathsSize; i++) {
			processPathEntries(DEFAULT_SIZE_CLASSPATH, bootclasspaths, paths[i], customEncoding, false);
		}
	} else {
		/* no bootclasspath specified
		 * we can try to retrieve the default librairies of the VM used to run
		 * the batch compiler
		 */
		 String javaversion = System.getProperty("java.version");//$NON-NLS-1$
		 if (javaversion != null && javaversion.equalsIgnoreCase("1.1.8")) { //$NON-NLS-1$
			this.logger.logWrongJDK();
			this.proceed = false;
			return;
		 }

	 	/*
	 	 * Handle >= JDK 1.2.2 settings: retrieve rt.jar
	 	 */
	 	 if (javaHome != null) {
			File[] directoriesToCheck = null;
			if (System.getProperty("os.name").startsWith("Mac")) {//$NON-NLS-1$//$NON-NLS-2$
				directoriesToCheck = new File[] {
					new File(javaHome, "../Classes"), //$NON-NLS-1$
				};
			} else {
				directoriesToCheck = new File[] { 
					new File(javaHome, "lib") //$NON-NLS-1$
				};
			}
			File[][] systemLibrariesJars = getLibrariesFiles(directoriesToCheck);
			if (systemLibrariesJars != null) {
				for (int i = 0, max = systemLibrariesJars.length; i < max; i++) {
					File[] current = systemLibrariesJars[i];
					if (current != null) {
						for (int j = 0, max2 = current.length; j < max2; j++) {
							FileSystem.Classpath classpath = 
								FileSystem.getClasspath(
									current[j].getAbsolutePath(),
									null, false, null); 
							if (classpath != null) {
								bootclasspaths.add(classpath);
							}
						}
					}
				}
			}
 		}
	}
	final int classpathsSize = classpaths.size();
	if (classpaths.size() != 0) {
		String[] paths = new String[classpathsSize];
		classpaths.toArray(paths);
		classpaths.clear();
		for (int i = 0; i < classpathsSize; i++) {
			processPathEntries(DEFAULT_SIZE_CLASSPATH, classpaths, paths[i], customEncoding, false);
		}			
	} else {
		// no user classpath specified.
		String classProp = System.getProperty("java.class.path"); //$NON-NLS-1$
		if ((classProp == null) || (classProp.length() == 0)) {
			this.logger.logNoClasspath();
			classpaths.add(FileSystem.getClasspath(System.getProperty("user.dir"), customEncoding, null));//$NON-NLS-1$
		} else {
			StringTokenizer tokenizer = new StringTokenizer(classProp, File.pathSeparator);
			String token;
			while (tokenizer.hasMoreTokens()) {
				token = tokenizer.nextToken();
				FileSystem.Classpath currentClasspath = FileSystem
						.getClasspath(token, customEncoding, null);
				if (currentClasspath != null) {
					classpaths.add(currentClasspath);
				} else {
					this.logger.logIncorrectClasspath(token);
					// should not happen - we go on anyway
				}
			}
		}
	}
	final int sourcepathClasspathsSize = sourcepathClasspaths.size();
	if (sourcepathClasspathsSize != 0) {
		String[] paths = new String[sourcepathClasspathsSize];
		sourcepathClasspaths.toArray(paths);
		sourcepathClasspaths.clear();
		for (int i = 0; i < sourcepathClasspathsSize; i++) {
			processPathEntries(DEFAULT_SIZE_CLASSPATH, sourcepathClasspaths, paths[i], customEncoding, true);
		}			
	}
	
	if (filesCount != 0)
		System.arraycopy(
			this.filenames,
			0,
			(this.filenames = new String[filesCount]),
			0,
			filesCount);

	/*
	 * Feed endorsedDirClasspath according to:
	 * - -extdirs first if present;
	 * - else java.ext.dirs if defined;
	 * - else default extensions directory for the platform.
	 */
	if (extdirsClasspaths == null) {
		extdirsClasspaths = new ArrayList(DEFAULT_SIZE_CLASSPATH);
		String extdirsStr = System.getProperty("java.ext.dirs"); //$NON-NLS-1$
		if (extdirsStr == null) {
			extdirsClasspaths.add(javaHome.getAbsolutePath() + "/lib/ext"); //$NON-NLS-1$
		} else {
			StringTokenizer tokenizer = new StringTokenizer(extdirsStr, File.pathSeparator);
			while (tokenizer.hasMoreTokens()) 
				extdirsClasspaths.add(tokenizer.nextToken());
		}
	}
	
	/*
	 * Feed extdirsClasspath with the entries found into the directories listed by
	 * extdirsNames.
	 */
	if (extdirsClasspaths.size() != 0) {
		File[] directoriesToCheck = new File[extdirsClasspaths.size()];
		for (int i = 0; i < directoriesToCheck.length; i++) 
			directoriesToCheck[i] = new File((String) extdirsClasspaths.get(i));
		extdirsClasspaths.clear();
		File[][] extdirsJars = getLibrariesFiles(directoriesToCheck);
		if (extdirsJars != null) {
			for (int i = 0, max = extdirsJars.length; i < max; i++) {
				File[] current = extdirsJars[i];
				if (current != null) {
					for (int j = 0, max2 = current.length; j < max2; j++) {
						FileSystem.Classpath classpath = 
							FileSystem.getClasspath(
									current[j].getAbsolutePath(),
									null, null); 
						if (classpath != null) {
							extdirsClasspaths.add(classpath);
						}
					}
				} else if (directoriesToCheck[i].isFile()) {
					this.logger.logIncorrectExtDirsEntry(directoriesToCheck[i].getAbsolutePath());
				}
			}
		}
	}

	/*
	 * Feed endorsedDirClasspath according to:
	 * - -endorseddirs first if present;
	 * - else java.endorsed.dirs if defined;
	 * - else default extensions directory for the platform. (/lib/endorsed)
	 */
	if (endorsedDirClasspath == null) {
		endorsedDirClasspath = new ArrayList(DEFAULT_SIZE_CLASSPATH);
		String endorsedDirsStr = System.getProperty("java.endorsed.dirs"); //$NON-NLS-1$
		if (endorsedDirsStr == null) {
			extdirsClasspaths.add(javaHome.getAbsolutePath() + "/lib/endorsed"); //$NON-NLS-1$
		} else {
			StringTokenizer tokenizer = new StringTokenizer(endorsedDirsStr, File.pathSeparator);
			while (tokenizer.hasMoreTokens()) 
				endorsedDirClasspath.add(tokenizer.nextToken());
		}
	}
	
	/*
	 * Feed extdirsClasspath with the entries found into the directories listed by
	 * extdirsNames.
	 */
	if (endorsedDirClasspath.size() != 0) {
		File[] directoriesToCheck = new File[endorsedDirClasspath.size()];
		for (int i = 0; i < directoriesToCheck.length; i++) 
			directoriesToCheck[i] = new File((String) endorsedDirClasspath.get(i));
		endorsedDirClasspath.clear();
		File[][] endorsedDirsJars = getLibrariesFiles(directoriesToCheck);
		if (endorsedDirsJars != null) {
			for (int i = 0, max = endorsedDirsJars.length; i < max; i++) {
				File[] current = endorsedDirsJars[i];
				if (current != null) {
					for (int j = 0, max2 = current.length; j < max2; j++) {
						FileSystem.Classpath classpath = 
							FileSystem.getClasspath(
									current[j].getAbsolutePath(),
									null, null); 
						if (classpath != null) {
							endorsedDirClasspath.add(classpath);
						}
					}
				} else if (directoriesToCheck[i].isFile()) {
					this.logger.logIncorrectEndorsedDirsEntry(directoriesToCheck[i].getAbsolutePath());
				}
			}
		}
	}
	
	/* 
	 * Concatenate classpath entries
	 * We put the bootclasspath at the beginning of the classpath
	 * entries, followed by the extension libraries, followed by
	 * the sourcepath followed by the classpath.  All classpath
	 * entries are searched for both sources and binaries except
	 * the sourcepath entries which are searched for sources only.
	 */
	bootclasspaths.addAll(endorsedDirClasspath);
	bootclasspaths.addAll(extdirsClasspaths);
	bootclasspaths.addAll(sourcepathClasspaths);
	bootclasspaths.addAll(classpaths);
	classpaths = bootclasspaths;
	this.checkedClasspaths = new FileSystem.Classpath[classpaths.size()];
	classpaths.toArray(this.checkedClasspaths);

	if (this.destinationPath == null) {
		this.generatePackagesStructure = false;
	} else if ("none".equals(this.destinationPath)) { //$NON-NLS-1$
		this.destinationPath = null;
	}
	
	if (didSpecifyCompliance) {
		Object version = this.options.get(CompilerOptions.OPTION_Compliance);
		if (CompilerOptions.VERSION_1_3.equals(version)) {
			if (!this.didSpecifySource) this.options.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_3);
			if (!this.didSpecifyTarget) this.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_1);
		} else if (CompilerOptions.VERSION_1_4.equals(version)) {
			if (!this.didSpecifySource) this.options.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_3);
			if (!this.didSpecifyTarget) this.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_2);
		} else if (CompilerOptions.VERSION_1_5.equals(version)) {
			if (!this.didSpecifySource) this.options.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_5);
			if (!this.didSpecifyTarget) this.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_5);
		} else if (CompilerOptions.VERSION_1_6.equals(version)) {
			if (!this.didSpecifySource) this.options.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_6);
			if (!this.didSpecifyTarget) this.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_6);
		}
	}
	if (this.didSpecifySource) {
		Object version = this.options.get(CompilerOptions.OPTION_Source);
		// default is source 1.3 target 1.2 and compliance 1.4
		if (CompilerOptions.VERSION_1_4.equals(version)) {
			if (!didSpecifyCompliance) this.options.put(CompilerOptions.OPTION_Compliance, CompilerOptions.VERSION_1_4);
			if (!this.didSpecifyTarget) this.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_4);
		} else if (CompilerOptions.VERSION_1_5.equals(version)) {
			if (!didSpecifyCompliance) this.options.put(CompilerOptions.OPTION_Compliance, CompilerOptions.VERSION_1_5);
			if (!this.didSpecifyTarget) this.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_5);
		} else if (CompilerOptions.VERSION_1_6.equals(version)) {
			if (!didSpecifyCompliance) this.options.put(CompilerOptions.OPTION_Compliance, CompilerOptions.VERSION_1_6);
			if (!this.didSpecifyTarget) this.options.put(CompilerOptions.OPTION_TargetPlatform, CompilerOptions.VERSION_1_6);
		}
	}

	final Object sourceVersion = this.options.get(CompilerOptions.OPTION_Source);
	final Object compliance = this.options.get(CompilerOptions.OPTION_Compliance);
	if (sourceVersion.equals(CompilerOptions.VERSION_1_6)
			&& CompilerOptions.versionToJdkLevel(compliance) < ClassFileConstants.JDK1_6) {
		// compliance must be 1.6 if source is 1.6
		throw new InvalidInputException(Main.bind("configure.incompatibleComplianceForSource", (String)this.options.get(CompilerOptions.OPTION_Compliance), CompilerOptions.VERSION_1_6)); //$NON-NLS-1$
	} else if (sourceVersion.equals(CompilerOptions.VERSION_1_5)
			&& CompilerOptions.versionToJdkLevel(compliance) < ClassFileConstants.JDK1_5) {
		// compliance must be 1.5 if source is 1.5
		throw new InvalidInputException(Main.bind("configure.incompatibleComplianceForSource", (String)this.options.get(CompilerOptions.OPTION_Compliance), CompilerOptions.VERSION_1_5)); //$NON-NLS-1$
	} else if (sourceVersion.equals(CompilerOptions.VERSION_1_4)
			&& CompilerOptions.versionToJdkLevel(compliance) < ClassFileConstants.JDK1_4) {
		// compliance must be 1.4 if source is 1.4
		throw new InvalidInputException(Main.bind("configure.incompatibleComplianceForSource", (String)this.options.get(CompilerOptions.OPTION_Compliance), CompilerOptions.VERSION_1_4)); //$NON-NLS-1$
	}

	// check and set compliance/source/target compatibilities
	if (this.didSpecifyTarget) {
		final Object targetVersion = this.options.get(CompilerOptions.OPTION_TargetPlatform); 
		// tolerate jsr14 target
		if (CompilerOptions.VERSION_JSR14.equals(targetVersion)) {
			// expecting source >= 1.5
			if (CompilerOptions.versionToJdkLevel(sourceVersion) < ClassFileConstants.JDK1_5) {
				throw new InvalidInputException(Main.bind("configure.incompatibleTargetForGenericSource", (String) targetVersion, (String) sourceVersion)); //$NON-NLS-1$
			}
		} else {
			// target must be 1.6 if source is 1.6
			if (CompilerOptions.versionToJdkLevel(sourceVersion) >= ClassFileConstants.JDK1_6
					&& CompilerOptions.versionToJdkLevel(targetVersion) < ClassFileConstants.JDK1_6){ 
				throw new InvalidInputException(Main.bind("configure.incompatibleTargetForSource", (String) targetVersion, CompilerOptions.VERSION_1_6)); //$NON-NLS-1$
			}
			// target must be 1.5 if source is 1.5
			if (CompilerOptions.versionToJdkLevel(sourceVersion) >= ClassFileConstants.JDK1_5
					&& CompilerOptions.versionToJdkLevel(targetVersion) < ClassFileConstants.JDK1_5){ 
				throw new InvalidInputException(Main.bind("configure.incompatibleTargetForSource", (String) targetVersion, CompilerOptions.VERSION_1_5)); //$NON-NLS-1$
			}
	   		 // target must be 1.4 if source is 1.4
	   		if (CompilerOptions.versionToJdkLevel(sourceVersion) >= ClassFileConstants.JDK1_4
					&& CompilerOptions.versionToJdkLevel(targetVersion) < ClassFileConstants.JDK1_4){ 
				throw new InvalidInputException(Main.bind("configure.incompatibleTargetForSource", (String) targetVersion, CompilerOptions.VERSION_1_4)); //$NON-NLS-1$
	   		}
			// target cannot be greater than compliance level
			if (CompilerOptions.versionToJdkLevel(compliance) < CompilerOptions.versionToJdkLevel(targetVersion)){ 
				throw new InvalidInputException(Main.bind("configure.incompatibleComplianceForTarget", (String)this.options.get(CompilerOptions.OPTION_Compliance), (String) targetVersion)); //$NON-NLS-1$
			}
		}
	}
	this.logger.logCommandLineArguments(newCommandLineArgs);
	this.logger.logOptions(this.options);
	this.logger.logClasspath(this.checkedClasspaths);
	if (this.repetitions == 0) {
		this.repetitions = 1;
	}
	if (this.repetitions >= 3 && this.timing) {
		this.times = new long[this.repetitions];
		this.timesCounter = 0;
	}
}

