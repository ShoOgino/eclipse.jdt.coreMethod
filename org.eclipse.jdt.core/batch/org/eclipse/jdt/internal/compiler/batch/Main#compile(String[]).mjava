	/*
	 *  Low-level API performing the actual compilation
	 */
	public boolean compile(String[] argv) {

		// decode command line arguments
		try {
			configure(argv);
			if (proceed) {
				if (showProgress)
					out.println(Main.bind("progress.compiling")); //$NON-NLS-1$
				for (int i = 0; i < repetitions; i++) {
					globalProblemsCount = 0;
					globalErrorsCount = 0;
					globalWarningsCount = 0;
					lineCount = 0;
					exportedClassFilesCounter = 0;

					if (repetitions > 1) {
						out.flush();
						out.println(
							Main.bind(
								"compile.repetition", //$NON-NLS-1$
								String.valueOf(i + 1),
								String.valueOf(repetitions)));
					} 
					long startTime = System.currentTimeMillis();
					// request compilation
					performCompilation();
					if (timer) {

						time = System.currentTimeMillis() - startTime;
						if (lineCount != 0) {
							out.println(
								Main.bind(
									"compile.instantTime", 	//$NON-NLS-1$
									new String[] {
										String.valueOf(lineCount),
										String.valueOf(time),
										String.valueOf((((int) ((lineCount * 10000.0) / time)) / 10.0))}));
						} else {
							out.println(Main.bind("compile.totalTime", String.valueOf(time))); //$NON-NLS-1$
						}
					}
					if (globalProblemsCount > 0) {
						if (globalProblemsCount == 1) {
							err.print(Main.bind("compile.oneProblem")); //$NON-NLS-1$
						} else {
							err.print(
								Main.bind("compile.severalProblems", String.valueOf(globalProblemsCount))); 	//$NON-NLS-1$
						}
						err.print(" ("); //$NON-NLS-1$
						if (globalErrorsCount > 0) {
							if (globalErrorsCount == 1) {
								err.print(Main.bind("compile.oneError")); //$NON-NLS-1$
							} else {
								err.print(
									Main.bind("compile.severalErrors", String.valueOf(globalErrorsCount))); 	//$NON-NLS-1$
							}
						}
						if (globalWarningsCount > 0) {
							if (globalErrorsCount > 0) {
								err.print(", "); //$NON-NLS-1$
							}
							if (globalWarningsCount == 1) {
								err.print(Main.bind("compile.oneWarning")); //$NON-NLS-1$
							} else {
								err.print(
									Main.bind("compile.severalWarnings", String.valueOf(globalWarningsCount))); 	//$NON-NLS-1$
							}
						}
						err.println(")"); //$NON-NLS-1$
					}
					if (exportedClassFilesCounter != 0
						&& (this.showProgress || this.timer || this.verbose)) {
						if (exportedClassFilesCounter == 1) {
							out.println(Main.bind("compile.oneClassFileGenerated")); //$NON-NLS-1$
						} else {
							out.println(
								Main.bind(
									"compile.severalClassFilesGenerated", //$NON-NLS-1$
									String.valueOf(exportedClassFilesCounter)));
						}
					}
				}
				if (showProgress)
					out.println();
			}
			if (systemExitWhenFinished) {
				out.flush();
				err.flush();
				System.exit(globalErrorsCount > 0 ? -1 : 0);
			}
		} catch (InvalidInputException e) {
			err.println(e.getMessage());
			err.println("------------------------"); //$NON-NLS-1$
			printUsage();
			if (systemExitWhenFinished) {
				System.exit(-1);
			}
			return false;
		} catch (ThreadDeath e) { // do not stop this one
			throw e;
		} catch (Throwable e) { // internal compiler error
			if (systemExitWhenFinished) {
				out.flush();
				err.flush();
				if (this.log != null) {
					err.close();
				}
				System.exit(-1);
			}
			return false;
			//e.printStackTrace();
		} finally {
			out.flush();
			err.flush();
			if (this.log != null) {
				err.close();
			}
		}
		if (globalErrorsCount == 0){
			return true;
		} else {
			return false;
		}
	}

