public char[][] getModulesDeclaringPackage(char[][] parentPackageName, char[] packageName, char[] moduleName) {
	String qualifiedPackageName = new String(CharOperation.concatWith(parentPackageName, packageName, '/'));

	if (moduleName == ModuleBinding.ANY) {
		// search the entire environment and answer which modules declare that package:
		for (Classpath cp : this.classpaths) {
			char[][] declaringModules = cp.getModulesDeclaringPackage(qualifiedPackageName, null);
			if (declaringModules != null)
				return declaringModules;
			// TODO(SHMOD): support package split among different classpath locations?
		}
	}
	String moduleNameString = String.valueOf(moduleName);
	if (moduleName == ModuleBinding.UNNAMED) {
		// search all classpaths that have no module
		for (Classpath cp : this.classpaths) {
			if (cp.getModule() == null) {
				if (!(cp instanceof IMultiModuleEntry)) { // multiModuleEntries have a module by definition
					if (cp.isPackage(qualifiedPackageName, moduleNameString))
						return new char[][] {ModuleBinding.UNNAMED};
				}
			}
		}
	} else {
		// specific search in a given module:
		Classpath classpath = this.moduleLocations.get(moduleNameString);
		if (classpath != null) {
			if (classpath.isPackage(qualifiedPackageName, moduleNameString))
				return new char[][] {moduleName};
		}
	}
	return null;
}

