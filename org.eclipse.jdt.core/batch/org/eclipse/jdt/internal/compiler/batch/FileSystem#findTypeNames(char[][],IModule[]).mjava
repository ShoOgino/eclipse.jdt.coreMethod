public char[][][] findTypeNames(char[][] packageName, IModule[] modules) {
	char[][][] result = null;
	if (packageName != null) {
		String qualifiedPackageName = new String(CharOperation.concatWith(packageName, '/'));
		String qualifiedPackageName2 = File.separatorChar == '/' ? qualifiedPackageName : qualifiedPackageName.replace('/', File.separatorChar);
		if (qualifiedPackageName == qualifiedPackageName2) {
			for (int i = 0, length = this.classpaths.length; i < length; i++) {
				for (IModule mod : modules) {
					if (!CharOperation.equals(mod.name(), ModuleEnvironment.UNNAMED) && !this.classpaths[i].servesModule(mod.name())) continue;
					char[][][] answers = this.classpaths[i].findTypeNames(qualifiedPackageName, mod);
					if (answers != null) {
						// concat with previous answers
						if (result == null) {
							result = answers;
						} else {
							int resultLength = result.length;
							int answersLength = answers.length;
							System.arraycopy(result, 0, (result = new char[answersLength + resultLength][][]), 0, resultLength);
							System.arraycopy(answers, 0, result, resultLength, answersLength);
						}
					}
				}
			}
		} else {
			for (int i = 0, length = this.classpaths.length; i < length; i++) {
				Classpath p = this.classpaths[i];
				for (IModule mod : modules) {
					if (!CharOperation.equals(mod.name(), ModuleEnvironment.UNNAMED) && !p.servesModule(mod.name())) continue;
					char[][][] answers = (p instanceof ClasspathJar)
							? p.findTypeNames(qualifiedPackageName, mod)
							: p.findTypeNames(qualifiedPackageName2, mod);
						if (answers != null) {
							// concat with previous answers
							if (result == null) {
								result = answers;
							} else {
								int resultLength = result.length;
								int answersLength = answers.length;
								System.arraycopy(result, 0, (result = new char[answersLength + resultLength][][]), 0, resultLength);
								System.arraycopy(answers, 0, result, resultLength, answersLength);
							}
						}
				}
			}
		}
	}
	return result;
}

