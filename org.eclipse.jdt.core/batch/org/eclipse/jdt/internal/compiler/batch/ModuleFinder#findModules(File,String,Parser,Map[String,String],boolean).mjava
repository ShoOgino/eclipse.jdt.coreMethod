	protected static List<FileSystem.Classpath> findModules(File f, String destinationPath, Parser parser, Map<String, String> options, boolean isModulepath) {
		List<FileSystem.Classpath> collector = new ArrayList<>();
		if (f.isDirectory()) {
			File[] files = f.listFiles();
			if (files == null) 
				return Collections.EMPTY_LIST;
			for (final File file : files) {
				FileSystem.Classpath modulePath = FileSystem.getClasspath(
						file.getAbsolutePath(),
						null,
						!isModulepath,
						null,
						destinationPath == null ? null : (destinationPath + File.separator + file.getName()), 
						options);
				if (modulePath != null) {
					collector.add(modulePath);
					IModule module = null;
					if (file.isDirectory()) {
						String[] list = file.list(new FilenameFilter() {
							@Override
							public boolean accept(File dir, String name) {
								if (dir == file && (name.equalsIgnoreCase(IModuleEnvironment.MODULE_INFO_CLASS)
										|| name.equalsIgnoreCase(IModuleEnvironment.MODULE_INFO_JAVA))) {
									return true;
								}
								return false;
							}
						});
						if (list.length > 0) {
							String fileName = list[0];
							switch (fileName) {
								case IModuleEnvironment.MODULE_INFO_CLASS:
									module = ModuleFinder.extractModuleFromClass(new File(file, fileName), modulePath);
									break;
								case IModuleEnvironment.MODULE_INFO_JAVA:
									module = ModuleFinder.extractModuleFromSource(new File(file, fileName), parser, modulePath);
									break;
							}
						}
					} else if (isJar(file)) {
						module = extractModuleFromJar(file, modulePath);
					}
					if (isModulepath && module == null) {
						 // The name includes the file's extension, but it shouldn't matter.
						module = new BasicModule(file.getName().toCharArray(), modulePath, true);
					}
					if (module != null)
						modulePath.acceptModule(module);
				}
			}
		}
		return collector;
	}

