	protected Commandline setupJavacCommand() throws BuildException {
		Commandline cmd = new Commandline();

		/*
		 * This option is used to never exit at the end of the ant task. 
		 */
		cmd.createArgument().setValue("-noExit"); //$NON-NLS-1$

		cmd.createArgument().setValue("-bootclasspath"); //$NON-NLS-1$
		final Javac javac = getJavac();
		Path bootcp = javac.getBootclasspath();
		if (bootcp != null && bootcp.size() != 0) {
			/*
			 * Set the bootclasspath for the Eclipse compiler.
			 */
			cmd.createArgument().setPath(bootcp);
		} else {
			javac.setIncludejavaruntime(true);
		}

		Project proj = javac.getProject();
		Path classpath = new Path(proj);

		/*
		 * Eclipse compiler doesn't support -extdirs.
		 * It is emulated using the classpath. We add extdirs entries after the 
		 * bootclasspath.
		 */
		addExtdirs(classpath, javac.getExtdirs());

		/*
		 * The java runtime is already handled, so we simply want to retrieve the
		 * ant runtime and the compile classpath.
		 */
		classpath.append(getCompileClasspath());

		// For -sourcepath, use the "sourcepath" value if present.
		// Otherwise default to the "srcdir" value.
		Path sourcepath = null;

        // retrieve the method getSourcepath() using reflect
        // This is done to improve the compatibility to ant 1.5
        Class javacClass = Javac.class;
        Method getSourcepathMethod = null;
        try {
	        getSourcepathMethod = javacClass.getMethod("getSourcepath", null); //$NON-NLS-1$
        } catch(NoSuchMethodException e) {
        	// if not found, then we cannot use this method (ant 1.5)
        }
        Path compileSourcePath = null;
        if (getSourcepathMethod != null) {
	 		try {
				compileSourcePath = (Path) getSourcepathMethod.invoke(javac, null);
			} catch (IllegalAccessException e) {
				// should never happen
			} catch (InvocationTargetException e) {
				// should never happen
			}
        }
 
		if (compileSourcePath != null) {
			sourcepath = compileSourcePath;
		} else {
			sourcepath = javac.getSrcdir();
		}
		classpath.append(sourcepath);
		/*
		 * Set the classpath for the Eclipse compiler.
		 */
		cmd.createArgument().setValue("-classpath"); //$NON-NLS-1$
		cmd.createArgument().setPath(javac.getClasspath());

		String memoryParameterPrefix = JavaEnvUtils.getJavaVersion().equals(JavaEnvUtils.JAVA_1_1) ? "-J-" : "-J-X"; //$NON-NLS-1$//$NON-NLS-2$
		String memInitialSize = javac.getMemoryInitialSize();
		if (memInitialSize != null) {
			if (!javac.isForkedJavac()) {
				attributes.log(Util.getString("ant.jdtadapter.info.ignoringMemoryInitialSize"), Project.MSG_WARN); //$NON-NLS-1$
			} else {
				cmd.createArgument().setValue(memoryParameterPrefix + "ms" + memInitialSize); //$NON-NLS-1$
			}
		}

		String memMaximumSize = javac.getMemoryMaximumSize();
		if (memMaximumSize != null) {
			if (!javac.isForkedJavac()) {
				attributes.log(Util.getString("ant.jdtadapter.info.ignoringMemoryMaximumSize"), Project.MSG_WARN); //$NON-NLS-1$
			} else {
				cmd.createArgument().setValue(memoryParameterPrefix + "mx" + memMaximumSize); //$NON-NLS-1$
			}
		}

		if (javac.getDebug()) {
	       // retrieve the method getDebugLevel() using reflect
	        // This is done to improve the compatibility to ant 1.5
	        Method getDebugLevelMethod = null;
	        try {
		        getDebugLevelMethod = javacClass.getMethod("getDebugLevel", null); //$NON-NLS-1$
	        } catch(NoSuchMethodException e) {
	        	// if not found, then we cannot use this method (ant 1.5)
	        	// debug level is only available with ant 1.5.x
	        }
     	    String debugLevel = null;
	        if (getDebugLevelMethod != null) {
				try {
					debugLevel = (String) getDebugLevelMethod.invoke(javac, null);
				} catch (IllegalAccessException e) {
					// should never happen
				} catch (InvocationTargetException e) {
					// should never happen
				}
        	}
			if (debugLevel != null) {
				if (debugLevel.length() == 0) {
					cmd.createArgument().setValue("-g:none"); //$NON-NLS-1$
				} else {
					cmd.createArgument().setValue("-g:" + debugLevel); //$NON-NLS-1$
				}
			} else {
				cmd.createArgument().setValue("-g"); //$NON-NLS-1$
			}
		} else {
			cmd.createArgument().setValue("-g:none"); //$NON-NLS-1$
		}

       // retrieve the method getCurrentCompilerArgs() using reflect
        // This is done to improve the compatibility to ant 1.5
        Method getCurrentCompilerArgsMethod = null;
        try {
	        getCurrentCompilerArgsMethod = javacClass.getMethod("getCurrentCompilerArgs", null); //$NON-NLS-1$
        } catch(NoSuchMethodException e) {
        	// if not found, then we cannot use this method (ant 1.5)
        	// debug level is only available with ant 1.5.x
        }
 	    String[] compilerArgs = null;
        if (getCurrentCompilerArgsMethod != null) {
			try {
				compilerArgs = (String[]) getCurrentCompilerArgsMethod.invoke(javac, null);
			} catch (IllegalAccessException e) {
				// should never happen
			} catch (InvocationTargetException e) {
				// should never happen
			}
    	}
    	
		final boolean deprecationSetting = javac.getDeprecation();
	   	if (compilerArgs == null) {
			/*
			 * Handle the nowarn option. If none, then we generate all warnings.
			 */
			if (javac.getNowarn()) {
				if (deprecationSetting) {
					cmd.createArgument().setValue("-warn:allDeprecation"); //$NON-NLS-1$
				} else {
					cmd.createArgument().setValue("-nowarn"); //$NON-NLS-1$
				}
			} else if (deprecationSetting) {
				cmd.createArgument().setValue("-warn:allDeprecation,constructorName,packageDefaultMethod,maskedCatchBlocks,unusedImports,staticReceiver"); //$NON-NLS-1$
			} else {
				cmd.createArgument().setValue("-warn:constructorName,packageDefaultMethod,maskedCatchBlocks,unusedImports,staticReceiver"); //$NON-NLS-1$
			}
    	} else {
			/*
			 * Handle the nowarn option. If none, then we generate all warnings.
			 */
			if (javac.getNowarn()) {
				if (deprecationSetting) {
					cmd.createArgument().setValue("-warn:allDeprecation"); //$NON-NLS-1$
				} else {
					cmd.createArgument().setValue("-nowarn"); //$NON-NLS-1$
				}
			} else if (deprecationSetting) {
				cmd.createArgument().setValue("-warn:allDeprecation"); //$NON-NLS-1$
			}
	   	}

		/*
		 * destDir option.
		 */
		final File destdir = javac.getDestdir();
		if (destdir != null) {
			cmd.createArgument().setValue("-d"); //$NON-NLS-1$
			cmd.createArgument().setFile(destdir.getAbsoluteFile());
		}

		/*
		 * target option.
		 */
		final String targetSetting = javac.getTarget();
		if (targetSetting != null) {
			cmd.createArgument().setValue("-target"); //$NON-NLS-1$
			cmd.createArgument().setValue(targetSetting);
		}

		/*
		 * verbose option
		 */
		if (javac.getVerbose()) {
			cmd.createArgument().setValue("-verbose"); //$NON-NLS-1$
			/*
			 * extra option allowed by the Eclipse compiler
			 */
			cmd.createArgument().setValue("-log"); //$NON-NLS-1$
			logFileName = destdir.getAbsolutePath() + ".log"; //$NON-NLS-1$
			cmd.createArgument().setValue(logFileName);
		}

		/*
		 * failnoerror option
		 */
		if (!javac.getFailonerror()) {
			cmd.createArgument().setValue("-proceedOnError"); //$NON-NLS-1$
		}

		/*
		 * source option
		 */
		final String source = javac.getSource();
		if (source != null) {
			cmd.createArgument().setValue("-source"); //$NON-NLS-1$
			cmd.createArgument().setValue(source);
		}

		if (JavaEnvUtils.getJavaVersion().equals(JavaEnvUtils.JAVA_1_4)) {
			cmd.createArgument().setValue("-1.4"); //$NON-NLS-1$
		} else {
			cmd.createArgument().setValue("-1.3"); //$NON-NLS-1$
		}

		/*
		 * encoding option
		 */
		final String encodingSetting = javac.getEncoding();
		if (encodingSetting != null) {
			cmd.createArgument().setValue("-encoding"); //$NON-NLS-1$
			cmd.createArgument().setValue(encodingSetting);
		}

		/*
		 * Add extra argument on the command line
		 */
		if (compilerArgs != null) {
	        cmd.addArguments(compilerArgs);
		}
		/*
		 * Eclipse compiler doesn't have a -sourcepath option. This is
		 * handled through the javac task that collects all source files in
		 * srcdir option.
		 */
		logAndAddFilesToCompile(cmd);
		return cmd;
	}

