	/**
	 * adds the import entry, but if its an existing import entry then preserves the comments surrounding the import
	 */
	private ImportDeclEntry addImportDeclEntry(String containerName, String fullTypeName, boolean isStatic, CompilationUnit root) {
		List/*ImportDeclaration*/ decls= root.imports();
		if (decls.isEmpty() || this.preserveExistingCommentsRanges == null || this.preserveExistingCommentsRanges.length == 0) {
			return new ImportDeclEntry(containerName.length(), fullTypeName, isStatic, null);
		}
		IRegion precedingCommentRange = null;
		IRegion trailingCommentRange = null;
		int prevOffset = this.replaceRange.getOffset();  // will store offset of the previous import's extended end
		int numOfImports = decls.size();
		for (int i= 0; i < numOfImports; i++) {
			ImportDeclaration curr= (ImportDeclaration) decls.get(i);
			int currOffset= curr.getStartPosition();
			int currLength= curr.getLength();
			int currExtendedStart = root.getExtendedStartPosition(curr);
			int currExtendedLen = root.getExtendedLength(curr);
			String name= getFullName(curr);
			String packName= getQualifier(curr);
			if (packName.equals(containerName) && (name.equals(fullTypeName) || name.endsWith("*"))) {//$NON-NLS-1$
				int preserveCommentsLen = this.preserveExistingCommentsRanges.length;
				for (int j = 0; j < preserveCommentsLen; j++) {
					int offset = this.preserveExistingCommentsRanges[j].getOffset();
					boolean wasRangeUsed = false;
					int existingCommentLength = this.preserveExistingCommentsRanges[j].getLength();
					if (offset == currExtendedStart) {
						// comments belonging to this import's extended start
						precedingCommentRange = new Region(offset, existingCommentLength);
						wasRangeUsed = true;
					} else if (offset < currExtendedStart && offset > prevOffset) {
						// comment between two imports but not inside either's extended ranges
						// to preserve the position of these comments add a dummy comment entry
						PackageEntry commentEntry = new PackageEntry(); // create a comment package entry for this
						commentEntry.setGroupID(packName);	// the comment should belong to the current group
						this.packageEntries.add(commentEntry);
						commentEntry.add(new ImportDeclEntry(packName.length(), null, false, new Region(offset, existingCommentLength)));
						wasRangeUsed = true;
					} else if ((currExtendedStart + currExtendedLen) != (currOffset + currLength)){
						if (offset == currOffset + currLength) {
							// comment is in the extended end of the import
							trailingCommentRange = new Region(offset, existingCommentLength);
							wasRangeUsed = true;
						} else if (offset > (currOffset + currLength)) {
							break;
						}
					}
					if (wasRangeUsed) {
						// remove this comment from preserveExistingCommentsRanges array
						IRegion[] tempRegions = new IRegion[--preserveCommentsLen];
						System.arraycopy(this.preserveExistingCommentsRanges, 0, tempRegions, 0, j);
						System.arraycopy(this.preserveExistingCommentsRanges, j+1, tempRegions, j, tempRegions.length - j);
						this.preserveExistingCommentsRanges = tempRegions;
						j--;
					}
				}
				return new ImportDeclEntry(containerName.length(), fullTypeName, isStatic, null, precedingCommentRange, trailingCommentRange);
			}
			prevOffset = currExtendedStart + currExtendedLen - 1;
		}
		return new ImportDeclEntry(containerName.length(), fullTypeName, isStatic, null);
	}

