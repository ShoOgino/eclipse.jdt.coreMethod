	/**
	 * Creates a placeholder node of the given type. <code>null</code> if the type is not supported
	 * @param nodeType Type of the node to create. Use the type constants in {@link NodeInfoStore}.
	 * @return Returns a place holder node.
	 */
	public final ASTNode newPlaceholderNode(int nodeType) {
		AST ast= fAst;
		switch (nodeType) {
			case ASTNode.ANNOTATION_TYPE_DECLARATION :
				return ast.newAnnotationTypeDeclaration();
			case ASTNode.ANNOTATION_TYPE_MEMBER_DECLARATION :
				return ast.newAnnotationTypeMemberDeclaration();
			case ASTNode.ANONYMOUS_CLASS_DECLARATION :
				return ast.newAnonymousClassDeclaration();
			case ASTNode.ARRAY_ACCESS :
				return ast.newArrayAccess();
			case ASTNode.ARRAY_CREATION :
				return ast.newArrayCreation();
			case ASTNode.ARRAY_INITIALIZER :
				return ast.newArrayInitializer();
			case ASTNode.ARRAY_TYPE :
				return ast.newArrayType(ast.newPrimitiveType(PrimitiveType.INT));
			case ASTNode.ASSERT_STATEMENT :
				return ast.newAssertStatement();
			case ASTNode.ASSIGNMENT :
				return ast.newAssignment();
			case ASTNode.BLOCK :
				return ast.newBlock();
			case ASTNode.BLOCK_COMMENT :
				return ast.newBlockComment();
			case ASTNode.BOOLEAN_LITERAL :
				return ast.newBooleanLiteral(false);
			case ASTNode.BREAK_STATEMENT :
				return ast.newBreakStatement();
			case ASTNode.CAST_EXPRESSION :
				return ast.newCastExpression();
			case ASTNode.CATCH_CLAUSE :
				return ast.newCatchClause();
			case ASTNode.CHARACTER_LITERAL :
				return ast.newCharacterLiteral();
			case ASTNode.CLASS_INSTANCE_CREATION :
				return ast.newClassInstanceCreation();
			case ASTNode.COMPILATION_UNIT :
				return ast.newCompilationUnit();
			case ASTNode.CONDITIONAL_EXPRESSION :
				return ast.newConditionalExpression();
			case ASTNode.CONSTRUCTOR_INVOCATION :
				return ast.newConstructorInvocation();
			case ASTNode.CONTINUE_STATEMENT :
				return ast.newContinueStatement();
			case ASTNode.DO_STATEMENT :
				return ast.newDoStatement();
			case ASTNode.EMPTY_STATEMENT :
				return ast.newEmptyStatement();
			case ASTNode.ENHANCED_FOR_STATEMENT :
				return ast.newEnhancedForStatement();
			case ASTNode.ENUM_CONSTANT_DECLARATION :
				return ast.newEnumConstantDeclaration();
			case ASTNode.ENUM_DECLARATION :
				return ast.newEnumDeclaration();
			case ASTNode.EXPRESSION_STATEMENT :
				return ast.newExpressionStatement(ast.newMethodInvocation());
			case ASTNode.FIELD_ACCESS :
				return ast.newFieldAccess();
			case ASTNode.FIELD_DECLARATION :
				return ast.newFieldDeclaration(ast.newVariableDeclarationFragment());
			case ASTNode.FOR_STATEMENT :
				return ast.newForStatement();
			case ASTNode.IF_STATEMENT :
				return ast.newIfStatement();
			case ASTNode.IMPORT_DECLARATION :
				return ast.newImportDeclaration();
			case ASTNode.INFIX_EXPRESSION :
				return ast.newInfixExpression();
			case ASTNode.INITIALIZER :
				return ast.newInitializer();
			case ASTNode.INSTANCEOF_EXPRESSION :
				return ast.newInstanceofExpression();
			case ASTNode.JAVADOC :
				return ast.newJavadoc();
			case ASTNode.LABELED_STATEMENT :
				return ast.newLabeledStatement();
			case ASTNode.LINE_COMMENT :
				return ast.newLineComment();
			case ASTNode.MARKER_ANNOTATION :
				return ast.newMarkerAnnotation();
			case ASTNode.MEMBER_REF :
				return ast.newMemberRef();
			case ASTNode.MEMBER_VALUE_PAIR :
				return ast.newMemberValuePair();
			case ASTNode.METHOD_DECLARATION :
				return ast.newMethodDeclaration();
			case ASTNode.METHOD_INVOCATION :
				return ast.newMethodInvocation();
			case ASTNode.METHOD_REF :
				return ast.newMethodRef();
			case ASTNode.METHOD_REF_PARAMETER :
				return ast.newMethodRefParameter();
			case ASTNode.MODIFIER :
				return ast.newModifier(Modifier.ModifierKeyword.ABSTRACT_KEYWORD);
			case ASTNode.NORMAL_ANNOTATION :
				return ast.newNormalAnnotation();
			case ASTNode.NULL_LITERAL :
				return ast.newNullLiteral();
			case ASTNode.NUMBER_LITERAL :
				return ast.newNumberLiteral();
			case ASTNode.PACKAGE_DECLARATION :
				return ast.newPackageDeclaration();
			case ASTNode.PARAMETERIZED_TYPE :
				return ast.newParameterizedType(ast.newSimpleName("id")); //$NON-NLS-1$
			case ASTNode.PARENTHESIZED_EXPRESSION :
				return ast.newParenthesizedExpression();
			case ASTNode.POSTFIX_EXPRESSION :
				return ast.newPostfixExpression();
			case ASTNode.PREFIX_EXPRESSION :
				return ast.newPrefixExpression();
			case ASTNode.PRIMITIVE_TYPE :
				return ast.newPrimitiveType(PrimitiveType.INT);
			case ASTNode.QUALIFIED_NAME :
				return ast.newQualifiedName(ast.newSimpleName("id"), ast.newSimpleName("id"));  //$NON-NLS-1$//$NON-NLS-2$
			case ASTNode.QUALIFIED_TYPE :
				return ast.newQualifiedType(ast.newSimpleType(ast.newSimpleName("id")), ast.newSimpleName("id")); //$NON-NLS-1$ //$NON-NLS-2$
			case ASTNode.RETURN_STATEMENT :
				return ast.newReturnStatement();
			case ASTNode.SIMPLE_NAME :
				return ast.newSimpleName("id"); //$NON-NLS-1$
			case ASTNode.SIMPLE_TYPE :
				return ast.newSimpleType(ast.newSimpleName("id")); //$NON-NLS-1$
			case ASTNode.SINGLE_MEMBER_ANNOTATION :
				return ast.newSingleMemberAnnotation();
			case ASTNode.SINGLE_VARIABLE_DECLARATION :
				return ast.newSingleVariableDeclaration();
			case ASTNode.STRING_LITERAL :
				return ast.newStringLiteral();
			case ASTNode.SUPER_CONSTRUCTOR_INVOCATION :
				return ast.newSuperConstructorInvocation();
			case ASTNode.SUPER_FIELD_ACCESS :
				return ast.newFieldAccess();
			case ASTNode.SUPER_METHOD_INVOCATION :
				return ast.newSuperMethodInvocation();
			case ASTNode.SWITCH_CASE:
				return ast.newSwitchCase();
			case ASTNode.SWITCH_STATEMENT :
				return ast.newSwitchStatement();
			case ASTNode.SYNCHRONIZED_STATEMENT :
				return ast.newSynchronizedStatement();
			case ASTNode.TAG_ELEMENT :
				return ast.newTagElement();
			case ASTNode.TEXT_ELEMENT :
				return ast.newTextElement();
			case ASTNode.THIS_EXPRESSION :
				return ast.newThisExpression();
			case ASTNode.THROW_STATEMENT :
				return ast.newThrowStatement();
			case ASTNode.TRY_STATEMENT :
				TryStatement tryStatement= ast.newTryStatement();
				tryStatement.setFinally(ast.newBlock()); // have to set at least a finally clock to be legal code
				return tryStatement;
			case ASTNode.TYPE_DECLARATION :
				return ast.newTypeDeclaration();
			case ASTNode.TYPE_DECLARATION_STATEMENT :
				return ast.newTypeDeclarationStatement(ast.newTypeDeclaration());
			case ASTNode.TYPE_LITERAL :
				return ast.newTypeLiteral();
			case ASTNode.TYPE_PARAMETER :
				return ast.newTypeParameter();
			case ASTNode.VARIABLE_DECLARATION_EXPRESSION :
				return ast.newVariableDeclarationExpression(ast.newVariableDeclarationFragment());
			case ASTNode.VARIABLE_DECLARATION_FRAGMENT :
				return ast.newVariableDeclarationFragment();
			case ASTNode.VARIABLE_DECLARATION_STATEMENT :
				return ast.newVariableDeclarationStatement(ast.newVariableDeclarationFragment());
			case ASTNode.WHILE_STATEMENT :
				return ast.newWhileStatement();
			case ASTNode.WILDCARD_TYPE :
				return ast.newWildcardType();
		}
		throw new IllegalArgumentException();
	}

