	private IRegion[] retrieveExistingCommentsInImports(CompilationUnit root) {
		List/*ImportDeclaration*/ decls= root.imports();
		if (decls.isEmpty()) {
			return null;
		}
		
		List commentList = root.getCommentList();
		int numberOfComments = commentList.size();
		List regions = null;
		int currentExtendedEnd = -1;
		int currEndLine= -1;

		/* for the first comment, we only take the trailing comment if any and the replace range doesn't 
		 * include the preceding comment
		 */
		for (int i= 0; i < decls.size(); i++) {
			ImportDeclaration next= (ImportDeclaration) decls.get(i);
			int nextOffset= next.getStartPosition();
			int nextLength= next.getLength();

			int extendedStart = root.getExtendedStartPosition(next);
			int extendedLength = root.getExtendedLength(next);
			int nextOffsetLine= root.getLineNumber(nextOffset);

			if (nextOffset != extendedStart) {
				// preceding comment
				int lengthOfPrecedingComment = nextOffset - extendedStart;
				if (i != 0) {
					if (regions == null) {
						regions = new ArrayList();
					}
					regions.add(new Region(extendedStart, lengthOfPrecedingComment));
				}
				
				if (extendedLength != (nextLength + lengthOfPrecedingComment)) {
					// Preceding and trailing comments 
					int regionLength = extendedLength - (nextLength + lengthOfPrecedingComment);
					if (regions == null) {
						regions = new ArrayList();
					}
					regions.add(new Region(nextOffset + nextLength, regionLength));
				}
			} else if (nextLength != extendedLength) {
				// no extended start - only trailing comment
				int regionLength = extendedLength - nextLength;
				if (regions == null) {
					regions = new ArrayList();
				}
				regions.add(new Region(nextOffset + nextLength, regionLength));
			}
			if (i > 0) {
				// record comments between the previous comment and the current one that are not part
				// of any comment extended range.
				if ((nextOffsetLine - currEndLine) > 1) {
					// check for comments between the two imports
					LineComment comment = root.getAST().newLineComment();
					comment.setSourceRange(currentExtendedEnd + 1, 0);
					int index = Collections.binarySearch(commentList, comment, new Comparator() {
						public int compare(Object o1, Object o2) {
							return ((Comment) o1).getStartPosition() - ((Comment) o2).getStartPosition();
						}
					});
					// index = -(insertion point) - 1. 
					if (index < 0) {
						loop: for (int j = -(index + 1); j < numberOfComments; j++) {
							Comment currentComment = (Comment) commentList.get(j);
							int commentStartPosition = currentComment.getStartPosition();
							int commentLength = currentComment.getLength();
							if ((commentStartPosition > currentExtendedEnd)
									&& ((commentStartPosition + commentLength - 1) < extendedStart)) {
								if (regions == null) {
									regions = new ArrayList();
								}
								regions.add(new Region(commentStartPosition, commentLength));
							} else {
								break loop;
							}
						}
					}
				}
			}
			currentExtendedEnd = extendedStart + extendedLength - 1;
			currEndLine = root.getLineNumber(currentExtendedEnd);
		}
		if (regions == null) {
			return null;
		}
		// sort regions according to their positions to restore comments in the same order
		IRegion[] result = (IRegion[]) regions.toArray(new IRegion[regions.size()]);
		Arrays.sort(result, new Comparator() {
			public int compare(Object o1, Object o2) {
				return ((IRegion) o1).getOffset() - ((IRegion) o2).getOffset();
			}
		});
		return result;
	}

