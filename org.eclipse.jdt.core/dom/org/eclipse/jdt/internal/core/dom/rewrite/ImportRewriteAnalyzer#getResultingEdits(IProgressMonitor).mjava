	public MultiTextEdit getResultingEdits(IProgressMonitor monitor) throws JavaModelException {
		if (monitor == null) {
			monitor= new NullProgressMonitor();
		}
		try {
			int importsStart=  this.replaceRange.getOffset();
			int importsLen= this.replaceRange.getLength();

			String lineDelim= this.compilationUnit.findRecommendedLineSeparator();
			IBuffer buffer= this.compilationUnit.getBuffer();

			int currPos= importsStart;
			MultiTextEdit resEdit= new MultiTextEdit();

			if ((this.flags & F_NEEDS_LEADING_DELIM) != 0) {
				// new import container
				resEdit.addChild(new InsertEdit(currPos, lineDelim));
			}

			PackageEntry lastPackage= null;

			Set onDemandConflicts= null;
			if (this.findAmbiguousImports) {
				onDemandConflicts= evaluateStarImportConflicts(monitor);
			}

			int spacesBetweenGroups= getSpacesBetweenImportGroups();

			ArrayList stringsToInsert= new ArrayList();

			int nPackageEntries= this.packageEntries.size();
			for (int i= 0; i < nPackageEntries; i++) {
				PackageEntry pack= (PackageEntry) this.packageEntries.get(i);
				if (this.filterImplicitImports && !pack.isStatic() && isImplicitImport(pack.getName())) {
					pack.filterImplicitImports(this.useContextToFilterImplicitImports);
				}
				int nImports= pack.getNumberOfImports();
				if (nImports == 0) {
					continue;
				}

				if (spacesBetweenGroups > 0) {
					// add a space between two different groups by looking at the two adjacent imports
					if (lastPackage != null && !pack.isComment() && !pack.isSameGroup(lastPackage)) {
						ImportDeclEntry last= lastPackage.getImportAt(lastPackage.getNumberOfImports() - 1);
						ImportDeclEntry first= pack.getImportAt(0);
						if (!lastPackage.isComment() && (last.isNew() || first.isNew())) {
							for (int k= spacesBetweenGroups; k > 0; k--) {
								stringsToInsert.add(lineDelim);
							}
						}
					} else if (lastPackage != null && lastPackage.isComment() && pack.isSameGroup(lastPackage)) {
						// the last pack may be a dummy for a comment which doesn't belong to any extended range
						stringsToInsert.add(lineDelim);
					}
				}
				lastPackage= pack;

				boolean isStatic= pack.isStatic();
				int threshold= isStatic ? this.staticImportOnDemandThreshold : this.importOnDemandThreshold;

				boolean doStarImport= pack.hasStarImport(threshold, onDemandConflicts);
				boolean allImportsAddedToStar = false;
				if (doStarImport && (pack.find("*") == null)) { //$NON-NLS-1$
					String[] imports = getNewImportStrings(buffer, pack, isStatic, lineDelim);
					for (int j = 0, max = imports.length; j < max; j++) {
						stringsToInsert.add(imports[j]);
					}
					allImportsAddedToStar = true;
				}

				for (int k= 0; k < nImports; k++) {
					ImportDeclEntry currDecl= pack.getImportAt(k);
					IRegion region= currDecl.getSourceRange();

					if (region == null) { // new entry
						if (!doStarImport || currDecl.isOnDemand() || (onDemandConflicts != null && onDemandConflicts.contains(currDecl.getSimpleName()))) {
							IRegion rangeBefore = currDecl.getPrecedingCommentRange();
							IRegion rangeAfter = currDecl.getTrailingCommentRange();
							if (rangeBefore != null) {
								stringsToInsert.add(buffer.getText(rangeBefore.getOffset(), rangeBefore.getLength()));
							}
							
							String trailingComment = null;
							if (rangeAfter != null) {
								trailingComment = buffer.getText(rangeAfter.getOffset(), rangeAfter.getLength());
							}
							String str= getNewImportString(currDecl.getElementName(), isStatic, trailingComment, lineDelim);
							stringsToInsert.add(str);
						} else if (doStarImport && !currDecl.isOnDemand() && !allImportsAddedToStar) {
							String simpleName = currDecl.getTypeQualifiedName();
							if (simpleName.indexOf('.') != -1) {
								String str= getNewImportString(currDecl.getElementName(), isStatic, lineDelim);
								if (stringsToInsert.indexOf(str) == -1) {
									stringsToInsert.add(str);
								}
							}
						}
					} else if (!doStarImport || currDecl.isOnDemand() || onDemandConflicts == null || onDemandConflicts.contains(currDecl.getSimpleName())) {
						int offset= region.getOffset();
						IRegion rangeBefore = currDecl.getPrecedingCommentRange();
						if (rangeBefore != null && currPos > rangeBefore.getOffset()) {
							// moved ahead of the leading comments, bring the currPos back
							currPos = rangeBefore.getOffset();
						}
						if (rangeBefore != null) {
							stringsToInsert.add(buffer.getText(rangeBefore.getOffset(), rangeBefore.getLength()));
						}
						removeAndInsertNew(buffer, currPos, offset, stringsToInsert, resEdit);
						stringsToInsert.clear();
						currPos= offset + region.getLength();
					} else if (doStarImport && !currDecl.isOnDemand()) {
						String simpleName = currDecl.getTypeQualifiedName();
						if (simpleName.indexOf('.') != -1) {
							IRegion rangeBefore = currDecl.getPrecedingCommentRange();
							if (rangeBefore != null && currPos > rangeBefore.getOffset()) {
								// moved ahead of the leading comments, bring the currPos back
								currPos = rangeBefore.getOffset();
							}
							if (rangeBefore != null) {
								stringsToInsert.add(buffer.getText(rangeBefore.getOffset(), rangeBefore.getLength()));
							}
							IRegion rangeAfter = currDecl.getTrailingCommentRange();
							String trailingComment = null;
							if (rangeAfter != null) {
								trailingComment = buffer.getText(rangeAfter.getOffset(), rangeAfter.getLength());
							}
							String str= getNewImportString(currDecl.getElementName(), isStatic, trailingComment, lineDelim);
							if (stringsToInsert.indexOf(str) == -1) {
								stringsToInsert.add(str);
							}
						}
					}
				}
			}

			// insert back all existing imports comments since existing imports were not preserved
			if (this.preserveExistingCommentsRanges != null) {
				for (int i = 0, max = this.preserveExistingCommentsRanges.length; (i < max && this.preserveExistingCommentsRanges[i] != null); i++) {
					IRegion region = this.preserveExistingCommentsRanges[i];
					String text = buffer.getText(region.getOffset(), region.getLength());
					// remove preceding whitespaces
					int index = 0;
					int length = text.length();
					loop: while (index < length) {
						if (Character.isWhitespace(text.charAt(index))) {
							index++;
						} else {
							break loop;
						}
					}
					if (index != 0) {
						text = text.substring(index);
					}
					if (!text.endsWith(lineDelim)) {
						text += lineDelim;
					}
					stringsToInsert.add(text);
				}
			}
			int end= importsStart + importsLen;
			removeAndInsertNew(buffer, currPos, end, stringsToInsert, resEdit);

			if (importsLen == 0) {
				if (!this.importsCreated.isEmpty() || !this.staticImportsCreated.isEmpty()) { // new import container
					if ((this.flags & F_NEEDS_TRAILING_DELIM) != 0) {
						resEdit.addChild(new InsertEdit(currPos, lineDelim));
					}
				} else {
					return new MultiTextEdit(); // no changes
				}
			}
			return resEdit;
		} finally {
			monitor.done();
		}
	}

