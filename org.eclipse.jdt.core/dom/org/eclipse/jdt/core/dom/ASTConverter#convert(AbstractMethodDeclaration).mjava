	public MethodDeclaration convert(AbstractMethodDeclaration methodDeclaration) {
		MethodDeclaration methodDecl = this.ast.newMethodDeclaration();
		/**
		 * http://dev.eclipse.org/bugs/show_bug.cgi?id=13233
		 * This handles cases where the parser built nodes with invalid modifiers.
		 */
		try {
			methodDecl.setModifiers(methodDeclaration.modifiers & org.eclipse.jdt.internal.compiler.lookup.CompilerModifiers.AccJustFlag);
		} catch(IllegalArgumentException e) {
			int legalModifiers =
				Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED
				| Modifier.STATIC | Modifier.FINAL | Modifier.SYNCHRONIZED
				| Modifier.NATIVE | Modifier.ABSTRACT | Modifier.STRICTFP;
			methodDecl.setModifiers(methodDeclaration.modifiers & legalModifiers);
			methodDecl.setFlags(ASTNode.MALFORMED);
		}
		boolean isConstructor = methodDeclaration.isConstructor();
		methodDecl.setConstructor(isConstructor);
		SimpleName methodName = this.ast.newSimpleName(new String(methodDeclaration.selector));
		int start = methodDeclaration.sourceStart;
		int end = retrieveIdentifierEndPosition(start, methodDeclaration.sourceEnd);
		methodName.setSourceRange(start, end - start + 1);
		methodDecl.setName(methodName);
		TypeReference[] thrownExceptions = methodDeclaration.thrownExceptions;
		if (thrownExceptions != null) {
			int thrownExceptionsLength = thrownExceptions.length;
			for (int i = 0; i < thrownExceptionsLength; i++) {
				methodDecl.thrownExceptions().add(convert(thrownExceptions[i]));
			}
		}
		Argument[] parameters = methodDeclaration.arguments;
		if (parameters != null) {
			int parametersLength = parameters.length;
			for (int i = 0; i < parametersLength; i++) {
				methodDecl.parameters().add(convert(parameters[i]));
			}
		}
		ExplicitConstructorCall explicitConstructorCall = null;
		if (isConstructor) {
			// set the return type to VOID
			methodDecl.setReturnType(this.ast.newPrimitiveType(PrimitiveType.VOID));
			ConstructorDeclaration constructorDeclaration = (ConstructorDeclaration) methodDeclaration;
			explicitConstructorCall = constructorDeclaration.constructorCall;
		} else {
			org.eclipse.jdt.internal.compiler.ast.MethodDeclaration method = (org.eclipse.jdt.internal.compiler.ast.MethodDeclaration) methodDeclaration;
			TypeReference typeReference = method.returnType;
			if (typeReference != null) {
				methodDecl.setReturnType(convertType(typeReference));
			}
		}
		int declarationSourceStart = methodDeclaration.declarationSourceStart;
		int declarationSourceEnd = methodDeclaration.bodyEnd;
		methodDecl.setSourceRange(declarationSourceStart, declarationSourceEnd - declarationSourceStart + 1);
		retrieveRightBraceOrSemiColonPosition(methodDecl);
		
		org.eclipse.jdt.internal.compiler.ast.Statement[] statements = methodDeclaration.statements;
		
		if (statements != null || explicitConstructorCall != null) {
			Block block = this.ast.newBlock();
			start = retrieveStartBlockPosition(methodDeclaration.sourceStart, declarationSourceEnd);
			end = retrieveEndBlockPosition(methodDeclaration.sourceStart, this.compilationUnitSource.length);
			block.setSourceRange(start, end - start + 1);
			if (explicitConstructorCall != null) {
				block.statements().add(convert(explicitConstructorCall));
			}
			int statementsLength = statements == null ? 0 : statements.length;
			for (int i = 0; i < statementsLength; i++) {
				if (statements[i] instanceof LocalDeclaration) {
					checkAndAddMultipleLocalDeclaration(statements, i, block.statements());
				} else {
					block.statements().add(convert(statements[i]));
				}
			}
			methodDecl.setBody(block);
		} else if (!methodDeclaration.isNative() && !methodDeclaration.isAbstract()) {
			start = retrieveStartBlockPosition(methodDeclaration.sourceStart, declarationSourceEnd);
			end = retrieveEndBlockPosition(methodDeclaration.sourceStart, this.compilationUnitSource.length);
			if (start != -1 && end != -1) {
				/*
				 * start or end can be equal to -1 if we have an interface's method.
				 */
				Block block = this.ast.newBlock();
				block.setSourceRange(start, end - start + 1);
				methodDecl.setBody(block);
			}
		}
		setJavaDocComment(methodDecl);
		if (this.resolveBindings) {
			recordNodes(methodDecl, methodDeclaration);
			methodDecl.resolveBinding();
		}
		return methodDecl;
	}	

