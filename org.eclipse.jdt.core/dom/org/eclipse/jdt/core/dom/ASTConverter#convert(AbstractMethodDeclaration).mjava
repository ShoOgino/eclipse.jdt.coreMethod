	public MethodDeclaration convert(AbstractMethodDeclaration methodDeclaration) {
		MethodDeclaration methodDecl = this.ast.newMethodDeclaration();
		if (this.resolveBindings) {
			recordNodes(methodDecl, methodDeclaration);
			methodDecl.resolveBinding();
		}
		methodDecl.setModifiers(methodDeclaration.modifiers & org.eclipse.jdt.internal.compiler.lookup.CompilerModifiers.AccJustFlag);
		boolean isConstructor = methodDeclaration.isConstructor();
		methodDecl.setConstructor(isConstructor);
		SimpleName methodName = this.ast.newSimpleName(new String(methodDeclaration.selector));
		methodName.setSourceRange(methodDeclaration.sourceStart, methodDeclaration.sourceEnd - methodDeclaration.sourceStart + 1);
		methodDecl.setName(methodName);
		TypeReference[] thrownExceptions = methodDeclaration.thrownExceptions;
		if (thrownExceptions != null) {
			int thrownExceptionsLength = thrownExceptions.length;
			for (int i = 0; i < thrownExceptionsLength; i++) {
				methodDecl.thrownExceptions().add(convert(thrownExceptions[i]));
			}
		}
		Argument[] parameters = methodDeclaration.arguments;
		if (parameters != null) {
			int parametersLength = parameters.length;
			for (int i = 0; i < parametersLength; i++) {
				methodDecl.parameters().add(convert(parameters[i]));
			}
		}
		if (isConstructor) {
			// set the return type to VOID
			methodDecl.setReturnType(this.ast.newPrimitiveType(PrimitiveType.VOID));
		} else {
			org.eclipse.jdt.internal.compiler.ast.MethodDeclaration method = (org.eclipse.jdt.internal.compiler.ast.MethodDeclaration) methodDeclaration;
			TypeReference typeReference = method.returnType;
			if (typeReference != null) {
				methodDecl.setReturnType(convertType(typeReference));
			}
		}
		int declarationSourceStart = methodDeclaration.declarationSourceStart;
		int declarationSourceEnd = methodDeclaration.bodyEnd;
		methodDecl.setSourceRange(declarationSourceStart, declarationSourceEnd - declarationSourceStart + 1);
		retrieveRightBraceOrSemiColonPosition(methodDecl);
		
		org.eclipse.jdt.internal.compiler.ast.Statement[] statements = methodDeclaration.statements;
		if (statements != null) {
			Block block = this.ast.newBlock();
			int start = retrieveStartBlockPosition(methodDeclaration.sourceStart, declarationSourceEnd);
			int end = retrieveEndBlockPosition(methodDeclaration.sourceStart, this.compilationUnitSource.length);
			block.setSourceRange(start, end - start + 1);
			int statementsLength = statements.length;
			for (int i = 0; i < statementsLength; i++) {
				if (statements[i] instanceof LocalDeclaration) {
					checkAndAddMultipleLocalDeclaration(statements, i, block.statements());
				} else {
					block.statements().add(convert(statements[i]));
				}
			}
			methodDecl.setBody(block);
		} else if (!methodDeclaration.isNative() && !methodDeclaration.isAbstract()) {
			int start = retrieveStartBlockPosition(methodDeclaration.sourceStart, declarationSourceEnd);
			int end = retrieveEndBlockPosition(methodDeclaration.sourceStart, this.compilationUnitSource.length);
			if (start != -1 && end != -1) {
				/*
				 * start or end can be equal to -1 if we have an interface's method.
				 */
				Block block = this.ast.newBlock();
				block.setSourceRange(start, end - start + 1);
				methodDecl.setBody(block);
			}
		}
		setJavaDocComment(methodDecl);
		return methodDecl;
	}	

