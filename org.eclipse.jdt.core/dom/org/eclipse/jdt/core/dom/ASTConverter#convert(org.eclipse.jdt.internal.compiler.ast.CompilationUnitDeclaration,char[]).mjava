	public CompilationUnit convert(org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration unit, char[] source) {
		this.compilationUnitSource = source;
		this.scanner.setSource(source);
		this.scanner.lineEnds = unit.compilationResult().lineSeparatorPositions;
		CompilationUnit compilationUnit = this.ast.newCompilationUnit();
		// handle the package declaration immediately
		// There is no node corresponding to the package declaration
		if (this.resolveBindings) {
			recordNodes(compilationUnit, unit);
		}
		if (unit.currentPackage != null) {
			PackageDeclaration packageDeclaration = convertPackage(unit);
			compilationUnit.setPackage(packageDeclaration);
		}
		org.eclipse.jdt.internal.compiler.ast.ImportReference[] imports = unit.imports;
		if (imports != null) {
			int importLength = imports.length;
			for (int i = 0; i < importLength; i++) {
				compilationUnit.imports().add(convertImport(imports[i]));
			}
		}
		// Parse comments
		int[][] comments = unit.comments;
		if (comments != null && this.insideComments) {
			// Build comment table
			this.commentsTable = new Comment[comments.length];
			int nbr = 0;
			for (int i = 0; i < comments.length; i++) {
				Comment comment = createComment(comments[i]);
				if (comment != null) {
					comment.setAlternateRoot(compilationUnit);
					this.commentsTable[nbr++] = comment;
				}
			}
			// Resize table if  necessary
			if (nbr<comments.length) {
				Comment[] newCommentsTable = new Comment[nbr];
				System.arraycopy(this.commentsTable, 0, newCommentsTable, 0, nbr);
				this.commentsTable = newCommentsTable;
			}
			compilationUnit.setCommentTable(this.commentsTable);
		}

		org.eclipse.jdt.internal.compiler.ast.TypeDeclaration[] types = unit.types;
		if (types != null) {
			int typesLength = types.length;
			for (int i = 0; i < typesLength; i++) {
				compilationUnit.types().add(convert(types[i]));
			}
		}
		compilationUnit.setSourceRange(unit.sourceStart, unit.sourceEnd - unit.sourceStart  + 1);
		
		int problemLength = unit.compilationResult.problemCount;
		if (problemLength != 0) {
			IProblem[] resizedProblems = null;
			final IProblem[] problems = unit.compilationResult.problems;
			if (problems.length == problemLength) {
				resizedProblems = problems;
			} else {
				System.arraycopy(problems, 0, (resizedProblems = new IProblem[problemLength]), 0, problemLength);
			}
			propagateErrors(compilationUnit, resizedProblems);
			compilationUnit.setProblems(resizedProblems);
		}
		if (this.resolveBindings) {
			lookupForScopes();
		}
		return compilationUnit;
	}

