	private void resolve(ICompilationUnit[] compilationUnits, String[] bindingKeys, ASTRequestor astRequestor, int apiLevel, Map compilerOptions, WorkingCopyOwner owner) {
	
		// temporararily connect ourselves to the ASTResolver - must disconnect when done
		astRequestor.compilationUnitResolver = this;
		this.bindingTables = new DefaultBindingResolver.BindingTables();
		CompilationUnitDeclaration unit = null;
		int i = 0;
		try {
			int length = compilationUnits.length;
			org.eclipse.jdt.internal.compiler.env.ICompilationUnit[] sourceUnits = new org.eclipse.jdt.internal.compiler.env.ICompilationUnit[length];
			System.arraycopy(compilationUnits, 0, sourceUnits, 0, length);
			beginToCompile(sourceUnits, bindingKeys);
			// process all units (some more could be injected in the loop by the lookup environment)
			for (; i < this.totalUnits; i++) {
				if (this.requestedSources.size() == 0 && this.requestedKeys.size() == 0) {
					// no need to keep resolving if no more ASTs and no more binding keys are needed
					// see https://bugs.eclipse.org/bugs/show_bug.cgi?id=114935
					// cleanup remaining units
					for (; i < this.totalUnits; i++) {
						this.unitsToProcess[i].cleanUp();
						this.unitsToProcess[i] = null;
					}
					break;
				}
				unit = this.unitsToProcess[i];
				try {
					super.process(unit, i); // this.process(...) is optimized to not process already known units

					// requested AST
					char[] fileName = unit.compilationResult.getFileName();					
					ICompilationUnit source = (ICompilationUnit) this.requestedSources.get(fileName);
					if (source != null) {
						// convert AST
						CompilationResult compilationResult = unit.compilationResult;
						org.eclipse.jdt.internal.compiler.env.ICompilationUnit sourceUnit = compilationResult.compilationUnit;
						char[] contents = sourceUnit.getContents();
						AST ast = AST.newAST(apiLevel);
						ast.setDefaultNodeFlag(ASTNode.ORIGINAL);
						ASTConverter converter = new ASTConverter(compilerOptions, true/*need to resolve bindings*/, this.monitor);
						BindingResolver resolver = new DefaultBindingResolver(unit.scope, owner, this.bindingTables);
						ast.setBindingResolver(resolver);
						converter.setAST(ast);
						CompilationUnit compilationUnit = converter.convert(unit, contents);
						compilationUnit.setJavaElement(source);
						compilationUnit.setLineEndTable(compilationResult.getLineSeparatorPositions());
						ast.setDefaultNodeFlag(0);
						ast.setOriginalModificationCount(ast.modificationCount());
						
						// pass it to requestor
						astRequestor.acceptAST(source, compilationUnit);
						
						worked(1);
					} 
					
					// requested binding
					Object key = this.requestedKeys.get(fileName);
					if (key instanceof BindingKeyResolver) {
						reportBinding(key, astRequestor, owner, unit);
						worked(1);
					} else if (key instanceof ArrayList) {
						Iterator iterator = ((ArrayList) key).iterator();
						while (iterator.hasNext()) {
							reportBinding(iterator.next(), astRequestor, owner, unit);
							worked(1);
						}
					}
					
					// remove at the end so that we don't resolve twice if a source and a key for the same file name have been requested
					this.requestedSources.removeKey(fileName);
					this.requestedKeys.removeKey(fileName);
						
/*	Code used to fault in types and resolve which is no longer necessary as all questions asked to forward references are
 * lazily resolved.
 * Code used to be:
					if (this.requestedKeys.containsKey(fileName) || this.requestedSources.containsKey(fileName)) {
					   ...
					} else {

						if (unit.scope != null)
							unit.scope.faultInTypes();// still force resolution of signatures, so clients can query DOM AST
				
						// the following ensures that all type, method and field bindings are correctly initialized
						// as they may be needed by further units
						// (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=111822)
						unit.resolve();
						
						// note that if this has a performance penalty on clients, the above code should be removed
						// the following patch would workaround bug 111822:

Index: FieldReference.java
===================================================================
RCS file: /cvsroot/eclipse/org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/FieldReference.java,v
retrieving revision 1.87
diff -u -r1.87 FieldReference.java
--- FieldReference.java	24 Sep 2005 15:23:46 -0000	1.87
+++ FieldReference.java	7 Oct 2005 13:46:12 -0000
@@ -407,7 +407,14 @@
 
 		FieldBinding originalField = binding.original();
 		SourceTypeBinding sourceType = (SourceTypeBinding) originalField.declaringClass;
-		TypeDeclaration typeDecl = sourceType.scope.referenceContext;
+		ClassScope classScope = sourceType.scope;
+		if (classScope == null) {
+			// Non compiler clients may not have resolved enough of the unit when processing it, and
+			// scopes got cleaned. Assuming these clients thus do not care about constant info, will simply
+			// pretend it is not a constant.
+			return NotAConstant;
+		}
+		TypeDeclaration typeDecl = classScope.referenceContext;
 		FieldDeclaration fieldDecl = typeDecl.declarationOf(originalField);
 
 		fieldDecl.resolve(originalField.isStatic() //side effect on binding 
*/					
				} finally {
					// cleanup compilation unit result
					unit.cleanUp();
				}
				this.unitsToProcess[i] = null; // release reference to processed unit declaration
				this.requestor.acceptResult(unit.compilationResult.tagAsAccepted());
			}
			
			// remaining binding keys
			DefaultBindingResolver resolver = new DefaultBindingResolver(this.lookupEnvironment, owner, this.bindingTables);
			Object[] keys = this.requestedKeys.valueTable;
			for (int j = 0, keysLength = keys.length; j < keysLength; j++) {
				BindingKeyResolver keyResolver = (BindingKeyResolver) keys[j];
				if (keyResolver == null) continue;
				Binding compilerBinding = keyResolver.getCompilerBinding();
				IBinding binding = compilerBinding == null ? null : resolver.getBinding(compilerBinding);
				// pass it to requestor
				astRequestor.acceptBinding(((BindingKeyResolver) this.requestedKeys.valueTable[j]).getKey(), binding);
				worked(1);
			}
		} catch (OperationCanceledException e) {
			throw e;
		} catch (AbortCompilation e) {
			this.handleInternalException(e, unit);
		} catch (Error e) {
			this.handleInternalException(e, unit, null);
			throw e; // rethrow
		} catch (RuntimeException e) {
			this.handleInternalException(e, unit, null);
			throw e; // rethrow
		} finally {
			// disconnect ourselves from ast requestor
            astRequestor.compilationUnitResolver = null;
		}
	}

