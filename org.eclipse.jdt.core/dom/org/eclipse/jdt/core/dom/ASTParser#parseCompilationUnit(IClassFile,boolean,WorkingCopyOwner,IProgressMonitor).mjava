	/**
	 * Parses the source string corresponding to the given Java class file
	 * element and creates and returns a corresponding abstract syntax tree.
	 * The source string is obtained from the Java model element using
	 * <code>IClassFile.getSource()</code>, and is only available for a class
	 * files with attached source.
	 * In all other respects, this method works the same as
	 * {@link #parseCompilationUnit(ICompilationUnit,boolean,WorkingCopyOwner,IProgressMonitor)
	 * parseCompilationUnit(ICompilationUnit,boolean,WorkingCopyOwner,IProgressMonitor)}.
	 * <p>
	 * Note that the compiler options that affect doc comment checking may also
	 * affect whether any bindings are resolved for nodes within doc comments.
	 * </p>
	 * 
	 * @param classFile the Java model class file whose corresponding source code is to be parsed
	 * @param resolveBindings <code>true</code> if bindings are wanted, 
	 *   and <code>false</code> if bindings are not of interest
	 * @param owner the owner of working copies that take precedence over underlying 
	 *   compilation units, or <code>null</code> if the primary owner should be used
	 * @param monitor the progress monitor used to report progress and request cancelation,
	 *   or <code>null</code> if none
	 * @return the compilation unit node
	 * @exception IllegalArgumentException if the given Java element does not 
	 * exist or if its source string cannot be obtained
	 * @see ASTNode#getFlags()
	 * @see ASTNode#MALFORMED
	 * @see ASTNode#getStartPosition()
	 * @see ASTNode#getLength()
	 * @see WorkingCopyOwner
	 */
	private static CompilationUnit parseCompilationUnit(
		IClassFile classFile,
		boolean resolveBindings,
		WorkingCopyOwner owner,
		IProgressMonitor monitor) {
			
		if (classFile == null) {
			throw new IllegalArgumentException();
		}
		if (owner == null) {
			owner = DefaultWorkingCopyOwner.PRIMARY;
		}
		char[] source = null;
		String sourceString = null;
		try {
			sourceString = classFile.getSource();
		} catch (JavaModelException e) {
			throw new IllegalArgumentException();
		}
		if (sourceString == null) {
			throw new IllegalArgumentException();
		}
		source = sourceString.toCharArray();
		if (!resolveBindings) {
			return parseCompilationUnit(source);
		}
		StringBuffer buffer = new StringBuffer(SuffixConstants.SUFFIX_STRING_java);
		
		String classFileName = classFile.getElementName(); // this includes the trailing .class
		buffer.insert(0, classFileName.toCharArray(), 0, classFileName.indexOf('.'));
		IJavaProject project = classFile.getJavaProject();
		CompilationUnitDeclaration compilationUnitDeclaration = null;
		try {
			// parse and resolve
			compilationUnitDeclaration =
				CompilationUnitResolver.resolve(
					source,
					CharOperation.splitOn('.', classFile.getType().getPackageFragment().getElementName().toCharArray()),
					buffer.toString(),
					project,
					null/*no node searcher*/,
					false/*don't cleanup*/,
					owner,
					monitor);
			ASTConverter converter = new ASTConverter(project.getOptions(true), true, monitor);
			AST ast = AST.newAST2();
			BindingResolver resolver = new DefaultBindingResolver(compilationUnitDeclaration.scope);
			ast.setBindingResolver(resolver);
			converter.setAST(ast);
		
			CompilationUnit cu = converter.convert(compilationUnitDeclaration, source);
			cu.setLineEndTable(compilationUnitDeclaration.compilationResult.lineSeparatorPositions);
			resolver.storeModificationCount(ast.modificationCount());
			return cu;
		} catch(JavaModelException e) {
			/* if a JavaModelException is thrown trying to retrieve the name environment
			 * then we simply do a parsing without creating bindings.
			 * Therefore all binding resolution will return null.
			 */
			return parseCompilationUnit(source);			
		} finally {
			if (compilationUnitDeclaration != null) {
				compilationUnitDeclaration.cleanUp();
			}
		}
	}

