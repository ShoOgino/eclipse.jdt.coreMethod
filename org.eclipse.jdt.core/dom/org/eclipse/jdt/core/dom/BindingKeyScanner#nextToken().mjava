	int nextToken() {
		this.start = this.token == ARRAY ? this.index : ++this.index;
		int previousTokenEnd = this.index-1;
		int length = this.source.length;
		while (this.index <= length) {
			char currentChar = this.index == length ? Character.MIN_VALUE : this.source[this.index];
			switch (currentChar) {
				case 'B':
				case 'C':
				case 'D':
				case 'F':
				case 'I':
				case 'J':
				case 'S':
				case 'V':
				case 'Z':
					// base type
					if (this.start == previousTokenEnd+1) {
						this.index++;
						this.token = TYPE;
						return this.token;
					}
					break;
				case 'L':
				case 'T':
					if (this.start == previousTokenEnd+1) {
						this.start = ++this.index;
					}
					break;
				case ';':
				case '$':
					this.token = TYPE;
					return this.token;
				case '.':
					this.start = this.index+1;
					break;
				case '[':
					while (this.index < length && this.source[this.index] == '[')
						this.index++;
					this.token = ARRAY;
					return this.token;
				case '<':
					if (this.index > this.start && this.source[this.start-1] == '.')
						if (this.source[this.start-2] == '>')
							this.token = TYPE;
						else
							this.token = METHOD;
					else
						this.token = TYPE;
					return this.token;
				case '(':
					this.token = METHOD;
					return this.token;
				case ')':
					this.start = ++this.index;
					this.token = END;
					return this.token;
				case ':':
					this.token = TYPE_PARAMETER;
					return this.token;
				case Character.MIN_VALUE:
					switch (this.token) {
						case START:
							this.token = PACKAGE;
							break;
						case TYPE:
							if (this.index > this.start && this.source[this.start-1] == '.')
								this.token = FIELD;
							else
								this.token = END;
							break;
						default:
							this.token = END;
							break;
					}
					return this.token;
			}
			this.index++;
		}
		this.token = END;
		return this.token;
	}

