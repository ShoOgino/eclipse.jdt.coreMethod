	int nextToken() {
		this.start = ++this.index;
		int length = this.source.length;
		while (this.index <= length) {
			char currentChar = this.index == length ? Character.MIN_VALUE : this.source[this.index];
			switch (currentChar) {
				case '/':
				case ',':
				case Character.MIN_VALUE:
					switch (this.token) {
						case START:
						case METHOD: // parameter
						case ARRAY:
							this.token = PACKAGE;
							break;
						case PACKAGE:
							if (this.source[this.start-1] == ',')
								this.token = PACKAGE;
							else
								this.token = TYPE;
							break;
						case TYPE:
							switch (this.source[this.start-1]) {
								case '$':
									this.token = TYPE;
									break;
								case ',':
								case '<':
								case '&':
									this.token = PACKAGE;
									break;
								default:
									this.token = FIELD;
							}
							break;
						case TYPE_PARAMETER:
							this.token = PACKAGE;
							break;
					}
					return this.token;
				case '$':
				case '[':
				case '<':
				case '&':
					switch (this.token) {
						case START: // case of base type with array dimension
							this.token = PACKAGE;
							break;
						case PACKAGE:
							this.token = TYPE;
							break;
						case TYPE:
							this.token = TYPE;
							break;
					}
					return this.token;
				case '(':
					this.token = METHOD;
					return this.token;
				case ')':
				case '>':
					this.start = ++this.index;
					if (this.index == length || this.source[this.index] != '$') {
						this.token = END;
						return this.token;
					} else {
						this.start = ++this.index;
					}
					break;
				case ']':
					this.start--;
					this.index++;
					while (this.index < length && this.source[this.index] == '[') {
						this.index +=2;
					}
					this.token = ARRAY;
					return this.token;
				case ':':
					this.token = TYPE_PARAMETER;
					return this.token;
			}
			this.index++;
		}
		this.token = END;
		return this.token;
	}

