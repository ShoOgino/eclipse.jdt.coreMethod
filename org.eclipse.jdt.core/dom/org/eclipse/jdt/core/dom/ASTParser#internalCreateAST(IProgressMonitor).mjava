	private ASTNode internalCreateAST(IProgressMonitor monitor) {
		boolean needToResolveBindings = this.resolveBindings;
		switch(this.astKind) {
			case K_CLASS_BODY_DECLARATIONS :
			case K_EXPRESSION :
			case K_STATEMENTS :
				if (this.rawSource != null) {
					if (this.sourceOffset + this.sourceLength > this.rawSource.length) {
					    throw new IllegalStateException();
					}
					return internalCreateASTForKind();
				}
				break;
			case K_COMPILATION_UNIT :
				CompilationUnitDeclaration compilationUnitDeclaration = null;
				try {
					NodeSearcher searcher = null;
					org.eclipse.jdt.internal.compiler.env.ICompilationUnit sourceUnit = null;
					IJavaElement element = null;
					if (this.compilationUnitSource != null) {
						sourceUnit = (org.eclipse.jdt.internal.compiler.env.ICompilationUnit) this.compilationUnitSource;
						// use a BasicCompilation that caches the source instead of using the compilationUnitSource directly 
						// (if it is a working copy, the source can change between the parse and the AST convertion)
						// (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=75632)
						sourceUnit = new BasicCompilationUnit(sourceUnit.getContents(), sourceUnit.getPackageName(), new String(sourceUnit.getFileName()), this.project);
						element = this.compilationUnitSource;
					} else if (this.classFileSource != null) {
						try {
							String sourceString = this.classFileSource.getSource();
							if (sourceString == null) {
								throw new IllegalStateException();
							}
							PackageFragment packageFragment = (PackageFragment) this.classFileSource.getParent();
							BinaryType type = (BinaryType) this.classFileSource.getType();
							IBinaryType binaryType = (IBinaryType) type.getElementInfo();
							// file name is used to recreate the Java element, so it has to be the toplevel .class file name
							char[] fileName = binaryType.getFileName();
							int firstDollar = CharOperation.indexOf('$', fileName);
							if (firstDollar != -1) {
								char[] suffix = SuffixConstants.SUFFIX_class;
								int suffixLength = suffix.length;
								char[] newFileName = new char[firstDollar + suffixLength];
								System.arraycopy(fileName, 0, newFileName, 0, firstDollar);
								System.arraycopy(suffix, 0, newFileName, firstDollar, suffixLength);
								fileName = newFileName;
							}
							sourceUnit = new BasicCompilationUnit(sourceString.toCharArray(), Util.toCharArrays(packageFragment.names), new String(fileName), this.project);
							element = this.classFileSource;
						} catch(JavaModelException e) {
							// an error occured accessing the java element
							throw new IllegalStateException();
						}
					} else if (this.rawSource != null) {
						needToResolveBindings = this.unitName != null && this.project != null && this.compilerOptions != null;
						sourceUnit = new BasicCompilationUnit(this.rawSource, null, this.unitName == null ? "" : this.unitName, this.project); //$NON-NLS-1$
					} else {
						throw new IllegalStateException();
					}
					if (this.partial) {
						searcher = new NodeSearcher(this.focalPointPosition);
					}
					if (needToResolveBindings && this.project != null) {
						try {
							// parse and resolve
							compilationUnitDeclaration = 
								CompilationUnitResolver.resolve(
									sourceUnit,
									this.project,
									searcher,
									this.compilerOptions,
									this.workingCopyOwner,
									monitor);
						} catch (JavaModelException e) {
							compilationUnitDeclaration = CompilationUnitResolver.parse(
									sourceUnit,
									searcher,
									this.compilerOptions);
							needToResolveBindings = false;
						}
					} else {
						compilationUnitDeclaration = CompilationUnitResolver.parse(
								sourceUnit,
								searcher,
								this.compilerOptions);
						needToResolveBindings = false;
					}
					CompilationUnit result = CompilationUnitResolver.convert(
						compilationUnitDeclaration, 
						sourceUnit.getContents(),
						this.apiLevel, 
						this.compilerOptions,
						needToResolveBindings,
						this.compilationUnitSource == null ? this.workingCopyOwner : this.compilationUnitSource.getOwner(),
						needToResolveBindings ? new DefaultBindingResolver.BindingTables() : null, 
						monitor);
					result.setJavaElement(element);
					return result;
				} finally {
					if (compilationUnitDeclaration != null && this.resolveBindings) {
						compilationUnitDeclaration.cleanUp();
					}
				}					
		}
		throw new IllegalStateException();
	}

