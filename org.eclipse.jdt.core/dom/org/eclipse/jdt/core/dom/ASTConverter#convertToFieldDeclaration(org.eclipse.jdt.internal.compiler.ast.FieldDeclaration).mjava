	private FieldDeclaration convertToFieldDeclaration(org.eclipse.jdt.internal.compiler.ast.FieldDeclaration fieldDecl) {
		VariableDeclarationFragment variableDeclarationFragment = convertToVariableDeclarationFragment(fieldDecl);
		FieldDeclaration fieldDeclaration = this.ast.newFieldDeclaration(variableDeclarationFragment);
		if (this.resolveBindings) {
			recordNodes(variableDeclarationFragment, fieldDecl);
			variableDeclarationFragment.resolveBinding();
		}
		fieldDeclaration.setSourceRange(fieldDecl.declarationSourceStart, fieldDecl.declarationEnd - fieldDecl.declarationSourceStart + 1);
		Type type = convertType(fieldDecl.type);
		setTypeForField(fieldDeclaration, type, variableDeclarationFragment.getExtraDimensions());
		/**
		 * http://dev.eclipse.org/bugs/show_bug.cgi?id=13233
		 * This handles cases where the parser built nodes with invalid modifiers.
		 */
		try {
			fieldDeclaration.setModifiers(fieldDecl.modifiers & org.eclipse.jdt.internal.compiler.lookup.CompilerModifiers.AccJustFlag);
		} catch(IllegalArgumentException e) {
			int legalModifiers = 
				Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED
				| Modifier.STATIC | Modifier.FINAL | Modifier.VOLATILE
				| Modifier.TRANSIENT;
			fieldDeclaration.setModifiers(fieldDecl.modifiers & legalModifiers);
			fieldDeclaration.setFlags(ASTNode.MALFORMED);
		}
		// The javadoc comment is now got from list store in compilation unit declaration
//		setJavaDocComment(fieldDeclaration);
//		fieldDeclaration.setJavadoc(convert(fieldDecl.javadoc));
		convert(fieldDecl.javadoc, fieldDeclaration);
		return fieldDeclaration;
	}

