	/**
	 * Parses the given source between the bounds specified by the given offset (inclusive)
	 * and the given length and creates and returns a corresponding abstract syntax tree.
	 * <p>
	 * The root node of the new AST depends on the given kind.
	 * <ul>
	 * <li>org.eclipse.jdt.core.dom.AST.K_CLASS_BODY_DECLARATIONS: The root node is an instance of
	 * <code>org.eclipse.jdt.core.dom.TypeDeclaration</code>. The type declaration itself doesn't contain any information.
	 * It is simply used to return all class body declarations inside the bodyDeclaratins() collection.</li>
	 * <li>org.eclipse.jdt.core.dom.AST.K_STATEMENTS: The root node is an instance of
	 * <code>org.eclipse.jdt.core.dom.Block</code>. The block itself doesn't contain any information.
	 * It is simply used to return all the statements.</li>
	 * <li>org.eclipse.jdt.core.dom.AST.K_EXPRESSION: The root node is an instance of a subclass of
	 * <code>org.eclipse.jdt.core.dom.Expression</code>.</li>
	 * </ul>
	 * </p>
	 * 
	 * <p>Each node in the subtree carries source range(s) information relating back
	 * to positions in the given source (the given source itself
	 * is not remembered with the AST). 
	 * The source range usually begins at the first character of the first token 
	 * corresponding to the node; leading whitespace and comments are <b>not</b>
	 * included. The source range usually extends through the last character of
	 * the last token corresponding to the node; trailing whitespace and
	 * comments are <b>not</b> included. There are a handful of exceptions
	 * (including compilation units and the various body declarations); the
	 * specification for these node type spells out the details.
	 * Source ranges nest properly: the source range for a child is always
	 * within the source range of its parent, and the source ranges of sibling
	 * nodes never overlap.
	 * </p>
	 * <p>
	 * This method does not compute binding information; all <code>resolveBinding</code>
	 * methods applied to nodes of the resulting AST return <code>null</code>.
	 * </p>
	 * <p><code>null</code> is returned:
	 * <ol>
	 * <li>If a syntax error is detected while parsing</li>
	 * <li>If the given source doesn't correspond to the given kind</li>
	 * </ol>
	 * </p>
	 * 
	 * @param kind the given kind to parse
	 * @param source the string to be parsed
	 * @param offset the given offset
	 * @param length the given length
	 * @param options the given options. If null, <code>JavaCore.getOptions()</code> is used.
	 * 
	 * @return ASTNode
	 * @see ASTNode#getStartPosition()
	 * @see ASTNode#getLength()
	 * @see AST#K_CLASS_BODY_DECLARATIONS
	 * @see AST#K_EXPRESSION
	 * @see AST#K_STATEMENTS
	 * @see JavaCore#getOptions()
	 * @since 3.0
	 */
	public static ASTNode parse(int kind, char[] source, int offset, int length, Map options) {
		if (options == null) {
			options = JavaCore.getOptions();
		}
		ASTConverter converter = new ASTConverter(options, false);
		converter.compilationUnitSource = source;
		converter.scanner.setSource(source);
		
		AST ast = new AST();
		ast.setBindingResolver(new BindingResolver());
		converter.setAST(ast);
		switch(kind) {
			case K_STATEMENTS :
				ConstructorDeclaration constructorDeclaration = CodeSnippetParsingUtil.parseStatements(source, offset, length, options);
				if (constructorDeclaration != null) {
					Block block = ast.newBlock();
					Statement[] statements = constructorDeclaration.statements;
					if (statements != null) {
						int statementsLength = statements.length;
						for (int i = 0; i < statementsLength; i++) {
							block.statements().add(converter.convert(statements[i]));
						}
					}
					return block;
				}
				break;
			case K_EXPRESSION :
				org.eclipse.jdt.internal.compiler.ast.Expression expression = CodeSnippetParsingUtil.parseExpression(source, offset, length, options);
				if (expression != null) {
					return converter.convert(expression);
				}
				break;
			case K_CLASS_BODY_DECLARATIONS :
				final org.eclipse.jdt.internal.compiler.ast.ASTNode[] nodes = CodeSnippetParsingUtil.parseClassBodyDeclarations(source, offset, length, options);
				if (nodes != null) {
					return converter.convert(nodes);
				}
		}
		return null;
	}

