	/**
	 * Parses the source string corresponding to the given Java class file
	 * element and creates and returns a corresponding abstract syntax tree.
	 * The source string is obtained from the Java model element using
	 * <code>IClassFile.getSource()</code>, and is only available for a class
	 * files with attached source. 
	 * In all other respects, this method works the same as
	 * {@link #parsePartialCompilationUnit(ICompilationUnit,int,boolean,WorkingCopyOwner,IProgressMonitor)
	 * parsePartialCompilationUnit(ICompilationUnit,int,boolean,WorkingCopyOwner,IProgressMonitor)}.
	 * 
	 * @param classFile the Java model class file whose corresponding source code is to be parsed
	 * @param position a position into the corresponding body declaration
	 * @param resolveBindings <code>true</code> if bindings are wanted, 
	 *   and <code>false</code> if bindings are not of interest
	 * @param owner the owner of working copies that take precedence over underlying 
	 *   compilation units, or <code>null</code> if the primary owner should be used
	 * @param monitor the progress monitor used to report progress and request cancelation,
	 *   or <code>null</code> if none
	 * @return the abridged compilation unit node
	 * @exception IllegalArgumentException if the given Java element does not 
	 * exist or the source range is null or if its source string cannot be obtained
	 * @see ASTNode#getFlags()
	 * @see ASTNode#MALFORMED
	 * @see ASTNode#getStartPosition()
	 * @see ASTNode#getLength()
	 * @since 3.0
	 */
	public static CompilationUnit parsePartialCompilationUnit(
        IClassFile classFile,
		int position,
		boolean resolveBindings,
		WorkingCopyOwner owner,
		IProgressMonitor monitor) {
				
		if (classFile == null) {
			throw new IllegalArgumentException();
		}
		if (owner == null) {
			owner = DefaultWorkingCopyOwner.PRIMARY;
		}

		char[] source = null;
		String sourceString = null;
		try {
			sourceString = classFile.getSource();
		} catch (JavaModelException e) {
			throw new IllegalArgumentException();
		}

		if (sourceString == null) {
			throw new IllegalArgumentException();
		}
		source = sourceString.toCharArray();

		NodeSearcher searcher = new NodeSearcher(position);

		final Map options = classFile.getJavaProject().getOptions(true);
		if (resolveBindings) {
			CompilationUnitDeclaration compilationUnitDeclaration = null;
			try {
				// parse and resolve
				compilationUnitDeclaration = CompilationUnitResolver.resolve(
					classFile,
					searcher,
					false/*don't cleanup*/,
					source,
					owner,
					monitor);
				
				ASTConverter converter = new ASTConverter(options, true, monitor);
				AST ast = new AST();
				BindingResolver resolver = new DefaultBindingResolver(compilationUnitDeclaration.scope);
				ast.setBindingResolver(resolver);
				converter.setAST(ast);
			
				CompilationUnit compilationUnit = converter.convert(compilationUnitDeclaration, source);
				compilationUnit.setLineEndTable(compilationUnitDeclaration.compilationResult.lineSeparatorPositions);
				resolver.storeModificationCount(ast.modificationCount());
				return compilationUnit;
			} catch(JavaModelException e) {
				/* if a JavaModelException is thrown trying to retrieve the name environment
				 * then we simply do a parsing without creating bindings.
				 * Therefore all binding resolution will return null.
				 */
				CompilationUnitDeclaration compilationUnitDeclaration2 = CompilationUnitResolver.parse(
					source,
					searcher,
					options);
				
				ASTConverter converter = new ASTConverter(options, false, monitor);
				AST ast = new AST();
				final BindingResolver resolver = new BindingResolver();
				ast.setBindingResolver(resolver);
				converter.setAST(ast);
	
				CompilationUnit compilationUnit = converter.convert(compilationUnitDeclaration2, source);
				compilationUnit.setLineEndTable(compilationUnitDeclaration2.compilationResult.lineSeparatorPositions);
				resolver.storeModificationCount(ast.modificationCount());
				return compilationUnit;
			} finally {
				if (compilationUnitDeclaration != null) {
					compilationUnitDeclaration.cleanUp();
				}
			}
		} else {
			CompilationUnitDeclaration compilationUnitDeclaration = CompilationUnitResolver.parse(
				source,
				searcher,
				options);
			
			ASTConverter converter = new ASTConverter(options, false, monitor);
			AST ast = new AST();
			final BindingResolver resolver = new BindingResolver();
			ast.setBindingResolver(resolver);
			converter.setAST(ast);

			CompilationUnit compilationUnit = converter.convert(compilationUnitDeclaration, source);
			compilationUnit.setLineEndTable(compilationUnitDeclaration.compilationResult.lineSeparatorPositions);
			resolver.storeModificationCount(ast.modificationCount());
			return compilationUnit;
		}
	}

