	public NameEnvironmentAnswer findType(char[] typeName, char[][] packageName, boolean searchSecondaryTypes, IModuleContext context) {
		checkCanceled();
		NameEnvironmentAnswer answer = super.findType(typeName, packageName, context);
		if (answer == null && searchSecondaryTypes) {
//			NameEnvironmentAnswer suggestedAnswer = null;
			String qualifiedPackageName = new String(CharOperation.concatWith(packageName, '/'));
			String qualifiedTypeName = new String(CharOperation.concatWith(packageName, typeName, '/'));
			String qualifiedBinaryFileName = qualifiedTypeName + SUFFIX_STRING_class;
//			for (int i = 0, length = this.classpaths.length; i < length; i++) {
//				if (!(this.classpaths[i] instanceof ClasspathDirectory)) continue;
//				ClasspathDirectory classpathDirectory = (ClasspathDirectory) this.classpaths[i];
//				for (IModule iModule : modules) {
//					if (!classpathDirectory.servesModule(iModule.name())) continue;
//					answer = classpathDirectory.findSecondaryInClass(typeName, qualifiedPackageName, qualifiedBinaryFileName);
//					if (answer != null) {
//						if (!answer.ignoreIfBetter()) {
//							if (answer.isBetter(suggestedAnswer))
//								return answer;
//						} else if (answer.isBetter(suggestedAnswer))
//							// remember suggestion and keep looking
//							suggestedAnswer = answer;
//					}
//				}
//			}
			Function<ClasspathDirectory, ITypeLookup> secondaryTypesLookup = d -> {
				return (t, qPackageName, qBinaryFileName,asBinaryOnly) -> {
					return d.findSecondaryInClass(t, qPackageName, qBinaryFileName);
				};
			};
			if (IModuleContext.UNNAMED_MODULE_CONTEXT == context) {
				answer =  Stream.of(this.classpaths)
						.filter(env -> env instanceof ClasspathDirectory)
						.map(p -> (ClasspathDirectory)p)
						.map(secondaryTypesLookup)
						.reduce(ITypeLookup::chain)
						.map(t -> t.findClass(typeName, qualifiedPackageName, qualifiedBinaryFileName)).orElse(null);
			} else {
				answer = context.getEnvironment()
						.filter(env -> env instanceof ClasspathDirectory)
						.map(p -> (ClasspathDirectory)p)
						.map(secondaryTypesLookup)
						.reduce(ITypeLookup::chain)
						.map(lookup -> lookup.findClass(typeName, qualifiedPackageName, qualifiedBinaryFileName))
						.orElse(null);
			}
		}
		return answer;
	}

