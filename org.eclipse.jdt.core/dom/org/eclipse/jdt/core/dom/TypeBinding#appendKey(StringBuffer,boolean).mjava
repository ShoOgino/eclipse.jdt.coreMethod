	public void appendKey(StringBuffer buffer, boolean rawTypeOnly) {
		if (this.key != null && !rawTypeOnly) {
			buffer.append(this.key);
			return;
		}
		if (isLocal()) {
			// declaring method or type
			SourceTypeBinding sourceBinding = (SourceTypeBinding) this.binding; // per construction, a local type can only be defined in source
			ClassScope scope = sourceBinding.scope;
			ClassScope classScope = scope.enclosingClassScope();
			org.eclipse.jdt.internal.compiler.ast.TypeDeclaration referenceContext = classScope.referenceContext;
			org.eclipse.jdt.internal.compiler.lookup.TypeBinding internalBinding = referenceContext.binding;
			ITypeBinding typeBinding = this.resolver.getTypeBinding(internalBinding);
			if (typeBinding != null) {
				((TypeBinding) typeBinding).appendKey(buffer);
			}
			buffer.append('$');
			CompilationUnitScope compilationUnitScope = scope.compilationUnitScope();
			CompilationUnitDeclaration compilationUnitDeclaration = compilationUnitScope.referenceContext;
			LocalTypeBinding[] localTypeBindings = compilationUnitDeclaration.localTypes;
			for (int i = 0, max = compilationUnitDeclaration.localTypeCount; i < max; i++) {
				if (localTypeBindings[i] == sourceBinding) {
					buffer.append(i+1);
					if (!isAnonymous()) {
						buffer.append('$');
						buffer.append(sourceBinding.sourceName);
					}
					break;
				}
			}
		} else {
			if (this.binding.isTypeVariable()) {
				appendTypeVariableKey(buffer, true/*include declaring element*/);
			} else if (this.binding.isWildcard()) {
				WildcardBinding wildcardBinding = (WildcardBinding) binding;
				org.eclipse.jdt.internal.compiler.lookup.TypeBinding bound = wildcardBinding.bound;
				if (bound != null)
					((TypeBinding) this.resolver.getTypeBinding(bound)).appendKey(buffer);
				else
					buffer.append(wildcardBinding.genericTypeSignature());
			} else if (this.isClass()
					|| this.isInterface()
					|| this.isEnum()
					|| this.isAnnotation()) {
				char[] qualifiedSourceName = this.binding.qualifiedSourceName();
				if (qualifiedSourceName != null) {
					CharOperation.replace(qualifiedSourceName, '.', '$');
					buffer
						.append(getPackage().getName())
						.append('/')
						.append(qualifiedSourceName);
				} else {
					buffer
						.append(getPackage().getName())
						.append('/')
						.append(getName());
				}
				if (!rawTypeOnly) {
					// only one of the type parameters or type arguments is non-empty at the same time
					appendTypeParameters(buffer, getTypeParameters());
					appendTypeArguments(buffer, getTypeArguments());
				}
			} else if (this.binding.isArrayType()) {
				if (getElementType() != null) {
					((TypeBinding) getElementType()).appendKey(buffer);
					int dimensions = getDimensions();
					for (int j = 0; j < dimensions; j++) {
						buffer.append('[').append(']');
					}
				} else {
					int dimensions = this.getDimensions();
					for (int j = 0; j < dimensions; j++) {
						buffer.append('[').append(']');
					}
				}
			} else {
				// this is a primitive type
				buffer.append(getName());
			}
		}
	}

