	private static void rootNodeToCompilationUnit(AST ast, ASTConverter converter, ASTNode node) {
		// TODO record the comments information
		CompilationUnit compilationUnit = ast.newCompilationUnit();
		CompilationResult compilationResult = CodeSnippetParsingUtil.RecordedCompilationResult;
		final int problemsCount = compilationResult.problemCount;
		switch(node.getNodeType()) {
			case ASTNode.BLOCK :
				{
					Block block = (Block) node;
					if (problemsCount != 0) {
						// propagate and record problems
						IProblem[] resizedProblems = null;
						final IProblem[] problems = compilationResult.problems;
						if (problems.length == problemsCount) {
							resizedProblems = problems;
						} else {
							System.arraycopy(problems, 0, (resizedProblems = new IProblem[problemsCount]), 0, problemsCount);
						}
						for (int i = 0, max = block.statements().size(); i < max; i++) {
							converter.propagateErrors((ASTNode) block.statements().get(i), resizedProblems);
						}
						compilationUnit.setProblems(resizedProblems);
					}
					TypeDeclaration typeDeclaration = ast.newTypeDeclaration();
					Initializer initializer = ast.newInitializer();
					initializer.setBody(block);
					typeDeclaration.bodyDeclarations().add(initializer);
					compilationUnit.types().add(typeDeclaration);
				}
				break;
			case ASTNode.TYPE_DECLARATION :
				{
					TypeDeclaration typeDeclaration = (TypeDeclaration) node;
					if (problemsCount != 0) {
						// propagate and record problems
						IProblem[] resizedProblems = null;
						final IProblem[] problems = compilationResult.problems;
						if (problems.length == problemsCount) {
							resizedProblems = problems;
						} else {
							System.arraycopy(problems, 0, (resizedProblems = new IProblem[problemsCount]), 0, problemsCount);
						}
						for (int i = 0, max = typeDeclaration.bodyDeclarations().size(); i < max; i++) {
							converter.propagateErrors((ASTNode) typeDeclaration.bodyDeclarations().get(i), resizedProblems);
						}
						compilationUnit.setProblems(resizedProblems);
					}
					compilationUnit.types().add(typeDeclaration);
				}
				break;
			default :
				if (node instanceof Expression) {
					Expression expression = (Expression) node;
					if (problemsCount != 0) {
						// propagate and record problems
						IProblem[] resizedProblems = null;
						final IProblem[] problems = compilationResult.problems;
						if (problems.length == problemsCount) {
							resizedProblems = problems;
						} else {
							System.arraycopy(problems, 0, (resizedProblems = new IProblem[problemsCount]), 0, problemsCount);
						}
						converter.propagateErrors(expression, resizedProblems);
						compilationUnit.setProblems(resizedProblems);
					}
					ExpressionStatement expressionStatement = ast.newExpressionStatement(expression);
					Block block = ast.newBlock();
					block.statements().add(expressionStatement);
					Initializer initializer = ast.newInitializer();
					initializer.setBody(block);
					TypeDeclaration typeDeclaration = ast.newTypeDeclaration();
					typeDeclaration.bodyDeclarations().add(initializer);
					compilationUnit.types().add(typeDeclaration);
				}
		}
		compilationUnit.setLineEndTable(compilationResult.lineSeparatorPositions);
		CodeSnippetParsingUtil.reset();
	}

