	public static void resolve(
		ICompilationUnit[] compilationUnits,
		String[] bindingKeys,
		ASTRequestor requestor,
		int apiLevel,
		Map options,
		IJavaProject javaProject,
		WorkingCopyOwner owner,
		IProgressMonitor monitor) {
	
		CancelableNameEnvironment environment = null;
		CancelableProblemFactory problemFactory = null;
		SubProgressMonitor subProgressMonitor = monitor == null ? null : new SubProgressMonitor(monitor, 100); // 100% of the work is done in this method
		try {
			if (subProgressMonitor != null) subProgressMonitor.beginTask("", compilationUnits.length + bindingKeys.length); //$NON-NLS-1$
			environment = new CancelableNameEnvironment(((JavaProject) javaProject), owner, subProgressMonitor);
			problemFactory = new CancelableProblemFactory(subProgressMonitor);
			CompilationUnitResolver resolver =
				new CompilationUnitResolver(
					environment,
					getHandlingPolicy(),
					options,
					getRequestor(),
					problemFactory, 
					subProgressMonitor);

			resolver.resolve(compilationUnits, bindingKeys, requestor, apiLevel, options, owner);
			if (NameLookup.VERBOSE) {
				System.out.println(Thread.currentThread() + " TIME SPENT in NameLoopkup#seekTypesInSourcePackage: " + environment.nameLookup.timeSpentInSeekTypesInSourcePackage + "ms");  //$NON-NLS-1$ //$NON-NLS-2$
				System.out.println(Thread.currentThread() + " TIME SPENT in NameLoopkup#seekTypesInBinaryPackage: " + environment.nameLookup.timeSpentInSeekTypesInBinaryPackage + "ms");  //$NON-NLS-1$ //$NON-NLS-2$
			}
		} catch (JavaModelException e) {
			// project doesn't exist -> simple parse without resolving
			parse(compilationUnits, requestor, apiLevel, options, monitor);
		} finally {
			if (subProgressMonitor != null) subProgressMonitor.done();
			if (environment != null) {
				environment.monitor = null; // don't hold a reference to this external object
			}
			if (problemFactory != null) {
				problemFactory.monitor = null; // don't hold a reference to this external object
			}
		}
	}

