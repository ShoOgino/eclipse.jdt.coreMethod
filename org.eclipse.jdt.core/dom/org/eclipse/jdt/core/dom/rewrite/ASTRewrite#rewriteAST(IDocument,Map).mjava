	/**
	 * Converts all modifications recorded by this rewriter
	 * into an object representing the corresponding text
	 * edits to the given document containing the original source
	 * code. The document itself is not modified.
	 * <p>
	 * Calling this methods does not discard the modifications
	 * on record. Subsequence modifications are added to the ones
	 * already on record. If this method is called again later,
	 * the resulting text edit object will accurately reflect
	 * the net cumulative affect of all those changes.
	 * </p>
	 * 
	 * @param document original document containing source code
	 * @param options the table of formatter options
	 * (key type: <code>String</code>; value type: <code>String</code>);
	 * or <code>null</code> to use the standard global options
	 * {@link JavaCore#getOptions() JavaCore.getOptions()}
	 * @return text edit object describing the changes to the
	 * document corresponding to the changes recorded by this rewriter
	 * @throws IllegalArgumentException An <code>IllegalArgumentException</code>
	 * is thrown if the document passed does not correspond to the AST that is rewritten. 
	 */
	public TextEdit rewriteAST(IDocument document, Map options) throws IllegalArgumentException {
		if (document == null) {
			throw new IllegalArgumentException();
		}
		TextEdit result= new MultiTextEdit();
		
		ASTNode rootNode= getRootNode();
		if (rootNode != null) {
			validateASTNotModified(rootNode);
			
			getRewriteEventStore().markMovedNodesRemoved();

			CompilationUnit astRoot= (CompilationUnit) rootNode.getRoot();
			ASTRewriteAnalyzer visitor= new ASTRewriteAnalyzer(document, astRoot, result, this.eventStore, this.nodeStore, options);
			rootNode.accept(visitor); // throws IllegalArgumentException
		}
		return result;
	}

