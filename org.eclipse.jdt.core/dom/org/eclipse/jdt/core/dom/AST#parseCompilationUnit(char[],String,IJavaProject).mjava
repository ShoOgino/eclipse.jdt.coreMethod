	/**
	 * Parses the given string as a Java compilation unit and creates and 
	 * returns a corresponding abstract syntax tree.
	 * <p>
	 * The returned compilation unit node is the root node of a new AST.
	 * Each node in the subtree carries source range(s) information relating back
	 * to positions in the given source string (the given source string itself
	 * is not remembered with the AST). If a syntax error is detected while
	 * parsing, the relevant node(s) of the tree will be flagged as 
	 * <code>MALFORMED</code>.
	 * </p>
	 * <p>
	 * If <code>javaProject</code> is not <code>null</code>, the various names
	 * and types appearing in the compilation unit can be resolved to "bindings"
	 * by calling the <code>resolveBinding</code> methods. These bindings 
	 * draw connections between the different parts of a program, and 
	 * generally afford a more powerful vantage point for clients who wish to
	 * analyze a program's structure more deeply. These bindings come at a 
	 * considerable cost in both time and space, however, and should not be
	 * requested frivilously. The additional space is not reclaimed until the 
	 * AST, all its nodes, and all its bindings become garbage. So it is very
	 * important to not retain any of these objects longer than absolutely
	 * necessary. Note that bindings can only be resolved while the AST remains
	 * in its original unmodified state. Once the AST is modified, all 
	 * <code>resolveBinding</code> methods return <code>null</code>.
	 * If <code>javaProject</code> is <code>null</code>, the analysis 
	 * does not go beyond parsing and building the tree, and all 
	 * <code>resolveBinding</code> methods return <code>null</code> from the 
	 * outset.
	 * </p>
	 * <p>
	 * If the source defined an existing binary type or source type in the same project,
	 * the source provided will hide the existing type.
	 * </p>
	 * 
	 * @param source the string to be parsed as a Java compilation unit
	 * @param unitName the name of the compilation unit to be parsed
	 * @param javaProject the Java project used to resolve names, or 
	 *    <code>null</code> if bindings are not resolved
	 * @return the compilation unit node
	 * @see ASTNode#getFlags
	 * @see ASTNode#MALFORMED
	 * @see ASTNode#getStartPositions
	 * @see ASTNode#getLengths
	 */
	public static CompilationUnit parseCompilationUnit(
		char[] source,
		String unitName,
		IJavaProject javaProject) {
	
		CompilationUnitDeclaration compilationUnitDeclaration = null;

		if (javaProject != null) {
			// If resolveBindings is true, we need to record the mod count
			// once newAST has been constructed. If the mod count goes above
			// this level, someone is modifying the AST and all bets are off
			// regarding resolved bindings. All existing binding info should be
			// discarded, and the various public resolveBinding methods should
			// thereafter return null.
			try {
				compilationUnitDeclaration =
					CompilationUnitResolver.resolve(
						source,
						unitName,
						javaProject,
						new AbstractSyntaxTreeVisitorAdapter());
				return convert(compilationUnitDeclaration, source);
			} catch (JavaModelException e) {
			}
		} else {
			return parseCompilationUnit(source);
		}
		return null;
	}

