	/**
	 * One result of the search consists of a new type.
	 *
	 * NOTE - All package and type names are presented in their readable form:
	 *    Package names are in the form "a.b.c".
	 *    Nested type names are in the qualified form "A.I".
	 *    The default package is represented by an empty array.
	 */
	public void acceptType(
		char[] packageName,
		char[] simpleTypeName,
		char[][] enclosingTypeNames,
		int modifiers,
		AccessRestriction accessRestriction) {

		if (this.options.checkVisibility) {
			if((modifiers & IConstants.AccPublic) == 0) {
				if((modifiers & IConstants.AccPrivate) != 0) return;
				
				char[] currentPackage = CharOperation.concatWith(this.unitScope.fPackage.compoundName, '.');
				if(!CharOperation.equals(packageName, currentPackage)) return;
			}
		}
		
		int accessibility = IAccessRule.K_ACCESSIBLE;
		if(accessRestriction != null) {
			switch (accessRestriction.getProblemId()) {
				case IProblem.ForbiddenReference:
					switch (this.options.restrictedReferenceFilter) {
						case AssistOptions.FILTER_WARNING:
							return;
						case AssistOptions.FILTER_ERROR:
							if(this.forbiddenReferenceIsError) return;
							break;
						
					}
					accessibility = IAccessRule.K_NON_ACCESSIBLE;
					break;
				case IProblem.DiscouragedReference:
					switch (this.options.restrictedReferenceFilter) {
						case AssistOptions.FILTER_WARNING:
							return;
						case AssistOptions.FILTER_ERROR:
							if(this.discouragedReferenceIsError) return;
							break;
						
					}
					accessibility = IAccessRule.K_DISCOURAGED;
					break;
			}
		}
		
		if(acceptedTypes == null) {
			acceptedTypes = new ObjectVector();
		}
		acceptedTypes.add(new AcceptedType(packageName, simpleTypeName, enclosingTypeNames, modifiers, accessibility));
	}

