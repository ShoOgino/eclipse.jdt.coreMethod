	private void findTypesAndPackages(char[] token, Scope scope) {

		if (token == null)
			return;
		ObjectVector typesFound = new ObjectVector();
		
		if (scope.enclosingSourceType() != null) {
			findNestedTypes(token, scope.enclosingSourceType(), scope, typesFound);
			findTypeParameters(token, scope);
		}

		if (this.unitScope != null) {
			int typeLength = token.length;
			SourceTypeBinding[] types = this.unitScope.topLevelTypes;

			for (int i = 0, length = types.length; i < length; i++) {
				SourceTypeBinding sourceType = types[i]; 

				if (typeLength > sourceType.sourceName.length)	continue;
				
				if (!CharOperation.prefixEquals(token, sourceType.sourceName, false))	continue;
				
				this.knownTypes.put(CharOperation.concat(sourceType.qualifiedPackageName(), sourceType.sourceName(), '.'), this);

				int relevance = computeBaseRelevance();
				relevance += computeRelevanceForInterestingProposal();
				relevance += computeRelevanceForCaseMatching(token, sourceType.sourceName);
				relevance += computeRelevanceForExpectingType(sourceType);
				relevance += computeRelevanceForQualification(false);
				relevance += computeRelevanceForRestrictions(false); // no access restriction for type in the current unit

				if (sourceType.isClass()){
					relevance += computeRelevanceForClass();
					relevance += computeRelevanceForException(sourceType.sourceName);
					
					this.noProposal = false;
					if(!this.requestor.isIgnored(CompletionProposal.TYPE_REF)) {
						CompletionProposal proposal = this.createProposal(CompletionProposal.TYPE_REF, this.actualCompletionPosition);
						proposal.setDeclarationSignature(sourceType.qualifiedPackageName());
						proposal.setSignature(getSignature(sourceType));
						proposal.setPackageName(sourceType.qualifiedPackageName());
						proposal.setTypeName(sourceType.sourceName());
						proposal.setCompletion(sourceType.sourceName());
						proposal.setFlags(sourceType.modifiers);
						proposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);
						proposal.setRelevance(relevance);
						this.requestor.accept(proposal);
						if(DEBUG) {
							this.printDebug(proposal);
						}
					}
				} else {
					relevance += computeRelevanceForInterface();
					
					this.noProposal = false;
					if(!this.requestor.isIgnored(CompletionProposal.TYPE_REF)) {
						CompletionProposal proposal = this.createProposal(CompletionProposal.TYPE_REF, this.actualCompletionPosition);
						proposal.setDeclarationSignature(sourceType.qualifiedPackageName());
						proposal.setSignature(getSignature(sourceType));
						proposal.setPackageName(sourceType.qualifiedPackageName());
						proposal.setTypeName(sourceType.sourceName());
						proposal.setCompletion(sourceType.sourceName());
						proposal.setFlags(sourceType.modifiers | Flags.AccInterface);
						proposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);
						proposal.setRelevance(relevance);
						this.requestor.accept(proposal);
						if(DEBUG) {
							this.printDebug(proposal);
						}
					}
				}
			}
		}
		
		this.findTypesFromStaticImports(token, scope, typesFound);
		
		if (token.length == 0) {
			if(this.expectedTypesPtr > -1) {
				next : for (int i = 0; i <= this.expectedTypesPtr; i++) {
					if(this.expectedTypes[i] instanceof ReferenceBinding) {
						ReferenceBinding refBinding = (ReferenceBinding)this.expectedTypes[i];
						
						boolean hasRestrictedAccess = refBinding.hasRestrictedAccess();
						if(this.options.checkRestrictions && hasRestrictedAccess) continue next;
						
						boolean inSameUnit = this.unitScope.isDefinedInSameUnit(refBinding);
						
						// top level types of the current unit are already proposed.
						if(!inSameUnit || (inSameUnit && refBinding.isMemberType())) {
							char[] packageName = refBinding.qualifiedPackageName();
							char[] typeName = refBinding.sourceName();
							char[] completionName = typeName;
							
							boolean isQualified = false;
							if (!this.insideQualifiedReference && !refBinding.isMemberType()) {
								if (mustQualifyType(packageName, typeName)) {
									if (packageName == null || packageName.length == 0)
										if (this.unitScope != null && this.unitScope.fPackage.compoundName != CharOperation.NO_CHAR_CHAR)
											continue next; // ignore types from the default package from outside it
									completionName = CharOperation.concat(packageName, typeName, '.');
									isQualified = true;
								}
							}
							
							int relevance = computeBaseRelevance();
							relevance += computeRelevanceForInterestingProposal();
							relevance += computeRelevanceForCaseMatching(token, typeName);
							relevance += computeRelevanceForExpectingType(refBinding);
							relevance += computeRelevanceForQualification(isQualified);
							relevance += computeRelevanceForRestrictions(hasRestrictedAccess);
							
							if(refBinding.isClass()) {
								relevance += computeRelevanceForClass();
								
								this.noProposal = false;
								if(!this.requestor.isIgnored(CompletionProposal.TYPE_REF)) {
									CompletionProposal proposal = this.createProposal(CompletionProposal.TYPE_REF, this.actualCompletionPosition);
									proposal.setDeclarationSignature(packageName);
									proposal.setSignature(getSignature(refBinding));
									proposal.setPackageName(packageName);
									proposal.setTypeName(typeName);
									proposal.setCompletion(completionName);
									proposal.setFlags(refBinding.modifiers);
									proposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);
									proposal.setRelevance(relevance);
									this.requestor.accept(proposal);
									if(DEBUG) {
										this.printDebug(proposal);
									}
								}
							} else if (refBinding.isInterface()) {
								relevance += computeRelevanceForInterface();
								
								this.noProposal = false;
								if(!this.requestor.isIgnored(CompletionProposal.TYPE_REF)) {
									CompletionProposal proposal = this.createProposal(CompletionProposal.TYPE_REF, this.actualCompletionPosition);
									proposal.setDeclarationSignature(packageName);
									proposal.setSignature(getSignature(refBinding));
									proposal.setPackageName(packageName);
									proposal.setTypeName(typeName);
									proposal.setCompletion(completionName);
									proposal.setFlags(refBinding.modifiers | Flags.AccInterface);
									proposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);
									proposal.setRelevance(relevance);
									this.requestor.accept(proposal);
									if(DEBUG) {
										this.printDebug(proposal);
									}
								}
							}
						}
					}
				}
			} 
		} else {
			findKeywords(token, baseTypes);
			this.nameEnvironment.findTypes(token, this);
			this.nameEnvironment.findPackages(token, this);
		}
	}

