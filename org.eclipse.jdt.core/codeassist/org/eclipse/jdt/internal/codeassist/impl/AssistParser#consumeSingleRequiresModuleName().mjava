protected void consumeSingleRequiresModuleName() {

	int index = indexOfAssistIdentifier();
	/* no need to take action if not inside assist identifiers */
	if (index < 0) {
		super.consumeSingleRequiresModuleName();
		return;
	}

	/* build specific assist node on requires statement */
	ModuleReference reference = createAssistModuleReference(index);
	this.assistNode = reference;
	this.lastCheckPoint = reference.sourceEnd + 1;
	pushOnAstStack(reference);

	if (this.currentToken == TokenNameSEMICOLON){
		reference.declarationSourceEnd = this.scanner.currentPosition - 1;
	} else {
		reference.declarationSourceEnd = (int) reference.sourcePositions[reference.tokens.length-1];
	}
	//endPosition is just before the ;
	reference.declarationSourceStart = this.intStack[this.intPtr--];
	// flush comments defined prior to import statements
	reference.declarationSourceEnd = flushCommentsDefinedPriorTo(reference.declarationSourceEnd);

	reference.declarationEnd = reference.declarationSourceEnd;
	//this.endPosition is just before the ;
	reference.modifiersSourceStart = this.intStack[this.intPtr--];
//	reference.modifiers = modifiers; // already set in the constructor
	reference.declarationSourceStart = reference.sourceStart;

	if (reference.modifiersSourceStart >= 0) {
		reference.declarationSourceStart = reference.modifiersSourceStart;
	}
	// recovery TBD
	if (this.currentElement != null){
		this.lastCheckPoint = reference.declarationSourceEnd+1;
		this.currentElement = this.currentElement.add(reference, 0);
		this.lastIgnoredToken = -1;
		this.restartRecovery = true; // used to avoid branching back into the regular automaton
	}

}

