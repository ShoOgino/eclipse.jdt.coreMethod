/*
 * Reset context so as to resume to regular parse loop
 * If unable to reset for resuming, answers false.
 *
 * Move checkpoint location, reset internal stacks and
 * decide which grammar goal is activated.
 */
protected boolean resumeAfterRecovery() {

	// reset internal stacks 
	astPtr = -1;
	astLengthPtr = -1;
	expressionPtr = -1;
	expressionLengthPtr = -1;
	identifierPtr = -1;	
	identifierLengthPtr	= -1;
	intPtr = -1;
	dimensions = 0 ;
	recoveredStaticInitializerStart = 0;

	// if in diet mode, reset the diet counter because we're going to restart outside an initializer.
	if (diet) dietInt = 0;

	/* attempt to move checkpoint location */
	if (!this.moveRecoveryCheckpoint()) return false;

	// only look for headers
	if (referenceContext instanceof CompilationUnitDeclaration
		|| this.assistNode != null){
		if(isInsideMethod() &&
			isIndirectlyInsideFieldInitialization() &&		
			this.assistNode == null
			){ 
			this.prepareForBlockStatements();
			goForBlockStatementsOrCatchHeader();
		} else {
			this.prepareForHeaders();
			goForHeaders();
			diet = true; // passed this point, will not consider method bodies
		}
		return true;
	}
	if (referenceContext instanceof AbstractMethodDeclaration
		|| referenceContext instanceof TypeDeclaration){
			
		if (currentElement instanceof RecoveredType){
			this.prepareForHeaders();
			goForHeaders();
		} else {
			this.prepareForBlockStatements();
			goForBlockStatementsOrCatchHeader();
		}
		return true;
	}
	// does not know how to restart
	return false;
}

