	/*
	 * Reset context so as to resume to regular parse loop
	 * If unable to reset for resuming, answers false.
	 *
	 * Move checkpoint location, reset internal stacks and
	 * decide which grammar goal is activated.
	 */
	protected boolean resumeAfterRecovery() {

		// reset internal stacks 
		astPtr = -1;
		astLengthPtr = -1;
		expressionPtr = -1;
		expressionLengthPtr = -1;
		identifierPtr = -1;
		identifierLengthPtr = -1;
		intPtr = -1;
		dimensions = 0;
		recoveredStaticInitializerStart = 0;

		// if in diet mode, reset the diet counter because we're going to restart outside an initializer.
		if (diet)
			dietInt = 0;

		/* attempt to move checkpoint location */
		if (!this.moveRecoveryCheckpoint())
			return false;

		// only look for headers
		if (referenceContext instanceof CompilationUnitDeclaration
			|| this.assistNode != null) {
			nestedMethod[nestedType = 0] = 0;
			variablesCounter[nestedType] = 0;
			realBlockStack[realBlockPtr = 0] = 0;
			goForHeaders();
			diet = true; // passed this point, will not consider method bodies
			return true;
		}
		if (referenceContext instanceof AbstractMethodDeclaration
			|| referenceContext instanceof TypeDeclaration) {

			if (currentElement instanceof RecoveredType) {
				nestedMethod[nestedType = 0] = 0;
				variablesCounter[nestedType] = 0;
				realBlockStack[realBlockPtr = 0] = 0;
				goForHeaders();
			} else {
				this.prepareForBlockStatements();
				goForBlockStatementsOrMethodHeaders();
			}
			return true;
		}
		// does not know how to restart
		return false;
	}

