private void findFields(
	char[] fieldName,
	FieldBinding[] fields,
	Scope scope,
	ObjectVector fieldsFound,
	boolean onlyStaticFields) {

	// Inherited fields which are hidden by subclasses are filtered out
	// No visibility checks can be performed without the scope & invocationSite

	int fieldLength = fieldName.length;
	next : for (int f = fields.length; --f >= 0;) {
		FieldBinding field = fields[f];
		if (onlyStaticFields && !field.isStatic()) continue next;
		if (fieldLength > field.name.length) continue next;
		if (!CharOperation.prefixEquals(fieldName, field.name, false /* ignore case */)) continue next;

		for (int i = fieldsFound.size; --i >= 0;) {
			FieldBinding otherField = (FieldBinding) fieldsFound.elementAt(i);
			if (field == otherField) continue next;
			if (CharOperation.equals(field.name, otherField.name, true)) {
				if (field.declaringClass.isSuperclassOf(otherField.declaringClass)) continue next;
				if (otherField.declaringClass.isInterface())
					if (field.declaringClass.implementsInterface(otherField.declaringClass, true)) continue next;
			}
		}

		fieldsFound.add(field);
		requestor.acceptField(
			field.declaringClass.qualifiedPackageName(),
			field.declaringClass.qualifiedSourceName(),
			field.name,
			field.type.qualifiedPackageName(),
			field.type.qualifiedSourceName(),
			field.name, // may include some qualification to resolve ambiguities
			field.modifiers,
			startPosition,
			endPosition);
	}
}

