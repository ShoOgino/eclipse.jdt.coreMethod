	private void findConstructors(
		ReferenceBinding currentType,
		TypeBinding[] argTypes,
		Scope scope,
		InvocationSite invocationSite) {
		// No visibility checks can be performed without the scope & invocationSite
		MethodBinding[] methods = currentType.methods();
		int minArgLength = argTypes == null ? 0 : argTypes.length;
		next : for (int f = methods.length; --f >= 0;) {
			MethodBinding constructor = methods[f];
			if (constructor.isConstructor()) {
				if (options.checkVisibility()
					&& !constructor.canBeSeenBy(invocationSite, scope))
					continue next;

				TypeBinding[] parameters = constructor.parameters;
				int paramLength = parameters.length;
				if (minArgLength > paramLength)
					continue next;
				for (int a = minArgLength; --a >= 0;)
					if (argTypes[a] != null) // can be null if it could not be resolved properly
						if (!scope.areTypesCompatible(argTypes[a], constructor.parameters[a]))
							continue next;

				char[][] parameterPackageNames = new char[paramLength][];
				char[][] parameterTypeNames = new char[paramLength][];
				for (int i = 0; i < paramLength; i++) {
					TypeBinding type = parameters[i];
					parameterPackageNames[i] = type.qualifiedPackageName();
					parameterTypeNames[i] = type.qualifiedSourceName();
				}
				char[] completion = TypeConstants.NoChar;
				// nothing to insert - do not want to replace the existing selector & arguments
				if (source == null
					|| source.length <= endPosition
					|| source[endPosition] != ')')
					completion = new char[] { ')' };
				requestor.acceptMethod(
					currentType.qualifiedPackageName(),
					currentType.qualifiedSourceName(),
					currentType.sourceName(),
					parameterPackageNames,
					parameterTypeNames,
					TypeConstants.NoChar,
					TypeConstants.NoChar,
					completion,
					constructor.modifiers,
					endPosition,
					endPosition);
			}
		}
	}

