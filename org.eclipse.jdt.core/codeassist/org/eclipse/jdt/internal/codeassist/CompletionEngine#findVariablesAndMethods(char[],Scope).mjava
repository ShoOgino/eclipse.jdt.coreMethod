private void findVariablesAndMethods(char[] token, Scope scope) {
	if (token == null) return;

	// Should local variables hide fields from the receiver type or any of its enclosing types?
	// we know its an implicit field/method access... see BlockScope getBinding/getImplicitMethod

	boolean staticsOnly = false; // need to know if we're in a static context (or inside a constructor)
	char[][] found = null;
	int lastPosition = -1;
	int tokenLength = token.length;
	ObjectVector fieldsFound = new ObjectVector();
	ObjectVector methodsFound = new ObjectVector();
	done : while (true) { // done when a COMPILATION_UNIT_SCOPE is found
		switch (scope.kind) {
			case Scope.METHOD_SCOPE :
				// handle the error case inside an explicit constructor call (see MethodScope>>findField)
				MethodScope methodScope = (MethodScope) scope;
				staticsOnly |= methodScope.isStatic | methodScope.isConstructorCall;
			case Scope.BLOCK_SCOPE :
				BlockScope blockScope = (BlockScope) scope;
				next : for (int i = 0, length = blockScope.locals.length; i < length; i++) {
					LocalVariableBinding local = blockScope.locals[i];
					if (local == null) break next;
					if (tokenLength > local.name.length) continue next;
					if (!CharOperation.prefixEquals(token, local.name, false /* ignore case */)) continue next;
					if (local.isSecret()) continue next;

					if (found == null) {
						found = new char[5][];
					} else {
						for (int f = 0; f < found.length; f++) {
							char[] name = found[f];
							if (name == null) break;
							if (CharOperation.equals(name, local.name, false /* ignore case */)) continue next;
						}
					}
					if (++lastPosition == found.length)
						System.arraycopy(found, 0, found = new char[lastPosition * 2][], 0, lastPosition);
					found[lastPosition] = local.name;

					requestor.acceptLocalVariable(
						local.name,
						NoChar,
						local.type == null ? local.declaration.type.toString().toCharArray() : local.type.qualifiedSourceName(),
						local.modifiers,
						startPosition,
						endPosition);
				}
				break;
			case Scope.CLASS_SCOPE :
				ClassScope classScope = (ClassScope) scope;
				SourceTypeBinding enclosingType = classScope.referenceContext.binding;
/*				if (tokenLength == 0) { // only search inside the type itself if no prefix was provided
					findFields(token, enclosingType.fields(), classScope, fieldsFound, staticsOnly);
					findMethods(token, enclosingType.methods(), classScope, methodsFound, staticsOnly, false);
					break done;
				} else { */
					findFields(token, enclosingType, classScope, fieldsFound, staticsOnly);
					findMethods(token, null, enclosingType, classScope, methodsFound, staticsOnly, false);
					staticsOnly |= enclosingType.isStatic();
//				}
				break;
			case Scope.COMPILATION_UNIT_SCOPE :
				break done;
		}
		scope = scope.parent;
	}
}

