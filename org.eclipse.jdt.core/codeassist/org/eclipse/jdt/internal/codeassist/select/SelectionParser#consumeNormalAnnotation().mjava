protected void consumeNormalAnnotation() {
	int index;
	
	if ((index = this.indexOfAssistIdentifier()) < 0) {
		super.consumeNormalAnnotation();
		return;
	} 
	
	NormalAnnotation normalAnnotation = null;
	int length = this.identifierLengthStack[this.identifierLengthPtr];
	TypeReference typeReference;
	
	/* retrieve identifiers subset and whole positions, the assist node positions
		should include the entire replaced source. */
	
	char[][] subset = identifierSubSet(index);
	identifierLengthPtr--;
	identifierPtr -= length;
	long[] positions = new long[length];
	System.arraycopy(
		identifierPositionStack, 
		identifierPtr + 1, 
		positions, 
		0, 
		length); 

	/* build specific assist on type reference */
	
	if (index == 0) {
		/* assist inside first identifier */
		typeReference = this.createSingleAssistTypeReference(
						assistIdentifier(), 
						positions[0]);
	} else {
		/* assist inside subsequent identifier */
		typeReference =	this.createQualifiedAssistTypeReference(
						subset,  
						assistIdentifier(), 
						positions);
	}
	assistNode = typeReference;
	this.lastCheckPoint = typeReference.sourceEnd + 1;
		
	normalAnnotation = new NormalAnnotation(typeReference, this.intStack[this.intPtr--]);
	if ((length = this.astLengthStack[this.astLengthPtr--]) != 0) {
		System.arraycopy(
			this.astStack, 
			(this.astPtr -= length) + 1, 
			normalAnnotation.memberValuePairs = new MemberValuePair[length], 
			0, 
			length); 
	}
	int sourceStart = normalAnnotation.sourceStart;
	if (this.modifiersSourceStart < 0) {
		this.modifiersSourceStart = sourceStart;
	} else if (this.modifiersSourceStart > sourceStart) {
		this.modifiersSourceStart = sourceStart;
	}
	normalAnnotation.declarationSourceEnd = this.rParenPos;
	pushOnExpressionStack(normalAnnotation);
}

