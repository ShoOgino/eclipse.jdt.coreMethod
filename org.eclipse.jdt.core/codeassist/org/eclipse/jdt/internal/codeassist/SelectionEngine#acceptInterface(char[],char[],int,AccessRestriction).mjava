	/**
	 * One result of the search consists of a new interface.
	 *
	 * NOTE - All package and type names are presented in their readable form:
	 *    Package names are in the form "a.b.c".
	 *    Nested type names are in the qualified form "A.I".
	 *    The default package is represented by an empty array.
	 */
	public void acceptInterface(
		char[] packageName,
		char[] interfaceName,
		int modifiers,
		AccessRestriction accessRestriction) {

		if (CharOperation.equals(interfaceName, this.selectedIdentifier)) {
			if (this.qualifiedSelection != null
				&& !CharOperation.equals(
					this.qualifiedSelection,
					CharOperation.concat(packageName, interfaceName, '.'))) {
				return;
			}
			
			if(mustQualifyType(packageName, interfaceName)) {
				char[][] acceptedInterface= new char[2][];
				acceptedInterface[0] = packageName;
				acceptedInterface[1] = interfaceName;
				
				if(this.acceptedInterfaces == null) {
					this.acceptedInterfaces = new char[10][][];
					this.acceptedInterfacesCount = 0;
				}
				int length = this.acceptedInterfaces.length;
				if(length == this.acceptedInterfacesCount) {
					System.arraycopy(this.acceptedInterfaces, 0, this.acceptedInterfaces = new char[(length + 1) * 2][][], 0, length);
				}
				this.acceptedInterfaces[this.acceptedInterfacesCount++] = acceptedInterface;
				
			} else {
				this.noProposal = false;
				this.requestor.acceptInterface(
					packageName,
					interfaceName,
					false,
					false,
					this.actualSelectionStart,
					this.actualSelectionEnd);
				this.acceptedAnswer = true;
			}
		}
	}

