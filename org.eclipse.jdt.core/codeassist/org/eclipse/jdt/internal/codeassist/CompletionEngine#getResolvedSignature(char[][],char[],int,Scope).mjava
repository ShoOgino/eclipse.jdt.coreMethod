	private char[] getResolvedSignature(char[][] parameterTypes, char[] fullyQualifiedTypeName, int parameterCount, Scope scope) {
		char[][] cn = CharOperation.splitOn('.', fullyQualifiedTypeName);

		TypeReference ref;
		if (cn.length == 1) {
			ref = new SingleTypeReference(cn[0], 0);
		} else {
			ref = new QualifiedTypeReference(cn,new long[cn.length]);
		}
		
		TypeBinding guessedType = null;
		INameEnvironment oldNameEnvironment = this.lookupEnvironment.nameEnvironment;
		this.lookupEnvironment.nameEnvironment = getNoCacheNameEnvironment();
		try {
			switch (scope.kind) {
				case Scope.METHOD_SCOPE :
				case Scope.BLOCK_SCOPE :
					guessedType = ref.resolveType((BlockScope)scope);
					break;
				case Scope.CLASS_SCOPE :
					guessedType = ref.resolveType((ClassScope)scope);
					break;
			}
		} finally {
			this.lookupEnvironment.nameEnvironment = oldNameEnvironment;
		}

		if (guessedType != null && guessedType.isValidBinding()) {
			if (guessedType instanceof SourceTypeBinding) {
				SourceTypeBinding refBinding = (SourceTypeBinding) guessedType;
				
				refBinding.methods(); // force resolution
				if (refBinding.scope == null || refBinding.scope.referenceContext == null) return null;
				TypeDeclaration typeDeclaration = refBinding.scope.referenceContext;
				AbstractMethodDeclaration[] methods = typeDeclaration.methods;
				next : for (int i = 0; i < methods.length; i++) {
					AbstractMethodDeclaration method = methods[i];
					
					if (method.binding == null || !method.isConstructor()) continue next;
					
					Argument[] arguments = method.arguments;
					int argumentsLength = arguments == null ? 0 : arguments.length;
					if (parameterCount != argumentsLength) continue next;
					
					for (int j = 0; j < argumentsLength; j++) {
						if (!CharOperation.equals(CharOperation.concatWith(arguments[j].type.getTypeName(), '.'), parameterTypes[j])) {
							continue next;
						}
					}
					
					return getSignature(method.binding);
				}
			}
		}
		
		return null;
	}

