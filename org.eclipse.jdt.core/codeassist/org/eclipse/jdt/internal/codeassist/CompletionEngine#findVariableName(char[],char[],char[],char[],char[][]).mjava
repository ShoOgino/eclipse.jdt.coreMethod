	// Helper method for private void findVariableNames(char[] name, TypeReference type )
	private void findVariableName(char[] token, char[] qualifiedPackageName, char[] qualifiedSourceName, char[] sourceName, char[][] excludeNames){
			if(sourceName == null || sourceName.length == 0)
				return;
			
			if(CharOperation.endsWith(sourceName, new char[]{'[' ,']'})) {
				sourceName = CharOperation.subarray(sourceName, 0, sourceName.length - 2);
			}

			char[] name = null;
			
			// compute variable name for base type
			try{
				nameScanner.setSourceBuffer(sourceName);
				switch (nameScanner.getNextToken()) {
					case TokenNameint :
					case TokenNamebyte :
					case TokenNameshort :
					case TokenNamechar :
					case TokenNamelong :
					case TokenNamefloat :
					case TokenNamedouble :
						if(token != null && token.length != 0)
							return;
						name = computeBaseNames(sourceName[0], excludeNames);
						break;
					case TokenNameboolean :
						if(token != null && token.length != 0)
							return;
						name = computeBaseNames('z', excludeNames);
						break;
				}
				if(name != null) {
					// accept result
					requestor.acceptVariableName(
						qualifiedPackageName,
						qualifiedSourceName,
						name,
						name,
						startPosition,
						endPosition);
					return;
				}
			} catch(InvalidInputException e){
			}
			
			// compute variable name for non base type
			char[][] names = computeNames(sourceName);
			next : for(int i = 0 ; i < names.length ; i++){
				name = names[i];
				
				if (!CharOperation.prefixEquals(token, name, false))
					continue next;
				
				// completion must be an identifier (not a keyword, ...).
				try{
					nameScanner.setSourceBuffer(name);
					if(nameScanner.getNextToken() != TokenNameIdentifier)
						continue next;
				} catch(InvalidInputException e){
					continue next;
				}
				
				int count = 2;
				char[] originalName = name;
				for(int j = 0 ; j < excludeNames.length ; j++){
					if(CharOperation.equals(name, excludeNames[j], false)) {
						name = CharOperation.concat(originalName, String.valueOf(count++).toCharArray());
						j = 0;
					}	
				}
				
				// accept result
				requestor.acceptVariableName(
					qualifiedPackageName,
					qualifiedSourceName,
					name,
					name,
					startPosition,
					endPosition);
			}
	}

