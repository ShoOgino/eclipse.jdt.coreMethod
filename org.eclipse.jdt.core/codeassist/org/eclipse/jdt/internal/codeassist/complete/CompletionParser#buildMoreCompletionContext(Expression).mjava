private void buildMoreCompletionContext(Expression expression) {
	Statement statement = expression;
	int kind = topKnownElementKind(COMPLETION_OR_ASSIST_PARSER);
	if(kind != 0) {
		int info = topKnownElementInfo(COMPLETION_OR_ASSIST_PARSER);
		nextElement : switch (kind) {
			case K_SELECTOR_QUALIFIER :
				int selector = topKnownElementInfo(COMPLETION_OR_ASSIST_PARSER, 2);
				if(selector == THIS_CONSTRUCTOR || selector == SUPER_CONSTRUCTOR) {
					ExplicitConstructorCall call = new ExplicitConstructorCall(
						(selector == THIS_CONSTRUCTOR) ? 
							ExplicitConstructorCall.This : 
							ExplicitConstructorCall.Super
					);
					call.arguments = new Expression[] {expression};
					call.sourceStart = expression.sourceStart;
					call.sourceEnd = expression.sourceEnd;
					assistNodeParent = call;
				} else {
					int invocType = topKnownElementInfo(COMPLETION_OR_ASSIST_PARSER,1);
					int qualifierExprPtr = info;
					
					// find arguments
					int length = expressionLengthStack[expressionLengthPtr];
					
					// search previous arguments if missing
					if(expressionLengthPtr > 0 && length == 1) {
						int start = (int) (identifierPositionStack[selector] >>> 32);
						if(this.expressionStack[expressionPtr-1] != null && this.expressionStack[expressionPtr-1].sourceStart > start) {
							length += expressionLengthStack[expressionLengthPtr-1];
						}

					}
					
					Expression[] arguments = null;
					if (length != 0) {
						arguments = new Expression[length];
						expressionPtr -= length;
						System.arraycopy(expressionStack, expressionPtr + 1, arguments, 0, length-1);
						arguments[length-1] = expression;
					}
					
					if(invocType != ALLOCATION && invocType != QUALIFIED_ALLOCATION) {
						MessageSend messageSend = new MessageSend();
						messageSend.selector = identifierStack[selector];
						messageSend.arguments = arguments;
	
						// find receiver
						switch (invocType) {
							case NO_RECEIVER:
								messageSend.receiver = ThisReference.implicitThis();
								break;
							case NAME_RECEIVER:
								// remove special flags for primitive types
								while (this.identifierLengthPtr >= 0 && this.identifierLengthStack[this.identifierLengthPtr] < 0) {
									this.identifierLengthPtr--;
								}
								
								// remove selector 
								this.identifierPtr--; 
								this.identifierLengthStack[this.identifierLengthPtr]--;
								// consume the receiver
								messageSend.receiver = this.getUnspecifiedReference();
								break;
							case SUPER_RECEIVER:
								messageSend.receiver = new SuperReference(0, 0);
								break;
							case EXPLICIT_RECEIVER:
								messageSend.receiver = this.expressionStack[qualifierExprPtr];
								break;
							default :
								messageSend.receiver = ThisReference.implicitThis();
								break;
						}
						assistNodeParent = messageSend;
					} else {
						if(invocType == ALLOCATION) {
							AllocationExpression allocationExpr = new AllocationExpression();
							allocationExpr.arguments = arguments;
							allocationExpr.type = getTypeReference(0);
							assistNodeParent = allocationExpr;
						} else {
							QualifiedAllocationExpression allocationExpr = new QualifiedAllocationExpression();
							allocationExpr.enclosingInstance = this.expressionStack[qualifierExprPtr];
							allocationExpr.arguments = arguments;
							allocationExpr.type = getTypeReference(0);
							assistNodeParent = allocationExpr;
						}
					}
				}
				break nextElement;
			case K_INSIDE_RETURN_STATEMENT :
				if(info == bracketDepth) {
					ReturnStatement returnStatement = new ReturnStatement(expression, expression.sourceStart, expression.sourceEnd);
					assistNodeParent = returnStatement;
				}
				break nextElement;
			case K_CAST_STATEMENT :
				Expression castType;
				if(this.expressionPtr > 0
					&& ((castType = this.expressionStack[this.expressionPtr-1]) instanceof TypeReference
						|| castType instanceof NameReference)) {
					CastExpression cast = new CastExpression(expression, getTypeReference(castType));
					cast.sourceStart = castType.sourceStart;
					cast.sourceEnd= expression.sourceEnd;
					assistNodeParent = cast;
				}
				break nextElement;
			case K_UNARY_OPERATOR :
				if(expressionPtr > -1) {
					Expression operatorExpression = null;
					switch (info) {
						case PLUS_PLUS :
							operatorExpression = new PrefixExpression(expression,IntLiteral.One, PLUS, expression.sourceStart);
							break;
						case MINUS_MINUS :
							operatorExpression = new PrefixExpression(expression,IntLiteral.One, MINUS, expression.sourceStart);
							break;
						default :
							operatorExpression = new UnaryExpression(expression, info);
							break;
					}
					if(operatorExpression != null) {
						assistNodeParent = operatorExpression;
					}
				}
				break nextElement;
			case K_BINARY_OPERATOR :
				if(expressionPtr > 0) {
					Expression operatorExpression = null;
					switch (info) {
						case AND_AND :
							operatorExpression = new AND_AND_Expression(this.expressionStack[expressionPtr-1], expression, info);
							break;
						case OR_OR :
							operatorExpression = new OR_OR_Expression(this.expressionStack[expressionPtr-1], expression, info);
							break;
						case EQUAL_EQUAL :
						case NOT_EQUAL :
							operatorExpression = new EqualExpression(this.expressionStack[expressionPtr-1], expression, info);
							break;
						case INSTANCEOF :
							// should never occur
							break;
						default :
							operatorExpression = new BinaryExpression(this.expressionStack[expressionPtr-1], expression, info);
							break;
					}
					if(operatorExpression != null) {
						assistNodeParent = operatorExpression;
					}
				}
				break nextElement;
			case K_ARRAY_INITIALIZER :
				ArrayInitializer arrayInitializer = new ArrayInitializer();
				arrayInitializer.expressions = new Expression[]{expression};
				expressionPtr -= expressionLengthStack[expressionLengthPtr--];
				
				if(expressionLengthPtr > -1
					&& expressionPtr > -1
					&& this.expressionStack[expressionPtr] != null
					&& this.expressionStack[expressionPtr].sourceStart > info) {
					expressionLengthPtr--;	
				}
					
				lastCheckPoint = scanner.currentPosition;
				
				if(topKnownElementKind(COMPLETION_OR_ASSIST_PARSER, 1) == K_ARRAY_CREATION) {
					ArrayAllocationExpression allocationExpression = new ArrayAllocationExpression();
					allocationExpression.type = getTypeReference(0);
					int length = expressionLengthStack[expressionLengthPtr];
					allocationExpression.dimensions = new Expression[length];

					allocationExpression.initializer = arrayInitializer;
					assistNodeParent = allocationExpression;
				} else if(currentElement instanceof RecoveredField && !(currentElement instanceof RecoveredInitializer)) {
					RecoveredField recoveredField = (RecoveredField) currentElement;
					if(recoveredField.fieldDeclaration.type.dimensions() == 0) {
						Block block = new Block(0);
						block.sourceStart = info;
						currentElement = currentElement.add(block, 1);
					} else {
						statement = arrayInitializer;
					}
				} else if(currentElement instanceof RecoveredLocalVariable) {
					RecoveredLocalVariable recoveredLocalVariable = (RecoveredLocalVariable) currentElement;
					if(recoveredLocalVariable.localDeclaration.type.dimensions() == 0) {
						Block block = new Block(0);
						block.sourceStart = info;
						currentElement = currentElement.add(block, 1);
					} else {
						statement = arrayInitializer;
					}
				} else {
					statement = arrayInitializer;
				}
				break nextElement;
			case K_ARRAY_CREATION :
				ArrayAllocationExpression allocationExpression = new ArrayAllocationExpression();
				allocationExpression.type = getTypeReference(0);
				allocationExpression.dimensions = new Expression[]{expression};
				
				assistNodeParent = allocationExpression;
				break nextElement;
			case K_ASSISGNMENT_OPERATOR :
				if(expressionPtr > 0 && expressionStack[expressionPtr - 1] != null) {
					Assignment assignment;
					if(info == EQUAL) {
						assignment = new Assignment(
							expressionStack[expressionPtr - 1],
							expression,
							expression.sourceEnd
						);
					} else {
						assignment = new CompoundAssignment(
							expressionStack[expressionPtr - 1],
							expression,
							info,
							expression.sourceEnd
						);
					}
					assistNodeParent = assignment;
				}
				break nextElement;
			case K_CONDITIONAL_OPERATOR :
				if(info == QUESTION) {
					if(expressionPtr > 0) {
						expressionPtr--;
						expressionLengthPtr--;
						expressionStack[expressionPtr] = expressionStack[expressionPtr+1];
						popElement(K_CONDITIONAL_OPERATOR);
						buildMoreCompletionContext(expression);
						return;
					}
				} else {
					if(expressionPtr > 1) {
						expressionPtr = expressionPtr - 2;
						expressionLengthPtr = expressionLengthPtr - 2;
						expressionStack[expressionPtr] = expressionStack[expressionPtr+2];
						popElement(K_CONDITIONAL_OPERATOR);
						buildMoreCompletionContext(expression);
						return;
					}
				}
				break nextElement;
			case K_BETWEEN_LEFT_AND_RIGHT_BRACKET :
				ArrayReference arrayReference;
				if(identifierPtr < 0 && expressionPtr > 0 && expressionStack[expressionPtr] == expression) {
					arrayReference =
						new ArrayReference(
							expressionStack[expressionPtr-1],
							expression);
				} else {
					arrayReference =
						new ArrayReference(
							getUnspecifiedReferenceOptimized(),
							expression);
				}
				assistNodeParent = arrayReference;
				break;
				
		}
	}
	if(assistNodeParent != null) {
		currentElement = currentElement.add((Statement)assistNodeParent, 0);
	} else {
		if(currentElement instanceof RecoveredField && !(currentElement instanceof RecoveredInitializer)
			&& ((RecoveredField) currentElement).fieldDeclaration.initialization == null) {
			
			assistNodeParent = ((RecoveredField) currentElement).fieldDeclaration;
			currentElement = currentElement.add(statement, 0);
		} else if(currentElement instanceof RecoveredLocalVariable
			&& ((RecoveredLocalVariable) currentElement).localDeclaration.initialization == null) {
			
			assistNodeParent = ((RecoveredLocalVariable) currentElement).localDeclaration;
			currentElement = currentElement.add(statement, 0);
		} else {
			currentElement = currentElement.add(expression, 0);
		}
	}
}

