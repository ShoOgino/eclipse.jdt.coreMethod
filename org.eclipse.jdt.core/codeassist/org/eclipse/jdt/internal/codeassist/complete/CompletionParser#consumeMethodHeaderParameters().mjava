protected void consumeMethodHeaderParameters() {
	super.consumeMethodHeaderParameters();
	
	if (currentElement != null
		&& currentToken == TokenNameIdentifier
		&& this.cursorLocation+1 >= scanner.startPosition
		&& this.cursorLocation < scanner.currentPosition){
		this.pushIdentifier();
		
		int index = -1;
		/* check if current awaiting identifier is the completion identifier */
		if ((index = this.indexOfAssistIdentifier()) > -1) {

			RecoveredMethod recoveredMethod = (RecoveredMethod)currentElement;
			/* filter out cases where scanner is still inside type header */
			if (!recoveredMethod.foundOpeningBrace) {
				AbstractMethodDeclaration method = recoveredMethod.methodDeclaration;
				if(method.thrownExceptions == null
					&& CharOperation.prefixEquals(identifierStack[index], Keywords.THROWS)) {
					CompletionOnKeyword1 completionOnKeyword = new CompletionOnKeyword1(
						identifierStack[index],
						identifierPositionStack[index],
						Keywords.THROWS);
					method.thrownExceptions = new TypeReference[]{completionOnKeyword};
					recoveredMethod.foundOpeningBrace = true;
					this.assistNode = completionOnKeyword;
					this.lastCheckPoint = completionOnKeyword.sourceEnd + 1;
				}
			}
		}
	}
}

