	private void complete(ASTNode astNode, ASTNode astNodeParent, Binding qualifiedBinding, Scope scope) {

		setSourceRange(astNode.sourceStart, astNode.sourceEnd);
		
		scope = computeForbiddenBindings(astNode, astNodeParent, scope);
		computeUninterestingBindings(astNodeParent, scope);
		if(astNodeParent != null) {
			if(!isValidParent(astNodeParent, astNode, scope)) return;
			computeExpectedTypes(astNodeParent, astNode, scope);
		}
		
		if (astNode instanceof CompletionOnFieldType) {

			CompletionOnFieldType field = (CompletionOnFieldType) astNode;
			CompletionOnSingleTypeReference type = (CompletionOnSingleTypeReference) field.type;
			this.completionToken = type.token;
			setSourceRange(type.sourceStart, type.sourceEnd);
			
			findTypesAndPackages(this.completionToken, scope);
			findKeywordsForMember(this.completionToken, field.modifiers);
			
			if(!field.isLocalVariable && field.modifiers == CompilerModifiers.AccDefault) {
				findMethods(this.completionToken,null,scope.enclosingSourceType(),scope,new ObjectVector(),false,false,true,null,null,false,false,true);
				proposeNewMethod(this.completionToken, scope.enclosingSourceType());
			}
		} else {
			if(astNode instanceof CompletionOnMethodReturnType) {
				
				CompletionOnMethodReturnType method = (CompletionOnMethodReturnType) astNode;
				SingleTypeReference type = (CompletionOnSingleTypeReference) method.returnType;
				this.completionToken = type.token;
				setSourceRange(type.sourceStart, type.sourceEnd);
				findTypesAndPackages(this.completionToken, scope.parent);
				findKeywordsForMember(this.completionToken, method.modifiers);
			
				if(method.modifiers == CompilerModifiers.AccDefault) {
					findMethods(this.completionToken,null,scope.enclosingSourceType(),scope,new ObjectVector(),false,false,true,null,null,false,false,true);
					proposeNewMethod(this.completionToken, scope.enclosingSourceType());
				}
			} else {
				
				if (astNode instanceof CompletionOnSingleNameReference) {
					CompletionOnSingleNameReference singleNameReference = (CompletionOnSingleNameReference) astNode;
					this.completionToken = singleNameReference.token;
					findVariablesAndMethods(
						this.completionToken,
						scope,
						(CompletionOnSingleNameReference) astNode,
						scope);
					// can be the start of a qualified type name
					findTypesAndPackages(this.completionToken, scope);
					findKeywords(this.completionToken, singleNameReference.possibleKeywords);
					if(astNodeParent instanceof SwitchStatement) {
						this.findEnumConstant(this.completionToken, (SwitchStatement) astNodeParent);
					}
					if(singleNameReference.canBeExplicitConstructor){
						if(CharOperation.prefixEquals(this.completionToken, Keywords.THIS, false)) {
							ReferenceBinding ref = scope.enclosingSourceType();
							findExplicitConstructors(Keywords.THIS, ref, (MethodScope)scope, singleNameReference);
						} else if(CharOperation.prefixEquals(this.completionToken, Keywords.SUPER, false)) {
							ReferenceBinding ref = scope.enclosingSourceType();
							findExplicitConstructors(Keywords.SUPER, ref.superclass(), (MethodScope)scope, singleNameReference);
						}
					}
				} else {
	
					if (astNode instanceof CompletionOnSingleTypeReference) {
	
						this.completionToken = ((CompletionOnSingleTypeReference) astNode).token;
						
						this.assistNodeIsClass = astNode instanceof CompletionOnClassReference;
						this.assistNodeIsException = astNode instanceof CompletionOnExceptionReference;
						this.assistNodeIsInterface = astNode instanceof CompletionOnInterfaceReference;
	
						// can be the start of a qualified type name
						if (qualifiedBinding == null) {
							findTypesAndPackages(this.completionToken, scope);
							} else {
								findMemberTypes(
								this.completionToken,
								(ReferenceBinding) qualifiedBinding,
								scope,
								scope.enclosingSourceType(),
								false,
								new ObjectVector());
						}
					} else {
						
						if (astNode instanceof CompletionOnQualifiedNameReference) {
	
							this.insideQualifiedReference = true;
							CompletionOnQualifiedNameReference ref =
								(CompletionOnQualifiedNameReference) astNode;
							this.completionToken = ref.completionIdentifier;
							long completionPosition = ref.sourcePositions[ref.sourcePositions.length - 1];
	
							if (qualifiedBinding instanceof VariableBinding) {
	
								setSourceRange((int) (completionPosition >>> 32), (int) completionPosition);
								TypeBinding receiverType = ((VariableBinding) qualifiedBinding).type;
								if (receiverType != null) {
									findFieldsAndMethods(this.completionToken, receiverType, scope, ref, scope,false,false);
								}
	
							} else {
	
								if (qualifiedBinding instanceof ReferenceBinding) {
	
									ReferenceBinding receiverType = (ReferenceBinding) qualifiedBinding;
									setSourceRange((int) (completionPosition >>> 32), (int) completionPosition);
	
									findMemberTypes(this.completionToken, receiverType, scope, scope.enclosingSourceType(), false, new ObjectVector());
	
									findClassField(this.completionToken, (TypeBinding) qualifiedBinding, scope);
									
									MethodScope methodScope = null;
									if((scope instanceof MethodScope && !((MethodScope)scope).isStatic)
										|| ((methodScope = scope.enclosingMethodScope()) != null && !methodScope.isStatic)) {
										if(this.completionToken.length > 0) {
											findKeywords(this.completionToken, new char[][]{Keywords.THIS});
										} else {
											int relevance = computeBaseRelevance();
											relevance += computeRelevanceForInterestingProposal();
											relevance += computeRelevanceForCaseMatching(this.completionToken, Keywords.THIS);
											relevance += computeRelevanceForRestrictions(false); // no access restriction for keywords
											this.noProposal = false;
											if(!this.requestor.isIgnored(CompletionProposal.KEYWORD)) {
												CompletionProposal proposal = this.createProposal(CompletionProposal.KEYWORD, this.actualCompletionPosition);
												proposal.setName(Keywords.THIS);
												proposal.setCompletion(Keywords.THIS);
												proposal.setReplaceRange(this.startPosition - this.offset, this.endPosition - this.offset);
												proposal.setRelevance(relevance);
												this.requestor.accept(proposal);
												if(DEBUG) {
													this.printDebug(proposal);
												}
											}
										}
									}
	
									findFields(
										this.completionToken,
										receiverType,
										scope,
										new ObjectVector(),
										new ObjectVector(),
										true,
										ref,
										scope,
										false,
										true);
	
									findMethods(
										this.completionToken,
										null,
										receiverType,
										scope,
										new ObjectVector(),
										true,
										false,
										false,
										ref,
										scope,
										false,
										false,
										true);
	
								} else {
	
									if (qualifiedBinding instanceof PackageBinding) {
	
										setSourceRange(astNode.sourceStart, (int) completionPosition);
										// replace to the end of the completion identifier
										findTypesAndSubpackages(this.completionToken, (PackageBinding) qualifiedBinding);
									}
								}
							}
	
						} else {
	
								if (astNode instanceof CompletionOnQualifiedTypeReference) {
	
								this.insideQualifiedReference = true;
								
								this.assistNodeIsClass = astNode instanceof CompletionOnQualifiedClassReference;
								this.assistNodeIsException = astNode instanceof CompletionOnQualifiedExceptionReference;
								this.assistNodeIsInterface = astNode instanceof CompletionOnQualifiedInterfaceReference;
								
								CompletionOnQualifiedTypeReference ref =
									(CompletionOnQualifiedTypeReference) astNode;
								this.completionToken = ref.completionIdentifier;
								long completionPosition = ref.sourcePositions[ref.tokens.length];
	
								// get the source positions of the completion identifier
								if (qualifiedBinding instanceof ReferenceBinding) {
	
									setSourceRange((int) (completionPosition >>> 32), (int) completionPosition);
									findMemberTypes(
										this.completionToken,
										(ReferenceBinding) qualifiedBinding,
										scope,
										scope.enclosingSourceType(),
										false,
										new ObjectVector());
	
								} else {
	
									if (qualifiedBinding instanceof PackageBinding) {
	
										setSourceRange(astNode.sourceStart, (int) completionPosition);
										// replace to the end of the completion identifier
										findTypesAndSubpackages(this.completionToken, (PackageBinding) qualifiedBinding);
									}
								}
	
							} else {
	
								if (astNode instanceof CompletionOnMemberAccess) {
									this.insideQualifiedReference = true;
									CompletionOnMemberAccess access = (CompletionOnMemberAccess) astNode;
									long completionPosition = access.nameSourcePosition;
									setSourceRange((int) (completionPosition >>> 32), (int) completionPosition);
					
									this.completionToken = access.token;
									
									findKeywords(this.completionToken, new char[][]{Keywords.NEW});
									
									findFieldsAndMethods(
										this.completionToken,
										(TypeBinding) qualifiedBinding,
										scope,
										access,
										scope,
										false,
										access.receiver instanceof SuperReference);
	
								} else {
	
									if (astNode instanceof CompletionOnMessageSend) {
										setSourceRange(astNode.sourceStart, astNode.sourceEnd, false);
										
										CompletionOnMessageSend messageSend = (CompletionOnMessageSend) astNode;
										TypeBinding[] argTypes =
											computeTypes(messageSend.arguments, (BlockScope) scope);
										this.completionToken = messageSend.selector;
										if (qualifiedBinding == null) {
											
											findImplicitMessageSends(this.completionToken, argTypes, scope, messageSend, scope);
										} else {
	
											findMethods(
												this.completionToken,
												argTypes,
												(ReferenceBinding) qualifiedBinding,
												scope,
												new ObjectVector(),
												false,
												true,
												false,
												messageSend,
												scope,
												false,
												messageSend.receiver instanceof SuperReference,
												true);
										}
	
									} else {
	
										if (astNode instanceof CompletionOnExplicitConstructorCall) {
											setSourceRange(astNode.sourceStart, astNode.sourceEnd, false);
											
											CompletionOnExplicitConstructorCall constructorCall =
												(CompletionOnExplicitConstructorCall) astNode;
											TypeBinding[] argTypes =
												computeTypes(constructorCall.arguments, (BlockScope) scope);
											findConstructors(
												(ReferenceBinding) qualifiedBinding,
												argTypes,
												scope,
												constructorCall,
												false);
	
										} else {
	
											if (astNode instanceof CompletionOnQualifiedAllocationExpression) {
												setSourceRange(astNode.sourceStart, astNode.sourceEnd, false);
												
												CompletionOnQualifiedAllocationExpression allocExpression =
													(CompletionOnQualifiedAllocationExpression) astNode;
												TypeBinding[] argTypes =
													computeTypes(allocExpression.arguments, (BlockScope) scope);
												
												ReferenceBinding ref = (ReferenceBinding) qualifiedBinding;
												if(ref.isClass()) {
													if(!ref.isAbstract()) {
														findConstructors(
															ref,
															argTypes,
															scope,
															allocExpression,
															false);
													}
												}
												if(!ref.isFinal()){
													findAnonymousType(
														ref,
														argTypes,
														scope,
														allocExpression);
												}
	
											} else {
	
												if (astNode instanceof CompletionOnClassLiteralAccess) {
													CompletionOnClassLiteralAccess access = (CompletionOnClassLiteralAccess) astNode;
													setSourceRange(access.classStart, access.sourceEnd);
									
													this.completionToken = access.completionIdentifier;
									
													findClassField(this.completionToken, (TypeBinding) qualifiedBinding, scope);
												} else {
													if(astNode instanceof CompletionOnMethodName) {
														CompletionOnMethodName method = (CompletionOnMethodName) astNode;
															
														setSourceRange(method.sourceStart, method.selectorEnd);
															
														FieldBinding[] fields = scope.enclosingSourceType().fields();
														char[][] excludeNames = new char[fields.length][];
														for(int i = 0 ; i < fields.length ; i++){
															excludeNames[i] = fields[i].name;
														}
														
														this.completionToken = method.selector;
														
														findVariableNames(this.completionToken, method.returnType, excludeNames, FIELD, method.modifiers);
													} else {
														if (astNode instanceof CompletionOnFieldName) {
															CompletionOnFieldName field = (CompletionOnFieldName) astNode;
															
															FieldBinding[] fields = scope.enclosingSourceType().fields();
															char[][] excludeNames = new char[fields.length][];
															for(int i = 0 ; i < fields.length ; i++){
																excludeNames[i] = fields[i].name;
															}
															
															this.completionToken = field.realName;
															
															findVariableNames(field.realName, field.type, excludeNames, FIELD, field.modifiers);
														} else {
															if (astNode instanceof CompletionOnLocalName ||
																astNode instanceof CompletionOnArgumentName){
																LocalDeclaration variable = (LocalDeclaration) astNode;
																
																LocalVariableBinding[] locals = ((BlockScope)scope).locals;
																char[][] excludeNames = new char[locals.length][];
																int localCount = 0;
																for(int i = 0 ; i < locals.length ; i++){
																	if(locals[i] != null) {
																		excludeNames[localCount++] = locals[i].name;
																	}
																}
																System.arraycopy(excludeNames, 0, excludeNames = new char[localCount][], 0, localCount);
																
																if(variable instanceof CompletionOnLocalName){
																	this.completionToken = ((CompletionOnLocalName) variable).realName;
																	findVariableNames(this.completionToken, variable.type, excludeNames, LOCAL, variable.modifiers);
																} else {
																	CompletionOnArgumentName arg = (CompletionOnArgumentName) variable;
																	this.completionToken = arg.realName;
																	findVariableNames(this.completionToken, variable.type, excludeNames, arg.isCatchArgument ? LOCAL : ARGUMENT, variable.modifiers);
																}
															} else {
																if(astNode instanceof CompletionOnKeyword) {
																	CompletionOnKeyword keyword = (CompletionOnKeyword)astNode;
																	findKeywords(keyword.getToken(), keyword.getPossibleKeywords());
																} else if(astNode instanceof CompletionOnParameterizedQualifiedTypeReference) {
																	CompletionOnParameterizedQualifiedTypeReference ref = (CompletionOnParameterizedQualifiedTypeReference) astNode;
																	
																	this.insideQualifiedReference = true;
							
																	this.assistNodeIsClass = ref.isClass();
																	this.assistNodeIsException = ref.isException();
																	this.assistNodeIsInterface = ref.isInterface();
																	
																	this.completionToken = ref.completionIdentifier;
																	long completionPosition = ref.sourcePositions[ref.tokens.length];
																	setSourceRange((int) (completionPosition >>> 32), (int) completionPosition);
																	findMemberTypes(
																		this.completionToken,
																		(ReferenceBinding) qualifiedBinding,
																		scope,
																		scope.enclosingSourceType(),
																		false,
																		new ObjectVector());
																} else if(astNode instanceof CompletionOnMarkerAnnotationName) {
																	CompletionOnMarkerAnnotationName annot = (CompletionOnMarkerAnnotationName) astNode;
																	
																	this.assistNodeIsAnnotation = true;
																	if(annot.type instanceof CompletionOnSingleTypeReference) {
																		CompletionOnSingleTypeReference type = (CompletionOnSingleTypeReference) annot.type;
																		this.completionToken = type.token;
																		setSourceRange(type.sourceStart, type.sourceEnd);
																		
																		findTypesAndPackages(this.completionToken, scope);
																	} else if(annot.type instanceof CompletionOnQualifiedTypeReference) {
																		CompletionOnQualifiedTypeReference type = (CompletionOnQualifiedTypeReference) annot.type;
																		this.completionToken = type.completionIdentifier;
																		setSourceRange(type.sourceStart, type.sourceEnd);
																		
																		findTypesAndPackages(this.completionToken, scope);
																	}
																} else if (astNode instanceof CompletionOnMemberValueName) {
																	CompletionOnMemberValueName memberValuePair = (CompletionOnMemberValueName) astNode;
																	Annotation annotation = (Annotation) astNodeParent;
																	
																	this.completionToken = memberValuePair.name;
																	
																	this.findAnnotationAttributes(this.completionToken, annotation.memberValuePairs(), (ReferenceBinding)annotation.resolvedType);
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}

