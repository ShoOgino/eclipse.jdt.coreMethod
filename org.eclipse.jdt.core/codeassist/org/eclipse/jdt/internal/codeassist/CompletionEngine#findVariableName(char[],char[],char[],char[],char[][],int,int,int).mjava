		// Helper method for private void findVariableNames(char[] name, TypeReference type )
	private void findVariableName(
		char[] token,
		char[] qualifiedPackageName,
		char[] qualifiedSourceName,
		char[] sourceName,
		char[][] excludeNames,
		int dim,
		int kind,
		int modifiers){
			
		if(sourceName == null || sourceName.length == 0)
			return;
		
		char[][] names = CharOperation.NO_CHAR_CHAR;
		switch (kind) {
			case FIELD :
				names = NameComputer.suggestFieldNames(
					javaProject,
					qualifiedPackageName,
					qualifiedSourceName,
					dim,
					modifiers,
					excludeNames);
				break;
			case LOCAL :
				names = NameComputer.suggestLocalVariableNames(
					javaProject,
					qualifiedPackageName,
					qualifiedSourceName,
					dim,
					excludeNames);
				break;
			case ARGUMENT :
				names = NameComputer.suggestArgumentNames(
					javaProject,
					qualifiedPackageName,
					qualifiedSourceName,
					dim,
					excludeNames);
				break;
		}

		// compute variable name for non base type
		char[] displayName;
		if (dim > 0){
			int l = qualifiedSourceName.length;
			displayName = new char[l+(2*dim)];
			System.arraycopy(qualifiedSourceName, 0, displayName, 0, l);
			for(int i = 0; i < dim; i++){
				displayName[l+(i*2)] = '[';
				displayName[l+(i*2)+1] = ']';
			}
		} else {
			displayName = qualifiedSourceName;
		}
		
		next : for(int i = 0 ; i < names.length ; i++){
			char[] name = names[i];
		
			if (!CharOperation.prefixEquals(token, name, false))
				continue next;
			
			int relevance = computeBaseRelevance();
			relevance += computeRelevanceForInterestingProposal();
			relevance += computeRelevanceForCaseMatching(token, name);
			
			// accept result
			requestor.acceptVariableName(
				qualifiedPackageName,
				displayName,
				name,
				name,
				startPosition - offset,
				endPosition - offset,
				relevance);
		}
		
	}

