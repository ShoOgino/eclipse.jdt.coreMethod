/**
 * Validate the given classpath and output location.
 * - Source folders cannot be nested inside the binary output, and reciprocally. They can coincidate.
 * - Source folders cannot be nested in each other.
 * - Output location must be nested inside project.
 *
 *  Note that the classpath entries are not validated automatically. Only bound variables are considered in
 *  the checking process (this allows to perform a consistency check on a classpath which has references to
 *  yet non existing projects, folders, ...).
 * 
 * @param classpath a given classpath
 * @param outputLocation a given output location
 * @return a status object with code <code>IStatus.OK</code> if
 *		the given classpath and output location are compatible, otherwise a status 
 *		object indicating what is wrong with the classpath or output location
 */
public static IJavaModelStatus validateClasspath(IJavaProject javaProject, IClasspathEntry[] classpath, IPath outputLocation) {

	IProject project = javaProject.getProject();
	IPath projectPath= project.getFullPath();

	/* validate output location */
	if (outputLocation == null) {
		return new JavaModelStatus(IJavaModelStatusConstants.NULL_PATH);
	}
	if (outputLocation.isAbsolute()) {
		if (!projectPath.isPrefixOf(outputLocation)) {
			return new JavaModelStatus(IJavaModelStatusConstants.PATH_OUTSIDE_PROJECT, javaProject, outputLocation.toString());
		}
	} else {
		return new JavaModelStatus(IJavaModelStatusConstants.RELATIVE_PATH, outputLocation);
	}

	boolean allowNestingInOutput = false;
	boolean hasSource = false;
	IClasspathEntry[] originalClasspath = classpath;
	for (int i = 0, length = classpath.length ; i < length; i++) {
		// use resolved variable
		if (classpath[i].getEntryKind() == IClasspathEntry.CPE_VARIABLE){
			if (classpath == originalClasspath) System.arraycopy(originalClasspath, 0, classpath = new IClasspathEntry[length], 0, length);
			classpath[i] = JavaCore.getResolvedClasspathEntry(classpath[i]);
		}
		if (classpath[i] != null){
			if (classpath[i].getEntryKind() == IClasspathEntry.CPE_SOURCE) hasSource = true;
			// check if any source entries coincidates with binary output - in which case nesting inside output is legal
			if (classpath[i].getPath().equals(outputLocation)) allowNestingInOutput = true;
		}
	}
	if (!hasSource) allowNestingInOutput = true; // if no source, then allowed
	
	// check all entries
	for (int i = 0 ; i < classpath.length; i++) {
		IClasspathEntry entry = classpath[i];
		if (entry == null) continue;
		IPath entryPath = entry.getPath();

		// no further check if entry coincidates with project or output location
		if (entryPath.equals(projectPath)) continue;
		if (entryPath.equals(outputLocation)) continue;
		
		// prevent nesting source entries in each other
		if (entry.getEntryKind() == IClasspathEntry.CPE_SOURCE){
			for (int j = 0; j < classpath.length; j++){
				IClasspathEntry otherEntry = classpath[j];
				if (otherEntry == null) continue;
				if (entry != otherEntry && otherEntry.getEntryKind() == IClasspathEntry.CPE_SOURCE){
					if (entryPath.isPrefixOf(otherEntry.getPath())){
						return new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind("classpath.cannotNestSourceFolderInSource",entryPath.toString(), otherEntry.getPath().toString())); //$NON-NLS-1$
					}
				}
			}
		}
		// prevent nesting output location inside entry
		if (entryPath.isPrefixOf(outputLocation)) {
			return new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind("classpath.cannotNestEntryInOutput",entryPath.toString(), outputLocation.toString())); //$NON-NLS-1$
		}

		// prevent nesting entry inside output location - when distinct from project or a source folder
		if (!allowNestingInOutput && outputLocation.isPrefixOf(entryPath)) {
			return new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind("classpath.cannotNestOutputInEntry", outputLocation.toString(), entryPath.toString())); //$NON-NLS-1$
		}
	}
	return JavaModelStatus.VERIFIED_OK;	
}

