/**
 * Validate the given classpath and output location.
 * - Source folders cannot be nested inside the binary output, and reciprocally. They can coincidate.
 * - Source folders cannot be nested in each other.
 * - Output location must be nested inside project.
 *
 *  Note that the classpath entries are not validated automatically. Only bound variables are considered in
 *  the checking process (this allows to perform a consistency check on a classpath which has references to
 *  yet non existing projects, folders, ...).
 * 
 * @param classpath a given classpath
 * @param outputLocation a given output location
 * @return a status object with code <code>IStatus.OK</code> if
 *		the given classpath and output location are compatible, otherwise a status 
 *		object indicating what is wrong with the classpath or output location
 */
public static IJavaModelStatus validateClasspath(IJavaProject javaProject, IClasspathEntry[] classpath, IPath outputLocation) {

	IProject project = javaProject.getProject();
	IPath projectPath= project.getFullPath();

	/* validate output location */
	if (outputLocation == null) {
		return new JavaModelStatus(IJavaModelStatusConstants.NULL_PATH);
	}
	if (outputLocation.isAbsolute()) {
		if (!projectPath.isPrefixOf(outputLocation)) {
			return new JavaModelStatus(IJavaModelStatusConstants.PATH_OUTSIDE_PROJECT, javaProject, outputLocation.toString());
		}
	} else {
		return new JavaModelStatus(IJavaModelStatusConstants.RELATIVE_PATH, outputLocation);
	}

	boolean allowNestingInOutput = false;
	boolean hasSource = false;

	// tolerate null path, it will be reset to default
	int length = classpath == null ? 0 : classpath.length; 

	IClasspathEntry[] originalClasspath = classpath;
	for (int i = 0 ; i < length; i++) {
		// use resolved variable
		if (classpath[i].getEntryKind() == IClasspathEntry.CPE_VARIABLE){
			if (classpath == originalClasspath) System.arraycopy(originalClasspath, 0, classpath = new IClasspathEntry[length], 0, length);
			classpath[i] = JavaCore.getResolvedClasspathEntry(classpath[i]);
		}
		if (classpath[i] != null){
			if (classpath[i].getEntryKind() == IClasspathEntry.CPE_SOURCE) hasSource = true;
			// check if any source entries coincidates with binary output - in which case nesting inside output is legal
			if (classpath[i].getPath().equals(outputLocation)) allowNestingInOutput = true;
		}
	}
	if (!hasSource) allowNestingInOutput = true; // if no source, then allowed
	
	ObjectSet pathes = new ObjectSet(length);
	
	// check all entries
	for (int i = 0 ; i < length; i++) {
		IClasspathEntry entry = classpath[i];

		if (entry == null) continue;

		IPath entryPath = entry.getPath();
		int kind = entry.getEntryKind();

		// complain if duplicate path
		if (!pathes.add(entryPath)){
			return new JavaModelStatus(IJavaModelStatusConstants.NAME_COLLISION, Util.bind("classpath.duplicateEntryPath", entryPath.toString())); //$NON-NLS-1$
		}
		// no further check if entry coincidates with project or output location
		if (entryPath.equals(projectPath)){
			// complain if self-referring project entry
			if (kind == IClasspathEntry.CPE_PROJECT){
				return new JavaModelStatus(IJavaModelStatusConstants.INVALID_PATH, Util.bind("classpath.cannotReferToItself", entryPath.toString()));//$NON-NLS-1$
			}
			continue;
		}
		if (entryPath.equals(outputLocation)) continue;


		// prevent nesting source entries in each other
		if (kind == IClasspathEntry.CPE_SOURCE 
				|| (kind == IClasspathEntry.CPE_LIBRARY && !org.eclipse.jdt.internal.compiler.util.Util.isArchiveFileName(entryPath.toString()))){
			for (int j = 0; j < classpath.length; j++){
				IClasspathEntry otherEntry = classpath[j];
				if (otherEntry == null) continue;
				int otherKind = otherEntry.getEntryKind();
				if (entry != otherEntry 
					&& (otherKind == IClasspathEntry.CPE_SOURCE 
							|| (otherKind == IClasspathEntry.CPE_LIBRARY 
									&& !org.eclipse.jdt.internal.compiler.util.Util.isArchiveFileName(otherEntry.getPath().toString())))){
					if (otherEntry.getPath().isPrefixOf(entryPath)){
						return new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind("classpath.cannotNestEntryInEntry", entryPath.toString(), otherEntry.getPath().toString())); //$NON-NLS-1$
					}
				}
			}
		}
		// prevent nesting output location inside entry
		if (entryPath.isPrefixOf(outputLocation)) {
			return new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind("classpath.cannotNestEntryInOutput",entryPath.toString(), outputLocation.toString())); //$NON-NLS-1$
		}

		// prevent nesting entry inside output location - when distinct from project or a source folder
		if (!allowNestingInOutput && outputLocation.isPrefixOf(entryPath)) {
			return new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind("classpath.cannotNestOutputInEntry", outputLocation.toString(), entryPath.toString())); //$NON-NLS-1$
		}
	}
	return JavaModelStatus.VERIFIED_OK;	
}

