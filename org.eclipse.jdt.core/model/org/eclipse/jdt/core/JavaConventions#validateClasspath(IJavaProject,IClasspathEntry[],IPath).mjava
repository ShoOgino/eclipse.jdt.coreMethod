	/**
	 * Validate the given classpath and output location, using the following rules:
	 * <ul>
	 *   <li> No duplicate path amongst classpath entries.
	 *   <li> Output location path is not null, it is absolute and located inside the project.
	 *   <li> A project cannot depend on itself directly.
	 *   <li> Source/library folders cannot be nested inside the binary output, and reciprocally.
	 *   <li> Source/library folders cannot be nested in each other.
	 *   <li> Output location must be nested inside project.
	 * </ul>
	 * TODO: Add rules for per-source-entry output location.
	 * 
	 *  Note that the classpath entries are not validated automatically. Only bound variables or containers are considered 
	 *  in the checking process (this allows to perform a consistency check on a classpath which has references to
	 *  yet non existing projects, folders, ...).
	 * 
	 * @param javaProject the given java project
	 * @param classpath a given classpath
	 * @param outputLocation a given output location
	 * @return a status object with code <code>IStatus.OK</code> if
	 *		the given classpath and output location are compatible, otherwise a status 
	 *		object indicating what is wrong with the classpath or output location
	 * @since 2.0
	 */
	public static IJavaModelStatus validateClasspath(IJavaProject javaProject, IClasspathEntry[] classpath, IPath projectOutputLocation) {
	
		IProject project = javaProject.getProject();
		IPath projectPath= project.getFullPath();
	
		/* validate output locations */
		if (projectOutputLocation == null) {
			return new JavaModelStatus(IJavaModelStatusConstants.NULL_PATH);
		}
		// tolerate null path, it will be reset to default
		int length = classpath == null ? 0 : classpath.length; 
		// collect other output locations
		int outputsLength = length+1;
		IPath[] outputLocations = new IPath[outputsLength];
		outputLocations[length] = projectOutputLocation;
		for (int i = 0; i < length; i++) {
			IClasspathEntry entry = classpath[i];
			IPath outputLocation = entry.getOutputLocation();
			if (outputLocation != null) {
				if (outputLocation.isAbsolute()) {
					if (!projectPath.isPrefixOf(outputLocation)) {
						return new JavaModelStatus(IJavaModelStatusConstants.PATH_OUTSIDE_PROJECT, javaProject, outputLocation.toString());
					} else {
						outputLocations[i] = outputLocation;
					}
				} else {
					return new JavaModelStatus(IJavaModelStatusConstants.RELATIVE_PATH, outputLocation);
				}
			}
		}
	
		boolean[] allowNestingInOutput = new boolean[length+1];
		boolean hasSource = false;
		boolean hasLibFolder = false;
		
		ArrayList resolvedEntries = new ArrayList();
		for (int i = 0 ; i < length; i++) {
			IClasspathEntry rawEntry = classpath[i];
			int kind = rawEntry.getEntryKind();
			switch(kind){
				
				case IClasspathEntry.CPE_VARIABLE :
					IClasspathEntry resolvedEntry = JavaCore.getResolvedClasspathEntry(rawEntry);
					if (resolvedEntry != null){
						// check if any source entries coincidates with a binary output - in which case nesting inside output is legal
						IPath resolvedPath = resolvedEntry.getPath();
						for (int j = 0; j < outputsLength; j++) {
							IPath outputLocation = outputLocations[j];
							if (outputLocation != null 
									&& resolvedPath.equals(outputLocation)) {
								allowNestingInOutput[j] = true;		
							}
						}
						resolvedEntries.add(resolvedEntry);
					}
					break;
	
				case IClasspathEntry.CPE_CONTAINER :
					try {
						IClasspathContainer container = JavaCore.getClasspathContainer(rawEntry.getPath(), javaProject);
						if (container != null){
							IClasspathEntry[] containerEntries = container.getClasspathEntries();
							if (containerEntries != null){
								for (int j = 0, containerLength = containerEntries.length; j < containerLength; j++){
									//resolvedEntry = JavaCore.getResolvedClasspathEntry(containerEntries[j]);
									resolvedEntry = containerEntries[j];
									if (resolvedEntry != null){
										// check if any source entries coincidates with a binary output - in which case nesting inside output is legal
										IPath resolvedPath = resolvedEntry.getPath();
										for (int k = 0; k < outputsLength; k++) {
											IPath outputLocation = outputLocations[k];
											if (outputLocation != null 
													&& resolvedPath.equals(outputLocation)) {
												allowNestingInOutput[k] = true;		
											}
										}
										resolvedEntries.add(resolvedEntry);
									}
								}
							}
						}
					} catch(JavaModelException e){
						return new JavaModelStatus(e);
					}
					break;
					
				case IClasspathEntry.CPE_SOURCE :
					hasSource = true;
				case IClasspathEntry.CPE_LIBRARY:
					if (kind != IClasspathEntry.CPE_SOURCE
							&& !org.eclipse.jdt.internal.compiler.util.Util.isArchiveFileName(rawEntry.getPath().lastSegment())) {
						hasLibFolder = true;
					}
				default :
					// check if any source entries coincidates with binary output - in which case nesting inside output is legal
					IPath rawPath = rawEntry.getPath();
					for (int j = 0; j < outputsLength; j++) {
						IPath outputLocation = outputLocations[j];
						if (outputLocation != null 
								&& rawPath.equals(outputLocation)) {
							allowNestingInOutput[j] = true;		
						}
					}
					resolvedEntries.add(rawEntry);
					break;
			}
		}
		if (!hasSource && !hasLibFolder) allowNestingInOutput[length] = true; // if no source and no lib folder, then allowed for project output
		
		length = resolvedEntries.size();
		classpath = new IClasspathEntry[length];
		resolvedEntries.toArray(classpath);
		
		HashSet pathes = new HashSet(length);
		
		// check all entries
		for (int i = 0 ; i < length; i++) {
			IClasspathEntry entry = classpath[i];
	
			if (entry == null) continue;
	
			IPath entryPath = entry.getPath();
			int kind = entry.getEntryKind();
	
			// complain if duplicate path
			if (!pathes.add(entryPath)){
				return new JavaModelStatus(IJavaModelStatusConstants.NAME_COLLISION, Util.bind("classpath.duplicateEntryPath", entryPath.toString())); //$NON-NLS-1$
			}
			// no further check if entry coincidates with project or output location
			if (entryPath.equals(projectPath)){
				// complain if self-referring project entry
				if (kind == IClasspathEntry.CPE_PROJECT){
					return new JavaModelStatus(IJavaModelStatusConstants.INVALID_PATH, Util.bind("classpath.cannotReferToItself", entryPath.toString()));//$NON-NLS-1$
				}
				continue;
			}
	
			// allow nesting source entries in each other as long as the outer entry excludes the inner one
			if (kind == IClasspathEntry.CPE_SOURCE 
					|| (kind == IClasspathEntry.CPE_LIBRARY && !org.eclipse.jdt.internal.compiler.util.Util.isArchiveFileName(entryPath.lastSegment()))){
				for (int j = 0; j < length; j++){
					IClasspathEntry otherEntry = classpath[j];
					if (otherEntry == null) continue;
					int otherKind = otherEntry.getEntryKind();
					IPath otherPath = otherEntry.getPath();
					if (entry != otherEntry 
						&& (otherKind == IClasspathEntry.CPE_SOURCE 
								|| (otherKind == IClasspathEntry.CPE_LIBRARY 
										&& !org.eclipse.jdt.internal.compiler.util.Util.isArchiveFileName(otherPath.lastSegment())))){
						if (otherPath.isPrefixOf(entryPath) 
								&& !otherPath.equals(entryPath)
								&& !Util.isExcluded(entryPath, ((ClasspathEntry)otherEntry).fullExclusionPatternChars())) {
							return new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind("classpath.cannotNestEntryInEntry", entryPath.toString(), otherEntry.getPath().toString())); //$NON-NLS-1$
						}
					}
				}
			}
			
			// prevent nesting output location inside entry
			for (int j = 0; j < outputsLength; j++) {
				IPath outputLocation = outputLocations[j];
				if (outputLocation != null) {
					if (!entryPath.equals(outputLocation) && entryPath.isPrefixOf(outputLocation)) {
						return new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind("classpath.cannotNestOutputInEntry", outputLocation.toString(), entryPath.toString())); //$NON-NLS-1$
					}
			
					// prevent nesting entry inside output location - when distinct from project or a source folder
					if (!allowNestingInOutput[j] && outputLocation.isPrefixOf(entryPath)) {
						return new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind("classpath.cannotNestEntryInOutput", entryPath.toString(), outputLocation.toString())); //$NON-NLS-1$
					}
				}
			}
		}
		return JavaModelStatus.VERIFIED_OK;	
	}

