	/**
	 * Validate the given classpath and output location, using the following rules:
	 * <ul>
	 *   <li> No duplicate path amongst classpath entries.
	 *   <li> Output location path is not null, it is absolute and located inside the project.
	 *   <li> A project cannot depend on itself directly.
	 *   <li> Source/library folders cannot be nested inside the binary output, and reciprocally.
	 *   <li> Source/library folders cannot be nested in each other.
	 *   <li> Output location must be nested inside project.
	 * </ul>
	 * 
	 *  Note that the classpath entries are not validated automatically. Only bound variables or containers are considered 
	 *  in the checking process (this allows to perform a consistency check on a classpath which has references to
	 *  yet non existing projects, folders, ...).
	 * 
	 * @param javaProject the given java project
	 * @param classpath a given classpath
	 * @param outputLocation a given output location
	 * @return a status object with code <code>IStatus.OK</code> if
	 *		the given classpath and output location are compatible, otherwise a status 
	 *		object indicating what is wrong with the classpath or output location
	 * @since 2.0
	 */
	public static IJavaModelStatus validateClasspath(IJavaProject javaProject, IClasspathEntry[] classpath, IPath outputLocation) {
	
		// TODO: allow nesting source folders (as long as nested one is excluded from the enclosing one)
		
		IProject project = javaProject.getProject();
		IPath projectPath= project.getFullPath();
	
		/* validate output location */
		if (outputLocation == null) {
			return new JavaModelStatus(IJavaModelStatusConstants.NULL_PATH);
		}
		if (outputLocation.isAbsolute()) {
			if (!projectPath.isPrefixOf(outputLocation)) {
				return new JavaModelStatus(IJavaModelStatusConstants.PATH_OUTSIDE_PROJECT, javaProject, outputLocation.toString());
			}
		} else {
			return new JavaModelStatus(IJavaModelStatusConstants.RELATIVE_PATH, outputLocation);
		}
	
		boolean allowNestingInOutput = false;
		boolean hasSource = false;
	
		// tolerate null path, it will be reset to default
		int length = classpath == null ? 0 : classpath.length; 
	
		ArrayList resolvedEntries = new ArrayList();
		for (int i = 0 ; i < length; i++) {
			IClasspathEntry rawEntry = classpath[i];
			switch(rawEntry.getEntryKind()){
				
				case IClasspathEntry.CPE_VARIABLE :
					IClasspathEntry resolvedEntry = JavaCore.getResolvedClasspathEntry(rawEntry);
					if (resolvedEntry != null){
						// check if any source entries coincidates with binary output - in which case nesting inside output is legal
						if (resolvedEntry.getPath().equals(outputLocation)) allowNestingInOutput = true;
						resolvedEntries.add(resolvedEntry);
					}
					break;
	
				case IClasspathEntry.CPE_CONTAINER :
					try {
						IClasspathContainer container = JavaCore.getClasspathContainer(rawEntry.getPath(), javaProject);
						if (container != null){
							IClasspathEntry[] containerEntries = container.getClasspathEntries();
							if (containerEntries != null){
								for (int j = 0, containerLength = containerEntries.length; j < containerLength; j++){
									//resolvedEntry = JavaCore.getResolvedClasspathEntry(containerEntries[j]);
									resolvedEntry = containerEntries[j];
									if (resolvedEntry != null){
										// check if any source entries coincidates with binary output - in which case nesting inside output is legal
										if (resolvedEntry.getPath().equals(outputLocation)) allowNestingInOutput = true;
										resolvedEntries.add(resolvedEntry);
									}
								}
							}
						}
					} catch(JavaModelException e){
						return new JavaModelStatus(e);
					}
					break;
					
				case IClasspathEntry.CPE_SOURCE :
					hasSource = true;
				default :
					// check if any source entries coincidates with binary output - in which case nesting inside output is legal
					if (rawEntry.getPath().equals(outputLocation)) allowNestingInOutput = true;
					resolvedEntries.add(rawEntry);
					break;
			}
		}
		if (!hasSource) allowNestingInOutput = true; // if no source, then allowed
		
		length = resolvedEntries.size();
		classpath = new IClasspathEntry[length];
		resolvedEntries.toArray(classpath);
		
		HashSet pathes = new HashSet(length);
		
		// check all entries
		for (int i = 0 ; i < length; i++) {
			IClasspathEntry entry = classpath[i];
	
			if (entry == null) continue;
	
			IPath entryPath = entry.getPath();
			int kind = entry.getEntryKind();
	
			// complain if duplicate path
			if (!pathes.add(entryPath)){
				return new JavaModelStatus(IJavaModelStatusConstants.NAME_COLLISION, Util.bind("classpath.duplicateEntryPath", entryPath.toString())); //$NON-NLS-1$
			}
			// no further check if entry coincidates with project or output location
			if (entryPath.equals(projectPath)){
				// complain if self-referring project entry
				if (kind == IClasspathEntry.CPE_PROJECT){
					return new JavaModelStatus(IJavaModelStatusConstants.INVALID_PATH, Util.bind("classpath.cannotReferToItself", entryPath.toString()));//$NON-NLS-1$
				}
				continue;
			}
	
			// prevent nesting source entries in each other
			if (kind == IClasspathEntry.CPE_SOURCE 
					|| (kind == IClasspathEntry.CPE_LIBRARY && !org.eclipse.jdt.internal.compiler.util.Util.isArchiveFileName(entryPath.lastSegment()))){
				for (int j = 0; j < classpath.length; j++){
					IClasspathEntry otherEntry = classpath[j];
					if (otherEntry == null) continue;
					int otherKind = otherEntry.getEntryKind();
					IPath otherPath = otherEntry.getPath();
					if (entry != otherEntry 
						&& (otherKind == IClasspathEntry.CPE_SOURCE 
								|| (otherKind == IClasspathEntry.CPE_LIBRARY 
										&& !org.eclipse.jdt.internal.compiler.util.Util.isArchiveFileName(otherPath.lastSegment())))){
						if (otherPath.isPrefixOf(entryPath) && !otherPath.equals(entryPath)) {
							return new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind("classpath.cannotNestEntryInEntry", entryPath.toString(), otherEntry.getPath().toString())); //$NON-NLS-1$
						}
					}
				}
			}
			// prevent nesting output location inside entry
			if (!entryPath.equals(outputLocation) && entryPath.isPrefixOf(outputLocation)) {
				return new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind("classpath.cannotNestEntryInOutput",entryPath.toString(), outputLocation.toString())); //$NON-NLS-1$
			}
	
			// prevent nesting entry inside output location - when distinct from project or a source folder
			if (!allowNestingInOutput && outputLocation.isPrefixOf(entryPath)) {
				return new JavaModelStatus(IJavaModelStatusConstants.INVALID_CLASSPATH, Util.bind("classpath.cannotNestOutputInEntry", outputLocation.toString(), entryPath.toString())); //$NON-NLS-1$
			}
		}
		return JavaModelStatus.VERIFIED_OK;	
	}

