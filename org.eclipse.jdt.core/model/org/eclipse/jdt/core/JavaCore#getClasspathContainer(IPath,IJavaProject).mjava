	/** 
	 * Answers the set of classpath entries corresponding to a given container for a specific project.
	 * Indeed, classpath containers can have a different meaning in different project, according to the behavior
	 * of the <code>ClasspathContainerInitializer</code> which got involved for resolving this container.
	 * In case this container path could not be resolved, then will answer <code>null</code>.
	 * <p>
	 * Both the container path and the project context are supposed to be non-null.
	 * <p>
	 * The set of entries associated with a classpath container may contain any of the following:
	 * <ul>
	 * <li> source entries (<code>CPE_SOURCE</code>) </li>
	 * <li> library entries (<code>CPE_LIBRARY</code>) </li>
	 * <li> project entries (<code>CPE_PROJECT</code>) </li>
	 * <li> variable entries (<code>CPE_VARIABLE</code>), note that these are not automatically resolved </li>
	 * </ul>
	 * A classpath container cannot reference further classpath containers.
	 * <p>
	 * @param containerPath - the name of the container which needs to be resolved
	 * @param changeScope - a specific project (IJavaProject) in which the container is being resolved
	 * 
	 * @exception JavaModelException if an exception occurred while resolving the container, or if the resolved container
	 *   contains illegal entries (further container entries or null entries).	 
	 * 
	 * @since 2.0
	 */
	public static IClasspathContainer getClasspathContainer(IPath containerPath, IJavaProject project) throws JavaModelException {

		Map projectContainers = (Map)JavaModelManager.Containers.get(project);
		if (projectContainers == null){
			projectContainers = new HashMap(1);
			JavaModelManager.Containers.put(project, projectContainers);
		}
		IClasspathContainer container = (IClasspathContainer)projectContainers.get(containerPath);

		if (container == JavaModelManager.ContainerInitializationInProgress) return null; // break cycle
		if (container == null){
			ClasspathContainerInitializer initializer = JavaModelManager.getClasspathContainerInitializer(containerPath.segment(0));
			if (initializer != null){
				projectContainers.put(containerPath, JavaModelManager.ContainerInitializationInProgress); // avoid initialization cycles
				boolean ok = false;
				try {
					initializer.initialize(containerPath, project);
					if (container != null){
						IClasspathEntry[] entries = container.getClasspathEntries();
						// validation - no nested classpath container
						if (entries != null){
							for (int i = 0; i < entries.length; i++){
								IClasspathEntry entry = entries[i];
								if (entry == null || entry.getEntryKind() == IClasspathEntry.CPE_CONTAINER){
									throw new JavaModelException(
										new JavaModelStatus(
											IJavaModelStatusConstants.INVALID_CP_CONTAINER_ENTRY,
											containerPath.toString()));
								}
							}
						}
					}
					ok = true;
				} catch(CoreException e){
					throw new JavaModelException(e);
				} finally {
					if (!ok) JavaModelManager.Containers.put(project, null); // flush cache
				}
				if (container != null){
					projectContainers.put(containerPath, container);
				}
				if (JavaModelManager.CP_RESOLVE_VERBOSE){
					System.out.print("CPContainer INIT - after resolution: " + containerPath + " --> "); //$NON-NLS-2$//$NON-NLS-1$
					if (container != null){
						System.out.print("container: "+container.getDescription()+" {"); //$NON-NLS-2$//$NON-NLS-1$
						IClasspathEntry[] entries = container.getClasspathEntries();
						if (entries != null){
							for (int i = 0; i < entries.length; i++){
								if (i > 0) System.out.println(", ");//$NON-NLS-1$
								System.out.println(entries[i]);
							}
						}
						System.out.println("}");//$NON-NLS-1$
					} else {
						System.out.println("{unbound}");//$NON-NLS-1$
					}
				}
			}
		}
		return container;			
	}

