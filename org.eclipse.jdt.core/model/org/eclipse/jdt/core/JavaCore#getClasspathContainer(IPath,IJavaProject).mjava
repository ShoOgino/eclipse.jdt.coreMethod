	/** 
	 * Answers the project specific value for a given classpath container.
	 * In case this container path could not be resolved, then will answer <code>null</code>.
	 * Both the container path and the project context are supposed to be non-null.
	 * <p>
	 * The containerPath is a formed by a first ID segment followed with extra segments, which can be 
	 * used as additional hints for resolution. If no container was ever recorded for this container path 
	 * onto this project (using <code>setClasspathContainer</code>, then a 
	 * <code>ClasspathContainerInitializer</code> will be activated if any was registered for this container 
	 * ID onto the extension point "org.eclipse.jdt.core.classpathContainerInitializer".
	 * <p>
	 * There is no assumption that the returned container must answer the exact same containerPath
	 * when requested <code>IClasspathContainer#getPath</code>. 
	 * Indeed, the containerPath is just an indication for resolving it to an actual container object.
	 * <p>
	 * Classpath container values are persisted locally to the workspace, but 
	 * are not preserved from a session to another. It is thus highly recommended to register a 
	 * <code>ClasspathContainerInitializer</code> for each referenced container 
	 * (through the extension point "org.eclipse.jdt.core.ClasspathContainerInitializer").
	 * <p>
	 * @param containerPath the name of the container, which needs to be resolved
	 * @param project a specific project in which the container is being resolved
	 * @return the corresponding classpath container or <code>null</code> if unable to find one.
	 * 
	 * @exception JavaModelException if an exception occurred while resolving the container, or if the resolved container
	 *   contains illegal entries (contains CPE_CONTAINER entries or null entries).	 
	 * 
	 * @see ClasspathContainerInitializer
	 * @see IClasspathContainer
	 * @see #setClasspathContainer(IPath, IJavaProject[], IClasspathContainer[], IProgressMonitor)
	 * @since 2.0
	 */
	public static IClasspathContainer getClasspathContainer(final IPath containerPath, final IJavaProject project) throws JavaModelException {

		IClasspathContainer container = JavaModelManager.getJavaModelManager().containerGet(project, containerPath);
		if (container == JavaModelManager.CONTAINER_INITIALIZATION_IN_PROGRESS) return null; // break cycle

		if (container == null){
			final ClasspathContainerInitializer initializer = JavaCore.getClasspathContainerInitializer(containerPath.segment(0));
			if (initializer != null){
				if (JavaModelManager.CP_RESOLVE_VERBOSE){
					Util.verbose(
						"CPContainer INIT - triggering initialization\n" + //$NON-NLS-1$
						"	project: " + project.getElementName() + '\n' + //$NON-NLS-1$
						"	container path: " + containerPath + '\n' + //$NON-NLS-1$
						"	initializer: " + initializer + '\n' + //$NON-NLS-1$
						"	invocation stack trace:"); //$NON-NLS-1$
					new Exception("<Fake exception>").printStackTrace(System.out); //$NON-NLS-1$
				}
				JavaModelManager.getJavaModelManager().containerPut(project, containerPath, JavaModelManager.CONTAINER_INITIALIZATION_IN_PROGRESS); // avoid initialization cycles
				boolean ok = false;
				try {
					// wrap initializer call with Safe runnable in case initializer would be causing some grief
					Platform.run(new ISafeRunnable() {
						public void handleException(Throwable exception) {
							Util.log(exception, "Exception occurred in classpath container initializer: "+initializer); //$NON-NLS-1$
						}
						public void run() throws Exception {
							initializer.initialize(containerPath, project);
						}
					});
					
					// retrieve value (if initialization was successful)
					container = JavaModelManager.getJavaModelManager().containerGet(project, containerPath);
					if (container == JavaModelManager.CONTAINER_INITIALIZATION_IN_PROGRESS) return null; // break cycle
					ok = true;
				} catch (RuntimeException e) {
					if (JavaModelManager.CP_RESOLVE_VERBOSE) {
						e.printStackTrace();
					}
					throw e;
				} catch (Error e) {
					if (JavaModelManager.CP_RESOLVE_VERBOSE) {
						e.printStackTrace();
					}
					throw e;
				} finally {
					if (!ok) {
						JavaModelManager.getJavaModelManager().containerPut(project, containerPath, null); // flush cache
						if (JavaModelManager.CP_RESOLVE_VERBOSE) {
							Util.verbose(
								"CPContainer INIT - FAILED\n" + //$NON-NLS-1$
								"	project: " + project.getElementName() + '\n' + //$NON-NLS-1$
								"	container path: " + containerPath + '\n' + //$NON-NLS-1$
								"	initializer: " + initializer); //$NON-NLS-1$
						}
					}
				}
				if (JavaModelManager.CP_RESOLVE_VERBOSE){
					StringBuffer buffer = new StringBuffer();
					buffer.append("CPContainer INIT - after resolution\n"); //$NON-NLS-1$
					buffer.append("	project: " + project.getElementName() + '\n'); //$NON-NLS-1$
					buffer.append("	container path: " + containerPath + '\n'); //$NON-NLS-1$
					if (container != null){
						buffer.append("	container: "+container.getDescription()+" {\n"); //$NON-NLS-2$//$NON-NLS-1$
						IClasspathEntry[] entries = container.getClasspathEntries();
						if (entries != null){
							for (int i = 0; i < entries.length; i++){
								buffer.append("		" + entries[i] + '\n'); //$NON-NLS-1$
							}
						}
						buffer.append("	}");//$NON-NLS-1$
					} else {
						buffer.append("	container: {unbound}");//$NON-NLS-1$
					}
					Util.verbose(buffer.toString());
				}
			} else {
				if (JavaModelManager.CP_RESOLVE_VERBOSE){
					Util.verbose(
						"CPContainer INIT - no initializer found\n" + //$NON-NLS-1$
						"	project: " + project.getElementName() + '\n' + //$NON-NLS-1$
						"	container path: " + containerPath); //$NON-NLS-1$
				}
			}
		}
		return container;			
	}

