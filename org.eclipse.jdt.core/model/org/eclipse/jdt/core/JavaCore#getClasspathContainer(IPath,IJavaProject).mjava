	/** 
	 * Answers the project specific value for a given classpath container.
	 * In case this container path could not be resolved, then will answer <code>null</code>.
	 * Both the container path and the project context are supposed to be non-null.
	 * <p>
	 * The containerPath is a 2-segments path, formed by an ID segment followed with a clue segment 
	 * that may be used for resolution. If no container was ever recorded for this container path onto this project
	 * (using <code>setClasspathContainer</code>, then a <code>ClasspathContainerInitializer</code>
	 * will be activated if any was registered for this container ID onto the extension point
	 * "org.eclipse.jdt.core.classpathContainerInitializer".
	 * <p>
	 * There is no assumption that the returned container must answer the exact same containerPath
	 * when requested <code>IClasspathContainer#getPath</code>. 
	 * Indeed, the containerPath is just an indication for resolving it to an actual container object.
	 * <p>
	 * Classpath container values are persisted locally to the workspace, but 
	 * are not preserved from a session to another. It is thus highly recommended to register a 
	 * <code>ClasspathContainerInitializer</code> for each referenced container 
	 * (through the extension point "org.eclipse.jdt.core.ClasspathContainerInitializer").
	 * <p>
	 * @param containerPath - the name of the container which needs to be resolved
	 * @param project - a specific project in which the container is being resolved
	 * @return IClasspathContainer - the corresponding classpath container or <code>null</code> if unable to find one.
	 * 
	 * @exception JavaModelException if an exception occurred while resolving the container, or if the resolved container
	 *   contains illegal entries (contains CPE_CONTAINER entries or null entries).	 
	 * 
	 * @see ClasspathContainerInitializer
	 * @see IClasspathContainer
	 * @see #setClasspathContainer(IPath, IJavaProject[], IClasspathContainer[], IProgressMonitor)
	 * @since 2.0
	 */
	public static IClasspathContainer getClasspathContainer(IPath containerPath, IJavaProject project) throws JavaModelException {

		Map projectContainers = (Map)JavaModelManager.Containers.get(project);
		if (projectContainers == null){
			projectContainers = new HashMap(1);
			JavaModelManager.Containers.put(project, projectContainers);
		}
		IClasspathContainer container = (IClasspathContainer)projectContainers.get(containerPath);

		if (container == JavaModelManager.ContainerInitializationInProgress) return null; // break cycle
		if (container == null){
			ClasspathContainerInitializer initializer = JavaModelManager.getClasspathContainerInitializer(containerPath.segment(0));
			if (initializer != null){
				projectContainers.put(containerPath, JavaModelManager.ContainerInitializationInProgress); // avoid initialization cycles
				boolean ok = false;
				try {
					// activate initializer
					initializer.initialize(containerPath, project);
					
					// retrieve value (if initialization was successful)
					container = (IClasspathContainer)projectContainers.get(containerPath);
					if (container != null){
						IClasspathEntry[] entries = container.getClasspathEntries();
						// validation - no nested classpath container
						if (entries != null){
							for (int i = 0; i < entries.length; i++){
								IClasspathEntry entry = entries[i];
								if (entry == null || entry.getEntryKind() == IClasspathEntry.CPE_CONTAINER){
									throw new JavaModelException(
										new JavaModelStatus(
											IJavaModelStatusConstants.INVALID_CP_CONTAINER_ENTRY,
											containerPath.toString()));
								}
							}
						}
					}
					ok = true;
				} catch(CoreException e){
					throw new JavaModelException(e);
				} finally {
					if (!ok) JavaModelManager.Containers.put(project, null); // flush cache
				}
				if (container != null){
					projectContainers.put(containerPath, container);
				}
				if (JavaModelManager.CP_RESOLVE_VERBOSE){
					System.out.print("CPContainer INIT - after resolution: " + containerPath + " --> "); //$NON-NLS-2$//$NON-NLS-1$
					if (container != null){
						System.out.print("container: "+container.getDescription()+" {"); //$NON-NLS-2$//$NON-NLS-1$
						IClasspathEntry[] entries = container.getClasspathEntries();
						if (entries != null){
							for (int i = 0; i < entries.length; i++){
								if (i > 0) System.out.println(", ");//$NON-NLS-1$
								System.out.println(entries[i]);
							}
						}
						System.out.println("}");//$NON-NLS-1$
					} else {
						System.out.println("{unbound}");//$NON-NLS-1$
					}
				}
			}
		}
		return container;			
	}

