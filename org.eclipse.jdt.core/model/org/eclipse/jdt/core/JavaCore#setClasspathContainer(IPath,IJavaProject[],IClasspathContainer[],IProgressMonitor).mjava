	/** 
	 * Bind a container reference path to some actual containers (<code>IClasspathContainer</code>).
	 * This API must be invoked whenever changes in container need to be reflected onto the JavaModel.
	 * Containers can have distinct values in different projects, therefore this API considers a
	 * set of projects with their respective containers.
	 * <p>
	 * <code>containerPath</code> is the path under which these values can be referenced through
	 * container classpath entries (<code>IClasspathEntry#CPE_CONTAINER</code>). A container path 
	 * is formed by a first ID segment followed with extra segments, which can be used as additional hints
	 * for the resolution. The container ID is used to identify a <code>ClasspathContainerInitializer</code> 
	 * registered on the extension point "org.eclipse.jdt.core.classpathContainerInitializer".
	 * <p>
	 * There is no assumption that each individual container value passed in argument 
	 * (<code>respectiveContainers</code>) must answer the exact same path when requested 
	 * <code>IClasspathContainer#getPath</code>. 
	 * Indeed, the containerPath is just an indication for resolving it to an actual container object. It can be 
	 * delegated to a <code>ClasspathContainerInitializer</code>, which can be activated through the extension
	 * point "org.eclipse.jdt.core.ClasspathContainerInitializer"). 
	 * <p>
	 * In reaction to changing container values, the JavaModel will be updated to reflect the new
	 * state of the updated container. 
	 * <p>
	 * This functionality cannot be used while the resource tree is locked.
	 * <p>
	 * Classpath container values are persisted locally to the workspace, but 
	 * are not preserved from a session to another. It is thus highly recommended to register a 
	 * <code>ClasspathContainerInitializer</code> for each referenced container 
	 * (through the extension point "org.eclipse.jdt.core.ClasspathContainerInitializer").
	 * <p>
	 * 
	 * @param containerPath - the name of the container reference, which is being updated
	 * @param affectedProjects - the set of projects for which this container is being bound
	 * @param respectiveContainers - the set of respective containers for the affected projects
	 * @param monitor a monitor to report progress
	 * 
	 * @see ClasspathContainerInitializer
	 * @see #getClasspathContainer(IPath, IJavaProject)
	 * @see IClasspathContainer
	 * @since 2.0
	 */
	public static void setClasspathContainer(IPath containerPath, IJavaProject[] affectedProjects, IClasspathContainer[] respectiveContainers, IProgressMonitor monitor) throws JavaModelException {

		Assert.isTrue(affectedProjects.length == respectiveContainers.length, Util.bind("classpath.mismatchProjectsContainers" )); //$NON-NLS-1$

		if (monitor != null && monitor.isCanceled()) return;

		int projectLength = affectedProjects.length;
		JavaModelManager manager = JavaModelManager.getJavaModelManager();
		IClasspathEntry[][] oldResolvedPaths = new IClasspathEntry[projectLength][];

		// filter out unmodified project containers
		int remaining = 0;
		for (int i = 0; i < projectLength; i++){

			if (monitor != null && monitor.isCanceled()) return;

			IJavaProject affectedProject = affectedProjects[i];
			IClasspathContainer newContainer = respectiveContainers[i];
			
			boolean found = false;
			if (affectedProject.getProject().exists()){
				IClasspathEntry[] rawClasspath = affectedProject.getRawClasspath();
				for (int j = 0, cpLength = rawClasspath.length; j <cpLength; j++) {
					IClasspathEntry entry = rawClasspath[j];
					if (entry.getEntryKind() == IClasspathEntry.CPE_CONTAINER && entry.getPath().equals(containerPath)){
						found = true;
						break;
					}
				}
			}
			if (!found){
				affectedProjects[i] = null; // filter out this project - does not reference the container path
			}
			
			Map perProjectContainers = (Map)JavaModelManager.Containers.get(affectedProject);
			if (perProjectContainers == null){
				perProjectContainers = new HashMap();
				JavaModelManager.Containers.put(affectedProject, perProjectContainers);
			} else {
				IClasspathContainer oldContainer = (IClasspathContainer) perProjectContainers.get(containerPath);
				if (oldContainer != null && oldContainer.equals(respectiveContainers[i])){
					affectedProjects[i] = null; // filter out this project - container did not change
					continue;
				}
			}
			if (found){
				remaining++;
				oldResolvedPaths[i] = affectedProject.getResolvedClasspath(true);
			}
			perProjectContainers.put(containerPath, newContainer);
		}
		
		if (remaining == 0) return;
		
		// trigger model refresh
		boolean wasFiring = manager.isFiring();
		int count = 0;
		try {
			if (wasFiring)
				manager.stopDeltas();
				
			for(int i = 0; i < projectLength; i++){

				if (monitor != null && monitor.isCanceled()) return;

				JavaProject affectedProject = (JavaProject)affectedProjects[i];
				if (affectedProject == null) continue; // was filtered out
				
				if (++count == remaining) { // re-enable firing for the last operation
					if (wasFiring) {
						wasFiring = false;
						manager.startDeltas();
					}
				}
			
				// force a refresh of the affected project (will compute deltas)
				affectedProject.setRawClasspath(
						affectedProject.getRawClasspath(),
						SetClasspathOperation.ReuseOutputLocation,
						monitor,
						!JavaModelManager.IsResourceTreeLocked, // can save resources
						!JavaModelManager.IsResourceTreeLocked && affectedProject.getWorkspace().isAutoBuilding(), // force save?
						oldResolvedPaths[i],
						remaining == 1, // no individual cycle check if more than 1 project
						false); // updating - no validation
			}
			if (remaining > 1){
				// use workspace runnable so as to allow marker creation - workaround bug 14733
//				ResourcesPlugin.getWorkspace().run(
//					new IWorkspaceRunnable() {
//						public void run(IProgressMonitor monitor) throws CoreException {
							JavaProject.updateAllCycleMarkers(); // update them all at once
//						}
//					}, 
//					monitor);					
			}
		} finally {
			if (wasFiring) {
				manager.startDeltas();
				// in case of exception traversing, deltas may be fired only in the next #fire() iteration
			}
		}
					
	}

