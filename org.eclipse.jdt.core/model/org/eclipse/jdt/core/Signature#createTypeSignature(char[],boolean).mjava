/**
 * Creates a new type signature from the given type name encoded as a character
 * array. This method is equivalent to
 * <code>createTypeSignature(new String(typeName),isResolved)</code>, although
 * more efficient for callers with character arrays rather than strings.
 *
 * @param typeName the possibly qualified type name
 * @param isResolved <code>true</code> if the type name is to be considered
 *   resolved (for example, a type name from a binary class file), and 
 *   <code>false</code> if the type name is to be considered unresolved
 *   (for example, a type name found in source code)
 * @return the encoded type signature
 * @see #createTypeSignature(java.lang.String,boolean)
 */
public static String createTypeSignature(char[] typeName, boolean isResolved) {
	int len = typeName.length;
	if (typeName[len - 1] != ']') {
		switch (len) {
			case 3 :
				if (typeName[0] == 'i' && typeName[1] == 'n' && typeName[2] == 't')
					return SIG_INT;
				break;
			case 4 :
				if (typeName[0] == 'v' && typeName[1] == 'o' && typeName[2] == 'i' && typeName[3] == 'd')
					return SIG_VOID;
				break;
			case 6 :
				if (typeName[0] == 'S' && typeName[1] == 't' && typeName[2] == 'r' && typeName[3] == 'i' && typeName[4] == 'n' && typeName[5] == 'g')
					if (!isResolved) return "QString;"; //$NON-NLS-1$
				break;
			case 7 :
				if (typeName[0] == 'b' && typeName[1] == 'o' && typeName[2] == 'o' && typeName[3] == 'l' && typeName[4] == 'e' && typeName[5] == 'a' && typeName[6] == 'n')
					return SIG_BOOLEAN;
				break;
		}
	}
	return createTypeSignature(new String(typeName), isResolved);
}

