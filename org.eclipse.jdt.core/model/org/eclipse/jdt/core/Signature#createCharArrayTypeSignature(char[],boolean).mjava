/**
 * Creates a new type signature from the given type name encoded as a character
 * array. This method is equivalent to
 * <code>createTypeSignature(new String(typeName),isResolved).toCharArray()</code>, although
 * more efficient for callers with character arrays rather than strings. If the 
 * type name is qualified, then it is expected to be dot-based.
 *
 * @param typeName the possibly qualified type name
 * @param isResolved <code>true</code> if the type name is to be considered
 *   resolved (for example, a type name from a binary class file), and 
 *   <code>false</code> if the type name is to be considered unresolved
 *   (for example, a type name found in source code)
 * @return the encoded type signature
 * @see #createTypeSignature(java.lang.String,boolean)
 * 
 * @since 2.0
 */
public static char[] createCharArrayTypeSignature(char[] typeName, boolean isResolved) {
	// TODO (jerome) - needs to be reworked for parameterized types like List<String[]>[]
	
	if (typeName == null) throw new IllegalArgumentException("null"); //$NON-NLS-1$
	int length = typeName.length;
	if (length == 0) throw new IllegalArgumentException(new String(typeName));

	int arrayCount = CharOperation.occurencesOf('[', typeName);
	char[] sig;
	
	switch (typeName[0]) {
		// primitive type?
		case 'b' :
			if (checkPrimitiveType(BOOLEAN, typeName)) {
				sig = new char[arrayCount+1];
				sig[arrayCount] = C_BOOLEAN;
				break;
			} else if (checkPrimitiveType(BYTE, typeName)) {
				sig = new char[arrayCount+1];
				sig[arrayCount] = C_BYTE;
				break;
			}
		case 'c':
			if (checkPrimitiveType(CHAR, typeName)) {
				sig = new char[arrayCount+1];
				sig[arrayCount] = C_CHAR;
				break;
			}
		case 'd':
			if (checkPrimitiveType(DOUBLE, typeName)) {
				sig = new char[arrayCount+1];
				sig[arrayCount] = C_DOUBLE;
				break;
			}
		case 'f':
			if (checkPrimitiveType(FLOAT, typeName)) {
				sig = new char[arrayCount+1];
				sig[arrayCount] = C_FLOAT;
				break;
			}
		case 'i':
			if (checkPrimitiveType(INT, typeName)) {
				sig = new char[arrayCount+1];
				sig[arrayCount] = C_INT;
				break;
			}
		case 'l':
			if (checkPrimitiveType(LONG, typeName)) {
				sig = new char[arrayCount+1];
				sig[arrayCount] = C_LONG;
				break;
			}
		case 's':
			if (checkPrimitiveType(SHORT, typeName)) {
				sig = new char[arrayCount+1];
				sig[arrayCount] = C_SHORT;
				break;
			}
		case 'v':
			if (checkPrimitiveType(VOID, typeName)) {
				sig = new char[arrayCount+1];
				sig[arrayCount] = C_VOID;
				break;
			}
		default:
			// non primitive type
			int sigLength = arrayCount + 1 + length + 1; // for example '[[[Ljava.lang.String;'
			sig = new char[sigLength];
			int sigIndex = arrayCount+1; // index in sig
			int startID = 0; // start of current ID in typeName
			int index = 0; // index in typeName
			while (index < length) {
				char currentChar = typeName[index];
				switch (currentChar) {
					case '.':
						if (startID == -1) throw new IllegalArgumentException(new String(typeName));
						if (startID < index) {
							sig = CharOperation.append(sig, sigIndex, typeName, startID, index);
							sigIndex += index-startID;
						}
						sig[sigIndex++] = C_DOT;
						index++;
						startID = index;
						break;
					case '[':
						if (startID != -1) {
							if (startID < index) {
								sig = CharOperation.append(sig, sigIndex, typeName, startID, index);
								sigIndex += index-startID;
							}
							startID = -1; // no more id after []
						}
						index++;
						break;
					default :
						if (startID != -1 && CharOperation.isWhitespace(currentChar)) {
							if (startID < index) {
								sig = CharOperation.append(sig, sigIndex, typeName, startID, index);
								sigIndex += index-startID;
							}
							startID = index+1;
						}
						index++;
						break;
				}
			}
			// last id
			if (startID != -1 && startID < index) {
				sig = CharOperation.append(sig, sigIndex, typeName, startID, index);
				sigIndex += index-startID;
			}
			
			// add L (or Q) at the beigininig and ; at the end
			sig[arrayCount] = isResolved ? C_RESOLVED : C_UNRESOLVED;
			sig[sigIndex++] = C_NAME_END;
			
			// resize if needed
			if (sigLength > sigIndex) {
				System.arraycopy(sig, 0, sig = new char[sigIndex], 0, sigIndex);
			}
	}

	// add array info
	for (int i = 0; i < arrayCount; i++) {
		sig[i] = C_ARRAY;
	}
	
	return sig;
}

