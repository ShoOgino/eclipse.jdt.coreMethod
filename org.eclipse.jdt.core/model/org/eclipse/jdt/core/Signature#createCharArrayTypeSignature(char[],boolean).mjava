/**
 * Creates a new type signature from the given type name encoded as a character
 * array. This method is equivalent to
 * <code>createTypeSignature(new String(typeName),isResolved).toCharArray()</code>, although
 * more efficient for callers with character arrays rather than strings. If the 
 * type name is qualified, then it is expected to be dot-based.
 *
 * @param typeName the possibly qualified type name
 * @param isResolved <code>true</code> if the type name is to be considered
 *   resolved (for example, a type name from a binary class file), and 
 *   <code>false</code> if the type name is to be considered unresolved
 *   (for example, a type name found in source code)
 * @return the encoded type signature
 * @see #createTypeSignature(java.lang.String,boolean)
 * 
 * @since 2.0
 */
public static char[] createCharArrayTypeSignature(char[] typeName, boolean isResolved) {

	if (typeName == null) throw new IllegalArgumentException(new String(typeName));
	int length = typeName.length;
	if (length == 0) throw new IllegalArgumentException(new String(typeName));

	boolean primitive = false;
	char primitiveSig = ' ';
	int index = 0;
	
	// primitive type?
	switch (typeName[index]) {
		case 'b' :
			if (CharOperation.fragmentEquals(BOOLEAN, typeName, index, true)) {
				primitiveSig = C_BOOLEAN;
				index += BOOLEAN.length;	
				primitive = true;			
				break;
			} else if (CharOperation.fragmentEquals(BYTE, typeName, index, true)) {
				primitiveSig = C_BYTE;
				index += BYTE.length;				
				primitive = true;			
				break;
			}
		case 'c':
			if (CharOperation.fragmentEquals(CHAR, typeName, index, true)) {
				primitiveSig = C_CHAR;
				index += CHAR.length;				
				primitive = true;			
				break;
			}
		case 'd':
			if (CharOperation.fragmentEquals(DOUBLE, typeName, index, true)) {
				primitiveSig = C_DOUBLE;
				index += DOUBLE.length;				
				primitive = true;			
				break;
			}
		case 'f':
			if (CharOperation.fragmentEquals(FLOAT, typeName, index, true)) {
				primitiveSig = C_FLOAT;
				index += FLOAT.length;				
				primitive = true;			
				break;
			}
		case 'i':
			if (CharOperation.fragmentEquals(INT, typeName, index, true)) {
				primitiveSig = C_INT;
				index += INT.length;				
				primitive = true;			
				break;
			}
		case 'l':
			if (CharOperation.fragmentEquals(LONG, typeName, index, true)) {
				primitiveSig = C_LONG;
				index += LONG.length;				
				primitive = true;			
				break;
			}
		case 's':
			if (CharOperation.fragmentEquals(SHORT, typeName, index, true)) {
				primitiveSig = C_SHORT;
				index += SHORT.length;				
				primitive = true;			
				break;
			}
		case 'v':
			if (CharOperation.fragmentEquals(VOID, typeName, index, true)) {
				primitiveSig = C_VOID;
				index += SHORT.length;				
				primitive = true;			
				break;
			}
	}

	// non primitive type and array count
	char[] sig = primitive ? null : new char[length];
	int sigIndex = 0;
	int arrayCount = 0;
	int startID = primitive ? -1 : 0;
	while (index < length) {
		char currentChar = typeName[index];
		switch (currentChar) {
			case '.':
				if (startID == -1) throw new IllegalArgumentException(new String(typeName));
				if (startID < index) {
					sig = CharOperation.append(sig, sigIndex, typeName, startID, index);
					sigIndex += index-startID;
				}
				int sigLength = sig.length;
				if (sigIndex >= sigLength) {
					System.arraycopy(sig, 0, sig = new char[sigLength*2], 0, sigLength);
				}
				sig[sigIndex++] = C_DOT;
				index++;
				startID = index;
				break;
			case '[':
				arrayCount++;
				if (startID != -1) {
					if (startID < index) {
						sig = CharOperation.append(sig, sigIndex, typeName, startID, index);
						sigIndex += index-startID;
					}
					startID = -1; // no more id after []
				}
				index++;
				break;
			default :
				if (startID != -1 && CharOperation.isWhitespace(currentChar)) {
					if (startID < index) {
						sig = CharOperation.append(sig, sigIndex, typeName, startID, index);
						sigIndex += index-startID;
					}
					startID = index+1;
				}
				index++;
				break;
		}
	}
	// last id
	if (startID != -1 && startID < index) {
		sig = CharOperation.append(sig, sigIndex, typeName, startID, index);
		sigIndex += index-startID;
	}
	
	// build result
	char[] result;
	if (primitive) {
		result = new char[arrayCount+1];
		result[arrayCount] = primitiveSig;
	} else {
		int resultLength = arrayCount + 1 + sigIndex + 1; // e.g. '[[[Ljava.lang.String;'
		result = new char[resultLength];
		System.arraycopy(sig, 0, result, arrayCount + 1, sigIndex);
		result[arrayCount] = isResolved ? C_RESOLVED : C_UNRESOLVED;
		result[resultLength-1] = C_NAME_END;
	}
	for (int i = 0; i < arrayCount; i++) {
		result[i] = C_ARRAY;
	}
	return result;
}

