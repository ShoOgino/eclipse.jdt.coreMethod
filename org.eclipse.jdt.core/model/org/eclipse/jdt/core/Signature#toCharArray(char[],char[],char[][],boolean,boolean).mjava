/**
 * Converts the given method signature to a readable form. The method signature is expected to
 * be dot-based.
 * <p>
 * For example:
 * <pre>
 * <code>
 * toString("([Ljava.lang.String;)V", "main", new String[] {"args"}, false, true) -> "void main(String[] args)"
 * </code>
 * </pre>
 * </p>
 * 
 * @param methodSignature the method signature to convert
 * @param methodName the name of the method to insert in the result, or 
 *   <code>null</code> if no method name is to be included
 * @param parameterNames the parameter names to insert in the result, or 
 *   <code>null</code> if no parameter names are to be included; if supplied,
 *   the number of parameter names must match that of the method signature
 * @param fullyQualifyTypeNames <code>true</code> if type names should be fully
 *   qualified, and <code>false</code> to use only simple names
 * @param includeReturnType <code>true</code> if the return type is to be
 *   included
 * @return the char array representation of the method signature
 * 
 * @since 2.0
 */
public static char[] toCharArray(char[] methodSignature, char[] methodName, char[][] parameterNames, boolean fullyQualifyTypeNames, boolean includeReturnType) {
	int length = parameterNames.length;
	String[] parameters = new String[length];
	for (int i=0;i<length;i++) {
		parameters[i] = new String(parameterNames[i]);
	}
	return toString(new String(methodSignature), new String(methodName), parameters, fullyQualifyTypeNames, includeReturnType).toCharArray();
	/*
	
	try {
		int sigLength = methodSignature.length;
		
		// compute result length
		
		// method signature
		int lastParen = -1;
		int resultLength = 0;
		signature: for (int i = 0; i < sigLength; i++) {
			switch (methodSignature[i]) {
				case C_ARRAY :
					resultLength += 2;
					break;
				case C_BOOLEAN :
					resultLength += 7; // boolean
					break;
				case C_BYTE :
					resultLength += 4; // byte
					break;
				case C_CHAR :
					resultLength += 4; // char
					break;
				case C_DOUBLE :
					resultLength += 6; // double
					break;
				case C_FLOAT :
					resultLength += 5; // float
					break;
				case C_INT :
					resultLength += 3; // int
					break;
				case C_LONG :
					resultLength += 4; // long
					break;
				case C_SHORT :
					resultLength += 5; // short
					break;
				case C_VOID :
					resultLength += 4; // void
					break;
				case C_RESOLVED :
				case C_UNRESOLVED :
					int end = CharOperation.indexOf(C_SEMICOLON, methodSignature, i);
					if (end == -1) throw new IllegalArgumentException();
					int start;
					if (fullyQualifyTypeNames) {
						start = i+1;
					} else {
						start = CharOperation.lastIndexOf(C_DOT, methodSignature, i, end);
						if (start == -1) start = i+1;
					} 
					resultLength += end-start;
					i = end;
					break;
				case C_PARAM_START :
					resultLength++; // space for "("
					break;
				case C_PARAM_END :
					lastParen = i;
					if (includeReturnType) {
						// remove space for ", " that was added with last parameter and add space for ") "
						// -> noop
						break;
					} else {
						// remove space for ", " that was added with last parameter and add space for ")"
						resultLength--;
						break signature;
					}
				default :
					throw new IllegalArgumentException();
			}
			resultLength += 2; // add space for ", "
		}
		
		// parameter names
		int parameterNamesLength = parameterNames.length;
		for (int i = 0; i <parameterNamesLength; i++) {
			resultLength += parameterNames[i].length + 1; // parameter name + space
		}
		// remove last space
		if (parameterNamesLength > 0) resultLength--;
		
		// create resulting char array
		char[] result = new char[resultLength];
		
		// returned type
		if (includeReturnType) {
			int arrayCount = 0;
			for (int i = lastParen+1; i < sigLength; i++) {
				switch (methodSignature[i]) {
					case C_ARRAY :
						arrayCount++;
						break;
					case C_BOOLEAN :
						resultLength += 7; // boolean
						break;
					case C_BYTE :
						resultLength += 4; // byte
						break;
					case C_CHAR :
						resultLength += 4; // char
						break;
					case C_DOUBLE :
						resultLength += 6; // double
						break;
					case C_FLOAT :
						resultLength += 5; // float
						break;
					case C_INT :
						resultLength += 3; // int
						break;
					case C_LONG :
						resultLength += 4; // long
						break;
					case C_SHORT :
						resultLength += 5; // short
						break;
					case C_VOID :
						resultLength += 4; // void
						break;
					case C_RESOLVED :
					case C_UNRESOLVED :
						int end = CharOperation.indexOf(C_SEMICOLON, methodSignature, i);
						if (end == -1) throw new IllegalArgumentException();
						int start;
						if (fullyQualifyTypeNames) {
							start = i+1;
						} else {
							start = CharOperation.lastIndexOf(C_DOT, methodSignature, i, end);
							if (start == -1) start = i+1;
						} 
						resultLength += end-start;
						i = end;
						break;
				}
			}
			
		}
	
		int count = getParameterCount(methodSignature);
		char[][] result = new char[count][];
		if (count == 0)
			return result;
		int i = CharOperation.indexOf(C_PARAM_START, methodSignature) + 1;
		count = 0;
		int start = i;
		for (;;) {
			char c = methodSignature[i++];
			switch (c) {
				case C_ARRAY :
					// array depth is i - start;
					break;
				case C_BOOLEAN :
				case C_BYTE :
				case C_CHAR :
				case C_DOUBLE :
				case C_FLOAT :
				case C_INT :
				case C_LONG :
				case C_SHORT :
				case C_VOID :
					// common case of base types
					if (i - start == 1) {
						switch (c) {
							case C_BOOLEAN :
								result[count++] = new char[] {C_BOOLEAN};
								break;
							case C_BYTE :
								result[count++] = new char[] {C_BYTE};
								break;
							case C_CHAR :
								result[count++] = new char[] {C_CHAR};
								break;
							case C_DOUBLE :
								result[count++] = new char[] {C_DOUBLE};
								break;
							case C_FLOAT :
								result[count++] = new char[] {C_FLOAT};
								break;
							case C_INT :
								result[count++] = new char[] {C_INT};
								break;
							case C_LONG :
								result[count++] = new char[] {C_LONG};
								break;
							case C_SHORT :
								result[count++] = new char[] {C_SHORT};
								break;
							case C_VOID :
								result[count++] = new char[] {C_VOID};
								break;
						}
					} else {
						result[count++] = CharOperation.subarray(methodSignature, start, i);
					}
					start = i;
					break;
				case C_RESOLVED :
				case C_UNRESOLVED :
					i = CharOperation.indexOf(C_SEMICOLON, methodSignature, i) + 1;
					if (i == 0)
						throw new IllegalArgumentException();
					result[count++] = CharOperation.subarray(methodSignature, start, i);
					start = i;
					break;
				case C_PARAM_END:
					return result;
				default :
					throw new IllegalArgumentException();
			}
		}
	
	StringBuffer sb = new StringBuffer();
	String[] paramTypes = getParameterTypes(methodSignature);
	if (includeReturnType) {
		String returnType = getReturnType(methodSignature);
		if (returnType.length() != 0) {
			returnType = toString(returnType);
			if (!fullyQualifyTypeNames) {
				int lastDot = returnType.lastIndexOf(C_DOT);
				if (lastDot != -1) {
					returnType = returnType.substring(lastDot + 1);
				}
			}
			sb.append(returnType);
			sb.append(' ');
		}
	}
	if (methodName != null)
		sb.append(methodName);
	sb.append(C_PARAM_START);
	for (int i = 0; i < paramTypes.length; ++i) {
		if (i != 0)
			sb.append(", "); //$NON-NLS-1$
		String readableParamType = toString(paramTypes[i]);
		if (!fullyQualifyTypeNames) {
			int lastDot = readableParamType.lastIndexOf(C_DOT);
			if (lastDot != -1) {
				readableParamType = readableParamType.substring(lastDot + 1);
			}
		}
		sb.append(readableParamType);
		if (parameterNames != null) {
			sb.append(' ');
			sb.append(parameterNames[i]);
		}
	}
	sb.append(C_PARAM_END);
	return sb.toString();
	*/
}

