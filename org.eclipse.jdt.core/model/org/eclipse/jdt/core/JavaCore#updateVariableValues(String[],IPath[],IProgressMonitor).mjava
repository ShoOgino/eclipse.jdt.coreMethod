	/**
	 * Internal updating of a variable values (null path meaning removal), allowing to change multiple variable values at once.
	 */
	private static void updateVariableValues(
		String[] variableNames,
		IPath[] variablePaths,
		IProgressMonitor monitor) throws JavaModelException {

		if (monitor != null && monitor.isCanceled()) return;
		
		boolean mayChangeProjectDependencies = false;
		int varLength = variableNames.length;
		
		// gather classpath information for updating
		HashMap affectedProjects = new HashMap(5);
		JavaModelManager manager = JavaModelManager.getJavaModelManager();
		IJavaModel model = manager.getJavaModel();

		// filter out unmodified variables
		int discardCount = 0;
		for (int i = 0; i < varLength; i++){
			IPath oldPath = (IPath)JavaModelManager.Variables.get(variableNames[i]);
			if (oldPath != null && oldPath.equals(variablePaths[i])){
				variableNames[i] = null;
				discardCount++;
			}
		}
		if (discardCount > 0){
			if (discardCount == varLength) return;
			int changedLength = varLength - discardCount;
			String[] changedVariableNames = new String[changedLength];
			IPath[] changedVariablePaths = new IPath[changedLength];
			for (int i = 0, index = 0; i < varLength; i++){
				if (variableNames[i] != null){
					changedVariableNames[index] = variableNames[i];
					changedVariablePaths[index] = variablePaths[i];
					index++;
				}
			}
			variableNames = changedVariableNames;
			variablePaths = changedVariablePaths;
			varLength = changedLength;
		}
		
		if (monitor != null && monitor.isCanceled()) return;

		if (model != null) {
			IJavaProject[] projects = model.getJavaProjects();
			nextProject : for (int i = 0, projectLength = projects.length; i < projectLength; i++){
				IJavaProject project = projects[i];
						
				// check to see if any of the modified variables is present on the classpath
				IClasspathEntry[] classpath = project.getRawClasspath();
				for (int j = 0, cpLength = classpath.length; j < cpLength; j++){
					
					IClasspathEntry entry = classpath[j];
					for (int k = 0; k < varLength; k++){

						String variableName = variableNames[k];						
						if (entry.getEntryKind() ==  IClasspathEntry.CPE_VARIABLE){

							if (entry.getPath().segment(0).equals(variableName)){
								affectedProjects.put(project, ((JavaProject)project).getResolvedClasspath(true));
								
								// also check whether it will be necessary to update proj references and cycle markers
								if (!mayChangeProjectDependencies && entry.getPath().segmentCount() ==  1){
									IPath oldPath = (IPath)JavaModelManager.Variables.get(variableName);
									if (oldPath != null && oldPath.segmentCount() == 1) {
										mayChangeProjectDependencies = true;
									} else {
										IPath newPath = variablePaths[k];
										if (newPath != null && newPath.segmentCount() == 1) {
											mayChangeProjectDependencies = true;
										}
									}
								}
								continue nextProject;
							}
							IPath sourcePath, sourceRootPath;
							if (((sourcePath = entry.getSourceAttachmentPath()) != null	&& sourcePath.segment(0).equals(variableName))
								|| ((sourceRootPath = entry.getSourceAttachmentRootPath()) != null	&& sourceRootPath.segment(0).equals(variableName))) {

								affectedProjects.put(project, ((JavaProject)project).getResolvedClasspath(true));
								continue nextProject;
							}
						}												
					}
				}
			}
		}
		// update variables
		for (int i = 0; i < varLength; i++){
			IPath path = variablePaths[i];
			if (path == null) {
				JavaModelManager.Variables.remove(variableNames[i]);
			} else {
				// new variable value is assigned
				JavaModelManager.Variables.put(variableNames[i], path);
			}
		}
				
		// update affected project classpaths
		int size = affectedProjects.size();
		if (!affectedProjects.isEmpty()) {
			boolean wasFiring = manager.isFiring();
			try {
				if (wasFiring)
					manager.stopDeltas();
				// propagate classpath change
				Iterator projectsToUpdate = affectedProjects.keySet().iterator();
				while (projectsToUpdate.hasNext()) {

					if (monitor != null && monitor.isCanceled()) return;

					JavaProject project = (JavaProject) projectsToUpdate.next();
					
					if (!projectsToUpdate.hasNext()) {
						// re-enable firing for the last operation
						if (wasFiring) {
							wasFiring = false;
							manager.startDeltas();
						}
					}
					project
						.setRawClasspath(
							project.getRawClasspath(),
							SetClasspathOperation.ReuseOutputLocation,
							monitor,
							true,
							project.getWorkspace().isAutoBuilding(),
							// force build if in auto build mode
							(IClasspathEntry[]) affectedProjects.get(project),
							size == 1 && mayChangeProjectDependencies); // no individual check if more than 1 project to update
				}
				if (size > 1 && mayChangeProjectDependencies){
					try {
						// use workspace runnable for protecting marker manipulation
//						ResourcesPlugin.getWorkspace().run(
//							new IWorkspaceRunnable() {
//								public void run(IProgressMonitor monitor) throws CoreException {
									JavaProject.updateAllCycleMarkers(); // update them all at once
//								}
//							}, 
//							monitor);					
					} catch(CoreException e){
						throw new JavaModelException(e);
					}
				}
			} finally {
				if (wasFiring) {
					manager.startDeltas();
					// in case of exception traversing, deltas may be fired only in the next #fire() iteration
				}
			}
		}
	}

