/**
 * Creates a new type signature from the given type name.
 * <p>
 * For example:
 * <pre>
 * <code>
 * createTypeSignature("int", hucairz) -> "I"
 * createTypeSignature("java.lang.String", true) -> "Ljava.lang.String;"
 * createTypeSignature("String", false) -> "QString;"
 * createTypeSignature("java.lang.String", false) -> "Qjava.lang.String;"
 * createTypeSignature("int []", false) -> "[I"
 * </code>
 * </pre>
 * </p>
 *
 * @param typeName the possibly qualified type name
 * @param isResolved <code>true</code> if the type name is to be considered
 *   resolved (for example, a type name from a binary class file), and 
 *   <code>false</code> if the type name is to be considered unresolved
 *   (for example, a type name found in source code)
 * @return the encoded type signature
 */
public static String createTypeSignature(String typeName, boolean isResolved) {
	try {
		Scanner scanner = new Scanner();
		scanner.setSource(typeName.toCharArray());
		int token = scanner.getNextToken();
		StringBuffer sig = new StringBuffer();
		int arrayCount = 0;
		boolean primitive = true;
		switch (token) {
			case ITerminalSymbols.TokenNameIdentifier :
				sig.append(scanner.getCurrentIdentifierSource());
				primitive = false;
				break;
			case ITerminalSymbols.TokenNameboolean :
				sig.append(Signature.SIG_BOOLEAN);
				break;
			case ITerminalSymbols.TokenNamebyte :
				sig.append(Signature.SIG_BYTE);
				break;
			case ITerminalSymbols.TokenNamechar :
				sig.append(Signature.SIG_CHAR);
				break;
			case ITerminalSymbols.TokenNamedouble :
				sig.append(Signature.SIG_DOUBLE);
				break;
			case ITerminalSymbols.TokenNamefloat :
				sig.append(Signature.SIG_FLOAT);
				break;
			case ITerminalSymbols.TokenNameint :
				sig.append(Signature.SIG_INT);
				break;
			case ITerminalSymbols.TokenNamelong :
				sig.append(Signature.SIG_LONG);
				break;
			case ITerminalSymbols.TokenNameshort :
				sig.append(Signature.SIG_SHORT);
				break;
			case ITerminalSymbols.TokenNamevoid :
				sig.append(Signature.SIG_VOID);
				break;
			default :
				throw new IllegalArgumentException();
		}
		token = scanner.getNextToken();
		while (!primitive && token == ITerminalSymbols.TokenNameDOT) {
			sig.append(scanner.getCurrentIdentifierSource());
			token = scanner.getNextToken();
			if (token == ITerminalSymbols.TokenNameIdentifier) {
				sig.append(scanner.getCurrentIdentifierSource());
				token = scanner.getNextToken();
			} else {
				throw new IllegalArgumentException();
			}
		}
		while (token == ITerminalSymbols.TokenNameLBRACKET) {
			token = scanner.getNextToken();
			if (token != ITerminalSymbols.TokenNameRBRACKET)
				throw new IllegalArgumentException();
			arrayCount++;
			token = scanner.getNextToken();
		}
		if (token != ITerminalSymbols.TokenNameEOF)
			throw new IllegalArgumentException();
		if (!primitive) {
			sig.insert(0, isResolved ? C_RESOLVED : C_UNRESOLVED);
		}
		if (arrayCount == 0) {
			if (primitive)
				return sig.toString();
		} else {
			char[] brackets = new char[arrayCount];
			while (arrayCount-- != 0) {
				brackets[arrayCount] = C_ARRAY;
			}
			sig.insert(0, brackets);
		}
		if (!primitive) {
			sig.append(C_NAME_END);
		}
		return sig.toString();
	} catch (InvalidInputException e) {
		throw new IllegalArgumentException();
	}
}

