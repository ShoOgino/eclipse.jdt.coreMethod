/**
 * Creates a new type signature from the given type name. If the type name is qualified,
 * then it is expected to be dot-based.
 * <p>
 * For example:
 * <pre>
 * <code>
 * createTypeSignature("int", hucairz) -> "I"
 * createTypeSignature("java.lang.String", true) -> "Ljava.lang.String;"
 * createTypeSignature("String", false) -> "QString;"
 * createTypeSignature("java.lang.String", false) -> "Qjava.lang.String;"
 * createTypeSignature("int []", false) -> "[I"
 * createTypeSignature("List&lt;String&gt;", false) -> "QList&lt;QString;&gt;;"
 * createTypeSignature("List&lt;?&gt;", false) -> "QList&lt;&ast;&gt;;"
 * createTypeSignature("List&lt;? extends EventListener&gt;", false) -> "QList&lt;-QEventListener;&gt;;"
 * createTypeSignature("List&lt;? super Reader&gt;", false) -> "QList&lt;+QReader;&gt;;"
 * </code>
 * </pre>
 * </p>
 *
 * @param typeName the possibly qualified type name
 * @param isResolved <code>true</code> if the type name is to be considered
 *   resolved (for example, a type name from a binary class file), and 
 *   <code>false</code> if the type name is to be considered unresolved
 *   (for example, a type name found in source code)
 * @return the encoded type signature
 */
public static String createTypeSignature(String typeName, boolean isResolved) {
	// TODO (jeem) - fundamental problem with resolve types involving type variables which are syntactically indistinguishable for type in default package
	return createTypeSignature(typeName == null ? null : typeName.toCharArray(), isResolved);
}

