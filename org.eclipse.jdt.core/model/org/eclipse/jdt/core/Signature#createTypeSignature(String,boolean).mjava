	/**
	 * Creates a new type signature from the given type name.
	 * <p>
	 * For example:
	 * <pre>
	 * <code>
	 * createTypeSignature("int", hucairz) -> "I"
	 * createTypeSignature("java.lang.String", true) -> "Ljava.lang.String;"
	 * createTypeSignature("String", false) -> "QString;"
	 * createTypeSignature("java.lang.String", false) -> "Qjava.lang.String;"
	 * createTypeSignature("int []", false) -> "[I"
	 * </code>
	 * </pre>
	 * </p>
	 *
	 * @param typeName the possibly qualified type name
	 * @param isResolved <code>true</code> if the type name is to be considered
	 *   resolved (for example, a type name from a binary class file), and 
	 *   <code>false</code> if the type name is to be considered unresolved
	 *   (for example, a type name found in source code)
	 * @return the encoded type signature
	 */
	public static String createTypeSignature(String typeName, boolean isResolved) {
		try {
			Scanner scanner = new Scanner();
			scanner.setSourceBuffer(typeName.toCharArray());
			int token = scanner.getNextToken();
			StringBuffer sig = new StringBuffer();
			int arrayCount = 0;
			boolean primitive = true;
			switch (token) {
				case TerminalSymbols.TokenNameIdentifier :
					sig.append(scanner.getCurrentIdentifierSource());
					primitive = false;
					break;
				case TerminalSymbols.TokenNameboolean :
					sig.append(Signature.SIG_BOOLEAN);
					break;
				case TerminalSymbols.TokenNamebyte :
					sig.append(Signature.SIG_BYTE);
					break;
				case TerminalSymbols.TokenNamechar :
					sig.append(Signature.SIG_CHAR);
					break;
				case TerminalSymbols.TokenNamedouble :
					sig.append(Signature.SIG_DOUBLE);
					break;
				case TerminalSymbols.TokenNamefloat :
					sig.append(Signature.SIG_FLOAT);
					break;
				case TerminalSymbols.TokenNameint :
					sig.append(Signature.SIG_INT);
					break;
				case TerminalSymbols.TokenNamelong :
					sig.append(Signature.SIG_LONG);
					break;
				case TerminalSymbols.TokenNameshort :
					sig.append(Signature.SIG_SHORT);
					break;
				case TerminalSymbols.TokenNamevoid :
					sig.append(Signature.SIG_VOID);
					break;
				default :
					throw new IllegalArgumentException();
			}
			token = scanner.getNextToken();
			while (!primitive && token == TerminalSymbols.TokenNameDOT) {
				sig.append(scanner.getCurrentIdentifierSource());
				token = scanner.getNextToken();
				if (token == TerminalSymbols.TokenNameIdentifier) {
					sig.append(scanner.getCurrentIdentifierSource());
					token = scanner.getNextToken();
				} else {
					throw new IllegalArgumentException();
				}
			}
			while (token == TerminalSymbols.TokenNameLBRACKET) {
				token = scanner.getNextToken();
				if (token != TerminalSymbols.TokenNameRBRACKET)
					throw new IllegalArgumentException();
				arrayCount++;
				token = scanner.getNextToken();
			}
			if (token != TerminalSymbols.TokenNameEOF)
				throw new IllegalArgumentException();
			if (!primitive) {
				sig.insert(0, isResolved ? C_RESOLVED : C_UNRESOLVED);
			}
			if (arrayCount == 0) {
				if (primitive)
					return sig.toString();
			} else {
				char[] brackets = new char[arrayCount];
				while (arrayCount-- != 0) {
					brackets[arrayCount] = C_ARRAY;
				}
				sig.insert(0, brackets);
			}
			if (!primitive) {
				sig.append(C_NAME_END);
			}
			return sig.toString();
		} catch (InvalidInputException e) {
			throw new IllegalArgumentException();
		}
	}

