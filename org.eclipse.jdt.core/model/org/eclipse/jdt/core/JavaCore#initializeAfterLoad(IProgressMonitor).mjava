	/**
	 * Initializes JavaCore internal structures to allow subsequent operations (such 
	 * as the ones that need a resolved classpath) to run full speed. A client may 
	 * choose to call this method in a background thread early after the workspace 
	 * has started so that the initialization is transparent to the user.
	 * <p>
	 * However calling this method is optional. Services will lazily perform 
	 * initialization when invoked. This is only a way to reduce initialization 
	 * overhead on user actions, if it can be performed before at some 
	 * appropriate moment.
	 * </p><p>
	 * This initialization runs accross all Java projects in the workspace. Thus the
	 * workspace root scheduling rule is used during this operation.
	 * </p><p>
	 * This method doesn't return until the initialization is complete.
	 * </p><p>
	 * This method can be called concurrently.
	 * </p>
	 * 
	 * @param monitor a progress monitor, or <code>null</code> if progress
	 *    reporting and cancellation are not desired
	 * @exception CoreException if the initialization fails, 
	 * 		the status of the exception indicates the reason of the failure
	 * @since 3.1
	 */
	public static void initializeAfterLoad(IProgressMonitor monitor) throws CoreException {
		// dummy query for waiting until the indexes are ready and classpath containers/variables are initialized
		SearchEngine engine = new SearchEngine();
		IJavaSearchScope scope = SearchEngine.createWorkspaceScope(); // initialize all containers and variables
		engine.searchAllTypeNames(
			null,
			"!@$#!@".toCharArray(), //$NON-NLS-1$
			SearchPattern.R_PATTERN_MATCH | SearchPattern.R_CASE_SENSITIVE,
			IJavaSearchConstants.CLASS,
			scope, 
			new TypeNameRequestor() {
				public void acceptType(
					int modifiers,
					char[] packageName,
					char[] simpleTypeName,
					char[][] enclosingTypeNames,
					String path) {
					// no type to accept
				}
			},
			IJavaSearchConstants.WAIT_UNTIL_READY_TO_SEARCH,
			monitor == null ? null : new SubProgressMonitor(monitor, 99) // 99% of the time is spent in the dummy search
		); 
		
		// ensure external jars are refreshed (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=93668)
		JavaModelManager.getJavaModelManager().getJavaModel().refreshExternalArchives(
			null/*refresh all projects*/, 
			monitor == null ? null : new SubProgressMonitor(monitor, 1) // 1% of the time is spent in jar refresh
		);
	}

