	/**
	 * Initializes JavaCore internal structures to allow subsequent operations (such
	 * as the ones that need a resolved classpath) to run full speed. A client may
	 * choose to call this method in a background thread early after the workspace
	 * has started so that the initialization is transparent to the user.
	 * <p>
	 * However calling this method is optional. Services will lazily perform
	 * initialization when invoked. This is only a way to reduce initialization
	 * overhead on user actions, if it can be performed before at some
	 * appropriate moment.
	 * </p><p>
	 * This initialization runs accross all Java projects in the workspace. Thus the
	 * workspace root scheduling rule is used during this operation.
	 * </p><p>
	 * This method may return before the initialization is complete. The
	 * initialization will then continue in a background thread.
	 * </p><p>
	 * This method can be called concurrently.
	 * </p>
	 *
	 * @param monitor a progress monitor, or <code>null</code> if progress
	 *    reporting and cancellation are not desired
	 * @exception CoreException if the initialization fails,
	 * 		the status of the exception indicates the reason of the failure
	 * @since 3.1
	 */
	public static void initializeAfterLoad(IProgressMonitor monitor) throws CoreException {
		try {
			if (monitor != null) 	monitor.beginTask(Messages.javamodel_initialization, 100);

			// initialize all containers and variables
			JavaModelManager manager = JavaModelManager.getJavaModelManager();
			try {
				if (monitor != null) {
					monitor.subTask(Messages.javamodel_configuring_classpath_containers);
					manager.batchContainerInitializationsProgress.set(new SubProgressMonitor(monitor, 50)); // 50% of the time is spent in initializing containers and variables
				}
				manager.deltaState.initializeRoots();
			} finally {
				manager.batchContainerInitializationsProgress.set(null);
			}

			// dummy query for waiting until the indexes are ready
			SearchEngine engine = new SearchEngine();
			IJavaSearchScope scope = SearchEngine.createWorkspaceScope();
			try {
				if (monitor != null)
					monitor.subTask(Messages.javamodel_configuring_searchengine);
				engine.searchAllTypeNames(
					null,
					SearchPattern.R_EXACT_MATCH,
					"!@$#!@".toCharArray(), //$NON-NLS-1$
					SearchPattern.R_PATTERN_MATCH | SearchPattern.R_CASE_SENSITIVE,
					IJavaSearchConstants.CLASS,
					scope,
					new TypeNameRequestor() {
						public void acceptType(
							int modifiers,
							char[] packageName,
							char[] simpleTypeName,
							char[][] enclosingTypeNames,
							String path) {
							// no type to accept
						}
					},
					// will not activate index query caches if indexes are not ready, since it would take to long
					// to wait until indexes are fully rebuild
					IJavaSearchConstants.CANCEL_IF_NOT_READY_TO_SEARCH,
					monitor == null ? null : new SubProgressMonitor(monitor, 49) // 49% of the time is spent in the dummy search
				);
			} catch (JavaModelException e) {
				// /search failed: ignore
			} catch (OperationCanceledException e) {
				if (monitor != null && monitor.isCanceled())
					throw e;
				// else indexes were not ready: catch the exception so that jars are still refreshed
			}

			// check if the build state version number has changed since last session
			// (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=98969)
			if (monitor != null)
				monitor.subTask(Messages.javamodel_getting_build_state_number);
			QualifiedName qName = new QualifiedName(JavaCore.PLUGIN_ID, "stateVersionNumber"); //$NON-NLS-1$
			IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();
			String versionNumber = null;
			try {
				versionNumber = root.getPersistentProperty(qName);
			} catch (CoreException e) {
				// could not read version number: consider it is new
			}
			final JavaModel model = manager.getJavaModel();
			String newVersionNumber = Byte.toString(State.VERSION);
			if (!newVersionNumber.equals(versionNumber)) {
				// build state version number has changed: touch every projects to force a rebuild
				if (JavaBuilder.DEBUG)
					System.out.println("Build state version number has changed"); //$NON-NLS-1$
				IWorkspaceRunnable runnable = new IWorkspaceRunnable() {
					public void run(IProgressMonitor progressMonitor2) throws CoreException {
						IJavaProject[] projects = null;
						try {
							projects = model.getJavaProjects();
						} catch (JavaModelException e) {
							// could not get Java projects: ignore
						}
						if (projects != null) {
							for (int i = 0, length = projects.length; i < length; i++) {
								IJavaProject project = projects[i];
								try {
									if (JavaBuilder.DEBUG)
										System.out.println("Touching " + project.getElementName()); //$NON-NLS-1$
									project.getProject().touch(progressMonitor2);
								} catch (CoreException e) {
									// could not touch this project: ignore
								}
							}
						}
					}
				};
				if (monitor != null)
					monitor.subTask(Messages.javamodel_building_after_upgrade);
				try {
					ResourcesPlugin.getWorkspace().run(runnable, monitor);
				} catch (CoreException e) {
					// could not touch all projects
				}
				try {
					root.setPersistentProperty(qName, newVersionNumber);
				} catch (CoreException e) {
					Util.log(e, "Could not persist build state version number"); //$NON-NLS-1$
				}
			}

			// ensure external jars are refreshed (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=93668)
			try {
				if (monitor != null)
					monitor.subTask(Messages.javamodel_refreshing_external_jars);
				model.refreshExternalArchives(
					null/*refresh all projects*/,
					monitor == null ? null : new SubProgressMonitor(monitor, 1) // 1% of the time is spent in jar refresh
				);
			} catch (JavaModelException e) {
				// refreshing failed: ignore
			}
		} finally {
			if (monitor != null) monitor.done();
		}
	}

