	/**
	 * Initializes JavaCore internal structures to allow subsequent operations (such 
	 * as the ones that need a resolved classpath) to run full speed. A client may 
	 * choose to call this method in a background thread early after the workspace 
	 * has started so that the initialization is transparent to the user.
	 * <p>
	 * However calling this method is optional. Services will lazily perform 
	 * initialization when invoked. This is only a way to reduce initialization 
	 * overhead on user actions, if it can be performed before at some 
	 * appropriate moment.
	 * </p><p>
	 * This initialization runs accross all Java projects in the workspace. Thus the
	 * workspace root scheduling rule is used during this operation.
	 * </p><p>
	 * This method may return before the initialization is complete. The 
	 * initialization will then continue in a background thread.
	 * </p><p>
	 * This method can be called concurrently.
	 * </p>
	 * 
	 * @param monitor a progress monitor, or <code>null</code> if progress
	 *    reporting and cancellation are not desired
	 * @exception CoreException if the initialization fails, 
	 * 		the status of the exception indicates the reason of the failure
	 * @since 3.1
	 */
	public static void initializeAfterLoad(IProgressMonitor monitor) throws CoreException {
		Job job = new Job(Messages.javamodel_initialization) {
			protected IStatus run(IProgressMonitor progressMonitor) {
				// dummy query for waiting until the indexes are ready and classpath containers/variables are initialized
				SearchEngine engine = new SearchEngine();
				IJavaSearchScope scope = SearchEngine.createWorkspaceScope(); // initialize all containers and variables
				try {
					engine.searchAllTypeNames(
						null,
						"!@$#!@".toCharArray(), //$NON-NLS-1$
						SearchPattern.R_PATTERN_MATCH | SearchPattern.R_CASE_SENSITIVE,
						IJavaSearchConstants.CLASS,
						scope, 
						new TypeNameRequestor() {
							public void acceptType(
								int modifiers,
								char[] packageName,
								char[] simpleTypeName,
								char[][] enclosingTypeNames,
								String path) {
								// no type to accept
							}
						},
						// will not activate index query caches if indexes are not ready, since it would take to long
						// to wait until indexes are fully rebuild
						IJavaSearchConstants.CANCEL_IF_NOT_READY_TO_SEARCH,
						progressMonitor == null ? null : new SubProgressMonitor(progressMonitor, 99) // 99% of the time is spent in the dummy search
					); 
				} catch (JavaModelException e) {
					// /search failed: ignore
				} catch (OperationCanceledException e) {
					if (progressMonitor != null && progressMonitor.isCanceled())
						throw e;
					// else indexes were not ready: catch the exception so that jars are still refreshed
				}
				
				// ensure external jars are refreshed (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=93668)
				try {
					JavaModelManager.getJavaModelManager().getJavaModel().refreshExternalArchives(
						null/*refresh all projects*/, 
						progressMonitor == null ? null : new SubProgressMonitor(progressMonitor, 1) // 1% of the time is spent in jar refresh
					);
				} catch (JavaModelException e) {
					// refreshing failed: ignore
				}
				
				return Status.OK_STATUS;
			}
			public boolean belongsTo(Object family) {
				return PLUGIN_ID.equals(family);
			}
		};
		job.setPriority(Job.SHORT);
		job.schedule(2000);	 // wait for the startup activity to calm down
		
	}

