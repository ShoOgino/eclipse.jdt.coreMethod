	/**
	 * Creates and returns a new classpath entry of kind <code>CPE_CONTAINER</code>
	 * for the given path. The path of the container will be used during resolution so as to map this
	 * container entry to a set of other classpath entries the container is acting for.
	 * <p>
	 * A container entry allows to express indirect references to a set of libraries, projects and variable entries,
	 * which can be interpreted differently for each Java project where it is used.
	 * A classpath container entry can be resolved using <code>JavaCore.getResolvedClasspathContainer</code>,
	 * and updated with <code>JavaCore.classpathContainerChanged</code>
	 * <p>
	 * A container is exclusively resolved by a <code>ClasspathContainerInitializer</code> registered onto the
	 * extension point "org.eclipse.jdt.core.classpathContainerInitializer".
	 * <p>
	 * A container path must be formed of at least one segment, where: <ul>
	 * <li> the first segment is a unique ID identifying the target container, there must be a container initializer registered
	 * 	onto this ID through the extension point  "org.eclipse.jdt.core.classpathContainerInitializer". </li>
	 * <li> the remaining segments will be passed onto the initializer, and can be used as additional
	 * 	hints during the initialization phase. </li>
	 * </ul>
	 * <p>
	 * Example of an ClasspathContainerInitializer for a classpath container denoting a default JDK container:
	 * <pre>
	 * containerEntry = JavaCore.newContainerEntry(new Path("MyProvidedJDK/default"));
	 * 
	 * &lt;extension
	 *    point="org.eclipse.jdt.core.classpathContainerInitializer"&gt;
	 *    &lt;containerInitializer
	 *       id="MyProvidedJDK"
	 *       class="com.example.MyInitializer"/&gt; 
	 * </pre>
	 * <p>
	 * The inclusion patterns determines the initial set of accessible source and class files in 
	 * the container; the exclusion patterns are then used to reduce this
	 * set. A source or class file that is not accessible can still be refered to but it is 
	 * tagged as being not accessible - the Java builder will create a problem 
	 * marker for example. The severity of this marker is controled through
	 * the {@link #COMPILER_PB_FORBIDDEN_REFERENCE} compiler option.
	 * Note this is different from inclusion and 
	 * exclusion patterns on source classpath entries, where a source file that
	 * is excluded is not even compiled.
	 * When no inclusion patterns are specified, all source and class files
	 * in the container are initially accessible. On the other hand, specifying one 
	 * or more inclusion patterns means that all <b>and only</b> source and
	 * class files matching at least one of the specified patterns are accessible. 
	 * If exclusion patterns are specified, the initial set of accessible source and 
	 * class files is then reduced by eliminating source and class files matched 
	 * by at least one of the exclusion patterns. Inclusion and exclusion 
	 * patterns look like relative file paths with wildcards and are interpreted 
	 * relative to each entry's path of the container. Patterns are case-sensitive 
	 * and they can contain '**', '*' or '?' wildcards (see 
	 * {@link IClasspathEntry#getExclusionPatterns()} for the full description
	 * of their syntax and semantics).
	 * </p>
	 * <p>
	 * For example, if one of the container's entry path is 
	 * <code>/Project/someLib.jar</code>, there are no inclusion filters, and the
	 * exclusion pattern is 
	 * <code>com/xyz/tests/&#42;&#42;</code>, then class files
	 * like <code>/Project/someLib.jar/com/xyz/Foo.class</code>
	 * and <code>/Project/someLib.jar/com/xyz/utils/Bar.class</code> would be accessible,
	 * whereas <code>/Project/someLib.jar/com/xyz/tests/T1.class</code>
	 * and <code>/Project/someLib.jar/com/xyz/tests/quick/T2.class</code> would not be
	 * accessible. 
	 * </p>
	 * <p>
	 * The <code>isExported</code> flag indicates whether this entry is contributed to dependent
	 * projects. If not exported, dependent projects will not see any of the classes from this entry.
	 * If exported, dependent projects will concatenate the inclusion patterns of this entry with the
	 * inclusion patterns of the projects, and they will concatenate the exclusion patterns of this entry
	 * with the exclusion patterns of the project. 
	 * </p>
	 * <p>
	 * Note that this operation does not attempt to validate classpath containers
	 * or access the resources at the given paths.
	 * </p>
	 * 
	 * @param containerPath the path identifying the container, it must be formed of at least
	 * 	one segment (ID+hints)
	 * @param inclusionPatterns the possibly empty list of inclusion patterns
	 *    represented as relative paths
	 * @param exclusionPatterns the possibly empty list of exclusion patterns
	 *    represented as relative paths
	 * @param isExported a boolean indicating whether this entry is contributed to dependent
	 *    projects in addition to the output location
	 * @return a new container classpath entry
	 * 
	 * @see JavaCore#getClasspathContainer(IPath, IJavaProject)
	 * @see JavaCore#setClasspathContainer(IPath, IJavaProject[], IClasspathContainer[], IProgressMonitor)
	 * @see JavaCore#newContainerEntry(IPath, boolean)
	 * @since 3.1
	 */	
	public static IClasspathEntry newContainerEntry(
			IPath containerPath, 
			IPath[] inclusionPatterns, 
			IPath[] exclusionPatterns, 
			boolean isExported) {
			
		if (containerPath == null) Assert.isTrue(false, "Container path cannot be null"); //$NON-NLS-1$
		if (containerPath.segmentCount() < 1) {
			Assert.isTrue(
				false,
				"Illegal classpath container path: \'" + containerPath.makeRelative().toString() + "\', must have at least one segment (containerID+hints)"); //$NON-NLS-1$//$NON-NLS-2$
		}
		return new ClasspathEntry(
			IPackageFragmentRoot.K_SOURCE,
			IClasspathEntry.CPE_CONTAINER,
			containerPath,
			inclusionPatterns,
			exclusionPatterns, 
			null, // source attachment
			null, // source attachment root
			null, // specific output folder
			isExported);
	}	

