	/**
	 * Returns an array that contains the resources generated by the Java builder when building the
	 * compilation units contained in the given region.
	 * <p>The contents of the array is accurate only if the elements of the given region have been built.</p>
	 *
	 * @param region the given region
	 * @param includesNonJavaResources a flag that indicates if non-java resources should be included
	 *
	 * @return an array that contains the resources generated by the Java builder when building the
	 * compilation units contained in the given region, an empty array if none
	 * @exception IllegalArgumentException if the given region is <code>null</code>
	 * @since 3.3
	 */
	public static IResource[] getGeneratedResources(IRegion region, boolean includesNonJavaResources) {
		if (region == null) throw new IllegalArgumentException("region cannot be null"); //$NON-NLS-1$
		IJavaElement[] elements = region.getElements();
		HashMap projectsStates = new HashMap();
		ArrayList collector = new ArrayList();
		for (int i = 0, max = elements.length; i < max; i++) {
			// collect all the java project
			IJavaElement element = elements[i];
			IJavaProject javaProject = element.getJavaProject();
			IProject project = javaProject.getProject();
			State state = null;
			State currentState = (State) projectsStates.get(project);
			if (currentState != null) {
				state = currentState;
			} else {
				state = (State) JavaModelManager.getJavaModelManager().getLastBuiltState(project, null);
				if (state != null) {
					projectsStates.put(project, state);
				}
			}
			if (state == null) continue;
			if (element.getElementType() == IJavaElement.JAVA_PROJECT) {
				IPackageFragmentRoot[] roots = null;
				try {
					roots = javaProject.getAllPackageFragmentRoots();
				} catch (JavaModelException e) {
					// ignore
				}
				if (roots == null) continue;
				IRegion region2 = JavaCore.newRegion();
				for (int j = 0; j < roots.length; j++) {
					region2.add(roots[j]);
				}
				IResource[] res = getGeneratedResources(region2, includesNonJavaResources);
				for (int j = 0, max2 = res.length; j < max2; j++) {
					collector.add(res[j]);
				}
				continue;
			}
			IPath outputLocation = null;
			try {
				outputLocation = javaProject.getOutputLocation();
			} catch (JavaModelException e) {
				// ignore
			}
			IJavaElement root = element;
			while (root != null && root.getElementType() != IJavaElement.PACKAGE_FRAGMENT_ROOT) {
				root = root.getParent();
			}
			if (root == null) continue;
			IPackageFragmentRoot packageFragmentRoot = (IPackageFragmentRoot) root;
			int rootPathSegmentCounts = packageFragmentRoot.getPath().segmentCount();
			try {
				IClasspathEntry entry = packageFragmentRoot.getRawClasspathEntry();
				IPath entryOutputLocation = entry.getOutputLocation();
				if (entryOutputLocation != null) {
					outputLocation = entryOutputLocation;
				}
			} catch (JavaModelException e) {
				e.printStackTrace();
			}
			if (outputLocation == null) continue;
			IContainer container = (IContainer) project.getWorkspace().getRoot().findMember(outputLocation);
			switch(element.getElementType()) {
				case IJavaElement.COMPILATION_UNIT :
					// get the .class files generated when this element was built
					ICompilationUnit unit = (ICompilationUnit) element;
					getGeneratedResource(unit, container, state, rootPathSegmentCounts, collector);
					break;
				case IJavaElement.PACKAGE_FRAGMENT :
					// collect all the .class files generated when all the units in this package were built
					IPackageFragment fragment = (IPackageFragment) element;
					ICompilationUnit[] compilationUnits = null;
					try {
						compilationUnits = fragment.getCompilationUnits();
					} catch (JavaModelException e) {
						// ignore
					}
					if (compilationUnits == null) continue;
					for (int j = 0, max2 = compilationUnits.length; j < max2; j++) {
						getGeneratedResource(compilationUnits[j], container, state, rootPathSegmentCounts, collector);
					}
					if (includesNonJavaResources) {
						// retrieve all non-java resources from the output location using the package fragment path
						Object[] nonJavaResources = null;
						try {
							nonJavaResources = fragment.getNonJavaResources();
						} catch (JavaModelException e) {
							// ignore
						}
						if (nonJavaResources != null) {
							addNonJavaResources(nonJavaResources, container, rootPathSegmentCounts, collector);
						}
					}
					break;
				case IJavaElement.PACKAGE_FRAGMENT_ROOT :
					// collect all the .class files generated when all the units in this package were built
					IPackageFragmentRoot fragmentRoot = (IPackageFragmentRoot) element;
					if (fragmentRoot.isArchive()) continue;
					IJavaElement[] children = null;
					try {
						children = fragmentRoot.getChildren();
					} catch (JavaModelException e) {
						// ignore
					}
					if (children == null) continue;
					for (int j = 0, max2 = children.length; j < max2; j++) {
						fragment = (IPackageFragment) children[j];
						ICompilationUnit[] units = null;
						try {
							units = fragment.getCompilationUnits();
						} catch (JavaModelException e) {
							// ignore
						}
						if (units == null) continue;
						for (int n = 0, max3 = units.length; n < max3; n++) {
							getGeneratedResource(units[n], container, state, rootPathSegmentCounts, collector);
						}
						if (includesNonJavaResources) {
							// retrieve all non-java resources from the output location using the package fragment path
							Object[] nonJavaResources = null;
							try {
								nonJavaResources = fragment.getNonJavaResources();
							} catch (JavaModelException e) {
								// ignore
							}
							if (nonJavaResources != null) {
								addNonJavaResources(nonJavaResources, container, rootPathSegmentCounts, collector);
							}
						}
					}
					break;
			}
		}
		int size = collector.size();
		if (size != 0) {
			IResource[] result = new IResource[size];
			collector.toArray(result);
			return result;
		}
		return NO_GENERATED_RESOURCES;
	}

