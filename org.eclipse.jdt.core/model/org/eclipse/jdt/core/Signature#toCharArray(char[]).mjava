/**
 * Converts the given type signature to a readable string. The signature is expected to
 * be dot-based.
 * 
 * <p>
 * For example:
 * <pre>
 * <code>
 * toString({'[', 'L', 'j', 'a', 'v', 'a', '.', 'l', 'a', 'n', 'g', '.', 'S', 't', 'r', 'i', 'n', 'g', ';'}) -> {'j', 'a', 'v', 'a', '.', 'l', 'a', 'n', 'g', '.', 'S', 't', 'r', 'i', 'n', 'g', '[', ']'}
 * toString({'I'}) -> {'i', 'n', 't'}
 * </code>
 * </pre>
 * </p>
 * <p>
 * Note: This method assumes that a type signature containing a <code>'$'</code>
 * is an inner type signature. While this is correct in most cases, someone could 
 * define a non-inner type name containing a <code>'$'</code>. Handling this 
 * correctly in all cases would have required resolving the signature, which 
 * generally not feasible.
 * </p>
 *
 * @param signature the type signature
 * @return the string representation of the type
 * @exception IllegalArgumentException if the signature is not syntactically
 *   correct
 * 
 * @since 2.0
 */
public static char[] toCharArray(char[] signature) throws IllegalArgumentException {
	try {
		int sigLength = signature.length;

		if (sigLength == 0 || signature[0] == C_PARAM_START || signature[0] == C_GENERIC_START) {
			return toCharArray(signature, CharOperation.NO_CHAR, null, true, true);
		}
		
		// compute result length
		int resultLength = 0;
		int index = -1;
		while (signature[++index] == C_ARRAY) {
			resultLength += 2; // []
		}
		switch (signature[index]) {
			case C_BOOLEAN :
				resultLength += BOOLEAN.length;
				break;
			case C_BYTE :
				resultLength += BYTE.length;
				break;
			case C_CHAR :
				resultLength += CHAR.length;
				break;
			case C_DOUBLE :
				resultLength += DOUBLE.length;
				break;
			case C_FLOAT :
				resultLength += FLOAT.length;
				break;
			case C_INT :
				resultLength += INT.length;
				break;
			case C_LONG :
				resultLength += LONG.length;
				break;
			case C_SHORT :
				resultLength += SHORT.length;
				break;
			case C_VOID :
				resultLength += VOID.length;
				break;
			case C_TYPE_VARIABLE :
			case C_RESOLVED :
			case C_UNRESOLVED :
				// TODO (jeem) - needs to handle type arguments
				int end = CharOperation.indexOf(C_SEMICOLON, signature, index);
				if (end == -1) throw new IllegalArgumentException();
				int start = index + 1;
				resultLength += end-start;
				break;
			default :
				throw new IllegalArgumentException();
		}
		
		char[] result = new char[resultLength];
		copyType(signature, 0, result, 0, true);

		/**
		 * Converts '$' separated type signatures into '.' separated type signature.
		 * NOTE: This assumes that the type signature is an inner type signature.
		 *       This is true in most cases, but someone can define a non-inner type 
		 *       name containing a '$'. However to tell the difference, we would have
		 *       to resolve the signature, which cannot be done at this point.
		 */
		CharOperation.replace(result, C_DOLLAR, C_DOT);

		return result;
	} catch (ArrayIndexOutOfBoundsException e) {
		throw new IllegalArgumentException();
	}	
}

