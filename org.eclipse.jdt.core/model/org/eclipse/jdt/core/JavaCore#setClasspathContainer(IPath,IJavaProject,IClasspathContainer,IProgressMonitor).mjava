	/** TOFIX
	 * Notification of a classpath container change. This notification must be performed
	 * by client code which did register some classpath container initializers, whenever 
	 * changes in container need to be reflected onto the JavaModel.
	 * <p>
	 * In reaction to this notification, the JavaModel will be updated to reflect the new
	 * state of the updated container. Note that the update can be scoped to either
	 * a given project or the entire Java model according to the affectedElement argument.
	 * This is symetric to container resolution which enables project specific resolution.
	 * <p>
	 * This functionality cannot be used while the resource tree is locked.
	 * <p>
	 * Classpath container states are persisted locally to the workspace, and 
	 * are preserved from session to session.
	 * <p>
	 * When notifying a container change, the corresponding container initializer should
	 * in turn expect to be activated so as to resolve the updated container path.
	 * 
	 * @param containerPath - the name of the container which is being updated
	 * @param affectedElement - the scope of the change, either a specific project (IJavaProject)
	 *     or the entire JavaModel (IJavaModel).
	 * @param monitor a monitor to report progress
	 * 
	 * @see #getResolvedClasspathContainer(IPath, IJavaProject)
	 * @since 2.0
	 */
	public void setClasspathContainer(IPath containerPath, IJavaProject affectedProject, IClasspathContainer container, IProgressMonitor monitor){
/*
		if (monitor != null && monitor.isCanceled()) return;
		
		JavaModelManager manager = JavaModelManager.getJavaModelManager();
		ArrayList projectsToCheck = new ArrayList();
		
		switch (affectedElement.getElementType()){
			case IJavaElement.JAVA_PROJECT:
				projectsToCheck.add(affectedElement);
				break;
			case IJavaElement.JAVA_MODEL:
				IJavaProject[] projects = manager.getJavaModel().getJavaProjects();
				for (int i = 0; i < projects.length; i++) {
					projectsToCheck.add(projects[i]);
				}
				break;
			default:
				// no effect if affected element isn't one of the above case
				return;
		}

		// gather classpath information for updating
		HashMap affectedProjects = new HashMap(5);

		if (monitor != null && monitor.isCanceled()) return;

		nextProject : for (int i = 0, projectLength = projectsToCheck.length; i < projectLength; i++){
			IJavaProject project = projectsToCheck[i];
					
			// check to see if any of the modified variables is present on the classpath
			IClasspathEntry[] classpath = project.getRawClasspath();
			for (int j = 0, cpLength = classpath.length; j < cpLength; j++){
				
				IClasspathEntry entry = classpath[j];
				for (int k = 0; k < varLength; k++){

					String variableName = variableNames[k];						
					if (entry.getEntryKind() ==  IClasspathEntry.CPE_CONTAINER){

						if (entry.getPath().equals(containerPath)){
							affectedProjects.put(project, ((JavaProject)project).getResolvedClasspath(true));
							
							// also check whether it will be necessary to update proj references and cycle markers
							if (!mayChangeProjectDependencies && entry.getPath().segmentCount() ==  1){
								IPath oldPath = (IPath)JavaModelManager.Variables.get(variableName);
								if (oldPath != null && oldPath.segmentCount() == 1) {
									mayChangeProjectDependencies = true;
								} else {
									IPath newPath = variablePaths[k];
									if (newPath != null && newPath.segmentCount() == 1) {
										mayChangeProjectDependencies = true;
									}
								}
							}
							continue nextProject;
						}
						IPath sourcePath, sourceRootPath;
						if (((sourcePath = entry.getSourceAttachmentPath()) != null	&& sourcePath.segment(0).equals(variableName))
							|| ((sourceRootPath = entry.getSourceAttachmentRootPath()) != null	&& sourceRootPath.segment(0).equals(variableName))) {

							affectedProjects.put(project, ((JavaProject)project).getResolvedClasspath(true));
							continue nextProject;
						}
					}												
				}
			}
		}

		// reset saved container path
		for (int i = 0; i < 
		Map projectContainers = (Map)JavaModelManager.Containers.get(project);
		if (projectContainers != null){
			IClasspathEntry[] entries = (IClasspathEntry[])projectContainers.get(containerPath);
				
		// update affected project classpaths
		if (!affectedProjects.isEmpty()) {
			boolean wasFiring = manager.isFiring();
			try {
				if (wasFiring)
					manager.stopDeltas();
				// propagate classpath change
				Iterator projectsToUpdate = affectedProjects.keySet().iterator();
				while (projectsToUpdate.hasNext()) {

					if (monitor != null && monitor.isCanceled()) return;

					JavaProject project = (JavaProject) projectsToUpdate.next();
					
					if (!projectsToUpdate.hasNext()) {
						// re-enable firing for the last operation
						if (wasFiring) {
							wasFiring = false;
							manager.startDeltas();
						}
					}
					project
						.setRawClasspath(
							project.getRawClasspath(),
							SetClasspathOperation.ReuseOutputLocation,
							monitor,
							true,
							project.getWorkspace().isAutoBuilding(),
							// force build if in auto build mode
							(IClasspathEntry[]) affectedProjects.get(project),
							mayChangeProjectDependencies);
				}
			} finally {
				if (wasFiring) {
					manager.startDeltas();
					// in case of exception traversing, deltas may be fired only in the next #fire() iteration
				}
			}
		}
*/
	}

