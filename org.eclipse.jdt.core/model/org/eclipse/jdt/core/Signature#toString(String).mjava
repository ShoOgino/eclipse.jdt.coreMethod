/**
 * Converts the given type signature to a readable string.
 * <p>
 * For example:
 * <pre>
 * <code>
 * toString("[Ljava.lang.String;") -> "java.lang.String[]"
 * toString("I") -> "int"
 * </code>
 * </pre>
 * </p>
 * <p>
 * Note: This method assumes that a type signature containing a <code>'$'</code>
 * is an inner type signature. While this is correct in most cases, someone could 
 * define a non-inner type name containing a <code>'$'</code>. Handling this 
 * correctly in all cases would have required resolving the signature, which 
 * generally not feasible.
 * </p>
 *
 * @param signature the type signature
 * @return the string representation of the type
 * @exception IllegalArgumentException if the signature is not syntactically
 *   correct
 */
public static String toString(String signature) throws IllegalArgumentException {
	try {
		if (signature.charAt(0) == C_PARAM_START) {
			return toString(signature, ""/*nonNLS*/, null, true, true);
		}
		int arrayCount = getArrayCount(signature);
		switch (signature.charAt(arrayCount)) {
			case C_BOOLEAN :
				return arrayIfy("boolean"/*nonNLS*/, arrayCount);
			case C_BYTE :
				return arrayIfy("byte"/*nonNLS*/, arrayCount);
			case C_CHAR :
				return arrayIfy("char"/*nonNLS*/, arrayCount);
			case C_DOUBLE :
				return arrayIfy("double"/*nonNLS*/, arrayCount);
			case C_FLOAT :
				return arrayIfy("float"/*nonNLS*/, arrayCount);
			case C_INT :
				return arrayIfy("int"/*nonNLS*/, arrayCount);
			case C_LONG :
				return arrayIfy("long"/*nonNLS*/, arrayCount);
			case C_SHORT :
				return arrayIfy("short"/*nonNLS*/, arrayCount);
			case C_VOID :
				return arrayIfy("void"/*nonNLS*/, arrayCount);
			case C_RESOLVED :
			case C_UNRESOLVED :
				int semi = signature.indexOf(C_SEMICOLON, arrayCount + 1);
				if (semi == -1)
					throw new IllegalArgumentException();
					
				/**
				 * Converts '$' separated type signatures into '.' separated type signature.
				 * NOTE: This assumes that the type signature is an inner type signature.
				 *       This is true in most cases, but someone can define a non-inner type 
				 *       name containing a '$'. However to tell the difference, we would have
				 *       to resolve the signature, which cannot be done at this point.
				 */
				String qualifiedTypeName = signature.substring(arrayCount+1, semi).replace(C_DOLLAR, C_DOT);
				
				return arrayIfy(qualifiedTypeName, arrayCount);
			default :
				throw new IllegalArgumentException();
		}
	} catch (StringIndexOutOfBoundsException e) {
		throw new IllegalArgumentException();
	}
}

