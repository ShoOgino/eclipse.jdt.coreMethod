/**
 * Converts the given type signature to a readable string. The signature is expected to
 * be dot-based.
 * 
 * <p>
 * For example:
 * <pre>
 * <code>
 * toString("[Ljava.lang.String;") -> "java.lang.String[]"
 * toString("I") -> "int"
 * </code>
 * </pre>
 * </p>
 * <p>
 * Note: This method assumes that a type signature containing a <code>'$'</code>
 * is an inner type signature. While this is correct in most cases, someone could 
 * define a non-inner type name containing a <code>'$'</code>. Handling this 
 * correctly in all cases would have required resolving the signature, which 
 * generally not feasible.
 * </p>
 *
 * @param signature the type signature
 * @return the string representation of the type
 * @exception IllegalArgumentException if the signature is not syntactically
 *   correct
 */
public static String toString(String signature) throws IllegalArgumentException {
	try {
		if (signature.charAt(0) == C_PARAM_START) {
			return toString(signature, "", null, true, true); //$NON-NLS-1$
		}
		int arrayCount = getArrayCount(signature);
		switch (signature.charAt(arrayCount)) {
			case C_BOOLEAN :
				return arrayIfy("boolean", arrayCount); //$NON-NLS-1$
			case C_BYTE :
				return arrayIfy("byte", arrayCount); //$NON-NLS-1$
			case C_CHAR :
				return arrayIfy("char", arrayCount); //$NON-NLS-1$
			case C_DOUBLE :
				return arrayIfy("double", arrayCount); //$NON-NLS-1$
			case C_FLOAT :
				return arrayIfy("float", arrayCount); //$NON-NLS-1$
			case C_INT :
				return arrayIfy("int", arrayCount); //$NON-NLS-1$
			case C_LONG :
				return arrayIfy("long", arrayCount); //$NON-NLS-1$
			case C_SHORT :
				return arrayIfy("short", arrayCount); //$NON-NLS-1$
			case C_VOID :
				return arrayIfy("void", arrayCount); //$NON-NLS-1$
			case C_RESOLVED :
			case C_UNRESOLVED :
				int semi = signature.indexOf(C_SEMICOLON, arrayCount + 1);
				if (semi == -1)
					throw new IllegalArgumentException();
					
				/**
				 * Converts '$' separated type signatures into '.' separated type signature.
				 * NOTE: This assumes that the type signature is an inner type signature.
				 *       This is true in most cases, but someone can define a non-inner type 
				 *       name containing a '$'. However to tell the difference, we would have
				 *       to resolve the signature, which cannot be done at this point.
				 */
				String qualifiedTypeName = signature.substring(arrayCount+1, semi).replace(C_DOLLAR, C_DOT);
				
				return arrayIfy(qualifiedTypeName, arrayCount);
			default :
				throw new IllegalArgumentException();
		}
	} catch (StringIndexOutOfBoundsException e) {
		throw new IllegalArgumentException();
	}
}

