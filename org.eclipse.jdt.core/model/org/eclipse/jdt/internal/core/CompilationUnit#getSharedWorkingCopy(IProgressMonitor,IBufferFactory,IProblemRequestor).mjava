/**
 * @see IWorkingCopy#getSharedWorkingCopy(IProgressMonitor, IBufferFactory, IProblemRequestor)
 * @deprecated
 */
public IJavaElement getSharedWorkingCopy(IProgressMonitor pm, IBufferFactory factory, IProblemRequestor problemRequestor) throws JavaModelException {
	
	if (isWorkingCopy()) return this;
	
	// if factory is null, default factory must be used
	if (factory == null) factory = this.getBufferManager().getDefaultBufferFactory();

	JavaModelManager manager = JavaModelManager.getJavaModelManager();
	
	// In order to be shared, working copies have to denote the same compilation unit 
	// AND use the same buffer factory.
	// Assuming there is a little set of buffer factories, then use a 2 level Map cache.
	Map sharedWorkingCopies = manager.sharedWorkingCopies;
	
	WorkingCopyOwner workingCopyOwner = new BufferFactoryWrapper(factory);
	Map perOwnerWorkingCopies = (Map) sharedWorkingCopies.get(workingCopyOwner);
	if (perOwnerWorkingCopies == null){
		perOwnerWorkingCopies = new HashMap();
		sharedWorkingCopies.put(workingCopyOwner, perOwnerWorkingCopies);
	}
	CompilationUnit workingCopy = (CompilationUnit)perOwnerWorkingCopies.get(this);
	if (workingCopy != null) {
		Object info = manager.getInfo(workingCopy);
		if (info instanceof WorkingCopyElementInfo) {
			((WorkingCopyElementInfo)info).incrementUseCount();

			if (SHARED_WC_VERBOSE) {
				System.out.println("Incrementing use count of shared working copy " + workingCopy.toStringWithAncestors()); //$NON-NLS-1$
			}

			return workingCopy;
		}
	} 
	workingCopy = new CompilationUnit((IPackageFragment)getParent(), getElementName(), workingCopyOwner);
	BecomeWorkingCopyOperation op = new BecomeWorkingCopyOperation(workingCopy, perOwnerWorkingCopies, problemRequestor);
	runOperation(op, pm);
	return workingCopy;
}

