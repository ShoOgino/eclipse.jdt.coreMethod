	/**
	 * Performs type search in a source package.
	 */
	protected void seekTypesInSourcePackage(String name, IPackageFragment pkg, boolean partialMatch, int acceptFlags, IJavaElementRequestor requestor) {
		
		ICompilationUnit[] compilationUnits = null;
		try {
			compilationUnits = pkg.getCompilationUnits();
		} catch (JavaModelException npe) {
			return; // the package is not present
		}

		// replace with working copies to look inside
		int length= compilationUnits.length;
		Map workingCopies = (Map) this.unitsToLookInside.getCurrent();
		int workingCopiesSize;
		if (workingCopies != null && (workingCopiesSize = workingCopies.size()) > 0) {
			Map temp = new HashMap(workingCopiesSize);
			temp.putAll(workingCopies);
			for (int i = 0; i < length; i++) {
				ICompilationUnit unit = compilationUnits[i];
				ICompilationUnit workingCopy = (ICompilationUnit)temp.remove(unit);
				if (workingCopy != null) {
					compilationUnits[i] = workingCopy;
				}
			}
			// add remaining working copies that belong to this package
			int index = 0;
			Collection values = temp.values();
			Iterator iterator = values.iterator();
			while (iterator.hasNext()) {
				ICompilationUnit workingCopy = (ICompilationUnit)iterator.next();
				if (pkg.equals(workingCopy.getParent())) {
					if (index == 0) {
						int valuesLength = values.size();
						index = length;
						length += valuesLength;
						System.arraycopy(compilationUnits, 0, compilationUnits = new ICompilationUnit[length], 0, index);
					}
					compilationUnits[index++] = workingCopy;
				}
			}
			if (index > 0 && index < length) {
				System.arraycopy(compilationUnits, 0, compilationUnits = new ICompilationUnit[index], 0, index);
				length = index;
			}
		}
			
		String matchName = name;
		int index= name.indexOf('$');
		boolean potentialMemberType = false;
		String potentialMatchName = null;
		if (index != -1) {
			//the compilation unit name of the inner type
			potentialMatchName = name.substring(0, index);
			potentialMemberType = true;
		}

		/**
		 * In the following, matchName will never have the extension ".java" and 
		 * the compilationUnits always will. So add it if we're looking for 
		 * an exact match.
		 */
		String unitName = partialMatch ? matchName.toLowerCase() : matchName + SUFFIX_STRING_java;
		String potentialUnitName = null;
		if (potentialMemberType) {
			potentialUnitName = partialMatch ? potentialMatchName.toLowerCase() : potentialMatchName + SUFFIX_STRING_java;
		}

		for (int i= 0; i < length; i++) {
			if (requestor.isCanceled())
				return;
			ICompilationUnit compilationUnit= compilationUnits[i];
			
			if (!potentialMemberType || nameMatches(unitName, compilationUnit, partialMatch)) {
				IType[] types= null;
				try {
					types= compilationUnit.getTypes();
				} catch (JavaModelException npe) {
					continue; // the compilation unit is not present
				}
				int typeLength= types.length;
				for (int j= 0; j < typeLength; j++) {
					if (requestor.isCanceled())
						return;
					IType type= types[j];
					if (nameMatches(matchName, type, partialMatch)) {
						if (acceptType(type, acceptFlags)) requestor.acceptType(type);
					}
				}
			} else if (potentialMemberType && nameMatches(potentialUnitName, compilationUnit, partialMatch)) {
				IType[] types= null;
				try {
					types= compilationUnit.getTypes();
				} catch (JavaModelException npe) {
					continue; // the compilation unit is not present
				}
				int typeLength= types.length;
				for (int j= 0; j < typeLength; j++) {
					if (requestor.isCanceled())
						return;
					IType type= types[j]; 
					if (nameMatches(potentialMatchName, type, partialMatch)) {
						seekQualifiedMemberTypes(name.substring(index + 1, name.length()), type, partialMatch, requestor, acceptFlags);
					}
				}
			}

		}
	}

