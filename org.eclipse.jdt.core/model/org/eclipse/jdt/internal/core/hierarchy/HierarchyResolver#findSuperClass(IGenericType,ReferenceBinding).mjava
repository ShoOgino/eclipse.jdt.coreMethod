/*
 * Creates the super class handle of the given type.
 * Returns null if the type has no super class.
 * Adds the simple name to the hierarchy missing types if the class is not found and returns null.
 */
private IType findSuperClass(IGenericType type, ReferenceBinding typeBinding) {
	ReferenceBinding superBinding = typeBinding.superclass();
	
	// check if the super binding was replaced with the java.lang.Object binding (because of a visibility problem for example)
	ClassScope scope;
	if (typeBinding instanceof SourceTypeBinding && (scope = ((SourceTypeBinding) typeBinding).scope) != null) {
		TypeDeclaration typeDeclaration = scope.referenceContext;
		TypeReference superclassRef = typeDeclaration == null ? null : typeDeclaration.superclass;
		TypeBinding superclass = superclassRef == null ? null : superclassRef.resolvedType;
		if (superclass instanceof ProblemReferenceBinding) {
			superclass = ((ProblemReferenceBinding) superclass).closestMatch;
			if (superclass != null) 
				((SourceTypeBinding) typeBinding).superclass = superBinding = (ReferenceBinding) superclass;
		}
	}
	
	if (superBinding != null) {
		superBinding = (ReferenceBinding) superBinding.erasure();
		if (superBinding.id == TypeIds.T_JavaLangObject && typeBinding.isHierarchyInconsistent()) {
			char[] superclassName;
			char separator;
			if (type instanceof IBinaryType) {
				superclassName = ((IBinaryType)type).getSuperclassName();
				separator = '/';
			} else if (type instanceof ISourceType) {
				superclassName = ((ISourceType)type).getSuperclassName();
				separator = '.';
			} else if (type instanceof HierarchyType) {
				superclassName = ((HierarchyType)type).superclassName;
				separator = '.';
			} else {
				return null;
			}
			
			if (superclassName != null) { // check whether subclass of Object due to broken hierarchy (as opposed to explicitly extending it)
				int lastSeparator = CharOperation.lastIndexOf(separator, superclassName);
				char[] simpleName = lastSeparator == -1 ? superclassName : CharOperation.subarray(superclassName, lastSeparator+1, superclassName.length);
				if (!CharOperation.equals(simpleName, TypeConstants.OBJECT)) {
					this.hasMissingSuperClass = true;
					this.builder.hierarchy.missingTypes.add(new String(simpleName));
					return null;
				}
			}
		}
		for (int t = this.typeIndex; t >= 0; t--) {
			if (this.typeBindings[t] == superBinding) {
				return this.builder.getHandle(this.typeModels[t], superBinding);
			}
		}
	} 
	return null;
}

