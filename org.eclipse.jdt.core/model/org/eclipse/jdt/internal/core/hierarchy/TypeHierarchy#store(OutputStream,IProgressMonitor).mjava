/**
 * @see ITypeHierarchy
 */
public void store(OutputStream output, IProgressMonitor monitor) throws JavaModelException {
	try {
		// compute types in hierarchy
		Hashtable hashtable = new Hashtable();
		Hashtable hashtable2 = new Hashtable();
		int count = 0;
		
		if(type != null) {
			Integer index = new Integer(count++);
			hashtable.put(type, index);
			hashtable2.put(index, type);
		}
		Object[] types = classToSuperclass.keySet().toArray();
		for (int i = 0; i < types.length; i++) {
			if(hashtable.get(types[i]) == null) {
				Integer index = new Integer(count++);
				hashtable.put(types[i], index);
				hashtable2.put(index, types[i]);
			}
		}
		types = classToSuperclass.values().toArray();
		for (int i = 0; i < types.length; i++) {
			if(hashtable.get(types[i]) == null) {
				Integer index = new Integer(count++);
				hashtable.put(types[i], index);
				hashtable2.put(index, types[i]);
			}
		}
		types = typeToSuperInterfaces.keySet().toArray();
		for (int i = 0; i < types.length; i++) {
			if(hashtable.get(types[i]) == null) {
				Integer index = new Integer(count++);
				hashtable.put(types[i], index);
				hashtable2.put(index, types[i]);
			}
		}
		Object[] tabTypes = typeToSuperInterfaces.values().toArray();
		for (int i = 0; i < types.length; i++) {
			types = (Object[])tabTypes[i];
			for (int j = 0; j < types.length; j++) {
				if(hashtable.get(types[j]) == null) {
					Integer index = new Integer(count++);
					hashtable.put(types[j], index);
					hashtable2.put(index, types[j]);
				}
			}
			
		}
		
		// save version of the hierarchy format
		output.write(VERSION);
		
		// save general info
		byte generalInfo = 0;
		if(computeSubtypes) {
			generalInfo |= COMPUTE_SUBTYPES;
		}
		output.write(generalInfo);
		
		// save project
		if(project != null) {
			output.write(project.getHandleIdentifier().getBytes());
		}
		output.write(SEPARATOR1);
		
		// save missing types
		for (int i = 0; i < missingTypes.size(); i++) {
			if(i != 0) {
				output.write(SEPARATOR2);
			}
			output.write(((String)missingTypes.get(i)).getBytes());
			
		}
		output.write(SEPARATOR1);
		
		// save types
		for (int i = 0; i < count ; i++) {
			IType t = (IType)hashtable2.get(new Integer(i));
			
			// n bytes
			output.write(t.getHandleIdentifier().getBytes());
			output.write(SEPARATOR4);
			output.write(flagsToBytes((Integer)typeFlags.get(t)));
			output.write(SEPARATOR4);
			byte info = CLASS;
			if(type != null && type.equals(t)) {
				info |= COMPUTED_FOR;
			}
			if(interfaces.contains(t)) {
				info |= INTERFACE;
			}
			if(rootClasses.contains(t)) {
				info |= ROOT;
			}
			output.write(info);
		}
		output.write(SEPARATOR1);
		
		// save superclasses
		types = classToSuperclass.keySet().toArray();
		for (int i = 0; i < types.length; i++) {
			IJavaElement key = (IJavaElement)types[i];
			IJavaElement value = (IJavaElement)classToSuperclass.get(key);
			
			output.write(((Integer)hashtable.get(key)).toString().getBytes());
			output.write('>');
			output.write(((Integer)hashtable.get(value)).toString().getBytes());
			output.write(SEPARATOR1);
		}
		output.write(SEPARATOR1);
		
		// save superinterfaces
		types = typeToSuperInterfaces.keySet().toArray();
		for (int i = 0; i < types.length; i++) {
			IJavaElement key = (IJavaElement)types[i];
			IJavaElement[] values = (IJavaElement[])typeToSuperInterfaces.get(key);
			
			if(values.length > 0) {
				output.write(((Integer)hashtable.get(key)).toString().getBytes());
				output.write(SEPARATOR3);
				for (int j = 0; j < values.length; j++) {
					IJavaElement value = values[j];
					if(j != 0) output.write(SEPARATOR2);
					output.write(((Integer)hashtable.get(value)).toString().getBytes());
				}
				output.write(SEPARATOR1);
			}
		}
		output.write(SEPARATOR1);
	} catch(IOException e) {
		throw new JavaModelException(new JavaModelStatus(IJavaModelStatus.ERROR));
	}
}

