public void resolveLocalType(IType type, Member declaringMember) throws JavaModelException {

	if (!(type instanceof SourceType)) {
		// TODO (jerome) handle binary type
		return;
	}

	// get top-level source types
	// NB: need all top-level source types as a local type can refer to a secondary type in the same unit
	org.eclipse.jdt.core.ICompilationUnit cu = type.getCompilationUnit();
	IType[] topLevelTypes = cu.getTypes();
	int length = topLevelTypes.length;
	ISourceType[] sourceTypes = new ISourceType[length];
	for (int i = 0; i < length; i++) {
		sourceTypes[i] = (ISourceType)((SourceType)topLevelTypes[i]).getElementInfo();
	}
	
	// build compilation unit declaration
	CompilationResult result = new CompilationResult(sourceTypes[0].getFileName(), 1, 1, this.options.maxProblemsPerUnit);
	CompilationUnitDeclaration unit =
		ElementInfoConverter.buildCompilationUnit(
			sourceTypes,
			true, // need local and anonymous types
			this.lookupEnvironment.problemReporter, 
			result);
			
	// build bindings
	if (unit != null) {
		TypeDeclaration typeDecl = new AstNodeFinder(unit).findType(type);
		if (typeDecl == null) return;
		try {
			this.lookupEnvironment.buildTypeBindings(unit);
			// TODO (jerome) optimize to resolve method that contains local type only
			this.lookupEnvironment.completeTypeBindings(unit, true/*build fields and methods*/);
			unit.scope.faultInTypes();
			unit.scope.verifyMethods(this.lookupEnvironment.methodVerifier());
			unit.resolve();
			this.focusType = typeDecl.binding;
			rememberWithSuperTypes(this.focusType, new HandleFactory(), unit.scope, (Openable)type.getCompilationUnit());
			reportHierarchy();
		} catch (AbortCompilation e) {
			// missing 'java.lang' package: ignore
		}
	}

}

