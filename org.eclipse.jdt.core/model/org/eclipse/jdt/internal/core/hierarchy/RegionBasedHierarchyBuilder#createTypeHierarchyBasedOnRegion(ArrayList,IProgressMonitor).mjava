/**
 * Configure this type hierarchy that is based on a region.
 */
private void createTypeHierarchyBasedOnRegion(ArrayList allOpenablesInRegion, IProgressMonitor monitor) {
	
	int size = allOpenablesInRegion.size();
	if (size != 0) {
		this.infoToHandle = new HashMap(size);
	}
	Openable[] openables = new Openable[size];
	allOpenablesInRegion.toArray(openables);

	try {
		// resolve
		if (monitor != null) monitor.beginTask("", size * 2/* 1 for build binding, 1 for connect hierarchy*/); //$NON-NLS-1$
		if (size > 0) {
			IType focusType = this.getType();
			CompilationUnit unitToLookInside = null;
			if (focusType != null) {
				unitToLookInside = (CompilationUnit)focusType.getCompilationUnit();
			}
			if (this.nameLookup != null && unitToLookInside != null) {
				try {
					nameLookup.setUnitsToLookInside(new ICompilationUnit[] {unitToLookInside}); // NB: this uses a PerThreadObject, so it is thread safe
					this.hierarchyResolver.resolve(openables, null, monitor);
				} finally {
					nameLookup.setUnitsToLookInside(null);
				}
			} else {
				this.hierarchyResolver.resolve(openables, null, monitor);
			}
		}
	} finally {
		if (monitor != null) monitor.done();
	}
}

