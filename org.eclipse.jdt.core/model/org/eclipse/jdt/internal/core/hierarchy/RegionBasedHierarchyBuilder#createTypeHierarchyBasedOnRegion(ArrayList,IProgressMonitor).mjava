/**
 * Configure this type hierarchy that is based on a region.
 */
private void createTypeHierarchyBasedOnRegion(ArrayList allTypesInRegion, IProgressMonitor monitor) {
	
	int size = allTypesInRegion.size();
	if (size != 0) {
		this.infoToHandle = new HashMap(size);
	}
	HashSet existingOpenables = new HashSet(size);
	Openable[] openables = new Openable[size];
	int openableIndex = 0;
	for (int i = 0; i < size; i++) {
		IType type = (IType)allTypesInRegion.get(i);
		Openable openable;
		if (type.isBinary()) {
			openable = (Openable)type.getClassFile();
		} else {
			openable = (Openable)type.getCompilationUnit();
		}
		if (existingOpenables.add(openable)) {
			openables[openableIndex++] = openable;
		}
	}
	if (openableIndex < size) {
		System.arraycopy(openables, 0, openables = new Openable[openableIndex], 0, openableIndex);
	}

	try {
		// resolve
		if (monitor != null) monitor.beginTask("", openableIndex * 2/* 1 for build binding, 1 for connect hierarchy*/); //$NON-NLS-1$
		if (openableIndex > 0) {
			IType focusType = this.getType();
			CompilationUnit unitToLookInside = null;
			if (focusType != null) {
				unitToLookInside = (CompilationUnit)focusType.getCompilationUnit();
			}
			if (this.nameLookup != null && unitToLookInside != null) {
				try {
					nameLookup.setUnitsToLookInside(new ICompilationUnit[] {unitToLookInside}); // NB: this uses a PerThreadObject, so it is thread safe
					this.hierarchyResolver.resolve(openables, null, monitor);
				} finally {
					nameLookup.setUnitsToLookInside(null);
				}
			} else {
				this.hierarchyResolver.resolve(openables, null, monitor);
			}
		}
	} finally {
		if (monitor != null) monitor.done();
	}
}

