/**
 * Configure this type hierarchy that is based on a region.
 */
private void createTypeHierarchyBasedOnRegion(ArrayList allTypesInRegion, IProgressMonitor monitor) {
	
	int size = allTypesInRegion.size();
	if (size != 0) {
		this.infoToHandle = new HashMap(size);
	}
	IType[] types = new IType[size];
	allTypesInRegion.toArray(types);

	/*
	 * NOTE: To workaround pb with hierarchy resolver that requests top  
	 * level types in the process of caching an enclosing type, this needs to
	 * be sorted in reverse alphabetical order so that top level types are cached
	 * before their inner types.
	 */
	Util.sort(
		types,
		new Util.Comparer() {
			/**
			 * @see Comparer#compare(Object, Object)
			 */
			public int compare(Object a, Object b) {
				return - ((IJavaElement)a).getParent().getElementName().compareTo(((IJavaElement)b).getParent().getElementName());
			}
		}
	);

	// collect infos and compilation units
	ArrayList infos = new ArrayList();
	ArrayList units = new ArrayList();
	types : for (int i = 0; i < size; i++) {
		try {
			IType type = types[i];
			this.addInfoFromElement((Openable)type.getOpenable(), infos, units, type.getPath().toString());
		} catch (JavaModelException npe) {
			continue types;
		}
	}

	// copy vectors into arrays
	IGenericType[] genericTypes;
	int infosSize = infos.size();
	if (infosSize > 0) {
		genericTypes = new IGenericType[infosSize];
		infos.toArray(genericTypes);
	} else {
		genericTypes = new IGenericType[0];
	}
	org.eclipse.jdt.internal.compiler.env.ICompilationUnit[] compilationUnits;
	int unitsSize = units.size();
	if (unitsSize > 0) {
		compilationUnits = new org.eclipse.jdt.internal.compiler.env.ICompilationUnit[unitsSize];
		units.toArray(compilationUnits);
	} else {
		compilationUnits = new org.eclipse.jdt.internal.compiler.env.ICompilationUnit[0];
	}

	try {
		// resolve
		if (monitor != null) monitor.beginTask("", (infosSize+unitsSize) * 2/* 1 for build binding, 1 for connect hierarchy*/); //$NON-NLS-1$
		if (infosSize > 0 || unitsSize > 0) {
			IType focusType = this.getType();
			CompilationUnit unitToLookInside = null;
			if (focusType != null) {
				unitToLookInside = (CompilationUnit)focusType.getCompilationUnit();
			}
			if (this.nameLookup != null && unitToLookInside != null) {
				try {
					nameLookup.setUnitsToLookInside(new IWorkingCopy[] {unitToLookInside}); // NB: this uses a PerThreadObject, so it is thread safe
					this.hierarchyResolver.resolve(genericTypes, compilationUnits, monitor);
				} finally {
					nameLookup.setUnitsToLookInside(null);
				}
			} else {
				this.hierarchyResolver.resolve(genericTypes, compilationUnits, monitor);
			}
		}
	} finally {
		if (monitor != null) monitor.done();
	}
}

