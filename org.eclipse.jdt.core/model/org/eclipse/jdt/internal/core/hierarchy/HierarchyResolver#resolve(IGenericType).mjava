/**
 * Resolve the supertypes for the supplied source type.
 * Inform the requestor of the resolved supertypes using:
 *    connect(ISourceType suppliedType, IGenericType superclass, IGenericType[] superinterfaces)
 */

public void resolve(IGenericType suppliedType) {
	try {
		if (suppliedType.isBinaryType()) {
			BinaryTypeBinding binaryTypeBinding = this.lookupEnvironment.cacheBinaryType((IBinaryType) suppliedType);
			remember(suppliedType, binaryTypeBinding);
			reportHierarchy(this.requestor.getType(), null, binaryTypeBinding);
		} else {
			// must start with the top level type
			ISourceType topLevelType = (ISourceType) suppliedType;
			while (topLevelType.getEnclosingType() != null)
				topLevelType = topLevelType.getEnclosingType();
			CompilationResult result = new CompilationResult(topLevelType.getFileName(), 1, 1, this.options.maxProblemsPerUnit);
			CompilationUnitDeclaration unit =
				SourceTypeConverter.buildCompilationUnit(
					new ISourceType[]{topLevelType}, 
					// no need for field and methods
					SourceTypeConverter.MEMBER_TYPE, // need member types
					// no need for field initialization
					this.lookupEnvironment.problemReporter, 
					result);

			if (unit != null) {
				this.lookupEnvironment.buildTypeBindings(unit);

				org.eclipse.jdt.core.ICompilationUnit cu = ((SourceTypeElementInfo)topLevelType).getHandle().getCompilationUnit();
				rememberAllTypes(unit, cu, false);

				this.lookupEnvironment.completeTypeBindings(unit, false);

				reportHierarchy(this.requestor.getType(), unit, null);
			}
		}
	} catch (AbortCompilation e) { // ignore this exception for now since it typically means we cannot find java.lang.Object
	} finally {
		reset();
	}
}

