private static void newSearchAllPossibleSubTypes(IType type, IJavaSearchScope scope2, Map binariesFromIndexMatches2,
		IPathRequestor pathRequestor, int waitingPolicy, IProgressMonitor progressMonitor) {
	SubMonitor subMonitor = SubMonitor.convert(progressMonitor);
	JavaIndex index = JavaIndex.getIndex();
	Nd pdom = index.getNd();
	char[] fieldDefinition = JavaNames.fullyQualifiedNameToFieldDescriptor(type.getFullyQualifiedName().toCharArray());
	pdom.acquireReadLock();

	IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();

	try {
		NdTypeId foundType = index.findType(fieldDefinition);

		if (foundType == null) {
			return;
		}

		ArrayDeque<NdType> typesToVisit = new ArrayDeque<>();
		Set<NdType> discoveredTypes = new HashSet<>();
		typesToVisit.addAll(foundType.getTypes());
		discoveredTypes.addAll(typesToVisit);

		while (!typesToVisit.isEmpty()) {
			NdType nextType = typesToVisit.removeFirst();
			NdTypeId typeId = nextType.getTypeId();

			String typePath = new String(JavaNames.getIndexPathFor(nextType, root));
			if (!scope2.encloses(typePath)) {
				continue;
			}

			subMonitor.setWorkRemaining(Math.max(typesToVisit.size(), 10)).split(1);

			boolean isLocalClass = nextType.isLocal() || nextType.isAnonymous();
			pathRequestor.acceptPath(typePath, isLocalClass);

			HierarchyBinaryType binaryType = (HierarchyBinaryType)binariesFromIndexMatches2.get(typePath);
			if (binaryType == null) {
				binaryType = createBinaryTypeFrom(nextType);
				binariesFromIndexMatches2.put(typePath, binaryType);
			}

			for (NdType subType : typeId.getSubTypes()) {
				if (!discoveredTypes.contains(subType)) {
					discoveredTypes.add(subType);
					typesToVisit.add(subType);
				}
			}
		}
	} finally {
		pdom.releaseReadLock();
	}
}

