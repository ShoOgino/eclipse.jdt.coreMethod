	/**
	 * Configure this type hierarchy that is based on a region.
	 */
	private void createTypeHierarchyBasedOnRegion(ArrayList allTypesInRegion) {
		
		int size = allTypesInRegion.size();
		if (size != 0) {
			this.infoToHandle = new HashMap(size);
		}
		ArrayList temp = new ArrayList(size);
		types : for (int i = 0; i < size; i++) {
			try {
				IType type = (IType) allTypesInRegion.get(i);
				IGenericType info = (IGenericType) ((JavaElement) type).getRawInfo();
				temp.add(info);
				if (info.isBinaryType()) {
					this.infoToHandle.put(info, type.getParent());
				}
				worked(1);
			} catch (JavaModelException npe) {
				continue types;
			}
		}

		size = temp.size();
		if (size > 0) {
			IGenericType[] genericTypes = new IGenericType[size];
			temp.toArray(genericTypes);
			IType focusType = this.getType();
			NameLookup nameLookup = null;
			try {
				if (focusType != null) {
					CompilationUnit unitToLookInside = (CompilationUnit)focusType.getCompilationUnit();
					if (unitToLookInside != null) {
						try {
							nameLookup = ((JavaProject)unitToLookInside.getJavaProject()).getNameLookup();
							nameLookup.setUnitsToLookInside(new IWorkingCopy[] {unitToLookInside});
						} catch (JavaModelException e) {
							// cannot set the working copies
						}
					}
				}
				this.hierarchyResolver.resolve(genericTypes);
			} finally {
				if (nameLookup != null) {
					nameLookup.setUnitsToLookInside(null);
				}
			}
		}
	}

