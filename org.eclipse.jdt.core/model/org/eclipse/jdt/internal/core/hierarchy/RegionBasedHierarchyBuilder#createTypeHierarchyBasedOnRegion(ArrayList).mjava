	/**
	 * Configure this type hierarchy that is based on a region.
	 */
	private void createTypeHierarchyBasedOnRegion(ArrayList allTypesInRegion) {
		
		int size = allTypesInRegion.size();
		if (size != 0) {
			this.infoToHandle = new HashMap(size);
		}
		ArrayList temp = new ArrayList(size);
		types : for (int i = 0; i < size; i++) {
			try {
				IType type = (IType) allTypesInRegion.get(i);
				IGenericType info = (IGenericType) ((JavaElement) type).getRawInfo();
				temp.add(info);
				if (info.isBinaryType()) {
					this.infoToHandle.put(info, type.getParent());
				}
				worked(1);
			} catch (JavaModelException npe) {
				continue types;
			}
		}

		size = temp.size();
		if (size > 0) {
			IGenericType[] genericTypes = new IGenericType[size];
			temp.toArray(genericTypes);
			IType focusType = this.getType();
			CompilationUnit unitToLookInside = null;
			if (focusType != null) {
				unitToLookInside = (CompilationUnit)focusType.getCompilationUnit();
			}
			if (this.nameLookup != null && unitToLookInside != null) {
				synchronized(this.nameLookup) { // prevent 2 concurrent accesses to name lookup while the working copies are set
					try {
						nameLookup.setUnitsToLookInside(new IWorkingCopy[] {unitToLookInside});
						this.hierarchyResolver.resolve(genericTypes);
					} finally {
						nameLookup.setUnitsToLookInside(null);
					}
				}
			} else {
				this.hierarchyResolver.resolve(genericTypes);
			}
		}
	}

