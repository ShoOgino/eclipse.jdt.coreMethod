/**
 * Resolve the supertypes for the supplied source types.
 * Inform the requestor of the resolved supertypes for each
 * supplied source type using:
 *    connect(ISourceType suppliedType, IGenericType superclass, IGenericType[] superinterfaces)
 *
 * Also inform the requestor of the supertypes of each
 * additional requested super type which is also a source type
 * instead of a binary type.
 */

public void resolve(IGenericType[] suppliedTypes, org.eclipse.jdt.core.ICompilationUnit[] closedCUs, HashSet localTypes, IProgressMonitor monitor) {
	try {
		int suppliedLength = suppliedTypes == null ? 0 : suppliedTypes.length;
		int sourceLength = closedCUs == null ? 0 : closedCUs.length;
		CompilationUnitDeclaration[] units = new CompilationUnitDeclaration[suppliedLength + sourceLength];
		boolean[] hasLocalType = new boolean[suppliedLength + sourceLength];
		
		// cache binary type bidings
		BinaryTypeBinding[] binaryBindings = new BinaryTypeBinding[suppliedLength];
		for (int i = 0; i < suppliedLength; i++) {
			if (suppliedTypes[i].isBinaryType()) {
				IBinaryType binaryType = (IBinaryType) suppliedTypes[i];
				try {
					binaryBindings[i] = this.lookupEnvironment.cacheBinaryType(binaryType, false);
				} catch (AbortCompilation e) {
					// classpath problem for this type: ignore
				}
			}
		}
		
		// build type bindings
		for (int i = 0; i < suppliedLength; i++) {
			if (suppliedTypes[i].isBinaryType()) {
				if (binaryBindings[i] != null) {
					try {
						remember(suppliedTypes[i], binaryBindings[i]);
					} catch (AbortCompilation e) {
						// classpath problem for this type: ignore
					}
				}
			} else {
				// must start with the top level type
				ISourceType topLevelType = (ISourceType) suppliedTypes[i];
				while (topLevelType.getEnclosingType() != null)
					topLevelType = topLevelType.getEnclosingType();
				
				// contains a potential subtype as a local or anonymous type?
				boolean containsLocalType = false;
				if (localTypes == null) { // case of hierarchy on region
					containsLocalType = false;
				} else if (topLevelType instanceof SourceTypeElementInfo) {
					IPath path = ((SourceTypeElementInfo)topLevelType).getHandle().getPath();
					containsLocalType = localTypes.contains(path.toString());
				}
				
				CompilationResult result = new CompilationResult(topLevelType.getFileName(), i, suppliedLength, this.options.maxProblemsPerUnit);
				if (!containsLocalType) {
					units[i] = 
						SourceTypeConverter.buildCompilationUnit(
							new ISourceType[]{topLevelType}, 
							true, // need for field and methods // TODO (jerome) need fields and methods only for supertypes of local types
							true, // need member types
							false, // no need for field initialization
							this.lookupEnvironment.problemReporter, 
							result);
				} else {
					units[i] =
						ElementInfoConverter.buildCompilationUnit(
							new SourceTypeElementInfo[]{(SourceTypeElementInfo)topLevelType}, 
							true, // need local types
							this.lookupEnvironment.problemReporter, 
							result);
					units[i].bits |= AstNode.HasAllMethodBodies;
					hasLocalType[i] = true;
				}
				if (units[i] != null) {
					try {
						this.lookupEnvironment.buildTypeBindings(units[i]);
					} catch (AbortCompilation e) {
						// classpath problem for this type: ignore
					}
				}
			}
			worked(monitor, 1);
		}
		Parser parser = new Parser(this.lookupEnvironment.problemReporter, true);
		for (int i = 0; i < sourceLength; i++){
			org.eclipse.jdt.core.ICompilationUnit closedCU = closedCUs[i];
			IResource file = closedCU.getResource();
			String osPath = file.getLocation().toOSString();
			ICompilationUnit sourceUnit = this.requestor.createCompilationUnitFromPath((Openable)closedCU, osPath);
			
			CompilationResult unitResult = new CompilationResult(sourceUnit, suppliedLength+i, suppliedLength+sourceLength, this.options.maxProblemsPerUnit); 
			CompilationUnitDeclaration parsedUnit = parser.dietParse(sourceUnit, unitResult);
			if (parsedUnit != null) {
				units[suppliedLength+i] = parsedUnit;

				// contains a potential subtype as a local or anonymous type?
				if (localTypes == null) { // case of hierarchy on region
					hasLocalType[suppliedLength+i] = false;
				} else {
					IPath path = file.getFullPath();
					hasLocalType[suppliedLength+i] = localTypes.contains(path.toString());
				}
			
				this.lookupEnvironment.buildTypeBindings(parsedUnit);
			}
			worked(monitor, 1);
		}
		
		// complete type bindings (ie. connect super types)
		for (int i = 0; i < suppliedLength; i++) {
			if (!suppliedTypes[i].isBinaryType()) { // note that binary types have already been remembered above
				CompilationUnitDeclaration parsedUnit = units[i];
				if (parsedUnit != null) {
					try {
						// NB: No need to get method bodies as they were already computed
						this.lookupEnvironment.completeTypeBindings(parsedUnit, true); // TODO (jerome) build fields and methods only for super types of local types
					} catch (AbortCompilation e) {
						// classpath problem for this type: ignore
					}
				}
			}
			worked(monitor, 1);
		}
		for (int i = 0; i < sourceLength; i++) {
			CompilationUnitDeclaration parsedUnit = units[suppliedLength+i];
			if (parsedUnit != null) {
				try {
					boolean localType = hasLocalType[suppliedLength+i];
					if (localType) {
						parser.getMethodBodies(parsedUnit);
					}
					this.lookupEnvironment.completeTypeBindings(parsedUnit, localType);
				} catch (AbortCompilation e) {
					// classpath problem for this type: ignore
				}
			}
			worked(monitor, 1);
		}
		
		// remember type bindings
		for (int i = 0; i < suppliedLength; i++) {
			if (!suppliedTypes[i].isBinaryType()) { // note that binary types have already been remembered above
				CompilationUnitDeclaration parsedUnit = units[i];
				if (parsedUnit != null) {
					boolean localType = hasLocalType[i];
					if (localType) {
						parsedUnit.scope.faultInTypes();
						parsedUnit.scope.verifyMethods(this.lookupEnvironment.methodVerifier());
						parsedUnit.resolve();
					}
						
					// must start with the top level type
					ISourceType topLevelType = (ISourceType) suppliedTypes[i];
					suppliedTypes[i] = null; // no longer needed pass this point				
					while (topLevelType.getEnclosingType() != null) {
						topLevelType = topLevelType.getEnclosingType();
					}
					org.eclipse.jdt.core.ICompilationUnit cu = ((SourceTypeElementInfo)topLevelType).getHandle().getCompilationUnit();
					rememberAllTypes(parsedUnit, cu, localType);
				}
			}
		}
		for (int i = 0; i < sourceLength; i++) {
			CompilationUnitDeclaration parsedUnit = units[suppliedLength+i];
			if (parsedUnit != null) {
				boolean localType = hasLocalType[suppliedLength+i];
				if (localType) {
					parsedUnit.scope.faultInTypes();
					parsedUnit.scope.verifyMethods(this.lookupEnvironment.methodVerifier());
					parsedUnit.resolve();
				}
				
				rememberAllTypes(parsedUnit, closedCUs[i], localType);
			}
		}

		reportHierarchy();
		
	} catch (ClassCastException e){ // work-around for 1GF5W1S - can happen in case duplicates are fed to the hierarchy with binaries hiding sources
	} catch (AbortCompilation e) { // ignore this exception for now since it typically means we cannot find java.lang.Object
	} finally {
		reset();
	}
}

