/**
 * Configure this type hierarchy based on the given potential subtypes.
 */
private void buildFromPotentialSubtypes(String[] allPotentialSubTypes) {
	IType focusType = this.getType();
		
	int length = allPotentialSubTypes.length;

	// inject the compilation unit of the focus type (so that types in
	// this cu have special visibility permission (this is also usefull
	// when the cu is a working copy)
	Openable focusCU = (Openable)focusType.getCompilationUnit();
	String focusPath = null;
	if (focusCU != null) {
		try {
			IResource underlyingResource;
			if (focusCU instanceof WorkingCopy) {
				underlyingResource = ((WorkingCopy)focusCU).getOriginalElement().getUnderlyingResource();
			} else {
				underlyingResource = focusCU.getUnderlyingResource();
			}
			focusPath = underlyingResource.getFullPath().toString();
		} catch (JavaModelException e) {
			// type does not exist
			return;
		}
		if (length > 0) {
			System.arraycopy(allPotentialSubTypes, 0, allPotentialSubTypes = new String[length+1], 0, length);
			allPotentialSubTypes[length] = focusPath;	
		} else {
			allPotentialSubTypes = new String[] {focusPath};
		}
		length++;
	}
	
	// sort by projects
	/*
	 * NOTE: To workaround pb with hierarchy resolver that requests top  
	 * level types in the process of caching an enclosing type, this needs to
	 * be sorted in reverse alphabetical order so that top level types are cached
	 * before their inner types.
	 */
	Util.sortReverseOrder(allPotentialSubTypes);
	
	ArrayList infos = new ArrayList();
	ArrayList units = new ArrayList();

	// create element infos for subtypes
	HandleFactory factory = new HandleFactory(ResourcesPlugin.getWorkspace());
	IJavaProject currentProject = null;
	for (int i = 0; i < length; i++) {
		try {
			String resourcePath = allPotentialSubTypes[i];
			
			// skip duplicate paths (e.g. if focus path was injected when it was already a potential subtype)
			if (i > 0 && resourcePath.equals(allPotentialSubTypes[i-1])) continue;
			
			Openable handle = 
				resourcePath.equals(focusPath) ? 
					focusCU :
					factory.createOpenable(resourcePath);
			if (handle == null) continue; // match is outside classpath
			
			IJavaProject project = handle.getJavaProject();
			if (currentProject == null) {
				currentProject = project;
				infos = new ArrayList(5);
				units = new ArrayList(5);
			} else if (!currentProject.equals(project)) {
				// build current project
				this.buildForProject((JavaProject)currentProject, infos, units);
				currentProject = project;
				infos = new ArrayList(5);
				units = new ArrayList(5);
			}
			
			this.addInfoFromElement(handle, infos, units, resourcePath);
			
			worked(1);
		} catch (JavaModelException e) {
			continue;
		}
	}
	
	// build last project
	try {
		if (currentProject == null) {
			// case of no potential subtypes
			currentProject = focusType.getJavaProject();
			this.addInfosFromType(focusType, infos);
		}
		this.buildForProject((JavaProject)currentProject, infos, units);
	} catch (JavaModelException e) {
	}
	
	// Compute hierarchy of focus type if not already done (case of a type with potential subtypes that are not real subtypes)
	if (!this.hierarchy.contains(focusType)) {
		try {
			currentProject = focusType.getJavaProject();
			infos = new ArrayList();
			units = new ArrayList();
			this.addInfosFromType(focusType, infos);
			this.buildForProject((JavaProject)currentProject, infos, units);
		} catch (JavaModelException e) {
		}
	}
	
	// Add focus if not already in (case of a type with no explicit super type)
	if (!this.hierarchy.contains(focusType)) {
		this.hierarchy.addRootClass(focusType);
	}
}

