/**
 * Configure this type hierarchy based on the given potential subtypes.
 */
private void buildFromPotentialSubtypes(String[] allPotentialSubTypes) {
	// sort by projects
	/*
	 * NOTE: To workaround pb with hierarchy resolver that requests top  
	 * level types in the process of caching an enclosing type, this needs to
	 * be sorted in reverse alphabetical order so that top level types are cached
	 * before their inner types.
	 */
	Util.sortReverseOrder(allPotentialSubTypes);
	
	ArrayList infos = new ArrayList();
	ArrayList units = new ArrayList();

	IType focusType = this.getType();

	// create element infos for subtypes
	IWorkspace workspace = focusType.getJavaProject().getProject().getWorkspace();
	HandleFactory factory = new HandleFactory(workspace);
	IJavaProject currentProject = null;
	for (int i = 0, length = allPotentialSubTypes.length; i < length; i++) {
		try {
			String resourcePath = allPotentialSubTypes[i];
			Openable handle = factory.createOpenable(resourcePath);
			if (handle == null) continue; // match is outside classpath
			
			// working copies take precedence over compilation units
			Object workingCopy = this.handleToWorkingCopy.get(handle);
			if (workingCopy != null) {
				handle = (Openable)workingCopy;
			}
			
			IJavaProject project = handle.getJavaProject();
			if (currentProject == null) {
				currentProject = project;
				infos = new ArrayList(5);
				units = new ArrayList(5);
			} else if (!currentProject.equals(project)) {
				this.buildForProject((JavaProject)currentProject, infos, units);
				currentProject = project;
				infos = new ArrayList(5);
				units = new ArrayList(5);
			}
			if (handle.isOpen()) {
				// reuse the info from the java model cache
				if (handle instanceof CompilationUnit) {
					this.addInfoFromOpenCU((CompilationUnit)handle, infos);
				} else if (handle instanceof ClassFile) {
					this.addInfoFromOpenClassFile((ClassFile)handle, infos);
				}
			} else {
				HierarchyBinaryType binaryType = (HierarchyBinaryType) binariesFromIndexMatches.get(resourcePath);
				if (binaryType != null){
					this.addInfoFromBinaryIndexMatch(handle, binaryType, infos);
				} else {
					// create a temporary info
					IJavaElement pkg = handle.getParent();
					PackageFragmentRoot root = (PackageFragmentRoot)pkg.getParent();
					if (root.isArchive()) {
						// class file in a jar
						this.createInfoFromClassFileInJar(handle, infos);
					} else {
						// file in a directory
						IPath path = new Path(resourcePath);
						IFile file = workspace.getRoot().getFile(path);
						IPath location = file.getLocation();
						if (location != null){
							String osPath = location.toOSString();
							if (handle instanceof CompilationUnit) {
								// compilation unit in a directory
								this.createCompilationUnitFromPath(handle, osPath, units);
							} else if (handle instanceof ClassFile) {
								// class file in a directory
								this.createInfoFromClassFile(handle, osPath, infos);
							}
						}
					}
				}
			}
			worked(1);
		} catch (JavaModelException e) {
			continue;
		}
	}
	try {
		if (currentProject == null) {
			// case of no potential subtypes
			currentProject = focusType.getJavaProject();
			this.addInfosFromType(focusType, infos);
		}
		this.buildForProject((JavaProject)currentProject, infos, units);
	} catch (JavaModelException e) {
	}
	
	// Compute hierarchy of focus type if not already done (case of a type with potential subtypes that are not real subtypes)
	if (!this.hierarchy.contains(focusType)) {
		try {
			currentProject = focusType.getJavaProject();
			infos = new ArrayList();
			units = new ArrayList();
			this.addInfosFromType(focusType, infos);
			this.buildForProject((JavaProject)currentProject, infos, units);
		} catch (JavaModelException e) {
		}
	}
	
	// Add focus if not already in (case of a type with no explicit super type)
	if (!this.hierarchy.contains(focusType)) {
		this.hierarchy.addRootClass(focusType);
	}
}

