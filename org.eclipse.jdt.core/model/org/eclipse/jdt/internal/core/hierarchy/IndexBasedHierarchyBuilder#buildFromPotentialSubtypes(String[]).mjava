/**
 * Configure this type hierarchy based on the given potential subtypes.
 */
private void buildFromPotentialSubtypes(String[] allPotentialSubTypes) {
	IType focusType = this.getType();
		
	int length = allPotentialSubTypes.length;

	// inject the compilation unit of the focus type (so that types in
	// this cu have special visibility permission (this is also usefull
	// when the cu is a working copy)
	Openable focusCU = (Openable)focusType.getCompilationUnit();
	String focusPath = null;
	if (focusCU != null) {
		try {
			IResource underlyingResource;
			if (focusCU instanceof WorkingCopy) {
				underlyingResource = ((WorkingCopy)focusCU).getOriginalElement().getUnderlyingResource();
			} else {
				underlyingResource = focusCU.getUnderlyingResource();
			}
			focusPath = underlyingResource.getFullPath().toString();
		} catch (JavaModelException e) {
			// type does not exist
			return;
		}
		if (length > 0) {
			System.arraycopy(allPotentialSubTypes, 0, allPotentialSubTypes = new String[length+1], 0, length);
			allPotentialSubTypes[length] = focusPath;	
		} else {
			allPotentialSubTypes = new String[] {focusPath};
		}
		length++;
	}
	
	// sort by projects
	/*
	 * NOTE: To workaround pb with hierarchy resolver that requests top  
	 * level types in the process of caching an enclosing type, this needs to
	 * be sorted in reverse alphabetical order so that top level types are cached
	 * before their inner types.
	 */
	Util.sortReverseOrder(allPotentialSubTypes);
	
	ArrayList infos = new ArrayList();
	ArrayList units = new ArrayList();

	// create element infos for subtypes
	IWorkspace workspace = focusType.getJavaProject().getProject().getWorkspace();
	HandleFactory factory = new HandleFactory(workspace);
	IJavaProject currentProject = null;
	for (int i = 0; i < length; i++) {
		try {
			String resourcePath = allPotentialSubTypes[i];
			
			// skip duplicate paths (e.g. if focus path was injected when it was already a potential subtype)
			if (i > 0 && resourcePath.equals(allPotentialSubTypes[i-1])) continue;
			
			Openable handle = 
				resourcePath.equals(focusPath) ? 
					focusCU :
					factory.createOpenable(resourcePath);
			if (handle == null) continue; // match is outside classpath
			
			IJavaProject project = handle.getJavaProject();
			if (currentProject == null) {
				currentProject = project;
				infos = new ArrayList(5);
				units = new ArrayList(5);
			} else if (!currentProject.equals(project)) {
				// build current project
				this.buildForProject((JavaProject)currentProject, infos, units);
				currentProject = project;
				infos = new ArrayList(5);
				units = new ArrayList(5);
			}
			if (handle.isOpen()) {
				// reuse the info from the java model cache
				if (handle instanceof CompilationUnit) {
					this.addInfoFromOpenCU((CompilationUnit)handle, infos);
				} else if (handle instanceof ClassFile) {
					this.addInfoFromOpenClassFile((ClassFile)handle, infos);
				}
			} else {
				HierarchyBinaryType binaryType = (HierarchyBinaryType) binariesFromIndexMatches.get(resourcePath);
				if (binaryType != null){
					this.addInfoFromBinaryIndexMatch(handle, binaryType, infos);
				} else {
					// create a temporary info
					IJavaElement pkg = handle.getParent();
					PackageFragmentRoot root = (PackageFragmentRoot)pkg.getParent();
					if (root.isArchive()) {
						// class file in a jar
						this.createInfoFromClassFileInJar(handle, infos);
					} else {
						// file in a directory
						IPath path = new Path(resourcePath);
						IFile file = workspace.getRoot().getFile(path);
						IPath location = file.getLocation();
						if (location != null){
							String osPath = location.toOSString();
							if (handle instanceof CompilationUnit) {
								// compilation unit in a directory
								this.createCompilationUnitFromPath(handle, osPath, units);
							} else if (handle instanceof ClassFile) {
								// class file in a directory
								this.createInfoFromClassFile(handle, osPath, infos);
							}
						}
					}
				}
			}
			worked(1);
		} catch (JavaModelException e) {
			continue;
		}
	}
	
	// build last project
	try {
		if (currentProject == null) {
			// case of no potential subtypes
			currentProject = focusType.getJavaProject();
			this.addInfosFromType(focusType, infos);
		}
		this.buildForProject((JavaProject)currentProject, infos, units);
	} catch (JavaModelException e) {
	}
	
	// Compute hierarchy of focus type if not already done (case of a type with potential subtypes that are not real subtypes)
	if (!this.hierarchy.contains(focusType)) {
		try {
			currentProject = focusType.getJavaProject();
			infos = new ArrayList();
			units = new ArrayList();
			this.addInfosFromType(focusType, infos);
			this.buildForProject((JavaProject)currentProject, infos, units);
		} catch (JavaModelException e) {
		}
	}
	
	// Add focus if not already in (case of a type with no explicit super type)
	if (!this.hierarchy.contains(focusType)) {
		this.hierarchy.addRootClass(focusType);
	}
}

