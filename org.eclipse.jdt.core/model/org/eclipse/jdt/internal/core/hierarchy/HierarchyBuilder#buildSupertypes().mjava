	/**
	 * Configure this type hierarchy by computing the supertypes only.
	 */
	protected void buildSupertypes() {

		IType focusType = this.getType();
		if (focusType == null)
			return;

		// get generic type from focus type
		IGenericType type;
		try {
			type = (IGenericType) ((JavaElement) focusType).getRawInfo();
		} catch (JavaModelException e) {
			// if the focus type is not present, or if cannot get workbench path
			// we cannot create the hierarchy
			return;
		}

		//NB: no need to set focus type on hierarchy resolver since no other type is injected
		//    in the hierarchy resolver, thus there is no need to check that a type is 
		//    a sub or super type of the focus type.
		ICompilationUnit unitToLookInside = focusType.getCompilationUnit();
		if (nameLookup != null && unitToLookInside != null) {
			synchronized(nameLookup) { // prevent 2 concurrent accesses to name lookup while the working copies are set
				try {
					nameLookup.setUnitsToLookInside(new IWorkingCopy[] {unitToLookInside});
					// resolve
					this.hierarchyResolver.resolve(type);
				} finally {
					nameLookup.setUnitsToLookInside(null);
				}
			}
		} else {
			// resolve
			this.hierarchyResolver.resolve(type);
		}

		// Add focus if not already in (case of a type with no explicit super type)
		if (!this.hierarchy.contains(focusType)) {
			this.hierarchy.addRootClass(focusType);
		}
	}

