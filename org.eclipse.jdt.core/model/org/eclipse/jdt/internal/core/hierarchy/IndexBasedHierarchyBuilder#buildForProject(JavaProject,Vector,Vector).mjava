private void buildForProject(JavaProject project, Vector infos, Vector units) throws JavaModelException {
	IType focusType = this.getType();
	if (focusType != null && focusType.getJavaProject().equals(project)) {
		// add focus type
		try {
			infos.addElement(((JavaElement) focusType).getRawInfo());
		} catch (JavaModelException e) {
			// if the focus type is not present, or if cannot get workbench path
			// we cannot create the hierarchy
			return;
		}
	}
	
	// copy vectors into arrays
	IGenericType[] genericTypes;
	int infosSize = infos.size();
	if (infosSize > 0) {
		genericTypes = new IGenericType[infosSize];
		infos.copyInto(genericTypes);
	} else {
		genericTypes = new IGenericType[0];
	}
	ICompilationUnit[] compilationUnits;
	int unitsSize = units.size();
	if (unitsSize > 0) {
		compilationUnits = new ICompilationUnit[unitsSize];
		units.copyInto(compilationUnits);
	} else {
		compilationUnits = new ICompilationUnit[0];
	}

	// resolve
	if (infosSize > 0 || unitsSize > 0) {
		this.searchableEnvironment = (SearchableEnvironment)project.getSearchableNameEnvironment();
		if (focusType != null && focusType.getJavaProject().equals(project)) {
			this.searchableEnvironment.unitToLookInside = (CompilationUnit)focusType.getCompilationUnit();
		}
		this.nameLookup = project.getNameLookup();
		this.hierarchyResolver = 
			new HierarchyResolver(this.searchableEnvironment, this, new DefaultProblemFactory());
		this.hierarchyResolver.resolve(genericTypes, compilationUnits);
		if (focusType != null && focusType.getJavaProject().equals(project)) {
			this.searchableEnvironment.unitToLookInside = null;
		}
	}
}

