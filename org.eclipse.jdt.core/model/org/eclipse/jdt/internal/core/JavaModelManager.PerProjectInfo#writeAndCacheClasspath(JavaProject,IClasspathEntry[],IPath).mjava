		public boolean writeAndCacheClasspath(final JavaProject javaProject, final IClasspathEntry[] newRawClasspath, final IPath newOutputLocation) throws JavaModelException {
			final boolean[] result = new boolean[1];
			try {
				// use a workspace runnable so that the notification of .classpath file change is done outside the synchronized block (to avoid deadlocks)
				IWorkspace workspace = 	ResourcesPlugin.getWorkspace();
				workspace.run(new IWorkspaceRunnable() {
					public void run(IProgressMonitor monitor) throws CoreException {
						// ensure that the writing of the .classpath file and the caching in memory are synchronized (see also readAnCacheClasspath which is synchronized)
						try {
							PerProjectInfo.this.writtingRawClasspath = true;
							synchronized (PerProjectInfo.this) {
								if (!javaProject.writeFileEntries(newRawClasspath, newOutputLocation)) {
									result[0] = false;
									return;
								}
								// store new raw classpath, new output and new status, and null out resolved info
								setRawClasspath(newRawClasspath, newOutputLocation, JavaModelStatus.VERIFIED_OK);
								result[0] = true;
							}
						} finally {
							PerProjectInfo.this.writtingRawClasspath = false;
						}
					}
				}, 
				this.project, // use project scheduling rule as this is needed to create the .classpath file if it doesn't exist yet
				IWorkspace.AVOID_UPDATE,
				null);
			} catch (CoreException e) {
				Util.log(e, "Exception while writing the .classpath file for " + javaProject); //$NON-NLS-1$
			}
			return result[0];
		}

