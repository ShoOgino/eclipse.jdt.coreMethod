/**
 * Computes the depth of the given java project following its classpath.
 * Only projects are taken into consideration. Store the depth in the given table.
 * Returns the depth.
 * Note that a project with no prerequisites has a depth of 0.
 * Returns -1 if a cycle is detected
 */
protected int computeDepth(String projectName, StringHashtableOfInt depthTable, String dependentProjectName, boolean generateMarkerOnError) throws JavaModelException {
	int depth = depthTable.get(projectName);
	switch (depth) {
		case -2: // project already visited -> it's a cycle
			if (generateMarkerOnError) {
				try {
					IMarker marker = this.workspace.getRoot().getProject(dependentProjectName).createMarker(IJavaModelMarker.TRANSIENT_PROBLEM);
					marker.setAttributes(
						new String[]{ IMarker.MESSAGE, IMarker.PRIORITY, IMarker.LOCATION, IJavaModelMarker.CYCLE_DETECTED},
						new Object[]{ Util.bind("classpath.cycle"/*nonNLS*/), new Integer(IMarker.PRIORITY_HIGH), dependentProjectName, dependentProjectName});
				} catch (CoreException e) {
					e.printStackTrace();
				}
			} else {
				throw new JavaModelException(new JavaModelStatus(IJavaModelStatusConstants.NAME_COLLISION));
			}
			return -1;
		case -1:
			depthTable.put(projectName, -2); // mark we're visiting the project
			int prereqDepth = -1;
			JavaProject project = (JavaProject)this.getJavaProject(projectName);
			String[] prerequisites = null;
			try {
				prerequisites = project.getRequiredProjectNames();
			} catch (JavaModelException e) {
				prerequisites = JavaProject.NO_PREREQUISITES;
			}
			for (int i = 0, length = prerequisites.length; i < length; i++) {
				String prerequisite = prerequisites[i];
				prereqDepth = 
					Math.max(
						prereqDepth, 
						this.computeDepth(prerequisite, depthTable, projectName, generateMarkerOnError)
					);
			}
			depth = 1 + prereqDepth;
			depthTable.put(projectName, depth);
			return depth;
		default:
			return depth;
	}
}

