	/*
	 * Update projects references so that the build order is consistent with the classpath
	 */
	public void updateProjectReferencesIfNecessary() throws JavaModelException {

		final String[] oldRequired = this.oldResolvedClasspath == null ? CharOperation.NO_STRINGS : this.project.projectPrerequisites(this.oldResolvedClasspath);
		IClasspathEntry[] newResolvedClasspath = this.project.getResolvedClasspath();
		final String[] newRequired = this.project.projectPrerequisites(newResolvedClasspath);
		final IProject projectResource = this.project.getProject();
		IWorkspaceRunnable runnable = new IWorkspaceRunnable() {
			public void run(IProgressMonitor monitor) throws CoreException {
				IProjectDescription description = projectResource.getDescription();

				IProject[] projectReferences = description.getDynamicReferences();

				HashSet oldReferences = new HashSet(projectReferences.length);
				for (int i = 0; i < projectReferences.length; i++){
					String projectName = projectReferences[i].getName();
					oldReferences.add(projectName);
				}
				HashSet newReferences = (HashSet)oldReferences.clone();

				for (int i = 0; i < oldRequired.length; i++){
					String projectName = oldRequired[i];
					newReferences.remove(projectName);
				}
				for (int i = 0; i < newRequired.length; i++){
					String projectName = newRequired[i];
					newReferences.add(projectName);
				}

				Iterator iter;
				int newSize = newReferences.size();

				checkIdentity: {
					if (oldReferences.size() == newSize){
						iter = newReferences.iterator();
						while (iter.hasNext()){
							if (!oldReferences.contains(iter.next())){
								break checkIdentity;
							}
						}
						return;
					}
				}
				String[] requiredProjectNames = new String[newSize];
				int index = 0;
				iter = newReferences.iterator();
				while (iter.hasNext()){
					requiredProjectNames[index++] = (String)iter.next();
				}
				Util.sort(requiredProjectNames); // ensure that if changed, the order is consistent

				IProject[] requiredProjectArray = new IProject[newSize];
				IWorkspaceRoot wksRoot = projectResource.getWorkspace().getRoot();
				for (int i = 0; i < newSize; i++){
					requiredProjectArray[i] = wksRoot.getProject(requiredProjectNames[i]);
				}
				description.setDynamicReferences(requiredProjectArray);
				projectResource.setDescription(description, IResource.AVOID_NATURE_CONFIG, null);
			}
		};
		try {
			// ensure that a sheduling rule is used so that the project description is not modified by another thread while we update it
			// see https://bugs.eclipse.org/bugs/show_bug.cgi?id=214981
			IWorkspace workspace = projectResource.getWorkspace();
			ISchedulingRule rule = workspace.getRuleFactory().modifyRule(projectResource); // sheduling rule for modifying the project
			workspace.run(runnable, rule, IWorkspace.AVOID_UPDATE, null);
		} catch(CoreException e){
			if (!ExternalJavaProject.EXTERNAL_PROJECT_NAME.equals(this.project.getElementName()))
				throw new JavaModelException(e);
		}
	}

