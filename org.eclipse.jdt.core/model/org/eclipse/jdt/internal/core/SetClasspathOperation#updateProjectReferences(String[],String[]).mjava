	/**
	 * Update projects references so that the build order is consistent with the classpath
	 */
	protected void updateProjectReferences(String[] oldRequired, String[] newRequired) {

		try {		
			if (!this.canChangeResource) return;

			checkIdentical : {
				int oldLength = oldRequired.length;
				if (oldLength == newRequired.length){
					for (int i = 0; i < oldLength; i++){
						if (!oldRequired[i].equals(newRequired[i])){
							break checkIdentical;
						}
					}
				}
				return;
			}
			
			JavaProject jproject = ((JavaProject) getElementsToProcess()[0]);
			IProject project = jproject.getProject();
			IProjectDescription description = project.getDescription();
			 
			IProject[] projectReferences = description.getReferencedProjects();
			
			HashSet oldReferences = new HashSet(projectReferences.length);
			for (int i = 0; i < projectReferences.length; i++){
				String projectName = projectReferences[i].getName();
				oldReferences.add(projectName);
			}
			HashSet newReferences = (HashSet)oldReferences.clone();

			for (int i = 0; i < oldRequired.length; i++){
				String projectName = oldRequired[i];
				newReferences.remove(projectName);
			}
			for (int i = 0; i < newRequired.length; i++){
				String projectName = newRequired[i];
				newReferences.add(projectName);
			}

			IProject[] requiredProjectArray = new IProject[newReferences.size()];
			IWorkspaceRoot wksRoot = project.getWorkspace().getRoot();
			Iterator iter = newReferences.iterator();
			int index = 0;
			while (iter.hasNext()){
				String newName = (String)iter.next();
				requiredProjectArray[index++] = wksRoot.getProject(newName);
			}
			description.setReferencedProjects(requiredProjectArray);
			project.setDescription(description, this.fMonitor);

		} catch(CoreException e){
		}
	}

