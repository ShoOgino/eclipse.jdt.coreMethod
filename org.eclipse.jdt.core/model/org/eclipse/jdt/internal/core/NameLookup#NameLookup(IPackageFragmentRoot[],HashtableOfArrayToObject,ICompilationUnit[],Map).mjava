	public NameLookup(IPackageFragmentRoot[] packageFragmentRoots, HashtableOfArrayToObject packageFragments, ICompilationUnit[] workingCopies, Map rootToResolvedEntries) {
		if (VERBOSE) {
			System.out.println(Thread.currentThread() + " BUILDING NameLoopkup");  //$NON-NLS-1$
			System.out.println(Thread.currentThread() + " -> pkg roots size: " + (packageFragmentRoots == null ? 0 : packageFragmentRoots.length));  //$NON-NLS-1$
			System.out.println(Thread.currentThread() + " -> pkgs size: " + (packageFragments == null ? 0 : packageFragments.size()));  //$NON-NLS-1$
			System.out.println(Thread.currentThread() + " -> working copy size: " + (workingCopies == null ? 0 : workingCopies.length));  //$NON-NLS-1$
		}
		this.packageFragmentRoots = packageFragmentRoots;
		this.packageFragments = packageFragments;
		if (workingCopies != null) {
			this.unitsToLookInside = new HashMap();
			HashSet visited = new HashSet();
			for (int i = 0, length = workingCopies.length; i < length; i++) {
				ICompilationUnit workingCopy = workingCopies[i];
				PackageFragment pkg = (PackageFragment) workingCopy.getParent();
				HashMap typeMap = (HashMap) this.unitsToLookInside.get(pkg);
				if (typeMap == null) {
					typeMap = new HashMap();
					this.unitsToLookInside.put(pkg, typeMap);
				}
				try {
					IType[] types = workingCopy.getTypes();
					for (int j = 0, typeLength = types.length; j < typeLength; j++) {
						IType type = types[j];
						String typeName = type.getElementName();
						Object existing = typeMap.get(typeName);
						if (existing == null) {
							typeMap.put(typeName, type);
						} else if (existing instanceof IType) {
							typeMap.put(typeName, new IType[] {(IType) existing, type});
						} else {
							IType[] existingTypes = (IType[]) existing;
							int existingTypeLength = existingTypes.length;
							System.arraycopy(existingTypes, 0, existingTypes = new IType[existingTypeLength+1], 0, existingTypeLength);
							existingTypes[length] = type;
							typeMap.put(typeName, existingTypes);
						}
					}
				} catch (JavaModelException e) {
					// working copy doesn't exist -> ignore
				}
				
				// add root of package fragment to cache
				IPackageFragmentRoot root = (IPackageFragmentRoot) pkg.getParent();
				if (visited.contains(root)) continue;
				String[] pkgName = pkg.names;
				IPackageFragmentRoot[] roots = (IPackageFragmentRoot[]) packageFragments.get(pkgName);
				if (roots == null) {
					packageFragments.put(pkgName, new IPackageFragmentRoot[] {root});
				} else {
					int rootLength = roots.length;
					System.arraycopy(roots, 0, roots = new IPackageFragmentRoot[rootLength+1], 0, rootLength);
					roots[rootLength] = root;
					packageFragments.put(pkgName, roots);
				}
				visited.add(root);
			}
		}
		this.rootToResolvedEntries = rootToResolvedEntries;
	}

