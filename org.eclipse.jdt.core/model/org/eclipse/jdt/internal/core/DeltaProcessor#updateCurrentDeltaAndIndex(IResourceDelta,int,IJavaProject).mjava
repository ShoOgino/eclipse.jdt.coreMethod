/*
 * Update the current delta (ie. add/remove/change the given element) and update the correponding index.
 * Returns whether the children of the given delta must be processed.
 * @throws a JavaModelException if the delta doesn't correspond to a java element of the given type.
 */
private boolean updateCurrentDeltaAndIndex(IResourceDelta delta, int elementType, IJavaProject project) throws JavaModelException {
	Openable element;
	switch (delta.getKind()) {
		case IResourceDelta.ADDED :
			IResource deltaRes = delta.getResource();
			element = this.createElement(deltaRes, elementType, project);
			if (element == null) {
				// resource might be containing shared roots (see bug 19058)
				this.updateRoots(deltaRes.getFullPath(), delta);
				throw newInvalidElementType();
			}
			this.updateIndex(element, delta);
			this.elementAdded(element, delta);
			return false;
		case IResourceDelta.REMOVED :
			deltaRes = delta.getResource();
			element = this.createElement(deltaRes, elementType, project);
			if (element == null) {
				// resource might be containing shared roots (see bug 19058)
				this.updateRoots(deltaRes.getFullPath(), delta);
				throw newInvalidElementType();
			}
			this.updateIndex(element, delta);
			this.elementRemoved(element, delta);
			return false;
		case IResourceDelta.CHANGED :
			int flags = delta.getFlags();
			if ((flags & IResourceDelta.CONTENT) != 0) {
				// content has changed
				element = this.createElement(delta.getResource(), elementType, project);
				if (element == null) throw newInvalidElementType();
				this.updateIndex(element, delta);
				this.contentChanged(element, delta);
			} else if (elementType == IJavaElement.JAVA_PROJECT) {
				if ((flags & IResourceDelta.OPEN) != 0) {
					// project has been opened or closed
					IProject res = (IProject)delta.getResource();
					element = this.createElement(res, elementType, project);
					if (element == null) {
						// resource might be containing shared roots (see bug 19058)
						this.updateRoots(res.getFullPath(), delta);
						throw newInvalidElementType();
					}
					if (res.isOpen()) {
						if (this.hasJavaNature(res)) {
							this.elementAdded(element, delta);
							this.indexManager.indexAll(res);
						}
					} else {
						JavaModel javaModel = JavaModelManager.getJavaModelManager().getJavaModel();
						boolean wasJavaProject = javaModel.findJavaProject(res) != null;
						if (wasJavaProject) {
							this.elementRemoved(element, delta);
							this.indexManager.discardJobs(element.getElementName());
							this.indexManager.removeIndexFamily(res.getFullPath());
							
						}
					}
					return false; // when a project is open/closed don't process children
				}
				if ((flags & IResourceDelta.DESCRIPTION) != 0) {
					IProject res = (IProject)delta.getResource();
					JavaModel javaModel = JavaModelManager.getJavaModelManager().getJavaModel();
					boolean wasJavaProject = javaModel.findJavaProject(res) != null;
					boolean isJavaProject = this.hasJavaNature(res);
					if (wasJavaProject != isJavaProject) {
						// project's nature has been added or removed
						element = this.createElement(res, elementType, project);
						if (element == null) throw newInvalidElementType(); // note its resources are still visible as roots to other projects
						if (isJavaProject) {
							this.elementAdded(element, delta);
							this.indexManager.indexAll(res);
						} else {
							this.elementRemoved(element, delta);
							this.indexManager.discardJobs(element.getElementName());
							this.indexManager.removeIndexFamily(res.getFullPath());
						}
						return false; // when a project's nature is added/removed don't process children
					}
				}
			}
			return true;
	}
	return true;
}

