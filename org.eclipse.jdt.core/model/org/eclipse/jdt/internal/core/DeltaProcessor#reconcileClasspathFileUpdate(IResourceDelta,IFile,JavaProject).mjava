	/**
	 * Update the JavaModel according to a .classpath file change. The file can have changed as a result of a previous
	 * call to JavaProject#setRawClasspath or as a result of some user update (through repository)	 */
	private void reconcileClasspathFileUpdate(IResourceDelta delta, IFile file, JavaProject project) {
			
		switch (delta.getKind()) {
			case IResourceDelta.REMOVED : // recreate one based on in-memory path
				try {
					project.saveClasspath(project.getRawClasspath(), project.getOutputLocation());
				} catch (JavaModelException e) {
					if (project.getProject().isAccessible()) {
						Util.log(e, "Could not save classpath for "+ project.getPath()); //$NON-NLS-1$
					}
				}
				break;
			case IResourceDelta.CHANGED :
				if ((delta.getFlags() & IResourceDelta.CONTENT) == 0  // only consider content change
						&& (delta.getFlags() & IResourceDelta.MOVED_FROM) == 0) // and also move and overide scenario (see http://dev.eclipse.org/bugs/show_bug.cgi?id=21420)
					break;
			case IResourceDelta.ADDED :
				// check if any actual difference
				project.flushClasspathProblemMarkers(false, true);
				boolean wasSuccessful = false; // flag recording if .classpath file change got reflected
				try {
					// force to (re)read the property file
					IClasspathEntry[] fileEntries = project.readClasspathFile(true/*create markers*/, false/*don't log problems*/);
					if (fileEntries == null)
						break; // could not read, ignore 
					if (project.isClasspathEqualsTo(project.getRawClasspath(), project.getOutputLocation(), fileEntries)) {
						wasSuccessful = true;
						break;
					}
		
					// will force an update of the classpath/output location based on the file information
					// extract out the output location
					IPath outputLocation = null;
					if (fileEntries != null && fileEntries.length > 0) {
						IClasspathEntry entry = fileEntries[fileEntries.length - 1];
						if (entry.getContentKind() == ClasspathEntry.K_OUTPUT) {
							outputLocation = entry.getPath();
							IClasspathEntry[] copy = new IClasspathEntry[fileEntries.length - 1];
							System.arraycopy(fileEntries, 0, copy, 0, copy.length);
							fileEntries = copy;
						}
					}
					// restore output location				
					if (outputLocation == null) {
						outputLocation = SetClasspathOperation.ReuseOutputLocation;
					}
					project.setRawClasspath(
						fileEntries, 
						outputLocation, 
						null, // monitor
						true, // canChangeResource
						project.getResolvedClasspath(true), // ignoreUnresolvedVariable
						true); // needValidation
					
					// if reach that far, the classpath file change got absorbed
					wasSuccessful = true;
				} catch (RuntimeException e) {
					// setRawClasspath might fire a delta, and a listener may throw an exception
					if (project.getProject().isAccessible()) {
						Util.log(e, "Could not set classpath for "+ project.getPath()); //$NON-NLS-1$
					}
					break;
				} catch (JavaModelException e) { // CP failed validation
					if (project.getProject().isAccessible()) {
						if (e.getJavaModelStatus().getException() instanceof CoreException) {
							// happens if the .classpath could not be written to disk
							project.createClasspathProblemMarker(
									Util.bind("classpath.couldNotWriteClasspathFile", project.getElementName(), e.getMessage()), //$NON-NLS-1$
									IMarker.SEVERITY_ERROR,
									false,	//  cycle error
									true);	//	file format error		
						} else {
							project.createClasspathProblemMarker(
									Util.bind("classpath.invalidClasspathInClasspathFile", project.getElementName(), e.getMessage()), //$NON-NLS-1$
									IMarker.SEVERITY_ERROR,
									false,	//  cycle error
									true);	//	file format error		
						}			
					}
					break;
				} finally {
					if (!wasSuccessful) { 
						try {
							project.setRawClasspath0(JavaProject.INVALID_CLASSPATH);
						} catch (JavaModelException e) {
						}
					}
				}
		}
	}

