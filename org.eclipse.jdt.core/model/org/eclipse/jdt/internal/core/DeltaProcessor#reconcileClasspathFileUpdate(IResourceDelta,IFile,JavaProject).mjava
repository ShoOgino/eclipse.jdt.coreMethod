	/**
	 * Update the JavaModel according to a .classpath file change. The file can have changed as a result of a previous
	 * call to JavaProject#setRawClasspath or as a result of some user update (through repository)	 */
	private void reconcileClasspathFileUpdate(IResourceDelta delta, IFile file, JavaProject project) {
			
		switch (delta.getKind()) {
			case IResourceDelta.REMOVED : // recreate one based on in-memory path
				try {
					project.saveClasspath(project.getRawClasspath(), project.getOutputLocation());
				} catch (JavaModelException e) {
					if (project.getProject().isAccessible()) {
						Util.log(e, "Could not save classpath for "+ project.getPath()); //$NON-NLS-1$
					}
				}
				break;
			case IResourceDelta.CHANGED :
				if ((delta.getFlags() & IResourceDelta.CONTENT) == 0  // only consider content change
						&& (delta.getFlags() & IResourceDelta.MOVED_FROM) == 0) // and also move and overide scenario (see http://dev.eclipse.org/bugs/show_bug.cgi?id=21420)
					break;
			case IResourceDelta.ADDED :
				// check if any actual difference
				project.flushClasspathProblemMarkers(false, true);
				try {
					// force to (re)read the property file
					IClasspathEntry[] fileEntries = null;
					try {
						String fileClasspathString = project.loadClasspath();
						if (fileClasspathString != null) {
							fileEntries = project.readPaths(fileClasspathString);
						}
					} catch(JavaModelException e) {
						if (project.getProject().isAccessible()) {
							Util.log(e, 
								"Exception while retrieving "+ project.getPath() //$NON-NLS-1$
								+"/.classpath, ignore change"); //$NON-NLS-1$
						}
						project.createClasspathProblemMarker(
							Util.bind("classpath.cannotReadClasspathFile", project.getElementName()), //$NON-NLS-1$
							IMarker.SEVERITY_ERROR,
							false,	//  cycle error
							true);	//	file format error
					} catch (IOException e) {
						if (project.getProject().isAccessible()) {
							Util.log(e, 
								"Exception while retrieving "+ project.getPath() //$NON-NLS-1$
								+"/.classpath, ignore change"); //$NON-NLS-1$
						}
						project.createClasspathProblemMarker(
							Util.bind("classpath.cannotReadClasspathFile", project.getElementName()), //$NON-NLS-1$
							IMarker.SEVERITY_ERROR,
							false,	//  cycle error
							true);	//	file format error
					}
					if (fileEntries == null)
						break; // could not read, ignore 
					if (project.isClasspathEqualsTo(project.getRawClasspath(), project.getOutputLocation(), fileEntries))
						break;
		
					// will force an update of the classpath/output location based on the file information
					// extract out the output location
					IPath outputLocation = null;
					if (fileEntries != null && fileEntries.length > 0) {
						IClasspathEntry entry = fileEntries[fileEntries.length - 1];
						if (entry.getContentKind() == ClasspathEntry.K_OUTPUT) {
							outputLocation = entry.getPath();
							IClasspathEntry[] copy = new IClasspathEntry[fileEntries.length - 1];
							System.arraycopy(fileEntries, 0, copy, 0, copy.length);
							fileEntries = copy;
						}
					}
					// restore output location				
					if (outputLocation == null) {
						outputLocation = SetClasspathOperation.ReuseOutputLocation;
					}
					project.setRawClasspath(
						fileEntries, 
						outputLocation, 
						null, // monitor
						true, // canChangeResource
						false, // forceSave
						project.getResolvedClasspath(true), // ignoreUnresolvedVariable
						true); // needValidation
				} catch (RuntimeException e) {
					// setRawClasspath might fire a delta, and a listener may throw an exception
					if (project.getProject().isAccessible()) {
						Util.log(e, "Could not set classpath for "+ project.getPath()); //$NON-NLS-1$
					}
					break;
				} catch (CoreException e) {
					// happens if the .classpath could not be written to disk
					if (project.getProject().isAccessible()) {
						Util.log(e, "Could not set classpath for "+ project.getPath()); //$NON-NLS-1$
					}
					break;
				}
		}
	}

