	/**
	 * Internal variant which can process any arbitrary classpath
	 */
	public IClasspathEntry[] getResolvedClasspath(
		IClasspathEntry[] classpathEntries,
		boolean ignoreUnresolvedEntry,
		boolean generateMarkerOnError)
		throws JavaModelException {

		if (generateMarkerOnError){
			flushClasspathProblemMarkers(false, false);
		}

		int length = classpathEntries.length;
		ArrayList resolvedEntries = new ArrayList();
		
		for (int i = 0; i < length; i++) {

			IClasspathEntry rawEntry = classpathEntries[i];

			/* validation if needed */
			if (generateMarkerOnError) {
				IJavaModelStatus status =
					JavaConventions.validateClasspathEntry(this, rawEntry, false);
				if (!status.isOK()) {
					String incompleteCPOption = this.getOption(JavaCore.CORE_INCOMPLETE_CLASSPATH, true);
					createClasspathProblemMarker(
						status.getMessage(), 
						JavaCore.ERROR.equals(incompleteCPOption) ? IMarker.SEVERITY_ERROR : IMarker.SEVERITY_WARNING,
						false,
						false);
				}
			}

			switch (rawEntry.getEntryKind()){
				
				case IClasspathEntry.CPE_VARIABLE :
				
					IClasspathEntry resolvedEntry = JavaCore.getResolvedClasspathEntry(rawEntry);
					if (resolvedEntry == null) {
						if (!ignoreUnresolvedEntry) {
							throw new JavaModelException(
								new JavaModelStatus(
									IJavaModelStatusConstants.CP_VARIABLE_PATH_UNBOUND,
									rawEntry.getPath().toString()));
						}
					} else {
						resolvedEntries.add(resolvedEntry);
					}
					break; 

				case IClasspathEntry.CPE_CONTAINER :
				
					IClasspathContainer container = JavaCore.getClasspathContainer(rawEntry.getPath(), this);
					if (container == null){
						// unbound container
						if (!ignoreUnresolvedEntry) {
							throw new JavaModelException(
								new JavaModelStatus(
									IJavaModelStatusConstants.CP_CONTAINER_PATH_UNBOUND,
									rawEntry.getPath().toString()));
						}
						break;
					}

					IClasspathEntry[] containerEntries = container.getClasspathEntries();
					if (containerEntries == null) break;

					// container was bound
					for (int j = 0, containerLength = containerEntries.length; j < containerLength; j++){
						IClasspathEntry containerRawEntry = containerEntries[j];
						
						if (generateMarkerOnError) {
							IJavaModelStatus status =
								JavaConventions.validateClasspathEntry(this, containerRawEntry, false);
							if (!status.isOK()) {
								String incompleteCPOption = this.getOption(JavaCore.CORE_INCOMPLETE_CLASSPATH, true);
								createClasspathProblemMarker(
									status.getMessage(), 
									JavaCore.ERROR.equals(incompleteCPOption) ? IMarker.SEVERITY_ERROR : IMarker.SEVERITY_WARNING,
									false,
									false);
						}
						}
						// if container is exported, then its nested entries must in turn be exported  (21749)
						if (rawEntry.isExported()){
							containerRawEntry = new ClasspathEntry(
								containerRawEntry.getContentKind(),
								containerRawEntry.getEntryKind(), 
								containerRawEntry.getPath(),
								containerRawEntry.getExclusionPatterns(),
								containerRawEntry.getSourceAttachmentPath(),
								containerRawEntry.getSourceAttachmentRootPath(),
								containerRawEntry.getOutputLocation(),
								true); // duplicate container entry for tagging it as exported
						}
						resolvedEntries.add(containerRawEntry);
					}
					break;
										
				default :

					resolvedEntries.add(rawEntry);
				
			}					
		}

		IClasspathEntry[] resolvedPath = new IClasspathEntry[resolvedEntries.size()];
		resolvedEntries.toArray(resolvedPath);

		return resolvedPath;
	}

