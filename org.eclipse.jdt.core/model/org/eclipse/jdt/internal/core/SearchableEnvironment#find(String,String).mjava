/**
 * Returns the given type in the the given package if it exists,
 * otherwise <code>null</code>.
 */
protected NameEnvironmentAnswer find(String typeName, String packageName) {
	if (packageName == null)
		packageName = IPackageFragment.DEFAULT_PACKAGE_NAME;
	IType type = this.nameLookup.findType(typeName, packageName, false, INameLookup.ACCEPT_CLASSES | INameLookup.ACCEPT_INTERFACES);
	if (type == null) {
		// look inside the compilation unit that is being searched currently
		//for a non-public or inner type.
		if (this.unitToLookInside != null) {
			if (this.unitToLookInside.getParent().getElementName().equals(packageName)) {
				try {
					IType[] allTypes = this.unitToLookInside.getTypes();
					for (int i= 0; i < allTypes.length; i++) {
						if (allTypes[i].getElementName().equals(typeName)) {
							type = allTypes[i];
							break;
						}
					}
				} catch (JavaModelException e) {
				}
			}
		}
	}
	if (type != null) {
		if (type instanceof BinaryType) {
			try {
				return new NameEnvironmentAnswer((IBinaryType) ((BinaryType) type).getRawInfo());
			} catch (JavaModelException npe) {
				return null;
			}
		} else { //SourceType
			try {
				return new NameEnvironmentAnswer((ISourceType)((SourceType)type).getRawInfo());
			} catch (JavaModelException npe) {
				return null;
			}
		}
	}
	return null;
}

