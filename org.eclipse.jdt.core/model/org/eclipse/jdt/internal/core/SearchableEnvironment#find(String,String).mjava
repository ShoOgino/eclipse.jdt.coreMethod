	/**
	 * Returns the given type in the the given package if it exists,
	 * otherwise <code>null</code>.
	 */
	protected NameEnvironmentAnswer find(String typeName, String packageName) {
		if (packageName == null)
			packageName = IPackageFragment.DEFAULT_PACKAGE_NAME;
		IType type =
			this.nameLookup.findType(
				typeName,
				packageName,
				false,
				NameLookup.ACCEPT_CLASSES | NameLookup.ACCEPT_INTERFACES);
		if (type != null) {
			boolean isBinary = type instanceof BinaryType;
			
			// determine associated access restriction
			AccessRestriction accessRestriction;
			if (isBinary) {
				accessRestriction = (AccessRestriction)this.accessRestrictions.get(this.project);
				if (accessRestriction == null) {
					accessRestriction = this.project.getProjectImportRestriction();
					if (accessRestriction != null) {
						this.accessRestrictions.put(this.project, accessRestriction);
					}
				}
			} else {
				JavaProject definingProject = (JavaProject) type.getJavaProject();
				if (!definingProject.equals(this.project)) {
					accessRestriction = (AccessRestriction)this.accessRestrictions.get(definingProject);
					if (accessRestriction == null) {
						accessRestriction = this.project.getProjectDependencyRestriction(definingProject);
						if (accessRestriction != null) {
							this.accessRestrictions.put(definingProject, accessRestriction);
						}
					}
				} else {
					accessRestriction = null;
				}
			}
			if (accessRestriction != null) {
				// TODO (philippe) improve char[] <-> String conversions to avoid performing them on the fly
				char[][] packageChars = CharOperation.splitOn('.', packageName.toCharArray());
				char[] typeChars = typeName.toCharArray();
				accessRestriction = accessRestriction.getViolatedRestriction(CharOperation.concatWith(packageChars, typeChars, '/'), null);
			}
			
			// construct name env answer
			if (isBinary) { // BinaryType
				try {
					return new NameEnvironmentAnswer((IBinaryType) ((BinaryType) type).getElementInfo(), accessRestriction);
				} catch (JavaModelException npe) {
					return null;
				}
			} else { //SourceType
				try {
					// retrieve the requested type
					SourceTypeElementInfo sourceType = (SourceTypeElementInfo)((SourceType)type).getElementInfo();
					ISourceType topLevelType = sourceType;
					while (topLevelType.getEnclosingType() != null) {
						topLevelType = topLevelType.getEnclosingType();
					}
					// find all siblings (other types declared in same unit, since may be used for name resolution)
					IType[] types = sourceType.getHandle().getCompilationUnit().getTypes();
					ISourceType[] sourceTypes = new ISourceType[types.length];

					// in the resulting collection, ensure the requested type is the first one
					sourceTypes[0] = sourceType;
					int length = types.length;
					for (int i = 0, index = 1; i < length; i++) {
						ISourceType otherType =
							(ISourceType) ((JavaElement) types[i]).getElementInfo();
						if (!otherType.equals(topLevelType) && index < length) // check that the index is in bounds (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=62861)
							sourceTypes[index++] = otherType;
					}
					return new NameEnvironmentAnswer(sourceTypes, accessRestriction);
				} catch (JavaModelException npe) {
					return null;
				}
			}
		}
		return null;
	}

