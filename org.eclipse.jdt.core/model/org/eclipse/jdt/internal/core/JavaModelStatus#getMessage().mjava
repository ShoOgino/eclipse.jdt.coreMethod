	/**
	 * Returns the message that is relevant to the code of this status.
	 */
	public String getMessage() {
		Throwable exception = getException();
		if (exception == null) {
			switch (getCode()) {
				case CORE_EXCEPTION :
					return Util.bind("status.coreException"); //$NON-NLS-1$

				case BUILDER_INITIALIZATION_ERROR:
					return Util.bind("build.initializationError"); //$NON-NLS-1$

				case BUILDER_SERIALIZATION_ERROR:
					return Util.bind("build.serializationError"); //$NON-NLS-1$

				case DEVICE_PATH:
					return Util.bind("status.cannotUseDeviceOnPath", getPath().toString()); //$NON-NLS-1$

				case DOM_EXCEPTION:
					return Util.bind("status.JDOMError"); //$NON-NLS-1$

				case ELEMENT_DOES_NOT_EXIST:
					return Util.bind("element.doesNotExist",((JavaElement)elements[0]).toStringWithAncestors()); //$NON-NLS-1$

				case EVALUATION_ERROR:
					return Util.bind("status.evaluationError", string); //$NON-NLS-1$

				case INDEX_OUT_OF_BOUNDS:
					return Util.bind("status.indexOutOfBounds"); //$NON-NLS-1$

				case INVALID_CONTENTS:
					return Util.bind("status.invalidContents"); //$NON-NLS-1$

				case INVALID_DESTINATION:
					return Util.bind("status.invalidDestination", ((JavaElement)elements[0]).toStringWithAncestors()); //$NON-NLS-1$

				case INVALID_ELEMENT_TYPES:
					StringBuffer buff= new StringBuffer(Util.bind("operation.notSupported")); //$NON-NLS-1$
					for (int i= 0; i < elements.length; i++) {
						if (i > 0) {
							buff.append(", "); //$NON-NLS-1$
						}
						buff.append(((JavaElement)elements[i]).toStringWithAncestors());
					}
					return buff.toString();

				case INVALID_NAME:
					return Util.bind("status.invalidName", string); //$NON-NLS-1$

				case INVALID_PACKAGE:
					return Util.bind("status.invalidPackage", string); //$NON-NLS-1$

				case INVALID_PATH:
					if (string != null) {
						return string;
					} else {
						return Util.bind("status.invalidPath", getPath() == null ? "null" : getPath().toString()); //$NON-NLS-1$ //$NON-NLS-2$
					}

				case INVALID_PROJECT:
					return Util.bind("status.invalidProject", string); //$NON-NLS-1$

				case INVALID_RESOURCE:
					return Util.bind("status.invalidResource", string); //$NON-NLS-1$

				case INVALID_RESOURCE_TYPE:
					return Util.bind("status.invalidResourceType", string); //$NON-NLS-1$

				case INVALID_SIBLING:
					if (string != null) {
						return Util.bind("status.invalidSibling", string); //$NON-NLS-1$
					} else {
						return Util.bind("status.invalidSibling", ((JavaElement)elements[0]).toStringWithAncestors()); //$NON-NLS-1$
					}

				case IO_EXCEPTION:
					return Util.bind("status.IOException"); //$NON-NLS-1$

				case NAME_COLLISION:
					if (elements != null && elements.length > 0) {
						IJavaElement element = elements[0];
						String name = element.getElementName();
						if (element instanceof IPackageFragment && name.equals(IPackageFragment.DEFAULT_PACKAGE_NAME)) {
							return Util.bind("operation.cannotRenameDefaultPackage"); //$NON-NLS-1$
						}
					}
					if (string != null) {
						return string;
					} else {
						return Util.bind("status.nameCollision", ""); //$NON-NLS-1$ //$NON-NLS-2$
					}
				case NO_ELEMENTS_TO_PROCESS:
					return Util.bind("operation.needElements"); //$NON-NLS-1$

				case NULL_NAME:
					return Util.bind("operation.needName"); //$NON-NLS-1$

				case NULL_PATH:
					return Util.bind("operation.needPath"); //$NON-NLS-1$

				case NULL_STRING:
					return Util.bind("operation.needString"); //$NON-NLS-1$

				case PATH_OUTSIDE_PROJECT:
					return Util.bind("operation.pathOutsideProject", string, ((JavaElement)elements[0]).toStringWithAncestors()); //$NON-NLS-1$

				case READ_ONLY:
					IJavaElement element = elements[0];
					String name = element.getElementName();
					if (element instanceof IPackageFragment && name.equals(IPackageFragment.DEFAULT_PACKAGE_NAME)) {
						return Util.bind("status.defaultPackageReadOnly"); //$NON-NLS-1$
					}
					return  Util.bind("status.readOnly", name); //$NON-NLS-1$

				case RELATIVE_PATH:
					return Util.bind("operation.needAbsolutePath", getPath().toString()); //$NON-NLS-1$

				case TARGET_EXCEPTION:
					return Util.bind("status.targetException"); //$NON-NLS-1$

				case UPDATE_CONFLICT:
					return Util.bind("status.updateConflict"); //$NON-NLS-1$

				case NO_LOCAL_CONTENTS :
					return Util.bind("status.noLocalContents", getPath().toString()); //$NON-NLS-1$

				case CP_CONTAINER_PATH_UNBOUND:
					IJavaProject javaProject = (IJavaProject)elements[0];
					ClasspathContainerInitializer initializer = JavaCore.getClasspathContainerInitializer(this.path.segment(0));
					String description = null;
					if (initializer != null) description = initializer.getDescription(this.path, javaProject);
					if (description == null) description = path.makeRelative().toString();
					return Util.bind("classpath.unboundContainerPath", description, javaProject.getElementName()); //$NON-NLS-1$

				case INVALID_CP_CONTAINER_ENTRY:
					javaProject = (IJavaProject)elements[0];
					IClasspathContainer container = null;
					description = null;
					try {
						container = JavaCore.getClasspathContainer(path, javaProject);
					} catch(JavaModelException e){
						// project doesn't exist: ignore
					}
					if (container == null) {
						 initializer = JavaCore.getClasspathContainerInitializer(path.segment(0));
						if (initializer != null) description = initializer.getDescription(path, javaProject);
					} else {
						description = container.getDescription();
					}
					if (description == null) description = path.makeRelative().toString();
					return Util.bind("classpath.invalidContainer", description, javaProject.getElementName()); //$NON-NLS-1$

			case CP_VARIABLE_PATH_UNBOUND:
				javaProject = (IJavaProject)elements[0];
				return Util.bind("classpath.unboundVariablePath", path.makeRelative().toString(), javaProject.getElementName()); //$NON-NLS-1$
					
			case CLASSPATH_CYCLE: 
				javaProject = (IJavaProject)elements[0];
				return Util.bind("classpath.cycle", javaProject.getElementName()); //$NON-NLS-1$
												 
			case DISABLED_CP_EXCLUSION_PATTERNS:
				javaProject = (IJavaProject)elements[0];
				String projectName = javaProject.getElementName();
				IPath newPath = path;
				if (path.segment(0).toString().equals(projectName)) {
					newPath = path.removeFirstSegments(1);
				}
				return Util.bind("classpath.disabledExclusionPatterns", newPath.makeRelative().toString(), projectName); //$NON-NLS-1$

			case DISABLED_CP_MULTIPLE_OUTPUT_LOCATIONS:
				javaProject = (IJavaProject)elements[0];
				projectName = javaProject.getElementName();
				newPath = path;
				if (path.segment(0).toString().equals(projectName)) {
					newPath = path.removeFirstSegments(1);
				}
				return Util.bind("classpath.disabledMultipleOutputLocations", newPath.makeRelative().toString(), projectName); //$NON-NLS-1$

			case INCOMPATIBLE_JDK_LEVEL:
					javaProject = (IJavaProject)elements[0];
					return Util.bind("classpath.incompatibleLibraryJDKLevel", new String[]{	//$NON-NLS-1$
						javaProject.getElementName(), 
						javaProject.getOption(JavaCore.COMPILER_CODEGEN_TARGET_PLATFORM, true), 
						path.makeRelative().toString(),
						string,
					});
			}
			if (string != null) {
				return string;
			} else {
				return ""; // //$NON-NLS-1$
			}
		} else {
			String message = exception.getMessage();
			if (message != null) {
				return message;
			} else {
				return exception.toString();
			}
		}
	}

