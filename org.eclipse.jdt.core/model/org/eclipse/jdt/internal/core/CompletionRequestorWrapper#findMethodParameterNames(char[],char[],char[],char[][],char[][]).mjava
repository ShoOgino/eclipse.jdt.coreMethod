private char[][] findMethodParameterNames(char[] declaringTypePackageName, char[] declaringTypeName, char[] selector, char[][] parameterPackageNames, char[][] parameterTypeNames){
	char[][] parameterNames = null;
	int length = parameterTypeNames.length;
	
	char[] typeName = CharOperation.concat(declaringTypePackageName,declaringTypeName,'.');
	IType type = nameLookup.findType(new String(typeName), false, NameLookup.ACCEPT_CLASSES & NameLookup.ACCEPT_INTERFACES);
	if(type instanceof BinaryType){
		String[] args = new String[length];
		for(int i = 0;	i< length ; i++){
			char[] parameterType = CharOperation.concat(parameterPackageNames[i],parameterTypeNames[i],'.');
			args[i] = Signature.createTypeSignature(parameterType,true);
		}
		IMethod method = type.getMethod(new String(selector),args);
		try{
			parameterNames = new char[length][];
			String[] params = method.getParameterNames();
			for(int i = 0;	i< length ; i++){
				parameterNames[i] = params[i].toCharArray();
			}
		} catch(JavaModelException e){
			parameterNames = null;
		}
			
	}
	// default parameters name
	if(parameterNames == null) {
		parameterNames = new char[length][];
		for (int i = 0; i < length; i++) {
			parameterNames[i] = CharOperation.concat(ARG, String.valueOf(i).toCharArray());
		}
	}
	return parameterNames;
}

