/**
 * Possible failures: <ul>
 *  <li>NO_ELEMENTS_TO_PROCESS - the project supplied to the operation is
 * 		<code>null</code>.
 *	<li>NULL_PATH - the output location path supplied to the operation
 * 		is <code>null</code>.
 *	<li>PATH_OUTSIDE_PROJECT - the output location path supplied to the operation
 * 		is outside of the project supplied to this operation.
 *	<li>DEVICE_PATH - the path supplied to this operation must not specify a 
 * 		device
 *	<li>RELATIVE_PATH - the path supplied to this operation must be
 *		an absolute path
 *	<li>INVALID_PATH - the output location cannot overlap any package fragment
 *		root, except the project folder.
 *  <li>ELEMENT_DOES_NOT_EXIST - the Java project does not exist
 * </ul>
 */
public IJavaModelStatus verify() {
	IJavaModelStatus status = super.verify();
	if (!status.isOK()) {
		return status;
	}
	if (fOutputLocation == null) {
			return new JavaModelStatus(IJavaModelStatusConstants.NULL_PATH);
	}
	
	if (fOutputLocation.isAbsolute()) {
		IProject project = ((IJavaProject) fElementsToProcess[0]).getProject();

		if (project.getFullPath().isPrefixOf(fOutputLocation)) {
			//project relative path
			String projectName = fOutputLocation.segment(0);
			if (!projectName.equals(fElementsToProcess[0].getElementName())) {
				//a workspace relative path outside of this project
				return new JavaModelStatus(IJavaModelStatusConstants.PATH_OUTSIDE_PROJECT, fOutputLocation);
			}
		} else {
			return new JavaModelStatus(IJavaModelStatusConstants.DEVICE_PATH, fOutputLocation);
		}
	} else {
		return new JavaModelStatus(IJavaModelStatusConstants.RELATIVE_PATH, fOutputLocation);
	}

	// retrieve classpath
	IClasspathEntry[] classpath = null;
	IJavaProject javaProject= (IJavaProject)getElementToProcess();
	IPath projectPath= javaProject.getProject().getFullPath();	
	try {
		classpath = javaProject.getResolvedClasspath(true);
	} catch (JavaModelException e) {
		return e.getJavaModelStatus();
	}

	// check if any source entries coincidates with binary output - in which case nesting inside output is legal
	boolean allowNestingInOutput = false;
	boolean hasSource = false;
	for (int i = 0 ; i < classpath.length; i++) {
		if (classpath[i].getEntryKind() == IClasspathEntry.CPE_SOURCE) hasSource = true;
		if (classpath[i].getPath().equals(fOutputLocation)){
			allowNestingInOutput = true;
			break;
		}
	}
	if (!hasSource) allowNestingInOutput = true; // if no source, then allowed

	// check all entries
	for (int i = 0 ; i < classpath.length; i++) {
		IClasspathEntry entry = classpath[i];
		IPath entryPath = entry.getPath();

		// no further check if entry coincidates with project or output location
		if (entryPath.equals(projectPath)) continue;
		if (entryPath.equals(fOutputLocation)) continue;
		
		// prevent nesting output location inside entry
		if (entryPath.isPrefixOf(fOutputLocation)) {
			return new JavaModelStatus(IJavaModelStatusConstants.INVALID_PATH, fOutputLocation);
		}

		// prevent nesting entry inside output location - when distinct from project or a source folder
		if (!allowNestingInOutput && fOutputLocation.isPrefixOf(entryPath)) {
			return new JavaModelStatus(IJavaModelStatusConstants.INVALID_PATH, fOutputLocation);
		}
	}
	return JavaModelStatus.VERIFIED_OK;
}

