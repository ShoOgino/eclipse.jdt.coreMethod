	/*
	 * Discards the per working copy info for the given working copy (making it a compilation unit)
	 * if its use count was 1. Otherwise, just decrement the use count.
	 * Close the working copy, its buffer and remove it from the shared working copy table.
	 * Ignore if no per-working copy info existed.
	 * Returns the new use count (or -1 if it didn't exist).
	 */
	public int discardPerWorkingCopyInfo(CompilationUnit workingCopy) throws JavaModelException {
		synchronized(perWorkingCopyInfos) {
			WorkingCopyOwner owner = workingCopy.owner;
			Map pathToPerWorkingCopyInfos = (Map)this.perWorkingCopyInfos.get(owner);
			if (pathToPerWorkingCopyInfos == null) return -1;
			
			IPath path = workingCopy.getPath();
			PerWorkingCopyInfo info = (PerWorkingCopyInfo)pathToPerWorkingCopyInfos.get(path);
			if (info == null) return -1;
			
			if (--info.useCount == 0) {
				IJavaElement originalElement = workingCopy.getPrimary();

				// remove per working copy info
				pathToPerWorkingCopyInfos.remove(path);
				if (pathToPerWorkingCopyInfos.isEmpty()) {
					this.perWorkingCopyInfos.remove(owner);
				}

				// remove infos + close buffer (since no longer working copy)
				removeInfoAndChildren(workingCopy);
				workingCopy.closeBuffer();
				
				// if original element is not on classpath flush it from the cache 
				if (!workingCopy.getParent().exists()) {
					((CompilationUnit)originalElement).close();
				}
			}
			return info.useCount;
		}
	}

