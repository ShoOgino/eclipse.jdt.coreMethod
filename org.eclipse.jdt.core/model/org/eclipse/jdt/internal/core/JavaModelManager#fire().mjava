	/**
	 * Fire Java Model deltas, flushing them after the fact. 
	 * If the firing mode has been turned off, this has no effect. 
	 */
	public void fire() {
		if (fFire) {
			this.mergeDeltas();
			try {
				Iterator iterator = fJavaModelDeltas.iterator();
				while (iterator.hasNext()) {
					IJavaElementDelta delta= (IJavaElementDelta) iterator.next();
					if (DeltaProcessor.VERBOSE){
						System.out.println("FIRING Delta ["+Thread.currentThread()+"]:\n" + delta);//$NON-NLS-1$//$NON-NLS-2$
					}
					
					// Refresh internal scopes
					Iterator scopes = this.scopes.keySet().iterator();
					while (scopes.hasNext()) {
						AbstractSearchScope scope = (AbstractSearchScope)scopes.next();
						scope.processDelta(delta);
					}
					
					ElementChangedEvent event= new ElementChangedEvent(delta);
					// Clone the listeners since they could remove themselves when told about the event 
					// (eg. a type hierarchy becomes invalid (and thus it removes itself) when the type is removed
					ArrayList listeners= (ArrayList) fElementChangedListeners.clone();
					for (int i= 0; i < listeners.size(); i++) {
						IElementChangedListener listener= (IElementChangedListener) listeners.get(i);
						listener.elementChanged(event);
					}
				}
			} finally {
				// empty the queue
				this.flush();
			}
		}
	}

