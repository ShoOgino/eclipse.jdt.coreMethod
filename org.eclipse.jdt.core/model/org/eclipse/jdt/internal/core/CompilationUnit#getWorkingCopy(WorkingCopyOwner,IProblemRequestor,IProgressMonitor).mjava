/**
 * @see IWorkingCopy#getWorkingCopy(WorkingCopyOwner, IProblemRequestor, IProgressMonitor)
 */
public ICompilationUnit getWorkingCopy(WorkingCopyOwner workingCopyOwner, IProblemRequestor problemRequestor, IProgressMonitor monitor) throws JavaModelException {
	if (isWorkingCopy()) return this;
	
	JavaModelManager manager = JavaModelManager.getJavaModelManager();
	
	// In order to be shared, working copies have to denote the same compilation unit 
	// AND use the same owner.
	// Assuming there is a little set of buffer factories, then use a 2 level Map cache.
	Map sharedWorkingCopies = manager.sharedWorkingCopies;
	
	Map perOwnerWorkingCopies = (Map) sharedWorkingCopies.get(workingCopyOwner);
	if (perOwnerWorkingCopies == null){
		perOwnerWorkingCopies = new HashMap();
		sharedWorkingCopies.put(workingCopyOwner, perOwnerWorkingCopies);
	}
	CompilationUnit workingCopy = (CompilationUnit)perOwnerWorkingCopies.get(this);
	if (workingCopy != null) {
		JavaModelManager.PerWorkingCopyInfo perWorkingCopyInfo = 
			manager.getPerWorkingCopyInfo(workingCopy, false/*don't create*/, true/*record usage*/, null/*not used since don't create*/);
		if (perWorkingCopyInfo != null) {

			if (SHARED_WC_VERBOSE) {
				System.out.println("Incrementing use count of shared working copy " + workingCopy.toStringWithAncestors()); //$NON-NLS-1$
			}

			return workingCopy;
		}
	} 
	workingCopy = new CompilationUnit((IPackageFragment)getParent(), getElementName(), workingCopyOwner);
	BecomeWorkingCopyOperation op = new BecomeWorkingCopyOperation(workingCopy, perOwnerWorkingCopies, problemRequestor);
	runOperation(op, monitor);
	return workingCopy;
}

