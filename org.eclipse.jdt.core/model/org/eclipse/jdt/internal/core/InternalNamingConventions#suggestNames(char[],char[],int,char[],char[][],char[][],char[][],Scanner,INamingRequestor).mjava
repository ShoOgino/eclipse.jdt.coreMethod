	private static void suggestNames(
		char[] packageName,
		char[] qualifiedTypeName,
		int dim,
		char[] internalPrefix,
		char[][] prefixes,
		char[][] suffixes,
		char[][] excludedNames,
		Scanner nameScanner,
		INamingRequestor requestor){
		
		if(qualifiedTypeName == null || qualifiedTypeName.length == 0)
			return;
		
		if(internalPrefix == null) {
			internalPrefix = CharOperation.NO_CHAR;
		} else {
			internalPrefix = removePrefix(internalPrefix, prefixes);
		}
		
		char[] typeName = CharOperation.lastSegment(qualifiedTypeName, '.');
	
		if(prefixes == null || prefixes.length == 0) {
			prefixes = new char[1][0];
		} else {
			int length = prefixes.length;
			System.arraycopy(prefixes, 0, prefixes = new char[length+1][], 0, length);
			prefixes[length] = CharOperation.NO_CHAR;
		}
	
		if(suffixes == null || suffixes.length == 0) {
			suffixes = new char[1][0];
		} else {
			int length = suffixes.length;
			System.arraycopy(suffixes, 0, suffixes = new char[length+1][], 0, length);
			suffixes[length] = CharOperation.NO_CHAR;
		}
	
		char[][] tempNames = null;
	
		// compute variable name for base type
		try{
			nameScanner.setSource(typeName);
			switch (nameScanner.getNextToken()) {
				case TerminalTokens.TokenNameint :
				case TerminalTokens.TokenNamebyte :
				case TerminalTokens.TokenNameshort :
				case TerminalTokens.TokenNamechar :
				case TerminalTokens.TokenNamelong :
				case TerminalTokens.TokenNamefloat :
				case TerminalTokens.TokenNamedouble :
				case TerminalTokens.TokenNameboolean :	
					char[] name = computeBaseTypeNames(typeName[0], excludedNames);
					if(name != null) {
						tempNames =  new char[][]{name};
					}
					break;
			}	
		} catch(InvalidInputException e){
			// ignore
		}

		// compute variable name for non base type
		if(tempNames == null) {
			tempNames = computeNames(typeName);
		}
	
		boolean acceptDefaultName = true;
		
		next : for (int i = 0; i < tempNames.length; i++) {
			char[] tempName = tempNames[i];
			if(dim > 0) {
				int length = tempName.length;
				if (tempName[length-1] == 's'){
					if(tempName.length > 1 && tempName[length-2] == 's') {
						System.arraycopy(tempName, 0, tempName = new char[length + 2], 0, length);
						tempName[length] = 'e';
						tempName[length+1] = 's';
					}
				} else if(tempName[length-1] == 'y') {
					System.arraycopy(tempName, 0, tempName = new char[length + 2], 0, length);
					tempName[length-1] = 'i';
					tempName[length] = 'e';
					tempName[length+1] = 's';
				} else {
					System.arraycopy(tempName, 0, tempName = new char[length + 1], 0, length);
					tempName[length] = 's';
				}
			}
		
			char[] unprefixedName = tempName;
			for (int j = 0; j <= internalPrefix.length; j++) {
				if(j == internalPrefix.length || CharOperation.prefixEquals(CharOperation.subarray(internalPrefix, j, -1), unprefixedName, false)) {
					tempName = CharOperation.concat(CharOperation.subarray(internalPrefix, 0, j), unprefixedName);
					if(j != 0) tempName[j] = Character.toUpperCase(tempName[j]);
					for (int k = 0; k < prefixes.length; k++) {
						if(prefixes[k].length > 0
							&& Character.isLetterOrDigit(prefixes[k][prefixes[k].length - 1])) {
							tempName[0] = Character.toUpperCase(tempName[0]);
						} else {
							tempName[0] = Character.toLowerCase(tempName[0]);
						}
						char[] prefixName = CharOperation.concat(prefixes[k], tempName);
						for (int l = 0; l < suffixes.length; l++) {
							char[] suffixName = CharOperation.concat(prefixName, suffixes[l]);
							suffixName =
								excludeNames(
									suffixName,
									prefixName,
									suffixes[l],
									excludedNames);
							if(JavaConventions.validateFieldName(new String(suffixName)).isOK()) {
								acceptName(suffixName, prefixes[k], suffixes[l],  k == 0, l == 0, internalPrefix.length - j, requestor);
								acceptDefaultName = false;
							} else {
								suffixName = CharOperation.concat(
									prefixName,
									String.valueOf(1).toCharArray(),
									suffixes[l]
								);
								suffixName =
									excludeNames(
										suffixName,
										prefixName,
										suffixes[l],
										excludedNames);
								if(JavaConventions.validateFieldName(new String(suffixName)).isOK()) {
									acceptName(suffixName, prefixes[k], suffixes[l], k == 0, l == 0, internalPrefix.length - j, requestor);
									acceptDefaultName = false;
								}
							}
						}
					}
					continue next;
				}
			}
		}
		// if no names were found
		if(acceptDefaultName) {
			char[] name = excludeNames(DEFAULT_NAME, DEFAULT_NAME, CharOperation.NO_CHAR, excludedNames);
			requestor.acceptNameWithoutPrefixAndSuffix(name, 0);
		}
	}

