/*
 * @see IMethod
 * Look for source attachment information to retrieve the actual parameter names as stated in source.
 */
public String[] getParameterNames() throws JavaModelException {
	if (this.parameterNames != null) 
		return this.parameterNames;

	// force source mapping if not already done
	IType type = (IType) getParent();
	SourceMapper mapper = getSourceMapper();
	if (mapper != null) {
		char[][] paramNames = mapper.getMethodParameterNames(this);
		
		// map source and try to find parameter names
		if(paramNames == null) {
			char[] source = mapper.findSource(type);
			if (source != null){
				mapper.mapSource(type, source);
			}
			paramNames = mapper.getMethodParameterNames(this);
		}
		
		// if parameter names exist, convert parameter names to String array
		if(paramNames != null) {
			this.parameterNames = new String[paramNames.length];
			for (int i = 0; i < paramNames.length; i++) {
				this.parameterNames[i] = new String(paramNames[i]);
			}
			return this.parameterNames;
		}
	}
	
	// try to see if we can retrieve the names from the attached javadoc
	IBinaryMethod info = (IBinaryMethod) getElementInfo();
	final int paramCount = Signature.getParameterCount(new String(info.getMethodDescriptor()));
	if (paramCount != 0) {
 		String javadocContents = null;
 		IType declaringType = this.getDeclaringType();
		PerProjectInfo projectInfo = JavaModelManager.getJavaModelManager().getPerProjectInfoCheckExistence(this.getJavaProject().getProject());
 		synchronized (projectInfo.javadocCache) {
 			javadocContents = (String) projectInfo.javadocCache.get(declaringType);
 			if (javadocContents == null) {
 				projectInfo.javadocCache.put(declaringType, BinaryType.EMPTY_JAVADOC);
 			}
 		}
 		if (javadocContents == null) {
 			long timeOut = 50; // default value
 			try {
 				String option = this.getJavaProject().getOption(JavaCore.CODEASSIST_TIMEOUT_FOR_PARAMETER_NAME_FROM_ATTACHED_JAVADOC, true);
 				if (option != null) {
 					timeOut = Long.parseLong(option);
 				}
 			} catch(NumberFormatException e) {
 				// ignore
 			}
 			if (timeOut == 0) {
 				// don't try to fetch the values
 				return this.parameterNames = getRawParameterNames(paramCount);
 			}
 			final class ParametersNameCollector {
 				String javadoc;
 				public void setJavadoc(String s) {
 					this.javadoc = s;
 				}
 				public String getJavadoc() {
 					return this.javadoc;
 				}
 	 		}
 			/*
 			 * The declaring type is not in the cache yet. The thread wil retrieve the javadoc contents
 			 */
	 		final ParametersNameCollector nameCollector = new ParametersNameCollector();
			Thread collect = new Thread() {
				public void run() {
					try {
						// this call has a side-effect on the per project info cache
						nameCollector.setJavadoc(BinaryMethod.this.getAttachedJavadoc(null, "UTF-8")); //$NON-NLS-1$
			        } catch (JavaModelException e) {
	 		        	// ignore
	 		        }
					synchronized(nameCollector) {
						nameCollector.notify();
					}
				}
			};
			collect.start();
			synchronized(nameCollector) {
				try {
					nameCollector.wait(timeOut);
				} catch (InterruptedException e) {
					// ignore
				}
			}
			javadocContents = nameCollector.getJavadoc();
 		} else if (javadocContents != BinaryType.EMPTY_JAVADOC){
 			// need to extract the part relative to the binary method since javadoc contains the javadoc for the declaring type
 			javadocContents = extractJavadoc(declaringType, javadocContents);
 		} else {
 			// we don't want to set the parameter names
 			return getRawParameterNames(paramCount);
 		}
		if (javadocContents != null && javadocContents != BinaryType.EMPTY_JAVADOC) {
			final int indexOfOpenParen = javadocContents.indexOf('(');
			if (indexOfOpenParen != -1) {
				final int indexOfClosingParen = javadocContents.indexOf(')', indexOfOpenParen);
				if (indexOfClosingParen != -1) {
					final char[] paramsSource =
						CharOperation.replace(
							javadocContents.substring(indexOfOpenParen + 1, indexOfClosingParen).toCharArray(),
							"&nbsp;".toCharArray(), //$NON-NLS-1$
							new char[] {' '});
					final char[][] params = CharOperation.splitOn(',', paramsSource);
					final int paramsLength = params.length;
					this.parameterNames = new String[paramsLength];
					for (int i = 0; i < paramsLength; i++) {
						final char[] param = params[i];
						int indexOfSpace = CharOperation.lastIndexOf(' ', param);
						if (indexOfSpace != -1) {
							this.parameterNames[i] = String.valueOf(param, indexOfSpace + 1, param.length - indexOfSpace -1);
						} else {
							this.parameterNames[i] = "arg" + i; //$NON-NLS-1$
						}
					}
					return this.parameterNames;
				}
			}
		}
	}
	// if still no parameter names, produce fake ones
	return this.parameterNames = getRawParameterNames(paramCount);
}

