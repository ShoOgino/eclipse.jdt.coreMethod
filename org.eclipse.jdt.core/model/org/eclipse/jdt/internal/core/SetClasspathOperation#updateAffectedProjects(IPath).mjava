	/**
	 * Update projects which are affected by this classpath change:
	 * those which refers to the current project as source (indirectly)
	 */
	protected void updateAffectedProjects(IPath prerequisiteProjectPath) {

		// remove all update classpath post actions for this project
		removeAllPostAction(prerequisiteProjectPath.toString());
		
		try {
			IJavaModel model = JavaModelManager.getJavaModelManager().getJavaModel();
			IJavaProject initialProject = this.project;
			IJavaProject[] projects = model.getJavaProjects();
			for (int i = 0, projectCount = projects.length; i < projectCount; i++) {
				try {
					final JavaProject affectedProject = (JavaProject) projects[i];
					if (affectedProject.equals(initialProject)) continue; // skip itself
					
					// consider ALL dependents (even indirect ones), since they may need to
					// flush their respective namelookup caches (all pkg fragment roots).

					IClasspathEntry[] classpath = affectedProject.getExpandedClasspath(true);
					for (int j = 0, entryCount = classpath.length; j < entryCount; j++) {
						IClasspathEntry entry = classpath[j];
						if (entry.getEntryKind() == IClasspathEntry.CPE_PROJECT
							&& entry.getPath().equals(prerequisiteProjectPath)) {
								
							postAction(new IPostAction() {
									public String getID() {
										return affectedProject.getPath().toString();
									}
									public void run() throws JavaModelException {
										affectedProject.setRawClasspath(
											UpdateClasspath, 
											SetClasspathOperation.ReuseOutputLocation, 
											SetClasspathOperation.this.progressMonitor, 
											SetClasspathOperation.this.canChangeResources,  
											affectedProject.getResolvedClasspath(true), 
											false, // updating only - no validation
											false); // updating only - no need to save
									}
								},
								REMOVEALL_APPEND);
							break;
						}
					}
				} catch (JavaModelException e) {
					// ignore
				}
			}
		} catch (JavaModelException e) {
			// ignore
		}
		
	}

