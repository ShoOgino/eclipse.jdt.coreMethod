/**
 * Open an <code>Openable</code> that is known to be closed (no check for <code>isOpen()</code>).
 * Returns the created element info.
 */
protected OpenableElementInfo openWhenClosed(IProgressMonitor pm) throws JavaModelException {
	try {
		
		if (JavaModelManager.VERBOSE){
			System.out.println("OPENING Element ("+ Thread.currentThread()+"): " + this.toStringWithAncestors()); //$NON-NLS-1$//$NON-NLS-2$
		}
		
		// 1) Parent must be open - open the parent if necessary
		openParent(pm);

		// 2) create the new element info and open a buffer if needed
		OpenableElementInfo info = createElementInfo();
		if (isSourceElement()) {
			this.openBuffer(pm);
		} 

		// 3) build the structure of the openable
		buildStructure(info, pm);

		// 4) anything special
		opening(info);
		
		if (JavaModelManager.VERBOSE) {
			System.out.println("-> Package cache size = " + JavaModelManager.getJavaModelManager().cache.pkgSize()); //$NON-NLS-1$
			System.out.println("-> Openable cache filling ratio = " + JavaModelManager.getJavaModelManager().cache.openableFillingRatio() + "%"); //$NON-NLS-1$//$NON-NLS-2$
		}
		
		return info;
	} catch (JavaModelException e) {
		// if any problems occuring openning the element, ensure that it's info
		// does not remain in the cache	(some elements, pre-cache their info
		// as they are being opened).
		JavaModelManager.getJavaModelManager().removeInfo(this);
		throw e;
	}
}

