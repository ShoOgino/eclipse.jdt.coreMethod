	/**
	 * Compute the package fragment children of this package fragment root.
	 * These are all of the directory zip entries, and any directories implied
	 * by the path of class files contained in the jar of this package fragment root.
	 */
	protected boolean computeChildren(OpenableElementInfo info, IResource underlyingResource) throws JavaModelException {
		final HashtableOfArrayToObject rawPackageInfo = new HashtableOfArrayToObject();
		IJavaElement[] children;
		ZipFile jar = null;
		try {
			Object file = JavaModel.getTarget(getPath(), true);
			long level = Util.getJdkLevel(file);
			final String compliance = CompilerOptions.versionFromJdkLevel(level);

			// always create the default package
			rawPackageInfo.put(CharOperation.NO_STRINGS, new ArrayList[] { EMPTY_LIST, EMPTY_LIST });

			if (this.isJimage) {
				try {
					org.eclipse.jdt.internal.compiler.util.Util.walkModuleImage(getPath().toFile(),
									new org.eclipse.jdt.internal.compiler.util.Util.JimageVisitor<Path>() {
						@Override
						public FileVisitResult visitPackage(Path dir, BasicFileAttributes attrs) throws IOException {
							initRawPackageInfo(rawPackageInfo, dir.toString(), true, compliance);
							return FileVisitResult.CONTINUE;
						}

						@Override
						public FileVisitResult visitFile(Path path, BasicFileAttributes attrs) throws IOException {
							initRawPackageInfo(rawPackageInfo, path.toString(), false, compliance);
							return FileVisitResult.CONTINUE;
						}
					});
				} catch (IOException e) {
					// We are not reading any specific Jimage file, so, move on for now
				}
			} else {
				jar = getJar();
				for (Enumeration e= jar.entries(); e.hasMoreElements();) {
					ZipEntry member= (ZipEntry) e.nextElement();
					initRawPackageInfo(rawPackageInfo, member.getName(), member.isDirectory(), compliance);
				}
			}
			// loop through all of referenced packages, creating package fragments if necessary
			// and cache the entry names in the rawPackageInfo table
			children = new IJavaElement[rawPackageInfo.size()];
			int index = 0;
			for (int i = 0, length = rawPackageInfo.keyTable.length; i < length; i++) {
				String[] pkgName = (String[]) rawPackageInfo.keyTable[i];
				if (pkgName == null) continue;
				children[index++] = getPackageFragment(pkgName);
			}
		} catch (CoreException e) {
			if (e.getCause() instanceof ZipException) {
				// not a ZIP archive, leave the children empty
				Util.log(IStatus.ERROR, "Invalid ZIP archive: " + toStringWithAncestors()); //$NON-NLS-1$
				children = NO_ELEMENTS;
			} else if (e instanceof JavaModelException) {
				throw (JavaModelException)e;
			} else {
				throw new JavaModelException(e);
			}
		} finally {
			JavaModelManager.getJavaModelManager().closeZipFile(jar);
		}

		info.setChildren(children);
		((JarPackageFragmentRootInfo) info).rawPackageInfo = rawPackageInfo;
		return true;
	}

