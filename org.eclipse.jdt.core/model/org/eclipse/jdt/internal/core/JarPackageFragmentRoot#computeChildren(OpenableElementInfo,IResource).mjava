	/**
	 * Compute the package fragment children of this package fragment root.
	 * These are all of the directory zip entries, and any directories implied
	 * by the path of class files contained in the jar of this package fragment root.
	 */
	@Override
	protected boolean computeChildren(OpenableElementInfo info, IResource underlyingResource) throws JavaModelException {
		final HashtableOfArrayToObject rawPackageInfo = new HashtableOfArrayToObject();
		final Map<String, String> overridden = new HashMap<>();
		IJavaElement[] children = NO_ELEMENTS;
		java.nio.file.FileSystem fs = null;
		try {
			// always create the default package
			rawPackageInfo.put(CharOperation.NO_STRINGS, new ArrayList[] { EMPTY_LIST, EMPTY_LIST });

			boolean usedIndex = false;
			if (JavaIndex.isEnabled()) {
				JavaIndex index = JavaIndex.getIndex();
				try (IReader reader = index.getNd().acquireReadLock()) {
					IPath resourcePath = JavaIndex.getLocationForElement(this); 
					if (!resourcePath.isEmpty()) {
						NdResourceFile resourceFile = index.getResourceFile(resourcePath.toString().toCharArray());
						if (index.isUpToDate(resourceFile)) {
							usedIndex = true;
							long level = resourceFile.getJdkLevel();
							String compliance = CompilerOptions.versionFromJdkLevel(level);
							// Locate all the non-classfile entries
							for (NdZipEntry next : resourceFile.getZipEntries()) {
								String filename = next.getFileName().getString();
								initRawPackageInfo(rawPackageInfo, filename, filename.endsWith("/"), compliance); //$NON-NLS-1$
							}
	
							// Locate all the classfile entries
							for (NdType type : resourceFile.getTypes()) {	
								String path = new String(type.getTypeId().getBinaryName()) + ".class"; //$NON-NLS-1$
								initRawPackageInfo(rawPackageInfo, path, false, compliance);
							}
						}
					}
				}
			}

			// If we weren't able to compute the set of children from the index (either the index was disabled or didn't
			// contain an up-to-date entry for this .jar) then fetch it directly from the .jar
			if (!usedIndex) {
				IPath path = getPath();
				Object target = JavaModel.getTarget(path, true);
				File localFile = JavaModelManager.getLocalFile(path);
				long classLevel = Util.getJdkLevel(target);
				String projectCompliance = this.getJavaProject().getOption(JavaCore.COMPILER_COMPLIANCE, true);
				Path filePath = Paths.get(localFile.getAbsolutePath().toString());
				URI uri = URI.create("jar:" + filePath.toUri());  //$NON-NLS-1$
				try {
					synchronized (this) {
						this.sync_count++;
						try {
							fs = FileSystems.getFileSystem(uri);
						}
						catch (FileSystemNotFoundException e) {
							// move on
						}
						if (fs == null) {
							HashMap<String, ?> env = new HashMap<>();
							fs = FileSystems.newFileSystem(uri, env);
						}
					}
					if (fs != null) {
						Path rootPath = fs.getPath("/"); //$NON-NLS-1$
						Path versionsPath = fs.getPath("/", "META-INF", "versions");  //$NON-NLS-1$//$NON-NLS-2$ //$NON-NLS-3$
						int earliestJavaVersion = ClassFileConstants.MAJOR_VERSION_9;
						long latestJDK = CompilerOptions.releaseToJDKLevel(projectCompliance);
						int latestJavaVer = (int) (latestJDK >> 16);
						List<Path> versions = new ArrayList<>();
						for(int i = latestJavaVer; i >= earliestJavaVersion; i--) {
							Path p = fs.getPath("/", "META-INF", "versions", "" + (i - 44));  //$NON-NLS-1$//$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
							if (Files.exists(p)) {
								versions.add(p);
							}
						}
						Path[] supportedVersions = versions.toArray(new Path[versions.size()]);
						if (supportedVersions.length > 0) {
							this.multiVersion = true;
						}
						try {
							for (Path pa : supportedVersions) {
								Files.walkFileTree(pa, new FileVisitor<java.nio.file.Path>() {
									@Override
									public FileVisitResult preVisitDirectory(java.nio.file.Path dir, BasicFileAttributes attrs)
											throws IOException {
										return FileVisitResult.CONTINUE;
									}
									@Override
									public FileVisitResult visitFile(java.nio.file.Path file, BasicFileAttributes attrs)
											throws IOException {
										String fileName = file.getFileName().toString();
										if (!overridden.containsKey(fileName)) {
											overridden.put(fileName, rootPath.relativize(pa).toString());
										}
										initRawPackageInfo(rawPackageInfo, pa.relativize(file).toString(), false, CompilerOptions.versionFromJdkLevel(classLevel));
										return FileVisitResult.CONTINUE;
									}

									@Override
									public FileVisitResult visitFileFailed(java.nio.file.Path file, IOException exc) throws IOException {
										return FileVisitResult.CONTINUE;
									}

									@Override
									public FileVisitResult postVisitDirectory(java.nio.file.Path dir, IOException exc)
											throws IOException {
										return FileVisitResult.CONTINUE;
									}
								});
							}
							Files.walkFileTree(rootPath, new FileVisitor<java.nio.file.Path>() {
								@Override
								public FileVisitResult preVisitDirectory(java.nio.file.Path dir, BasicFileAttributes attrs)
										throws IOException {
									if (dir.equals(versionsPath)) {
										return FileVisitResult.SKIP_SUBTREE;
									}
									return FileVisitResult.CONTINUE;
								}
								@Override
								public FileVisitResult visitFile(java.nio.file.Path file, BasicFileAttributes attrs)
										throws IOException {
									initRawPackageInfo(rawPackageInfo, rootPath.relativize(file).toString(), false, CompilerOptions.versionFromJdkLevel(classLevel));
									return FileVisitResult.CONTINUE;
								}

								@Override
								public FileVisitResult visitFileFailed(java.nio.file.Path file, IOException exc) throws IOException {
									return FileVisitResult.CONTINUE;
								}

								@Override
								public FileVisitResult postVisitDirectory(java.nio.file.Path dir, IOException exc)
										throws IOException {
									return FileVisitResult.CONTINUE;
								}
							});
							// loop through all of referenced packages, creating package fragments if necessary
							// and cache the entry names in the rawPackageInfo table
							children = new IJavaElement[rawPackageInfo.size()];
							int index = 0;
							for (int i = 0, length = rawPackageInfo.keyTable.length; i < length; i++) {
								String[] pkgName = (String[]) rawPackageInfo.keyTable[i];
								if (pkgName == null) continue;
								children[index++] = getPackageFragment(pkgName);
							}
						} catch (IOException e) {
							Util.log(IStatus.ERROR, "Error reading archive: " + toStringWithAncestors()); //$NON-NLS-1$
						}
					}
				} catch (FileSystemNotFoundException fse) {
					Util.log(IStatus.ERROR, "Error reading archive: " + toStringWithAncestors()); //$NON-NLS-1$
					children = NO_ELEMENTS;
				} catch (ProviderNotFoundException e) {
					Util.log(IStatus.ERROR, "Provider not found: " + toStringWithAncestors()); //$NON-NLS-1$
					children = NO_ELEMENTS;
				} catch (IOException e) {
					Util.log(IStatus.ERROR, "Error reading archive: " + toStringWithAncestors()); //$NON-NLS-1$
					children = NO_ELEMENTS;
				}  finally {
					synchronized (this) {
						if (fs != null) {
							try {
								if (--this.sync_count == 0)
									fs.close();
							} catch (IOException e) {
								Util.log(IStatus.ERROR, "Error reading archive: " + toStringWithAncestors()); //$NON-NLS-1$
							}
						}
					}
				}
			}
		} catch (CoreException e) {
			if (e.getCause() instanceof ZipException) {
				// not a ZIP archive, leave the children empty
				Util.log(IStatus.ERROR, "Invalid ZIP archive: " + toStringWithAncestors()); //$NON-NLS-1$
				children = NO_ELEMENTS;
			} else if (e instanceof JavaModelException) {
				throw (JavaModelException)e;
			} else {
				throw new JavaModelException(e);
			}
		}
		info.setChildren(children);
		((JarPackageFragmentRootInfo) info).rawPackageInfo = rawPackageInfo;
		((JarPackageFragmentRootInfo) info).overriddenClasses = overridden;
		return true;
	}

