	/**
	 * Compute the package fragment children of this package fragment root.
	 * These are all of the directory zip entries, and any directories implied
	 * by the path of class files contained in the jar of this package fragment root.
	 */
	@Override
	protected boolean computeChildren(OpenableElementInfo info, IResource underlyingResource) throws JavaModelException {
		final HashtableOfArrayToObject rawPackageInfo = new HashtableOfArrayToObject();
		final Set<String> overridden = new HashSet<>();
		IJavaElement[] children;
		try {
			// always create the default package
			rawPackageInfo.put(CharOperation.NO_STRINGS, new ArrayList[] { EMPTY_LIST, EMPTY_LIST });

			boolean usedIndex = false;
			if (JavaIndex.isEnabled()) {
				JavaIndex index = JavaIndex.getIndex();
				try (IReader reader = index.getNd().acquireReadLock()) {
					IPath resourcePath = JavaIndex.getLocationForElement(this); 
					if (!resourcePath.isEmpty()) {
						NdResourceFile resourceFile = index.getResourceFile(resourcePath.toString().toCharArray());
						if (index.isUpToDate(resourceFile)) {
							usedIndex = true;
							long level = resourceFile.getJdkLevel();
							String compliance = CompilerOptions.versionFromJdkLevel(level);
							// Locate all the non-classfile entries
							for (NdZipEntry next : resourceFile.getZipEntries()) {
								String filename = next.getFileName().getString();
								initRawPackageInfo(rawPackageInfo, filename, filename.endsWith("/"), compliance); //$NON-NLS-1$
							}
	
							// Locate all the classfile entries
							for (NdType type : resourceFile.getTypes()) {	
								String path = new String(type.getTypeId().getBinaryName()) + ".class"; //$NON-NLS-1$
								initRawPackageInfo(rawPackageInfo, path, false, compliance);
							}
						}
					}
				}
			}

			// If we weren't able to compute the set of children from the index (either the index was disabled or didn't
			// contain an up-to-date entry for this .jar) then fetch it directly from the .jar
			if (!usedIndex) {
				Object file = JavaModel.getTarget(getPath(), true);
				long classLevel = Util.getJdkLevel(file);
				String projectCompliance = this.getJavaProject().getOption(JavaCore.COMPILER_COMPLIANCE, true);
				long projectLevel = CompilerOptions.versionToJdkLevel(projectCompliance);
				ZipFile jar = null;
				try {
					jar = getJar();
					String version = "META-INF/versions/" + projectCompliance + "/";  //$NON-NLS-1$//$NON-NLS-2$
					int versionPathLength = version.length();
					if (projectLevel >= ClassFileConstants.JDK9 && jar.getEntry(version) != null) {
						this.multiVersion = true;
						this.versionPath = version;
					}
					for (Enumeration e= jar.entries(); e.hasMoreElements();) {
						ZipEntry member= (ZipEntry) e.nextElement();
						String name = member.getName();
						if (this.multiVersion && name.length() > versionPathLength && name.startsWith(version)) {
							name = name.substring(version.length());
							if (org.eclipse.jdt.internal.compiler.util.Util.isClassFileName(name)) {
								overridden.add(name);
							}
						}
						initRawPackageInfo(rawPackageInfo, name, member.isDirectory(), CompilerOptions.versionFromJdkLevel(classLevel));
					}
				}  finally {
					JavaModelManager.getJavaModelManager().closeZipFile(jar);
				}
			}
			// loop through all of referenced packages, creating package fragments if necessary
			// and cache the entry names in the rawPackageInfo table
			children = new IJavaElement[rawPackageInfo.size()];
			int index = 0;
			for (int i = 0, length = rawPackageInfo.keyTable.length; i < length; i++) {
				String[] pkgName = (String[]) rawPackageInfo.keyTable[i];
				if (pkgName == null) continue;
				children[index++] = getPackageFragment(pkgName);
			}
		} catch (CoreException e) {
			if (e.getCause() instanceof ZipException) {
				// not a ZIP archive, leave the children empty
				Util.log(IStatus.ERROR, "Invalid ZIP archive: " + toStringWithAncestors()); //$NON-NLS-1$
				children = NO_ELEMENTS;
			} else if (e instanceof JavaModelException) {
				throw (JavaModelException)e;
			} else {
				throw new JavaModelException(e);
			}
		}

		info.setChildren(children);
		((JarPackageFragmentRootInfo) info).rawPackageInfo = rawPackageInfo;
		((JarPackageFragmentRootInfo) info).overriddenClasses = overridden;
		return true;
	}

