	/**
	 * Get all secondary types for a project and store result in per project info cache.
	 * 
	 * @param project Project we want get secondary types from
	 * @return HashMap Table of secondary type names->path for given project
	 */
	public HashMap getSecondaryTypes(IJavaProject project) throws JavaModelException {
		if (VERBOSE) {
			StringBuffer buffer = new StringBuffer("JavaModelManager.getSecondaryTypesPaths("); //$NON-NLS-1$
			buffer.append(project.getElementName());
			buffer.append(')');
			Util.verbose(buffer.toString());
		}

		PerProjectInfo projectInfo = getPerProjectInfoCheckExistence(project.getProject());
		if (projectInfo.secondaryTypes != null) return projectInfo.secondaryTypes;
		final HashMap secondaryTypePaths = new HashMap(3);

		IRestrictedAccessTypeRequestor nameRequestor = new IRestrictedAccessTypeRequestor() {
			public void acceptType(int modifiers, char[] packageName, char[] simpleTypeName, char[][] enclosingTypeNames, String path, AccessRestriction access) {
				String key = packageName==null ? "" : new String(packageName); //$NON-NLS-1$
				HashMap types = (HashMap) secondaryTypePaths.get(key);
				if (types == null) {
					types = new HashMap();
				}
				types.put(new String(simpleTypeName), path);
				secondaryTypePaths.put(key, types);
			}
		};

		// Build scope using prereq projects but only source folders
		IPackageFragmentRoot[] allRoots = project.getAllPackageFragmentRoots();
		int length = allRoots.length, size = 0;
		IPackageFragmentRoot[] allSourceFolders = new IPackageFragmentRoot[length];
		for (int i=0; i<length; i++) {
			if (allRoots[i].getKind() == IPackageFragmentRoot.K_SOURCE) {
				allSourceFolders[size++] = allRoots[i];
			}
		}
		if (size < length) {
			System.arraycopy(allSourceFolders, 0, allSourceFolders = new IPackageFragmentRoot[size], 0, size);
		}
			
		// Search all secondary types on scope
		new BasicSearchEngine().searchAllSecondaryTypeNames(allSourceFolders, nameRequestor);
		if (VERBOSE) {
			System.out.print(Thread.currentThread() + " -> secondary paths: ");  //$NON-NLS-1$
			if (secondaryTypePaths == null) {
				System.out.println(" NONE"); //$NON-NLS-1$
			} else {
				System.out.println();
				Iterator keys = secondaryTypePaths.keySet().iterator();
				while (keys.hasNext()) {
					String qualifiedName = (String) keys.next();
					Util.verbose("		- "+qualifiedName+'-'+secondaryTypePaths.get(qualifiedName) ); //$NON-NLS-1$
				}
			}
		}
		
		// Build types from paths
		Iterator packages = secondaryTypePaths.keySet().iterator();
		while (packages.hasNext()) {
			String packName = (String) packages.next();
			HashMap types = (HashMap) secondaryTypePaths.get(packName);
			Iterator names = types.keySet().iterator();
			while (names.hasNext()) {
				String typeName = (String) names.next();
				String path = (String) types.get(typeName);
				if (org.eclipse.jdt.internal.core.util.Util.isJavaLikeFileName(path)) {
					IFile file = ResourcesPlugin.getWorkspace().getRoot().getFile(new Path(path));
					ICompilationUnit unit = JavaModelManager.createCompilationUnitFrom(file, null);
					IType type = unit.getType(typeName);
					types.put(typeName, type); // replace stored path with type itself
				}
			}
		}
		
		// Store result in per project info cache
		return (projectInfo.secondaryTypes = secondaryTypePaths);
	}

