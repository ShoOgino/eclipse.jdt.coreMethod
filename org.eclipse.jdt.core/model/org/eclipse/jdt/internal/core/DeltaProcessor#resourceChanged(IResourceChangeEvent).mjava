	/*
	 * Notification that some resource changes have happened
	 * on the platform, and that the Java Model should update any required
	 * internal structures such that its elements remain consistent.
	 * Translates <code>IResourceDeltas</code> into <code>IJavaElementDeltas</code>.
	 *
	 * @see IResourceDelta
	 * @see IResource 
	 */
	public void resourceChanged(IResourceChangeEvent event) {

		int eventType = this.overridenEventType == -1 ? event.getType() : this.overridenEventType;
		IResource resource = event.getResource();
		IResourceDelta delta = event.getDelta();
		
		switch(eventType){
			case IResourceChangeEvent.PRE_DELETE :
				try {
					if(resource.getType() == IResource.PROJECT 
						&& ((IProject) resource).hasNature(JavaCore.NATURE_ID)) {
							
						deleting((IProject)resource);
					}
				} catch(CoreException e){
					// project doesn't exist or is not open: ignore
				}
				return;
				
			case IResourceChangeEvent.POST_CHANGE :
				HashSet elementsToRefresh = this.state.removeExternalElementsToRefresh();
				if (isAffectedBy(delta) // avoid populating for SYNC or MARKER deltas
						|| elementsToRefresh != null) { 
					try {
						try {
							stopDeltas();
							checkProjectsBeingAddedOrRemoved(delta);
							
							// generate classpath change deltas
							if (this.classpathChanges.size() > 0) {
								boolean hasDelta = this.currentDelta != null;
								JavaElementDelta javaDelta = currentDelta();
								Iterator changes = this.classpathChanges.values().iterator();
								while (changes.hasNext()) {
									ClasspathChange change = (ClasspathChange) changes.next();
									int result = change.generateDelta(javaDelta);
									if ((result & ClasspathChange.HAS_DELTA) != 0) {
										hasDelta = true;
										change.requestIndexing();
										this.state.addClasspathValidation(change.project);
									}
									if ((result & ClasspathChange.HAS_PROJECT_CHANGE) != 0) {
										this.state.addProjectReferenceChange(change.project, change.oldResolvedClasspath);
									}
									if ((result & ClasspathChange.HAS_LIBRARY_CHANGE) != 0) {
										state.addExternalFolderChange(change.project, change.oldResolvedClasspath);
									}
								}
								this.classpathChanges.clear();
								if (!hasDelta)
									this.currentDelta = null;
							}
							
							// add late coming elements to refresh (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=212769 )
							if (elementsToRefresh == null) {
								elementsToRefresh = this.state.removeExternalElementsToRefresh();
							} else {
								HashSet newElementsToRefresh = this.state.removeExternalElementsToRefresh();
								if (newElementsToRefresh != null)
									elementsToRefresh.addAll(newElementsToRefresh);
							}
							
							// generate external archive change deltas
							if (elementsToRefresh != null) {
								createExternalArchiveDelta(elementsToRefresh, null);
							}
							
							// generate Java deltas from resource changes
							IJavaElementDelta translatedDelta = processResourceDelta(delta);
							if (translatedDelta != null) { 
								registerJavaModelDelta(translatedDelta);
							}
						} finally {
							this.sourceElementParserCache = null; // don't hold onto parser longer than necessary
							startDeltas();
						}
						IElementChangedListener[] listeners;
						int listenerCount;
						synchronized (this.state) {
							listeners = this.state.elementChangedListeners;
							listenerCount = this.state.elementChangedListenerCount;
						}
						notifyTypeHierarchies(listeners, listenerCount);
						fire(null, ElementChangedEvent.POST_CHANGE);
					} finally {
						// workaround for bug 15168 circular errors not reported 
						this.state.resetOldJavaProjectNames();
						this.oldRoots = null;
					}
				}
				return;
				
			case IResourceChangeEvent.PRE_BUILD :
				boolean isAffected = isAffectedBy(delta);
				boolean needCycleValidation = isAffected && validateClasspaths(delta);

				// update external folders if necessary
			    ExternalFolderChange[] folderChanges = this.state.removeExternalFolderChanges();
				if (folderChanges != null) {
				    for (int i = 0, length = folderChanges.length; i < length; i++) {
				        try {
					        folderChanges[i].updateExternalFoldersIfNecessary(null);
				        } catch (JavaModelException e) {
				        	if (!e.isDoesNotExist())
				        		Util.log(e, "Exception while updating external folders"); //$NON-NLS-1$
				        }
				    }
				}
				
				// create classpath markers if necessary
				ClasspathValidation[] validations = this.state.removeClasspathValidations();
				if (validations != null) {
					for (int i = 0, length = validations.length; i < length; i++) {
						ClasspathValidation validation = validations[i];
						validation.validate();
					}
				}
				
				// update project references if necessary
			    ProjectReferenceChange[] projectRefChanges = this.state.removeProjectReferenceChanges();
				if (projectRefChanges != null) {
				    for (int i = 0, length = projectRefChanges.length; i < length; i++) {
				        try {
					        projectRefChanges[i].updateProjectReferencesIfNecessary();
				        } catch(JavaModelException e) {
				            // project doesn't exist any longer, continue with next one
				        	if (!e.isDoesNotExist())
				        		Util.log(e, "Exception while updating project references"); //$NON-NLS-1$
				        }
				    }
				}
				
				if (needCycleValidation || projectRefChanges != null) {
					// update all cycle markers since the project references changes may have affected cycles
					try {
						JavaProject.validateCycles(null);
					} catch (JavaModelException e) {
						// a project no longer exists
					}
				}
				
				if (isAffected) {
					JavaModel.flushExternalFileCache();
					JavaBuilder.buildStarting();
				}
				
				// does not fire any deltas
				return;

			case IResourceChangeEvent.POST_BUILD :
				JavaBuilder.buildFinished();
				return;
		}
	}

