protected void buildStructure(OpenableElementInfo info, IProgressMonitor monitor) throws JavaModelException {

	if (monitor != null && monitor.isCanceled()) return;

	// remove existing (old) infos
	removeInfo();

	HashMap newElements = new HashMap(11);
	info.setIsStructureKnown(generateInfos(info, monitor, newElements, getResource()));
	JavaModelManager.getJavaModelManager().getElementsOutOfSynchWithBuffers().remove(this);
	for (Iterator iter = newElements.keySet().iterator(); iter.hasNext();) {
		IJavaElement key = (IJavaElement) iter.next();
		Object value = newElements.get(key);
		JavaModelManager.getJavaModelManager().putInfo(key, value);
	}
	// add the info for this at the end, to ensure that a getInfo cannot reply null in case the LRU cache needs
	// to be flushed. Might lead to performance issues.
	// see PR 1G2K5S7: ITPJCORE:ALL - NPE when accessing source for a binary type
	JavaModelManager.getJavaModelManager().putInfo(this, info);	

	// problem detection 
	if (monitor != null && monitor.isCanceled()) return;

	IProblemRequestor problemRequestor = this.getProblemRequestor();
	if (problemRequestor != null && problemRequestor.isActive()){
		problemRequestor.beginReporting();
		CompilationUnitProblemFinder.process(this, problemRequestor, monitor); // TODO: is the JavaModel lock taken here ? Can run client code
		problemRequestor.endReporting();
	}
}

