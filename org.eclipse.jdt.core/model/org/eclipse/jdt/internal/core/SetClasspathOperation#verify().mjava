/**
 * Possible failures: <ul>
 *  <li>NO_ELEMENTS_TO_PROCESS - the project supplied to the operation is
 * 		<code>null</code>.
 *	<li>NULL_PATH - the output location path supplied to the operation
 * 		is <code>null</code>.
 *	<li>PATH_OUTSIDE_PROJECT - the output location path supplied to the operation
 * 		is outside of the project supplied to this operation.
 *	<li>DEVICE_PATH - the path supplied to this operation must not specify a 
 * 		device
 *	<li>RELATIVE_PATH - the path supplied to this operation must be
 *		an absolute path
 *	<li>INVALID_PATH - the output location cannot overlap any package fragment
 *		root, except the project folder.
 *  <li>ELEMENT_DOES_NOT_EXIST - the Java project does not exist
 * </ul>
 */
public IJavaModelStatus verify() {
	IJavaModelStatus status = super.verify();
	if (!status.isOK()) {
		return status;
	}
	IClasspathEntry[] classpath = this.newRawPath;
	IJavaProject javaProject = (IJavaProject)getElementToProcess();
	IPath projectPath= javaProject.getProject().getFullPath();

	// retrieve output location
	IPath outputLocation;
	try {
		outputLocation = javaProject.getOutputLocation();
	} catch(JavaModelException e){
		return e.getJavaModelStatus();
	}

	// check if any source entries coincidates with binary output - in which case nesting inside output is legal
	boolean allowNestingInOutput = false;
	boolean hasSource = false;
	for (int i = 0 ; i < classpath.length; i++) {
		if (classpath[i].getEntryKind() == IClasspathEntry.CPE_SOURCE) hasSource = true;
		if (classpath[i].getPath().equals(outputLocation)){
			allowNestingInOutput = true;
			break;
		}
	}
	if (!hasSource) allowNestingInOutput = true; // if no source, then allowed
	
	// check all entries
	for (int i = 0 ; i < classpath.length; i++) {
		IClasspathEntry entry = classpath[i];
		IPath entryPath = entry.getPath();

		// no further check if entry coincidates with project or output location
		if (entryPath.equals(projectPath)) continue;
		if (entryPath.equals(outputLocation)) continue;
		
		// prevent nesting source entries in each other
		if (entry.getEntryKind() == IClasspathEntry.CPE_SOURCE){
			for (int j = 0; j < classpath.length; j++){
				IClasspathEntry otherEntry = classpath[j];
				if (entry != otherEntry && otherEntry.getEntryKind() == IClasspathEntry.CPE_SOURCE){
					if (entryPath.isPrefixOf(otherEntry.getPath())){
						return new JavaModelStatus(IJavaModelStatusConstants.INVALID_PATH, entryPath);
					}
				}
			}
		}
		// prevent nesting output location inside entry
		if (entryPath.isPrefixOf(outputLocation)) {
			return new JavaModelStatus(IJavaModelStatusConstants.INVALID_PATH, entryPath);
		}

		// prevent nesting entry inside output location - when distinct from project or a source folder
		if (!allowNestingInOutput && outputLocation.isPrefixOf(entryPath)) {
			return new JavaModelStatus(IJavaModelStatusConstants.INVALID_PATH, entryPath);
		}
	}
	return JavaModelStatus.VERIFIED_OK;
}

