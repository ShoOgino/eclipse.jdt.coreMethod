private void generateModuleInfos(ClassFile classFile, IBinaryType info, HashMap newElements, ArrayList childrenHandles) {
	// TODO: The following needs fix once we can get ModuleDeclaration from IndexBinaryType
	IModule modDecl = (info instanceof ClassFileReader) ? ((ClassFileReader) info).getModuleDeclaration() : null;
	if (modDecl != null) {
		char[] modName = modDecl.name();
		BinaryModule handle = new BinaryModule(classFile, new String(modName));
		ModuleDescriptionInfo moduleInfo = new ModuleDescriptionInfo();
		moduleInfo.name = modName;
		// It is illegal to add module to ClassFile's children because
		// we use ClassFile itself to store binary children of BinaryModule,
		// which means module can't be part of its own children list.
		// childrenHandles.add(handle); 
		IPackageExport[] exportedPackages = modDecl.exports();
		if (exportedPackages != null) {
			for (IPackageExport iPackageExport : exportedPackages) {
				generatePackageExportInfos(handle, newElements, iPackageExport.name(), iPackageExport.targets(), childrenHandles);
			}
		}
		IModuleReference[] requiredModules = modDecl.requires();
		if (requiredModules != null) {
			for (IModuleReference iModuleReference : requiredModules) {
				generateModuleRequirementInfos(handle, newElements, iModuleReference.name(), iModuleReference.getModifiers(), childrenHandles);
			}
		}
		IService[] provides = modDecl.provides();
		if (provides != null) {
			for (IService iSer : provides) {
				generateServiceInfos(handle, newElements, iSer.name(), iSer.with(), childrenHandles);
			}
		}
		moduleInfo.usedServices = modDecl.uses();
		IPackageExport[] opens = modDecl.opens();
		if (opens != null) {
			for (IPackageExport iPackageExport : exportedPackages) {
				generatOpensInfos(handle, newElements, iPackageExport.name(), iPackageExport.targets(), childrenHandles);
			}
		}
		setModule(handle);
		newElements.put(handle, moduleInfo);
	}
}

