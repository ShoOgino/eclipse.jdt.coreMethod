/**
 * Moves the gap to location and adjust its size to the
 * anticipated change size. The size represents the expected 
 * range of the gap that will be filled after the gap has been moved.
 * Thus the gap is resized to actual size + the specified size and
 * moved to the given position.
 */
protected void moveAndResizeGap(int position, int size) {
	char[] content = null;
	int oldSize = fGapEnd - fGapStart;
	int newSize = fHighWatermark + size;
	if (newSize < 0) {
		if (oldSize > 0) {
			content = new char[fContents.length - oldSize];
			System.arraycopy(fContents, 0, content, 0, fGapStart);
			System.arraycopy(fContents, fGapEnd, content, fGapStart, content.length - fGapStart);
			fContents = content;
		}
		fGapStart = fGapEnd = position;
		return;
	}
	content = new char[fContents.length + (newSize - oldSize)];
	int newGapStart = position;
	int newGapEnd = newGapStart + newSize;
	if (oldSize == 0) {
		System.arraycopy(fContents, 0, content, 0, newGapStart);
		System.arraycopy(fContents, newGapStart, content, newGapEnd, content.length - newGapEnd);
	} else
		if (newGapStart < fGapStart) {
			int delta = fGapStart - newGapStart;
			System.arraycopy(fContents, 0, content, 0, newGapStart);
			System.arraycopy(fContents, newGapStart, content, newGapEnd, delta);
			System.arraycopy(fContents, fGapEnd, content, newGapEnd + delta, fContents.length - fGapEnd);
		} else {
			int delta = newGapStart - fGapStart;
			System.arraycopy(fContents, 0, content, 0, fGapStart);
			System.arraycopy(fContents, fGapEnd, content, fGapStart, delta);
			System.arraycopy(fContents, fGapEnd + delta, content, newGapEnd, content.length - newGapEnd);
		}
	fContents = content;
	fGapStart = newGapStart;
	fGapEnd = newGapEnd;
}

