	/**
	 * Sets the classpath of the pre-specified project.
	 */
	protected void executeOperation() throws JavaModelException {

		// resolve new path (asking for marker creation if problems)
		JavaProject project = getProject();
		IClasspathEntry[] newResolvedPath = 
			project.getResolvedClasspath(
				this.newRawPath,
				true, // ignoreUnresolvedEntry
				this.canChangeResource);// also update cp markers
				
		// compute needCycleCheck bit
		computeCycleCheck(this.oldResolvedPath, newResolvedPath, project.getJavaModelManager(), project);

		// project reference updated - may throw an exception if unable to write .project file
		updateProjectReferencesIfNecessary();

		// classpath file updated - may throw an exception if unable to write .classpath file
		saveClasspathIfNecessary();
		
		// perform classpath and output location updates, if exception occurs in classpath update,
		// make sure the output location is updated before surfacing the exception (in case the output
		// location update also throws an exception, give priority to the classpath update one).
		JavaModelException originalException = null;

		try {
			if (this.newRawPath != ReuseClasspath) updateClasspath(newResolvedPath);

		} catch(JavaModelException e){
			originalException = e;
			throw e;

		} finally { // if traversed by an exception we still need to update the output location when necessary

			try {
				if (this.newOutputLocation != ReuseOutputLocation) updateOutputLocation();

			} catch(JavaModelException e){
				if (originalException != null) throw originalException; 
				throw e;
			}
		}
		done();
	}

