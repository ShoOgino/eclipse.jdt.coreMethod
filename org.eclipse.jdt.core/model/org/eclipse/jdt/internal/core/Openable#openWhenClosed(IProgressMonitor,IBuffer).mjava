/**
 * Open an <code>Openable</code> that is known to be closed (no check for <code>isOpen()</code>).
 * Use the given buffer to get the source, or open a new one if null.
 */
protected void openWhenClosed(IProgressMonitor pm, IBuffer buffer) throws JavaModelException {
	try {
		
		if (JavaModelManager.VERBOSE){
			System.out.println("OPENING Element ("+ Thread.currentThread()+"): " + this.toStringWithAncestors()); //$NON-NLS-1$//$NON-NLS-2$
		}
		
		// 1) Parent must be open - open the parent if necessary
		openParent(pm);
		
		// 1.5) Ensure my resource is local
		IResource resource = getCorrespondingResource();
		if (resource != null) {
			try {
				JavaModelManager.getJavaModelManager().ensureLocal(resource);
			} catch (CoreException e) {
				throw new JavaModelException(e);
			}
		}

		// 2) create the new element info and open a buffer if needed
		OpenableElementInfo info = createElementInfo();
		if (buffer == null) {
			if (resource != null && isSourceElement()) {
				this.openBuffer(pm);
			} 
		} else {
			this.getBufferManager().addBuffer(buffer);
			buffer.addBufferChangedListener(this);
		}

		// 3) build the structure of the openable
		buildStructure(info, null, pm);

		// 4) anything special
		opening(info);
		
		if (JavaModelManager.VERBOSE) {
			System.out.println("-> Package cache filling rate = " + fgJavaModelManager.cache.pkgFillingRate() + "%"); //$NON-NLS-1$//$NON-NLS-2$
			System.out.println("-> Openable cache filling rate = " + fgJavaModelManager.cache.openableFillingRate() + "%"); //$NON-NLS-1$//$NON-NLS-2$
		}

		// if any problems occuring openning the element, ensure that it's info
		// does not remain in the cache	(some elements, pre-cache their info
		// as they are being opened).
	} catch (JavaModelException e) {
		fgJavaModelManager.removeInfo(this);
		throw e;
	}
}

