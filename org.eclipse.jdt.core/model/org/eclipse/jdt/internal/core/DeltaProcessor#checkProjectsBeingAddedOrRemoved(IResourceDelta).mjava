	/*
	 * Process the given delta and look for projects being added, opened, closed or
	 * with a java nature being added or removed.
	 * Note that projects being deleted are checked in deleting(IProject).
	 * In all cases, add the project's dependents to the list of projects to update
	 * so that the classpath related markers can be updated.
	 */
	private void checkProjectsBeingAddedOrRemoved(IResourceDelta delta) {
		IResource resource = delta.getResource();
		boolean processChildren = false;
	
		switch (resource.getType()) {
			case IResource.ROOT :
				// workaround for bug 15168 circular errors not reported 
				if (this.state.modelProjectsCache == null) {
					try {
						this.state.modelProjectsCache = this.manager.getJavaModel().getJavaProjects();
					} catch (JavaModelException e) {
						// java model doesn't exist: never happens
					}
				}
				processChildren = true;
				break;
			case IResource.PROJECT :
				// NB: No need to check project's nature as if the project is not a java project:
				//     - if the project is added or changed this is a noop for projectsBeingDeleted
				//     - if the project is closed, it has already lost its java nature
				IProject project = (IProject)resource;
				JavaProject javaProject = (JavaProject)JavaCore.create(project);
				switch (delta.getKind()) {
					case IResourceDelta.ADDED :
						this.manager.batchContainerInitializations = true;
					
						// remember project and its dependents
						this.addToRootsToRefreshWithDependents(javaProject);
						
						// workaround for bug 15168 circular errors not reported 
						if (JavaProject.hasJavaNature(project)) {
							this.addToParentInfo(javaProject);
						}
						
						// ensure project references are updated (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=121569)
						try {
							this.state.updateProjectReferences(
								javaProject, 
								null/*no old classpath*/, 
								null/*compute new resolved classpath later*/, 
								null/*read raw classpath later*/, 
								false/*cannot change resources*/);
						} catch (JavaModelException e1) {
							// project always exists
						}
					
						this.state.rootsAreStale = true; 
						break;
						
					case IResourceDelta.CHANGED : 
							if ((delta.getFlags() & IResourceDelta.OPEN) != 0) {
								this.manager.batchContainerInitializations = true;
		
								// project opened or closed: remember  project and its dependents
								this.addToRootsToRefreshWithDependents(javaProject);
								
								// workaround for bug 15168 circular errors not reported 
								if (project.isOpen()) {
									if (JavaProject.hasJavaNature(project)) {
										this.addToParentInfo(javaProject);
									}
								} else {
									try {
										javaProject.close();
									} catch (JavaModelException e) {
										// java project doesn't exist: ignore
									}
									this.removeFromParentInfo(javaProject);
									this.manager.removePerProjectInfo(javaProject);
									this.manager.containerRemove(javaProject);
								}
								this.state.rootsAreStale = true;
							} else if ((delta.getFlags() & IResourceDelta.DESCRIPTION) != 0) {
								boolean wasJavaProject = this.manager.getJavaModel().findJavaProject(project) != null;
								boolean isJavaProject = JavaProject.hasJavaNature(project);
								if (wasJavaProject != isJavaProject) { 
									this.manager.batchContainerInitializations = true;
									
									// java nature added or removed: remember  project and its dependents
									this.addToRootsToRefreshWithDependents(javaProject);
		
									// workaround for bug 15168 circular errors not reported 
									if (isJavaProject) {
										this.addToParentInfo(javaProject);
									} else {
										// remove classpath cache so that initializeRoots() will not consider the project has a classpath
										this.manager.removePerProjectInfo(javaProject);
										// remove container cache for this project
										this.manager.containerRemove(javaProject);
										// close project
										try {
											javaProject.close();
										} catch (JavaModelException e) {
											// java project doesn't exist: ignore
										}
										this.removeFromParentInfo(javaProject);
									}
									this.state.rootsAreStale = true;
								} else {
									// in case the project was removed then added then changed (see bug 19799)
									if (isJavaProject) { // need nature check - 18698
										this.addToParentInfo(javaProject);
										processChildren = true;
									}
								}
							} else {
								// workaround for bug 15168 circular errors not reported 
								// in case the project was removed then added then changed
								if (JavaProject.hasJavaNature(project)) { // need nature check - 18698
									this.addToParentInfo(javaProject);
									processChildren = true;
								}						
							}		
							break;
	
					case IResourceDelta.REMOVED : 
						this.manager.batchContainerInitializations = true;
	
						// remove classpath cache so that initializeRoots() will not consider the project has a classpath
						this.manager.removePerProjectInfo(javaProject);
						// remove container cache for this project
						this.manager.containerRemove(javaProject);
						
						this.state.rootsAreStale = true;
						break;
				}
				
				// in all cases, refresh the external jars for this project
				addForRefresh(javaProject);
				
				break;
			case IResource.FILE :
				IFile file = (IFile) resource;
				/* classpath file change */
				if (file.getName().equals(JavaProject.CLASSPATH_FILENAME)) {
					this.manager.batchContainerInitializations = true;
					reconcileClasspathFileUpdate(delta, (JavaProject)JavaCore.create(file.getProject()));
					this.state.rootsAreStale = true;
				}
				break;
				
		}
		if (processChildren) {
			IResourceDelta[] children = delta.getAffectedChildren();
			for (int i = 0; i < children.length; i++) {
				checkProjectsBeingAddedOrRemoved(children[i]);
			}
		}
	}

