/**
 * Creates a marker from each problem and adds it to the resource.
 * The marker is as follows:
 *   - its type is T_PROBLEM
 *   - its plugin ID is the JavaBuilder's plugin ID
 *	 - its message is the problem's message
 *	 - its priority reflects the severity of the problem
 *	 - its range is the problem's range
 *	 - it has an extra attribute "ID" which holds the problem's id
 */
protected void storeProblemsFor(SourceFile sourceFile, IProblem[] problems) throws CoreException {
	if (sourceFile == null || problems == null || problems.length == 0) return;

	String missingClassFile = null;
	IResource resource = sourceFile.resource;
	for (int i = 0, l = problems.length; i < l; i++) {
		IProblem problem = problems[i];
		int id = problem.getID();
		switch (id) {
			case IProblem.IsClassPathCorrect :
				JavaBuilder.removeProblemsAndTasksFor(javaBuilder.currentProject); // make this the only problem for this project
				String[] args = problem.getArguments();
				missingClassFile = args[0];
				break;
			case IProblem.SuperclassMustBeAClass :
			case IProblem.SuperInterfaceMustBeAnInterface :
			case IProblem.HierarchyCircularitySelfReference :
			case IProblem.HierarchyCircularity :
			case IProblem.HierarchyHasProblems :
			case IProblem.SuperclassNotFound :
			case IProblem.SuperclassNotVisible :
			case IProblem.SuperclassAmbiguous :
			case IProblem.SuperclassInternalNameProvided :
			case IProblem.SuperclassInheritedNameHidesEnclosingName :
			case IProblem.InterfaceNotFound :
			case IProblem.InterfaceNotVisible :
			case IProblem.InterfaceAmbiguous :
			case IProblem.InterfaceInternalNameProvided :
			case IProblem.InterfaceInheritedNameHidesEnclosingName :
				// ensure that this file is always retrieved from source for the rest of the build
				if (!problemSourceFiles.contains(sourceFile))
					problemSourceFiles.add(sourceFile);
				break;
		}

		IMarker marker;
		if (id != IProblem.Task) {
			marker = resource.createMarker(IJavaModelMarker.JAVA_MODEL_PROBLEM_MARKER);
			marker.setAttributes(
				new String[] {
					IMarker.MESSAGE, 
					IMarker.SEVERITY, 
					IJavaModelMarker.ID, 
					IMarker.CHAR_START, 
					IMarker.CHAR_END, 
					IMarker.LINE_NUMBER, 
					IJavaModelMarker.ARGUMENTS},
				new Object[] { 
					problem.getMessage(),
					new Integer(problem.isError() ? IMarker.SEVERITY_ERROR : IMarker.SEVERITY_WARNING), 
					new Integer(id),
					new Integer(problem.getSourceStart()),
					new Integer(problem.getSourceEnd() + 1),
					new Integer(problem.getSourceLineNumber()),
					Util.getProblemArgumentsForMarker(problem.getArguments())
				});
		} else {
			marker = resource.createMarker(IJavaModelMarker.TASK_MARKER);
			int priority = IMarker.PRIORITY_NORMAL;
			String compilerPriority = problem.getArguments()[2];
			if (JavaCore.COMPILER_TASK_PRIORITY_HIGH.equals(compilerPriority))
				priority = IMarker.PRIORITY_HIGH;
			else if (JavaCore.COMPILER_TASK_PRIORITY_LOW.equals(compilerPriority))
				priority = IMarker.PRIORITY_LOW;
			marker.setAttributes(
				new String[] {
					IMarker.MESSAGE, 
					IMarker.PRIORITY, 
					IMarker.DONE, 
					IMarker.CHAR_START, 
					IMarker.CHAR_END, 
					IMarker.LINE_NUMBER},
				new Object[] { 
					problem.getMessage(),
					new Integer(priority),
					new Boolean(false),
					new Integer(problem.getSourceStart()),
					new Integer(problem.getSourceEnd() + 1),
					new Integer(problem.getSourceLineNumber()),
				});
		}

/* Do NOT want to populate the Java Model just to find the matching Java element.
 * Also cannot query compilation units located in folders with invalid package
 * names such as 'a/b.c.d/e'.

		// compute a user-friendly location
		IJavaElement element = JavaCore.create(resource);
		if (element instanceof org.eclipse.jdt.core.ICompilationUnit) { // try to find a finer grain element
			org.eclipse.jdt.core.ICompilationUnit unit = (org.eclipse.jdt.core.ICompilationUnit) element;
			IJavaElement fragment = unit.getElementAt(problem.getSourceStart());
			if (fragment != null) element = fragment;
		}
		String location = null;
		if (element instanceof JavaElement)
			location = ((JavaElement) element).readableName();
		if (location != null)
			marker.setAttribute(IMarker.LOCATION, location);
*/

		if (missingClassFile != null)
			throw new MissingClassFileException(missingClassFile);
	}
}

