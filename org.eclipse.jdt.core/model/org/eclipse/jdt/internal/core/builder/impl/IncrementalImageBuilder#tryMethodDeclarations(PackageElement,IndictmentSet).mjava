/**
 * If a subtype of the originator of a method indictment redefines
 * the method for which there is an indictment, it must be recompiled.
 */
protected boolean tryMethodDeclarations(PackageElement unit, IndictmentSet indictments) {
	final boolean GUILTY = true, INNOCENT = false;
	IType[] methodIndictmentOwners = indictments.getMethodIndictmentOwners();
	if (methodIndictmentOwners.length == 0) {
		return INNOCENT;
	}
	/* if problems were detected, some innerclasses might not have been generated,
		thus the state would not reflect their presence, and even if guilty could not
		be convicted (also see 1GA6CV7) */
	Vector problemVector = fOldState.getProblemReporter().getProblemVector(fOldState.getSourceEntry(unit));
	if (problemVector != null){
		Enumeration problems = problemVector.elements();
		while (problems.hasMoreElements()){
			IProblemDetail problem = (IProblemDetail) problems.nextElement();
			if ((problem.getSeverity() & IProblemDetail.S_ERROR) != 0) return GUILTY;
		}
	}	
	IType[] types = fOldState.getInternalDependencyGraph().getTypes(unit);
	for (int i = 0; i < types.length; ++i) {
		boolean found = false;
		BuilderType trialType = getBuilderType(types[i]);
		for (int j = 0, len = methodIndictmentOwners.length; j < len; ++j) {
			//note this is conservative because owners are not matched to their methods
			if (trialType.hasSuperType(methodIndictmentOwners[j])) {
				found = true;
				break;
			}
		}
		if (found) {
			if (tryMethodDeclarations(trialType, indictments)){
				return GUILTY;
			}
		}
	}
	return INNOCENT;
}

