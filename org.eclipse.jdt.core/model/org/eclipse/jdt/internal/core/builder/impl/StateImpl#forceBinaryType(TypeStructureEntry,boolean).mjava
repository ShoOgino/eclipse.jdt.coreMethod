	/**
	 * The IBinaryType for this TypeStructureEntry has been flushed from
	 * the cache.  Rebuild the IBinaryType from binary.  May or may not force
	 * a lazy build, depending on the parameter lazyBuildCU.
	 */
	protected IBinaryType forceBinaryType(
		TypeStructureEntry tsEntry,
		boolean lazyBuildCU) {
		IType type = tsEntry.getType();
		SourceEntry sEntry = tsEntry.getSourceEntry();
		IBinaryType binaryType = null;

		/* if its a class file, get descriptor from binary index */
		if (sEntry.isBinary()) {
			try {
				byte[] bytes = getElementContentBytes(sEntry);
				binaryType =
					new ClassFileReader(bytes, sEntry.getPathWithZipEntryName().toCharArray());
			} catch (ClassFormatException e) {
				/* problem will be generated below */
			}
		} else {
			/* entry is source in workspace; get binary from broker */
			IType typeSS = (IType) type.inState(this);
			byte[] bytes = getBinary(typeSS, lazyBuildCU);
			if (bytes != null) {
				try {
					binaryType =
						new ClassFileReader(bytes, sEntry.getPathWithZipEntryName().toCharArray());
				} catch (ClassFormatException e) {
					/* problem will be generated below */
				}
			}
		}
		if (lazyBuildCU && binaryType == null) {
			/* couldn't parse the class file */
			ProblemDetailImpl problem =
				new ProblemDetailImpl("unable to parse class file: " + type.getName(), sEntry);
			fProblemReporter.putProblem(sEntry, problem);
		}
		return binaryType;
	}

