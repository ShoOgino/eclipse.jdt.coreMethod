/**
 * Returns the parameter type handles, extracted from the given method 
 * or constructor signature.  Parameter names can either be fully
 * qualified VM type names, or DC API source signature names.  The
 * class java.lang.String would be represented as either: 
 * 	VM name: Ljava.lang.String;
 *		DC name: QString;
 */
protected IType[] parameterTypesFromSignature(final String signature) {
	Vector typeVector = new Vector();

	/* The signature looks like this:
	 * 	name(<parm1><parm2><parm3>...)<return type>
	 */

	/* extract parameters from signature */
	String localSig = signature.substring(signature.indexOf('(') + 1, signature.lastIndexOf(')'));

	/* parse each parameter */
	while (localSig.length() > 0) {

		/* 
		 * Each parameter can be defined by the following productions:
		 * 	parameter: arrayType
		 * 	arrayType: [arrayType OR type
		 *		type: L<classname>; OR <single character for base type>
		 */

		/* skip array characters */
		int position = 0;
		while (localSig.charAt(position) == '[') {
			position++;
		}
		IType parmType;
		char c = localSig.charAt(position);
		if (c == 'L' || c == 'Q') {
			/* its a class type */
			int endIndex = localSig.indexOf(";") + 1;
			parmType = classTypeFromName(localSig.substring(position, endIndex));
			localSig = localSig.substring(endIndex);
		} else {
			/* its a base type */
			parmType = primitiveTypeFromTypeCode(localSig.charAt(position));
			localSig = localSig.substring(position + 1);
		}

		/* if its an array type */
		if (position != 0) {
			parmType = new ArrayTypeHandleImpl((TypeImpl) parmType, position);
		}
		typeVector.addElement(parmType);
	}

	/* convert results vector to an array */
	IType[] results = new IType[typeVector.size()];
	typeVector.copyInto(results);
	return results;
}

