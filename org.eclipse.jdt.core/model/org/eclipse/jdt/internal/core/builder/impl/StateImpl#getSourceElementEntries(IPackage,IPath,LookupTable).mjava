	/**
	 * Iterates through the children of a package fragment and adds all visible source element entries to the table.
	 */
	protected void getSourceElementEntries(IPackage pkg, IPath path, LookupTable entryTable) {
		try {
			IPackageFragmentRoot root= null;
			IPackageFragment frag= null;
			boolean isDefault= pkg.isUnnamed();
			String pkgName= isDefault ? IPackageFragment.DEFAULT_PACKAGE_NAME : pkg.getName();
			String pkgPath= pkgName.replace('.', '/');
			if (isZipElement(path)) {
				IResource member= null;
				if (!path.isAbsolute() || getProject().getWorkspace().getRoot().findMember(path) != null) {
					root= getJavaProject().getPackageFragmentRoot(getFile(path));
				} else {
					root= getJavaProject().getPackageFragmentRoot(path.toOSString());
				}
				frag= root.getPackageFragment(pkgName);
			} else {
				IPackageFragmentRoot[] roots= getPackageFragmentRootsInClassPath();
				for (int i= 0; i < roots.length; ++i) {
					IPackageFragmentRoot testRoot= roots[i];
					if (!testRoot.isArchive() && testRoot.getUnderlyingResource().getFullPath().isPrefixOf(path)) {
						root= testRoot;
						frag= testRoot.getPackageFragment(pkgName);
						break;
					}
				}
			}
			boolean isArchive= root.isArchive();
			if (!isArchive && !root.exists()) {
				return;
			}
			if (isArchive && root.getUnderlyingResource() != null && !root.getUnderlyingResource().isLocal(IResource.DEPTH_ZERO)) {
				return;
			}
			if (frag == null || !frag.exists()) {
				return;
			}
			IPath entryPath= null;
			String zipEntryPath = null;
			String zipEntryFileName= null;
			((PackageFragment) frag).refreshChildren();
			ICompilationUnit[] units= frag.getCompilationUnits();
			for (int i= 0; i < units.length; ++i) {
				ICompilationUnit unit= units[i];
				String fileName= unit.getElementName();
				// get the corresponding .class file name
				String classFileName = "";
				if (Util.isJavaFileName(fileName)) { // paranoia check
					classFileName = fileName.substring(0, fileName.length()-5).concat(".class");
				}
				// see if a source entry exists for this file name
				// or for the corresponding .class file
				if (entryTable.get(fileName) == null && entryTable.get(classFileName) == null) {
					if (isArchive) {
						entryPath= path;
						zipEntryPath = isDefault || pkgPath.length() == 0 ? null : pkgPath;
						zipEntryFileName= fileName;
					} else {
						entryPath= unit.getUnderlyingResource().getFullPath();
						zipEntryPath = null;
						zipEntryFileName= null;
					}
					SourceEntry sEntry= new SourceEntry(entryPath, zipEntryPath, zipEntryFileName);
					entryTable.put(fileName, sEntry);
				}
			}
			IClassFile[] classFiles= frag.getClassFiles();
			for (int i= 0; i < classFiles.length; ++i) {
				IClassFile classFile= classFiles[i];
				String fileName= classFile.getElementName();
				// get the corresponding .java file name
				// note: this handles nested types, but not secondary types (e.g. class B defined in A.java)
				String javaFileName = "";
				if (Util.isClassFileName(fileName)) { // paranoia check
					// strip off any nested types
					javaFileName = fileName.substring(0, fileName.length()-6);
					int dol = javaFileName.indexOf('$');
					if (dol != -1) {
						javaFileName = javaFileName.substring(0, dol);
					}
					javaFileName = javaFileName.concat(".java");
				}
				// see if a source entry exists for this file name
				// or for the corresponding .java file
				if (entryTable.get(fileName) == null && entryTable.get(javaFileName) == null) {
					if (isArchive) {
						entryPath= path;
						zipEntryPath = isDefault || pkgPath.length() == 0 ? null : pkgPath;
						zipEntryFileName= fileName;
					} else {
						if (!classFile.getUnderlyingResource().isLocal(IResource.DEPTH_ZERO))
							continue;
						entryPath= classFile.getUnderlyingResource().getFullPath();
						zipEntryPath = null;
						zipEntryFileName= null;
					}
					SourceEntry sEntry= new SourceEntry(entryPath, zipEntryPath, zipEntryFileName);
					entryTable.put(fileName, sEntry);
				}
			}
		} catch (JavaModelException e) {
			throw internalException(e);
		}
	}

