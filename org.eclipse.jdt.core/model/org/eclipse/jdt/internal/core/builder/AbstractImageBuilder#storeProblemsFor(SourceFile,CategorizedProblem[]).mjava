/**
 * Creates a marker from each problem and adds it to the resource.
 * The marker is as follows:
 *   - its type is T_PROBLEM
 *   - its plugin ID is the JavaBuilder's plugin ID
 *	 - its message is the problem's message
 *	 - its priority reflects the severity of the problem
 *	 - its range is the problem's range
 *	 - it has an extra attribute "ID" which holds the problem's id
 *   - it's GENERATED_BY attribute is positioned to JavaBuilder.GENERATED_BY if
 *     the problem was generated by JDT; else the GENERATED_BY attribute is 
 *     carried from the problem to the marker in extra attributes, if present.
 */
protected void storeProblemsFor(SourceFile sourceFile, CategorizedProblem[] problems) throws CoreException {
	if (sourceFile == null || problems == null || problems.length == 0) return;
	 // once a classpath error is found, ignore all other problems for this project so the user can see the main error
	// but still try to compile as many source files as possible to help the case when the base libraries are in source
	if (!this.keepStoringProblemMarkers) return; // only want the one error recorded on this source file

	IResource resource = sourceFile.resource;
	HashSet managedMarkerTypes = JavaModelManager.getJavaModelManager().compilationParticipants.managedMarkerTypes();
	for (int i = 0, l = problems.length; i < l; i++) {
		CategorizedProblem problem = problems[i];
		int id = problem.getID();

		// handle missing classfile situation
		if (id == IProblem.IsClassPathCorrect) {
			String missingClassfileName = problem.getArguments()[0];
			if (JavaBuilder.DEBUG)
				System.out.println(Messages.bind(Messages.build_incompleteClassPath, missingClassfileName));
			boolean isInvalidClasspathError = JavaCore.ERROR.equals(javaBuilder.javaProject.getOption(JavaCore.CORE_INCOMPLETE_CLASSPATH, true));
			// insert extra classpath problem, and make it the only problem for this project (optional)
			if (isInvalidClasspathError && JavaCore.ABORT.equals(javaBuilder.javaProject.getOption(JavaCore.CORE_JAVA_BUILD_INVALID_CLASSPATH, true))) {
				JavaBuilder.removeProblemsAndTasksFor(javaBuilder.currentProject); // make this the only problem for this project
				this.keepStoringProblemMarkers = false;
			}
			IMarker marker = this.javaBuilder.currentProject.createMarker(IJavaModelMarker.JAVA_MODEL_PROBLEM_MARKER);
			marker.setAttribute(IMarker.MESSAGE, Messages.bind(Messages.build_incompleteClassPath, missingClassfileName)); 
			marker.setAttribute(IMarker.SEVERITY, isInvalidClasspathError ? IMarker.SEVERITY_ERROR : IMarker.SEVERITY_WARNING);
			marker.setAttribute(IJavaModelMarker.CATEGORY_ID, CategorizedProblem.CAT_BUILDPATH);
			marker.setAttribute(IMarker.SOURCE_ID, JavaBuilder.SOURCE_ID);
			// even if we're not keeping more markers, still fall through rest of the problem reporting, so that offending
			// IsClassPathCorrect problem gets recorded since it may help locate the offending reference
		}

		String markerType = problem.getMarkerType();
		boolean managedProblem = false;
		if (IJavaModelMarker.JAVA_MODEL_PROBLEM_MARKER.equals(markerType)
				|| (managedProblem = managedMarkerTypes.contains(markerType))) {
			IMarker marker = resource.createMarker(markerType);

			// standard attributes
			marker.setAttributes(
				JAVA_PROBLEM_MARKER_ATTRIBUTE_NAMES,
				new Object[] { 
					problem.getMessage(), // message
					problem.isError() ? S_ERROR : S_WARNING, // severity
					new Integer(id), // ID
					new Integer(problem.getSourceStart()), // start
					new Integer(problem.getSourceEnd() + 1), // end
					new Integer(problem.getSourceLineNumber()), // line
					Util.getProblemArgumentsForMarker(problem.getArguments()), // arguments
					new Integer(problem.getCategoryID()) // category ID
				}
			);
			// GENERATED_BY attribute for JDT problems
			if (!managedProblem) {
				marker.setAttribute(IMarker.SOURCE_ID, JavaBuilder.SOURCE_ID);
			}
			// optional extra attributes
			String[] extraAttributeNames = problem.getExtraMarkerAttributeNames();
			int extraLength = extraAttributeNames == null ? 0 : extraAttributeNames.length;
			if (extraLength > 0) {
				marker.setAttributes(extraAttributeNames, problem.getExtraMarkerAttributeValues());
			}

			if (!this.keepStoringProblemMarkers) return; // only want the one error recorded on this source file
		}
	}
}

