public boolean build(SimpleLookupTable deltas) {
	// initialize builder
	// walk this project's deltas, find changed source files
	// walk prereq projects' deltas, find changed class files & add affected source files
	//   use the build state # to skip the deltas for certain prereq projects
	//   ignore changed zip/jar files since they caused a full build
	// compile the source files & acceptResult()
	// compare the produced class files against the existing ones on disk
	// recompile all dependent source files of any type with structural changes or new/removed secondary type
	// keep a loop counter to abort & perform a full build

	if (JavaBuilder.DEBUG)
		System.out.println("INCREMENTAL build"); //$NON-NLS-1$

	try {
		resetCollections();

		notifier.subTask(Util.bind("build.analyzingDeltas")); //$NON-NLS-1$
		IResourceDelta sourceDelta = (IResourceDelta) deltas.get(javaBuilder.currentProject);
		if (sourceDelta != null)
			if (!findSourceFiles(sourceDelta)) return false;
		notifier.updateProgressDelta(0.10f);

		Object[] keyTable = deltas.keyTable;
		Object[] valueTable = deltas.valueTable;
		for (int i = 0, l = keyTable.length; i < l; i++) {
			IResourceDelta delta = (IResourceDelta) valueTable[i];
			if (delta != null) {
				IResource[] binaryResources = (IResource[]) javaBuilder.binaryResources.get(keyTable[i]);
				if (binaryResources != null)
					if (!findAffectedSourceFiles(delta, binaryResources)) return false;
			}
		}
		notifier.updateProgressDelta(0.10f);

		notifier.subTask(Util.bind("build.analyzingSources")); //$NON-NLS-1$
		addAffectedSourceFiles();
		notifier.updateProgressDelta(0.05f);

		int compileLoop = 0;
		float increment = 0.40f;
		while (locations.size() > 0) { // added to in acceptResult
			if (++compileLoop > MaxCompileLoop) {
				if (JavaBuilder.DEBUG)
					System.out.println("ABORTING incremental build... exceeded loop count"); //$NON-NLS-1$
				return false;
			}
			notifier.checkCancel();

			String[] allSourceFiles = new String[locations.size()];
			locations.toArray(allSourceFiles);
			String[] initialTypeStrings = new String[typeNames.size()];
			typeNames.toArray(initialTypeStrings);
			resetCollections();

			workQueue.addAll(allSourceFiles);
			notifier.setProgressPerCompilationUnit(increment / allSourceFiles.length);
			increment = increment / 2;
			compile(allSourceFiles, initialTypeStrings);
			if (secondaryTypesToRemove != null) { // delayed deleting secondary types until the end of the compile loop
				for (int i = 0, length = secondaryTypesToRemove.size(); i < length; i++)
					removeClassFile((IPath) secondaryTypesToRemove.get(i));
				this.secondaryTypesToRemove = null;
				this.previousLocations = null; // cannot optimize recompile case when a secondary type is deleted
			}
			addAffectedSourceFiles();
		}
	} catch (AbortIncrementalBuildException e) {
		// abort the incremental build and let the batch builder handle the problem
		if (JavaBuilder.DEBUG)
			System.out.println("ABORTING incremental build... cannot find " + e.qualifiedTypeName + //$NON-NLS-1$
				". Could have been renamed inside its existing source file."); //$NON-NLS-1$
		return false;
	} catch (CoreException e) {
		throw internalException(e);
	} finally {
		cleanUp();
	}
	return true;
}

