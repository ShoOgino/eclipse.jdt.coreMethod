	/**
	 * Removes the given source element from the new state's tables
	 * and dependency graph.  Marks all JCUs that depend on the removed element. 
	 */
	protected void removeSourceElement(SourceEntry entry) {
		PackageElement element = fOldState.packageElementFromSourceEntry(entry);
		SourceEntry oldEntry = fOldState.getSourceEntry(element);
		if (oldEntry == null) {
			// It didn't exist in the old state (strange).
			return;
		}

		// delete problems for this entry
		// only delete non-syntax problems, since new syntax problems may have already
		// been generated during namespace computations
		fNewState.getProblemReporter().removeNonSyntaxErrors(oldEntry);

		/* remove type descriptor for types that belong to this source element */
		DependencyGraph graph = fNewState.getInternalDependencyGraph();
		Hashtable structureTable = fNewState.getPrincipalStructureTable();
		IType[] types = graph.getTypes(element);
		if (types != null) {
			for (int i = 0; i < types.length; ++i) {
				IType type = types[i];
				structureTable.remove(type);
				if (!element.isBinary()) {
					fNewState.getBinaryOutput().deleteBinary(type);
				}
			}
		}
		markDependentsAsNeedingCompile(element);
		graph.remove(element);

		// The element has already been removed from the source element table.
		// So don't do any source element table or fragment logic here.

		// Don't delete the namespace for the package here, because it cannot be rebuilt lazily
		// since the package may be in process of being removed.
	}

