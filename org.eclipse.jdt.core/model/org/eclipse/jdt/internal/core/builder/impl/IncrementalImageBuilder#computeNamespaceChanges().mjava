/**
 * Computes namespace changes for each added, removed and changed class file or JCU.
 * The appropriate namespace node is informed of the changes, and it
 * may invalidate its dependents where necessary.  JCUs that need compiling
 * as a result of invalidations are stored by the state.
 * Must process removed types here, even though in most cases there will already
 * be an explicit dependency on the removed type, because it is possible for others
 * to have a namespace dependency but not a type dependency (e.g. in the case of errors).
 */
protected void computeNamespaceChanges() {

	for (Enumeration e = fSourceDeltas.elements(); e.hasMoreElements();) {
		IResourceDelta delta = (IResourceDelta) e.nextElement();
		JavaModelManager.getJavaModelManager().closeAffectedElements(delta);
	}

	// Should really only process packages in image context here,
	// but in general other packages may depend on namespaces being added, 
	// not just those being removed and changed.  So for now, process everything.

	// The computations here must be based on the computed namespaces rather than
	// directly off of the namespace contributions of affected source elements
	// since the namespace computation may remove items due to conflicts.

	int numPackages = fAddedPackageHandles.size() + fRemovedPackageHandles.size() + fChangedPackageHandles.size();
	if (numPackages == 0) {
		fNotifier.updateProgressDelta(0.10f);
		return;
	}
	float progressDelta = 0.10f / numPackages;

	// Process changes in the set of package prefixes
	if (fAddedPackageHandles.size() > 0 || fRemovedPackageHandles.size() > 0) {
		computePackagePrefixChanges();
	}

	// Process added packages
	for (Enumeration addedPkgs = fAddedPackageHandles.elements(); addedPkgs.hasMoreElements();) {
		IPackage pkg = (IPackage) addedPkgs.nextElement();
		fNotifier.subTask(Util.bind("build.analyzing", PackageImpl.readableName(pkg))); //$NON-NLS-1$

		// Mark all dependents of missing namespace as needing compile.
		markDependentsAsNeedingCompile(pkg);

		// If any types currently exist with the same name as this package,
		// they must be recompiled
		markOverlappingTypesAsNeedingCompile(pkg);
		fNotifier.updateProgressDelta(progressDelta);
		fNotifier.checkCancel();
	}

	// Process removed packages
	for (Enumeration removedPkgs = fRemovedPackageHandles.elements(); removedPkgs.hasMoreElements();) {
		IPackage pkg = (IPackage) removedPkgs.nextElement();
		fNotifier.subTask(Util.bind("build.analyzing", PackageImpl.readableName(pkg))); //$NON-NLS-1$

		// Mark all dependents of namespace as needing compile.
		markDependentsAsNeedingCompile(pkg);

		// If any types currently exist with the same name as this package,
		// they must be recompiled
		markOverlappingTypesAsNeedingCompile(pkg);
		fNotifier.updateProgressDelta(progressDelta);
		fNotifier.checkCancel();
	}

	// Process changed packages
	for (Enumeration changedPkgs = fChangedPackageHandles.elements(); changedPkgs.hasMoreElements();) {
		IPackage pkg = (IPackage) changedPkgs.nextElement();
		fNotifier.subTask(Util.bind("build.analyzing", PackageImpl.readableName(pkg))); //$NON-NLS-1$
		computeNamespaceChanges(pkg);
		fNotifier.updateProgressDelta(progressDelta);
		fNotifier.checkCancel();
	}
}

