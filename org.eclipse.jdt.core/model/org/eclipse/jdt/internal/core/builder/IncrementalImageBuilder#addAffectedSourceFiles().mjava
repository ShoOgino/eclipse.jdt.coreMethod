protected void addAffectedSourceFiles() {
	if (qualifiedStrings.elementSize == 0 && simpleStrings.elementSize == 0) return;

	// the qualifiedStrings are of the form 'p1/p2' & the simpleStrings are just 'X'
	char[][][] qualifiedNames = ReferenceCollection.internQualifiedNames(qualifiedStrings);
	// if a well known qualified name was found then we can skip over these
	if (qualifiedNames.length < qualifiedStrings.elementSize)
		qualifiedNames = null;
	char[][] simpleNames = ReferenceCollection.internSimpleNames(simpleStrings);
	// if a well known name was found then we can skip over these
	if (simpleNames.length < simpleStrings.elementSize)
		simpleNames = null;

	Object[] keyTable = newState.references.keyTable;
	Object[] valueTable = newState.references.valueTable;
	next : for (int i = 0, l = valueTable.length; i < l; i++) {
		ReferenceCollection refs = (ReferenceCollection) valueTable[i];
		if (refs != null && refs.includes(qualifiedNames, simpleNames)) {
			String typeLocator = (String) keyTable[i];
			IFile file = javaBuilder.currentProject.getFile(typeLocator);
			if (file.exists()) {
				ClasspathMultiDirectory md = sourceLocations[0];
				if (sourceLocations.length > 1) {
					IPath sourceFileFullPath = file.getFullPath();
					for (int j = 0, m = sourceLocations.length; j < m; j++) {
						if (sourceLocations[j].sourceFolder.getFullPath().isPrefixOf(sourceFileFullPath)) {
							md = sourceLocations[j];
							if (md.exclusionPatterns == null || !Util.isExcluded(file, md.exclusionPatterns))
								break;
						}
					}
				}
				SourceFile sourceFile = new SourceFile(file, md);
				if (sourceFiles.contains(sourceFile)) continue next;
				if (compiledAllAtOnce && previousSourceFiles != null && previousSourceFiles.contains(sourceFile))
					continue next; // can skip previously compiled files since already saw hierarchy related problems

				if (JavaBuilder.DEBUG)
					System.out.println("  adding affected source file " + typeLocator); //$NON-NLS-1$
				sourceFiles.add(sourceFile);
			}
		}
	}
}

