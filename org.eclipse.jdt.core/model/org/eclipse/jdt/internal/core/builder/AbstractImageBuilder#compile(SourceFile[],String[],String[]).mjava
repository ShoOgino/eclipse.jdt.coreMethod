void compile(SourceFile[] units, String[] initialTypeNames, String[] additionalFilenames) {
	if (units.length == 0) return;
	notifier.aboutToCompile(units[0]); // just to change the message

	// extend additionalFilenames with all hierarchical problem types found during this entire build
	if (!problemTypeLocations.isEmpty()) {
		int toAdd = problemTypeLocations.size();
		int length = additionalFilenames == null ? 0 : additionalFilenames.length;
		if (length == 0)
			additionalFilenames = new String[toAdd];
		else
			System.arraycopy(additionalFilenames, 0, additionalFilenames = new String[length + toAdd], 0, length);
		for (int i = 0; i < toAdd; i++)
			additionalFilenames[length + i] = (String) problemTypeLocations.get(i);
	}
	nameEnvironment.setNames(initialTypeNames, additionalFilenames);
	notifier.checkCancel();
	try {
		inCompiler = true;
		compiler.compile(units);
	} finally {
		inCompiler = false;
	}
	// Check for cancel immediately after a compile, because the compiler may
	// have been cancelled but without propagating the correct exception
	notifier.checkCancel();
}

