	/**
	 * Reads a <code>limit-modules</code> attribute, and computes the transitive closure of requested modules. 
	 * @param javaProject the current java project
	 * @param entry the classpath entry to process
	 * @return a set of module names or <code>null</code> if the classpath attribute was not set.
	 * @see IClasspathAttribute#LIMIT_MODULES
	 */
	static Set<String> computeLimitModules(JavaProject javaProject, ClasspathEntry entry) {
		String extraAttribute = ClasspathEntry.getExtraAttribute(entry, IClasspathAttribute.LIMIT_MODULES);
		if (extraAttribute == null)
			return null;
		
		// collect all modules of this CP entry:
		Map<String, IModule> modules = new HashMap<>();
		for (IPackageFragmentRoot root : javaProject.findPackageFragmentRoots(entry)) {
			if (root instanceof JrtPackageFragmentRoot) {
				IModule module = ((JrtPackageFragmentRoot) root).getModule();
				if (module != null)
					modules.put(String.valueOf(module.name()), module);
			}
		}

		// collect the transitive closure of modules contained in limitSet
		Set<String> limitSet = new HashSet<>(Arrays.asList(extraAttribute.split(","))); //$NON-NLS-1$
		Set<String> result = new HashSet<>(limitSet);
		for (Map.Entry<String, IModule> moduleEntry: modules.entrySet()) {
			if (limitSet.contains(moduleEntry.getKey()))
				addTransitive(moduleEntry.getValue(), modules, result);
		}
		return result;
	}

