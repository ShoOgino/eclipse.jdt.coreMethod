	/**
	 * Returns a copy of this node, but with the dependents and dependencies
	 * left unchanged.  They are later replaced using replaceDeps().
	 * Be careful that this implementation applies to any information in subclasses.
	 * Right now, all information except the dependents are non-state-specific
	 * and can be shared.
	 */
	INode copyWithoutReplacingDeps() {
		AbstractNode newNode = this.copy();

		/* copy dependencies into new array */
		int depCount = fDependencies.length;
		newNode.fDependencies = new INode[depCount];
		for (int i = depCount; --i >= 0;) {
			newNode.fDependencies[i] = fDependencies[i];
		}

		newNode.fNumDependents = fNumDependents;
		newNode.fDependents = new INode[fNumDependents];
		newNode.fOrder = fOrder;
		return newNode;
	}

