/**
 * Compile the given elements, adding more elements to the work queue 
 * if they are affected by the changes.
 */
protected void compile(Vector vToCompile) {
	int i = 0;
	Vector vToCompileAtOnce = new Vector(Math.min(vToCompile.size(), MAX_AT_ONCE));
	while (i < vToCompile.size()) {
		vToCompileAtOnce.removeAllElements();
		while (i < vToCompile.size() && vToCompileAtOnce.size() < MAX_AT_ONCE) {
			PackageElement unit = (PackageElement) vToCompile.elementAt(i);
			// Although it needed compiling when this method was called,
			// it may have already been compiled due to being brought in
			// by another unit.
			if (fWorkQueue.needsCompile(unit)) {
				SourceEntry sEntry = fNewState.getSourceEntry(unit);
				CompilerCompilationUnit compUnit = new CompilerCompilationUnit(fNewState, sEntry, fNotifier);
				compiling(compUnit);
				vToCompileAtOnce.addElement(compUnit);
				checkCancel();
			}
			++i;
		}
		if (vToCompileAtOnce.size() > 0) {
			CompilerCompilationUnit[] toCompile = new CompilerCompilationUnit[vToCompileAtOnce.size()];
			vToCompileAtOnce.copyInto(toCompile);
			try {
				fDC.inCompiler = true;
				getCompiler().compile(toCompile);
			} finally {
				fDC.inCompiler = false;
			}

			/* Check for cancel immediately after a compile, because the compile may have been
			 * canceled but without propagating the build canceled exception. */
			checkCancel();

			/* store results in new state and get new units to compile */
			ConvertedCompilationResult[] results = getCompilationResults();
			updateState(results);
			checkCancel();
		}
	}
}

