/**
 * If this type is a subtype is the originator of an abstract method
 * indictment, it must be compiled
 */
protected boolean tryAbstractMethodIndictments(PackageElement unit, IndictmentSet indictments) {
	final boolean GUILTY = true, INNOCENT = false;	
	IType[] trialTypes = indictments.getAbstractMethodOriginators();
	if (trialTypes.length == 0) {
		return false;
	}
	/* if problems were detected, some innerclasses might not have been generated,
		thus the state would not reflect their presence, and even if guilty could not
		be convicted (also see 1GA6CV7) */
	Vector problemVector = fOldState.getProblemReporter().getProblemVector(fOldState.getSourceEntry(unit));
	if (problemVector != null){
		Enumeration problems = problemVector.elements();
		while (problems.hasMoreElements()){
			IProblemDetail problem = (IProblemDetail) problems.nextElement();
			if ((problem.getSeverity() & IProblemDetail.S_ERROR) != 0) return GUILTY;
		}
	}	
	
	/* do for each type in this package element */
	IType[] types = fOldState.getInternalDependencyGraph().getTypes(unit);
	for (int i = 0, imax = types.length; i < imax; i++) {
		IType type = types[i];
		TypeStructureEntry tsEntry = fOldState.getTypeStructureEntry(type, false);

		/* shouldn't happen, but trust nobody! */
		if (tsEntry == null) {
			continue;
		}
		IType oldType = (IType) type.inState(fOldState);
		int flags = oldType.getModifiers();

		/* interfaces aren't affected by method additions/removals in super interfaces,
		   other than for compatibility checking, which is handled elsewhere */
		if (oldType.isInterface()) {
			continue;
		}

		/* only check superclasses if this class is not abstract, */
		/* because abstract classes aren't affected by abstract method additions/removals */
		/* on their superclasses, only on their superinterfaces */
		boolean checkSuperclasses = (flags & IConstants.AccAbstract) == 0;

		/* do for each abstract method originator */
		BuilderType builderType = getBuilderType(type);
		for (int j = 0, jmax = trialTypes.length; j < jmax; ++j) {
			IType trialType = trialTypes[j];
			if (checkSuperclasses) {
				if (builderType.hasSuperclass(trialType)) {
					return GUILTY;
				}
			}
			if (builderType.hasSuperInterface(trialType)) {
				return GUILTY;
			}
		}
	}

	/* no supertypes convicted this package element, so it must be innocent */
	return INNOCENT;
}

