	/**
	 * Creates state tables that are dependent only on the workspace, and not
	 * on build results.  This includes the package map, source element table,
	 * and the namespace table.
	 */
	protected void buildInitialPackageMap() {
		fPackageMap = new PackageMap();

		/* do for each package fragment root in (classpath INTERSECT workspace) */
		try {
			IPackageFragmentRoot[] roots = getPackageFragmentRootsInClassPath();
			IPath outputLocation = getJavaProject().getOutputLocation();
			for (int i = 0; i < roots.length; ++i) {
				IPackageFragmentRoot root = roots[i];
				if (root.exists()) {
					((PackageFragmentRoot) root).refreshChildren();
					IJavaElement[] frags = root.getChildren();
					for (int j = 0; j < frags.length; ++j) {
						IPackageFragment frag = (IPackageFragment) frags[j];
						if (frag.exists()) {
							String pkgName = frag.getElementName();
							IPackage pkg =
								pkgName.length() == 0
									? defaultPackageForProject()
									: fDevelopmentContext.getImage().getPackageHandle(pkgName, false);
							IPath path =
								root.isArchive() ? root.getPath() : frag.getUnderlyingResource().getFullPath();
							fPackageMap.putFragment(pkg, path);
						}
					}
				}
			}
		} catch (JavaModelException e) {
			throw internalException(e);
		}

		/* build the reverse index -- the path map */
		fPathMap = new PathMap(fPackageMap);
	}

