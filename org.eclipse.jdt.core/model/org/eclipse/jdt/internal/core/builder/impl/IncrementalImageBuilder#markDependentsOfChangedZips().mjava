/**
 * All elements that refer to changed zips, or packages
 * referred to by changed zips, must be recompiled.
 * This is conservative, but since the old zip structure
 * is not available, we can't do much better.
 */
protected void markDependentsOfChangedZips() {

	PathMap oldPathMap = fOldState.getPathMap();
	PathMap newPathMap = fNewState.getPathMap();
	
	/* do for each changed zip */
	for (Enumeration e = fChangedZips.elements(); e.hasMoreElements();) {
		IPath zip = (IPath) e.nextElement();

		/* mark dependents of packages in old zip */
		IPackage[] pkgs = oldPathMap.packageHandlesFromPath(zip);
		for (int i = 0; i < pkgs.length; i++) {
			markDependentsAsNeedingCompile(pkgs[i]);
		}

		/* mark dependents of packages in new zip */
		pkgs = newPathMap.packageHandlesFromPath(zip);
		for (int i = 0; i < pkgs.length; i++) {
			markDependentsAsNeedingCompile(pkgs[i]);
		}

		/* mark dependents of the zip itself */
		markDependentsAsNeedingCompile(zip);
	}

	/* also handle zips which were removed from class path */
	IPath[] paths = oldPathMap.getPaths();
	for (int i = 0; i < paths.length; ++i) {
		IPath zip = paths[i];
		if (fOldState.isZipElement(zip) && !newPathMap.hasPath(zip)) {

			/* mark dependents of packages in old zip */
			IPackage[] pkgs = oldPathMap.packageHandlesFromPath(zip);
			for (int j = 0; j < pkgs.length; j++) {
				markDependentsAsNeedingCompile(pkgs[j]);
			}
				
			/* mark dependents of the zip itself */
			markDependentsAsNeedingCompile(zip);
		}
	}
}

