	/**
	 * Stores the result of a compilation in the state tables
	 */
	protected void putCompilationResult(ConvertedCompilationResult result) {
		PackageElement unit= result.getPackageElement();

		/* get source entry for result */
		SourceEntry sEntry= getSourceEntry(unit);

		/* record problems */
		fProblemReporter.removeNonSyntaxErrors(sEntry);
		IProblemDetail[] problems= result.getProblems();
		for (int i= 0; i < problems.length; ++i) {
			fProblemReporter.putProblem(sEntry, problems[i]);
		}

		/* This records the types actually contributed, */
		/* to record in the dependency graph. */
		TypeStructureEntry[] tsEntries= result.getTypes();
		IType[] types= new IType[tsEntries.length];
		int count= 0;

		/* record type structure */
		for (int i= 0; i < tsEntries.length; i++) {
			TypeStructureEntry tsEntry= tsEntries[i];
			IType typeHandle= tsEntry.getType();
			// Sanity check before putting in table
			TypeStructureEntry tsExisting= (TypeStructureEntry) fPrincipalStructureTable.get(typeHandle);
			if (tsExisting != null) {
				if (!tsExisting.getSourceEntry().getFileName().equals(sEntry.getFileName())) {
					// Same type provided by different files
					String msg= Util.bind("build.duplicateType"/*nonNLS*/, typeHandle.getName(), tsExisting.getSourceEntry().getFileName());
					ProblemDetailImpl problem= new ProblemDetailImpl(msg, sEntry);
					fProblemReporter.putProblem(sEntry, problem);
					// skip it
					continue;
				}
			}

			// Finally, put it in table.
			fPrincipalStructureTable.put(typeHandle, tsEntry);
			types[count++]= typeHandle;
		}

		/* Update the dependency graph. */
		if (count < types.length) {
			System.arraycopy(types, 0, types= new IType[count], 0, count);
		}
		fGraph.add(unit, types, result.getDependencies());
	}

