void combineIntoModuleEntry(ClasspathLocation sourceLocation, IModule patchedModule, Map<String, IModulePathEntry> moduleEntries) {
	sourceLocation.setModule(patchedModule);
	String patchedModuleName = String.valueOf(patchedModule.name());
	IModulePathEntry mainEntry = moduleEntries.get(patchedModuleName);
	ClasspathLocation[] combinedLocations = null;
	if (mainEntry instanceof ModulePathEntry.Multi) {
		((ModulePathEntry.Multi) mainEntry).addPatchLocation(sourceLocation);
		return;
	} else if (mainEntry instanceof ClasspathJrt) {
		combinedLocations = new ClasspathLocation[] { (ClasspathLocation) mainEntry, sourceLocation };
		moduleEntries.put(patchedModuleName, new ModulePathEntry.Multi(null, patchedModule, combinedLocations));
		return;
	} else if (mainEntry instanceof ModulePathEntry) {
		ClasspathLocation[] mainLocs = ((ModulePathEntry) mainEntry).locations;
		combinedLocations = Arrays.copyOf(mainLocs, mainLocs.length+1);
		combinedLocations[combinedLocations.length-1] = sourceLocation;
	} else if (mainEntry instanceof ClasspathLocation) {
		combinedLocations = new ClasspathLocation[] { (ClasspathLocation) mainEntry, sourceLocation };
	} else {
		throw new IllegalStateException("Cannot patch the module of classpath entry "+mainEntry); //$NON-NLS-1$
	}
	moduleEntries.put(patchedModuleName, new ModulePathEntry(null, patchedModule, combinedLocations));
}

