	/**
	 * Stores the results of a compilation in the appropriate state tables.
	 * Keeps track of what compilation units need to be compiled as a result
	 * of the changes.
	 */
	protected void updateState(ConvertedCompilationResult[] results) {
		int n = results.length;
		PackageElement[] oldUnits = new PackageElement[n];
		PackageElement[] newUnits = new PackageElement[n];
		IType[][] oldTypeList = new IType[n][];

		// Preparation
		DependencyGraph oldGraph = fOldState.getInternalDependencyGraph();
		DependencyGraph newGraph = fNewState.getInternalDependencyGraph();

		for (int i = 0; i < n; i++) {
			PackageElement element = results[i].getPackageElement();

			// Be sure the package is in the set of affected packages.
			// It may not be if this unit was recompiled in a package
			// other than the ones which have direct changes.
			IPackage pkg = element.getPackage();
			fAffectedPackages.put(pkg, pkg);

			// Be sure to look up the source entries in the old and new state,
			// since they may be different.
			SourceEntry oldSourceEntry = fOldState.getSourceEntry(element);
			oldUnits[i] =
				(oldSourceEntry == null
					? null
					: fOldState.packageElementFromSourceEntry(oldSourceEntry));
			SourceEntry newSourceEntry = fNewState.getSourceEntry(element);
			newUnits[i] = fNewState.packageElementFromSourceEntry(newSourceEntry);
			if (oldUnits[i] != null) {
				oldTypeList[i] = oldGraph.getTypes(oldUnits[i]);
			}
		}

		// Remove old problems and principal structure from new state before
		// storing new results.
		for (int i = 0; i < n; i++) {
			if (oldUnits[i] != null) {
				SourceEntry sEntry = fOldState.getSourceEntry(oldUnits[i]);
				fNewState.getProblemReporter().removeNonSyntaxErrors(sEntry);
			}
			if (oldTypeList[i] != null) {
				IType[] oldTypes = oldTypeList[i];
				for (int j = 0; j < oldTypes.length; ++j) {
					fNewState.getPrincipalStructureTable().remove(oldTypes[j]);
				}
			}
		}

		super.updateState(results);

		// now calculate the changes
		for (int i = 0; i < n; i++) {
			PackageElement unit = newUnits[i];
			if (unit == null) {
				// Unit isn't visible. Shouldn't have gotten this far.  Skip it.
				continue;
			}

			/**
			 * Assumption: namespace changes have been dealt with before
			 * compilation.  Compilation units that were removed have already generated
			 * type collaborator indictments.  Here, we are only concerned
			 * with changes within each compilation unit.
			 */

			TypeStructureEntry[] newTSEntries = results[i].getTypes();
			IndictmentSet indictments = new IndictmentSet();

			/* do for each type generated by unit in old state */
			IType[] oldTypes = oldTypeList[i];
			if (oldTypes != null) {
				for (int j = 0; j < oldTypes.length; ++j) {
					IType oldType = oldTypes[j];
					boolean found = false;
					for (int k = 0; k < newTSEntries.length; ++k) {
						if (newTSEntries[k] != null && newTSEntries[k].getType().equals(oldType)) {
							found = true;
							break;
						}
					}
					if (!found) {
						getBuilderType(oldType).computeIndictments(indictments);
					}
				}
			}

			/* do for each type in result */
			for (int j = 0; j < newTSEntries.length; j++) {
				TypeStructureEntry newTSEntry = newTSEntries[j];
				if (newTSEntry != null) {
					/* compute the indictments for this type */
					IType type = newTSEntry.getType();
					BuilderType bType = getBuilderType(type);

					/* the new tsEntry wasn't known at compilation time */
					if (bType.getNewTypeStructureEntry() == null) {
						bType.setNewTypeStructureEntry(newTSEntry);
					}
					bType.computeIndictments(indictments);
				}
			}
			if (!indictments.isEmpty()) {
				issueIndictments(unit, indictments, false);
			}
		}
	}

