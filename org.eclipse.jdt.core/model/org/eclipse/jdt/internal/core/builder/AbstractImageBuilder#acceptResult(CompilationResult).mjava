public void acceptResult(CompilationResult result) {
	// In Batch mode, we write out the class files, hold onto the dependency info
	// & additional types and report problems.

	// In Incremental mode, when writing out a class file we need to compare it
	// against the previous file, remembering if structural changes occured.
	// Before reporting the new problems, we need to update the problem count &
	// remove the old problems. Plus delete additional class files that no longer exist.

	SourceFile compilationUnit = (SourceFile) result.getCompilationUnit(); // go directly back to the sourceFile
	if (!workQueue.isCompiled(compilationUnit)) {
		try {
			workQueue.finished(compilationUnit);
			updateProblemsFor(compilationUnit, result); // record compilation problems before potentially adding duplicate errors
			updateTasksFor(compilationUnit, result); // record tasks

			String typeLocator = compilationUnit.typeLocator();
			ClassFile[] classFiles = result.getClassFiles();
			int length = classFiles.length;
			ArrayList duplicateTypeNames = null;
			ArrayList definedTypeNames = new ArrayList(length);
			for (int i = 0; i < length; i++) {
				ClassFile classFile = classFiles[i];
				char[][] compoundName = classFile.getCompoundName();
				char[] typeName = compoundName[compoundName.length - 1];
				boolean isNestedType = CharOperation.contains('$', typeName);

				// Look for a possible collision, if one exists, report an error but do not write the class file
				if (isNestedType) {
					String qualifiedTypeName = new String(classFile.outerMostEnclosingClassFile().fileName());
					if (newState.isDuplicateLocator(qualifiedTypeName, typeLocator))
						continue;
				} else {
					String qualifiedTypeName = new String(classFile.fileName()); // the qualified type name "p1/p2/A"
					if (newState.isDuplicateLocator(qualifiedTypeName, typeLocator)) {
						if (duplicateTypeNames == null)
							duplicateTypeNames = new ArrayList();
						duplicateTypeNames.add(compoundName);
						createProblemFor(compilationUnit.resource, Util.bind("build.duplicateClassFile", new String(typeName)), JavaCore.ERROR); //$NON-NLS-1$
						continue;
					}
					newState.recordLocatorForType(qualifiedTypeName, typeLocator);
				}
				definedTypeNames.add(writeClassFile(classFile, compilationUnit.sourceLocation.binaryFolder, !isNestedType));
			}

			finishedWith(typeLocator, result, compilationUnit.getMainTypeName(), definedTypeNames, duplicateTypeNames);
			notifier.compiled(compilationUnit);
		} catch (CoreException e) {
			Util.log(e, "JavaBuilder handling CoreException"); //$NON-NLS-1$
			createProblemFor(compilationUnit.resource, Util.bind("build.inconsistentClassFile"), JavaCore.ERROR); //$NON-NLS-1$
		}
	}
}

