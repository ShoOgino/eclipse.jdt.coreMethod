public void acceptResult(CompilationResult result) {
	// In Batch mode, we write out the class files, hold onto the dependency info
	// & additional types and report problems.

	// In Incremental mode, when writing out a class file we need to compare it
	// against the previous file, remembering if structural changes occured.
	// Before reporting the new problems, we need to update the problem count &
	// remove the old problems. Plus delete additional class files that no longer exist.

	// only need to find resource for the sourceLocation when problems need to be reported against it
	String sourceLocation = new String(result.getFileName()); // the full filesystem path "d:/xyz/eclipse/src1/Test/p1/p2/A.java"
	if (!workQueue.isCompiled(sourceLocation)) {
		try {
			workQueue.finished(sourceLocation);
			updateProblemsFor(sourceLocation, result); // record compilation problems before potentially adding duplicate errors

			ICompilationUnit compilationUnit = result.getCompilationUnit();
			ClassFile[] classFiles = result.getClassFiles();
			int length = classFiles.length;
			ArrayList duplicateTypeNames = null;
			ArrayList definedTypeNames = new ArrayList(length);
			for (int i = 0; i < length; i++) {
				ClassFile classFile = classFiles[i];
				char[][] compoundName = classFile.getCompoundName();
				char[] typeName = compoundName[compoundName.length - 1];
				boolean isNestedType = CharOperation.contains('$', typeName);

				// Look for a possible collision, if one exists, report an error but do not write the class file
				if (isNestedType) {
					String qualifiedTypeName = new String(classFile.outerMostEnclosingClassFile().fileName());
					if (newState.isDuplicateLocation(qualifiedTypeName, sourceLocation))
						continue;
				} else {
					String qualifiedTypeName = new String(classFile.fileName()); // the qualified type name "p1/p2/A"
					if (newState.isDuplicateLocation(qualifiedTypeName, sourceLocation)) {
						if (duplicateTypeNames == null)
							duplicateTypeNames = new ArrayList();
						duplicateTypeNames.add(compoundName);
						createErrorFor(resourceForLocation(sourceLocation), Util.bind("build.duplicateClassFile", new String(typeName))); //$NON-NLS-1$
						continue;
					}
					newState.recordLocationForType(qualifiedTypeName, sourceLocation);
				}
				definedTypeNames.add(writeClassFile(classFile, !isNestedType));
			}

			finishedWith(sourceLocation, result, compilationUnit.getMainTypeName(), definedTypeNames, duplicateTypeNames);
			notifier.compiled(compilationUnit);
		} catch (CoreException e) {
			Util.log(e, "JavaBuilder handling CoreException"); //$NON-NLS-1$
			createErrorFor(resourceForLocation(sourceLocation), Util.bind("build.inconsistentClassFile")); //$NON-NLS-1$
		}
	}
}

