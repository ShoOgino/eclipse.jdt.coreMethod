/**
 * Returns an <code>ISearch</code> that will look for methods or constructors 
 * with matching name, parameter types, and return type.  
 * <p>
 * When searching for a constructor, the return type is ignored.
 * <p>
 * <b>Example:</b> Search for declarations of methods named <code>toString</code>
 * whose second argument is <code>int</code>. The search will be conducted 
 * in the scope of the <code>hanoiExample</code> package.
 *  <code><pre>
 * IImage image = dc.getImage();
 * ISearchFactory factory = image.newSearchFactory();
 * IHandle[] scope = {image.getPackageHandle("hanoiExample")};
 * ISearch search = 
 *  factory.searchForMethod(
 *      "toString", 
 *      new String[] {"*", "int"}, 
 *      "*",
 *      scope, 
 *      SEARCH_FOR_DECLS);
 * search.run();
 *  </code></pre>
 * <br>
 * @param methodName the method name to search for, possibly containing wildcards ("*")
 * @param paramTypes the names of parameter types the method being searched for must 
 *      have, possibly containing wildcards. An empty array indicates a method with 
 *      zero parameters.
 * @param returnType the name of the return type the method being 
 *      searched for must have, possibly containing wildcards. A return type 
 *      of "*" effectively ignores the return type.
 * @param scope the packages and types to search in
 * @param context the context flags. SEARCH_FOR_DECLS make sense as a flag for 
 *      this method search. Using SEARCH_FOR_PRINCIPLE_STRUCTURE_REFS will have no effect since methods
 *      cannot be referenced in the principle structure. When searching the source,
 *      SEARCH_FOR_SOURCE_REFS will ignore the return type, and only use the 
 *      number of parameters, not the parameter types.  This is because at the source 
 *      level only the method name and number of parameters are 
 * known.
 * @see ISearch
 */
ISearch searchForMethod(
		String methodName,
		String[] paramTypes,
		String returnType,
		IHandle[] scope,
		int context);

