/** Returns the patched module if that is served by the current (binary) location. */
IModule collectModuleEntries(ClasspathLocation bLocation, IPath path, boolean isOnModulePath, Set<String> limitModules,
								String patchedModuleName, IModule patchedModule, Map<String, IModulePathEntry> moduleEntries) {
	if (bLocation instanceof IMultiModuleEntry) {
		IMultiModuleEntry binaryModulePathEntry = (IMultiModuleEntry) bLocation;
		for (String moduleName : binaryModulePathEntry.getModuleNames(limitModules)) {
			moduleEntries.put(moduleName, binaryModulePathEntry);
		}
		if (patchedModuleName != null) {
			IModule module = binaryModulePathEntry.getModule(patchedModuleName.toCharArray());
			if (module != null)
				return module;
			// TODO(SHMOD): report problem: patchedModuleName didn't match a module from this location
		}
	} else if (isOnModulePath) {
		IModulePathEntry binaryModulePathEntry = new ModulePathEntry(path, bLocation);
		IModule module = binaryModulePathEntry.getModule();
		if (module != null) {
			String moduleName = String.valueOf(module.name());
			if (limitModules == null || limitModules.contains(moduleName)) {
				moduleEntries.put(moduleName, binaryModulePathEntry);
				if (patchedModuleName != null) {
					if (moduleName.equals(patchedModuleName))
						return module;
					// TODO(SHMOD): report problem: patchedModuleName didn't match a module from this location
				}
			}
		}
	}
	return patchedModule;
}

