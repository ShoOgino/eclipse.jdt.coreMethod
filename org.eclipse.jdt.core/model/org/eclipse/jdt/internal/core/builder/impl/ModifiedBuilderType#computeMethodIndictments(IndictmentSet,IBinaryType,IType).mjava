/**
 * Computes the method indictments for this type
 */
public void computeMethodIndictments(IndictmentSet indictments, IBinaryType newType, IType typeHandle) {

	boolean issueAbstractMethodIndictment = false;
	if ((fOldStructure.getModifiers() & IConstants.AccAbstract) != 
		(newType.getModifiers() & IConstants.AccAbstract)) {
		issueAbstractMethodIndictment = true;
	}

	/* create a set of all old methods */
	HashtableOfObject oldMethodsTable = new HashtableOfObject(21);
	IBinaryMethod[] oldMethods = fOldStructure.getMethods();
	if (oldMethods != null) {
		for (int i = 0; i < oldMethods.length; i++) {
			IBinaryMethod oldMethod = oldMethods[i];
			char[] sig = CharOperation.concat(oldMethod.getSelector(), oldMethod.getMethodDescriptor());
			oldMethodsTable.put(sig, oldMethod);
		}
	}

	/* check if each new method was in old method list */
	IBinaryMethod[] newMethods = newType.getMethods();
	if (newMethods != null) {
		for (int i = 0; i < newMethods.length; i++) {
			IBinaryMethod newMethod = (IBinaryMethod) newMethods[i];
			char[] sig = CharOperation.concat(newMethod.getSelector(), newMethod.getMethodDescriptor());
			IBinaryMethod oldMethod = (IBinaryMethod) oldMethodsTable.get(sig);
			if (oldMethod == null) {
				/* it's a new method -- issue an indictment */
				indictments.add(Indictment.createMethodIndictment(typeHandle, newType, newMethod));

				/* if the new method is abstract, issue an abstract method indictment too */
				if ((newMethod.getModifiers() & IConstants.AccAbstract) != 0) {
					issueAbstractMethodIndictment = true;
				}
			} else {
				/* if it has it changed, issue an indictment */
				oldMethodsTable.put(sig, null); // TBD: there is no remove on HashtableOfObject
				if (!BinaryStructure.compare(oldMethod, newMethod)) {
					indictments.add(Indictment.createMethodIndictment(typeHandle, fOldStructure, oldMethod));
				}
				/* if an existing method changes its abstract state, issue an abstract method indictment too */
				if ((oldMethod.getModifiers() & IConstants.AccAbstract) != (newMethod.getModifiers() & IConstants.AccAbstract)) {
					issueAbstractMethodIndictment = true;
				}
			}
		}
	}

	/* remaining old methods have been deleted -- issue indictments */
	Object[] remaining = oldMethodsTable.valueTable;
	for (int i = remaining.length; i-- > 0;) {
		if (remaining[i] != null) {
			IBinaryMethod oldMethod = (IBinaryMethod) remaining[i];
			indictments.add(Indictment.createMethodIndictment(typeHandle, fOldStructure, oldMethod));

			/* if old method is abstract, issue an abstract method indictment too */
			if ((oldMethod.getModifiers() & IConstants.AccAbstract) != 0) {
				issueAbstractMethodIndictment = true;
			}
		}
	}

	/* issue abstract method indictment now, if need be */
	if (issueAbstractMethodIndictment) {
		indictments.add(Indictment.createAbstractMethodIndictment(typeHandle));
	}
}

