	/**
	 * Returns true if there is a change to the supertype hierarchy of this type.
	 * Needs to check the whole hierarchy because changes from higher up are -not- 
	 * automatically propagated through the dependency graph.
	 */
	protected boolean detectHierarchyChange() {
		/* If we've already done the work, return the result */
		if (fComputedHierarchy) {
			return fHasHierarchyChange;
		}
		fComputedHierarchy = true;
		if (getNewTypeStructureEntry() == null) {
			return fHasHierarchyChange = true;
		}
		IBinaryType oldType = getOldBinaryType();
		if (oldType == null) {
			return fHasHierarchyChange = true;
		}
		IBinaryType newType = getNewBinaryType();

		/* check superclasses */
		char[] oldSuper = oldType.getSuperclassName();
		char[] newSuper = newType.getSuperclassName();
		if (oldSuper == null ^ newSuper == null) {
			return fHasHierarchyChange = true;
		}
		if (oldSuper != null && newSuper != null) {
			if (!CharOperation.equals(oldSuper, newSuper)) {
				return fHasHierarchyChange = true;
			}

			/* recurse on superclass */
			BuilderType superBuilderType =
				fBuilder.getBuilderType(
					BinaryStructure.getType(getNewState(), getNewTypeStructureEntry(), oldSuper));
			if (superBuilderType.detectHierarchyChange()) {
				return fHasHierarchyChange = true;
			}
		}

		/* check interfaces */
		char[][] oldInterfaces = oldType.getInterfaceNames();
		char[][] newInterfaces = newType.getInterfaceNames();
		if (!CharOperation.equals(oldInterfaces, newInterfaces)) {
			return fHasHierarchyChange = true;
		}

		/* recurse on interfaces */
		if (oldInterfaces != null) {
			for (int i = 0; i < oldInterfaces.length; i++) {
				BuilderType superBuilderType =
					fBuilder.getBuilderType(
						BinaryStructure.getType(
							getNewState(),
							getNewTypeStructureEntry(),
							oldInterfaces[i]));
				if (superBuilderType.detectHierarchyChange()) {
					return fHasHierarchyChange = true;
				}
			}
		}
		return fHasHierarchyChange = false;
	}

