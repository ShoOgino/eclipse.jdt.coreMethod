	/** 
	 * Write the dependency graph.
	 */
	protected void writeDependencyGraph(
		StateImpl state,
		StateSnapConstantPool pool,
		DataOutputStream out)
		throws IOException {
		out.writeUTF("DependencyGraph");
		DependencyGraph graph = state.getInternalDependencyGraph();
		graph.integrityCheck();
		/**
		 * We only care about serializing JCU nodes, since they
		 * are the only nodes with dependency information.  All
		 * other nodes will be serialized indirectly as dependencies
		 * of JCU nodes.
		 * Do we care about Type/Zip/Namespace nodes that have no dependents???
		 */
		for (Enumeration e = graph.getJCUNodes(); e.hasMoreElements();) {
			JCUNode jcu = (JCUNode) e.nextElement();
			out.writeBoolean(true);
			SourceEntry sEntry = state.getSourceEntry(jcu.getPackageElement());
			if (sEntry == null) {
				System.out.println(
					"Warning: StatSnap: Attempt to serialize dependency graph node for missing JCU: "
						+ jcu.getPackageElement()
						+ ". Skipping...");
			} else {
				Assert.isNotNull(sEntry);
				out.writeInt(pool.index(sEntry));
				IType[] types = jcu.getTypes();
				Assert.isTrue(types.length < 256);
				out.writeByte(types.length);
				for (int i = 0; i < types.length; ++i) {
					out.writeInt(pool.index(types[i]));
				}

				// Write dependencies
				INode[] dependencies = jcu.getDependencies();
				int numDep = dependencies.length;
				Assert.isTrue(numDep < 65536);
				out.writeShort(numDep);
				for (int i = 0; i < numDep; ++i) {
					INode dep = dependencies[i];
					switch (dep.getKind()) {
						case INode.JCU_NODE :
							{
								PackageElement element = ((JCUNode) dep).getPackageElement();
								SourceEntry depEntry = state.getSourceEntry(element);
								out.writeInt(pool.index(depEntry));
								break;
							}
						case INode.TYPE_NODE :
							{
								PackageElement element = ((TypeNode) dep).getPackageElement();
								SourceEntry depEntry = state.getSourceEntry(element);
								out.writeInt(pool.index(depEntry));
								break;
							}
						case INode.NAMESPACE_NODE :
							{
								IPackage pkg = ((NamespaceNode) dep).getPackage();
								out.writeInt(pool.index(pkg));
								break;
							}
						case INode.ZIP_NODE :
							{
								IPath path = ((ZipNode) dep).getZipFile();
								out.writeInt(pool.index(path));
								break;
							}
						default :
							badFormat();
					}
				}
			}
		}
		out.writeBoolean(false);
		writeEmptyAttributes(out);
	}

