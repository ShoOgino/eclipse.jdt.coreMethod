/**
 * Computes the added, removed, changed classes for this incremental build.
 * Vectors contain SourceEntry objects for each source element being added, 
 * removed, or changed.
 *
 * Takes into account package fragments, and only yields elements which are visible
 *
 * It's important to do this computation using the computed namespaces rather than
 * directly from the source element tables, since types may be removed during namespace
 * computation.
 */
protected void computeAllClasses() {
	fAddedClasses = new Vector();
	fRemovedClasses = new Vector();
	fChangedClasses = new Vector();
	fChangedZips = new Vector(1);

	/* do for each added builder package */
	for (Enumeration e = fAddedPackageHandles.elements(); e.hasMoreElements();) {
		IPackage pkg = (IPackage) e.nextElement();
		SourceEntry[] entries = fNewState.getSourceEntries(pkg);
		if (entries != null) {
			for (int i = 0; i < entries.length; ++i) {
				fAddedClasses.addElement(entries[i]);
			}
		}
	}

	/* do for each removed builder package */
	for (Enumeration e = fRemovedPackageHandles.elements(); e.hasMoreElements();) {
		IPackage pkg = (IPackage) e.nextElement();
		// Don't force the package's table.
		// If the package's table was not forced in the old state,
		// there should be no work to do for its classes.
		if (fOldState.getSourceElementTable().containsPackage(pkg)) {
			SourceEntry[] entries = fOldState.getSourceEntries(pkg);
			if (entries != null) {
				for (int i = 0; i < entries.length; ++i) {
					fRemovedClasses.addElement(entries[i]);
				}
			}
		}
	}

	/* build table of changed package elements, keyed by package */
	Hashtable changeTable = new Hashtable(fChangedPkgOrZips.size() * 2 + 1);
	for (Enumeration e = fChangedPkgOrZips.elements(); e.hasMoreElements();) {
		IResourceDelta changedPkgOrZip = (IResourceDelta) e.nextElement();
		IPath path = changedPkgOrZip.getFullPath();

		// ask the state if it is a ZIP file only if it is present in this state
		if (fNewState.isZipElement(path)) {
			/**
			 * Don't do any finer grained change calculation,
			 * all dependents of the zip and its namespaces
			 * will be recompiled
			 */
			fChangedZips.addElement(path);
		} else {
			addChangedFileNamesFromChangedPackage(changedPkgOrZip, changeTable);
		}
	}

	/* do for each changed builder package */
	for (Enumeration e = fChangedPackageHandles.elements(); e.hasMoreElements();) {
		IPackage pkg = (IPackage) e.nextElement();
		Hashtable changesForPkg = (Hashtable) changeTable.get(pkg);
		Hashtable fileNames = new Hashtable();
		SourceEntry[] oldEntries = fOldState.getSourceEntries(pkg);
		if (oldEntries != null) {
			for (int i = 0; i < oldEntries.length; ++i) {
				SourceEntry oldEntry = oldEntries[i];
				fileNames.put(oldEntry.getFileName(), oldEntry);
			}
		}
		SourceEntry[] newEntries = fNewState.getSourceEntries(pkg);
		if (newEntries != null) {
			for (int i = 0; i < newEntries.length; ++i) {
				SourceEntry newEntry = newEntries[i];
				String fileName = newEntry.getFileName();
				SourceEntry oldEntry = (SourceEntry) fileNames.remove(fileName);
				if (oldEntry != null) {
					// Present in old and new.  Has it changed?
					if (!newEntry.equals(oldEntry)) {
						// It has changed path, so treat it as a removal and an addition
						fRemovedClasses.addElement(oldEntry);
						fAddedClasses.addElement(newEntry);
					}
					else if (changesForPkg != null && changesForPkg.containsKey(fileName)) {
						fChangedClasses.addElement(newEntry);
					}
				} else {
					// Present only in new
					fAddedClasses.addElement(newEntry);
				}
			}
		}
		// Remaining ones are removed.
		for (Enumeration ee = fileNames.elements(); ee.hasMoreElements();) {
			fRemovedClasses.addElement(ee.nextElement());
		}
	}
}

