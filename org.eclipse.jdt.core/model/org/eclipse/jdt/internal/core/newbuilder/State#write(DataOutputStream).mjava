void write(DataOutputStream out) throws IOException {
	out.writeByte(VERSION);
	out.writeUTF(javaProjectName);
	out.writeInt(buildNumber);
	out.writeInt(lastStructuralBuildNumber);
	out.writeUTF(outputLocationString);

	int length = classpathLocations.length;
	out.writeInt(length);
	for (int i = 0; i < length; ++i) {
		ClasspathLocation c = classpathLocations[i];
		if (c instanceof ClasspathMultiDirectory) {
			out.writeByte(1);
			ClasspathMultiDirectory md = (ClasspathMultiDirectory) c;
			out.writeUTF(md.sourcePath);
			out.writeUTF(md.binaryPath);
		} else if (c instanceof ClasspathDirectory) {
			out.writeByte(2);
			out.writeUTF(((ClasspathDirectory) c).binaryPath);
		} else if (c instanceof ClasspathJar) {
			out.writeByte(3);
			out.writeUTF(((ClasspathJar) c).zipFilename);
		}
	}

	length = structuralBuildNumbers.size();
	out.writeInt(length);
	if (length > 0) {
		Object[] keyTable = structuralBuildNumbers.keyTable;
		Object[] valueTable = structuralBuildNumbers.valueTable;
		for (int i = 0, l = keyTable.length; i < l; i++) {
			if (keyTable[i] != null) {
				out.writeUTF((String) keyTable[i]);
				out.writeInt(((Integer) valueTable[i]).intValue());
			}
		}
	}

	ArrayList internedQualifiedNames = new ArrayList(31);
	ArrayList internedSimpleNames = new ArrayList(31);
	Object[] valueTable = references.valueTable;
	for (int i = 0, l = valueTable.length; i < l; i++) {
		if (valueTable[i] != null) {
			ReferenceCollection collection = (ReferenceCollection) valueTable[i];
			char[][][] qNames = collection.qualifiedNameReferences;
			for (int j = 0, qLength = qNames.length; j < qLength; j++) {
				char[][] qName = qNames[j];
				if (!internedQualifiedNames.contains(qName)) { // remember the names have been interned
					internedQualifiedNames.add(qName);
					for (int k = 0, sLength = qName.length; k < sLength; k++) {
						char[] sName = qName[k];
						if (!internedSimpleNames.contains(sName)) // remember the names have been interned
							internedSimpleNames.add(sName);
					}
				}
			}
			char[][] sNames = collection.simpleNameReferences;
			for (int j = 0, sLength = sNames.length; j < sLength; j++) {
				char[] sName = sNames[j];
				if (!internedSimpleNames.contains(sName)) // remember the names have been interned
					internedSimpleNames.add(sName);
			}
		}
	}
	char[][] internedArray = new char[internedSimpleNames.size()][];
	internedSimpleNames.toArray(internedArray);
	writeNames(internedArray, out);
	// now write the interned qualified names as arrays of interned simple names
	length = internedQualifiedNames.size();
	out.writeInt(length);
	for (int i = 0; i < length; i++) {
		char[][] qName = (char[][]) internedQualifiedNames.get(i);
		int qLength = qName.length;
		out.writeInt(qLength);
		for (int j = 0; j < qLength; j++)
			out.writeInt(internedSimpleNames.indexOf(qName[j]));
	}

	length = references.size();
	out.writeInt(length);
	Object[] keyTable = references.keyTable;
	for (int i = 0, l = keyTable.length; i < l; i++) {
		if (keyTable[i] != null) {
			out.writeUTF((String) keyTable[i]);
			ReferenceCollection collection = (ReferenceCollection) valueTable[i];
			if (collection instanceof AdditionalTypeCollection) {
				out.writeByte(1);
				AdditionalTypeCollection atc = (AdditionalTypeCollection) collection;
				writeNames(atc.additionalTypeNames, out);
			} else {
				out.writeByte(2);
			}
			char[][][] qNames = collection.qualifiedNameReferences;
			int qLength = qNames.length;
			out.writeInt(qLength);
			for (int j = 0; j < qLength; j++)
				out.writeInt(internedQualifiedNames.indexOf(qNames[j]));
			char[][] sNames = collection.simpleNameReferences;
			int sLength = sNames.length;
			out.writeInt(sLength);
			for (int j = 0; j < sLength; j++)
				out.writeInt(internedSimpleNames.indexOf(sNames[j]));
		}
	}
}

