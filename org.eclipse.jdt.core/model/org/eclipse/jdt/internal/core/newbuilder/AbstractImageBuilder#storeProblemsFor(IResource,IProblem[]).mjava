/**
 * Creates a marker from each problem and adds it to the resource.
 * The marker is as follows:
 *   - its type is T_PROBLEM
 *   - its plugin ID is the JavaBuilder's plugin ID
 *	 - its message is the problem's message
 *	 - its priority reflects the severity of the problem
 *	 - its range is the problem's range
 *	 - it has an extra attribute "ID" which holds the problem's id
 */
protected void storeProblemsFor(IResource resource, IProblem[] problems) throws CoreException {
	if (problems == null || problems.length == 0) return;

	boolean classPathIsIncorrect = false;
	for (int i = 0, length = problems.length; i < length; i++) {
		IProblem problem = problems[i];
		int id = problem.getID();
		switch (id) {
			case ProblemIrritants.IsClassPathCorrect :
				removeProblemsFor(javaBuilder.currentProject); // make this the only problem for this project
				classPathIsIncorrect = true;
				break;
			case ProblemIrritants.SuperclassMustBeAClass :
			case ProblemIrritants.SuperInterfaceMustBeAnInterface :
			case ProblemIrritants.HierarchyCircularitySelfReference :
			case ProblemIrritants.HierarchyCircularity :
			case ProblemIrritants.HierarchyHasProblems :
			case ProblemIrritants.InvalidSuperclassBase :
			case ProblemIrritants.InvalidSuperclassBase + 1 :
			case ProblemIrritants.InvalidSuperclassBase + 2 :
			case ProblemIrritants.InvalidSuperclassBase + 3 :
			case ProblemIrritants.InvalidSuperclassBase + 4 :
			case ProblemIrritants.InvalidInterfaceBase :
			case ProblemIrritants.InvalidInterfaceBase + 1 :
			case ProblemIrritants.InvalidInterfaceBase + 2 :
			case ProblemIrritants.InvalidInterfaceBase + 3 :
			case ProblemIrritants.InvalidInterfaceBase + 4 :
				// ensure that this file is always retrieved from source for the rest of the build
				String fileLocation = resource.getLocation().toString();
				if (!problemTypeLocations.contains(fileLocation))
					problemTypeLocations.add(fileLocation);
		}

		IMarker marker = resource.createMarker(ProblemMarkerTag);
		marker.setAttributes(
			new String[] {IMarker.MESSAGE, IMarker.SEVERITY, "ID", IMarker.CHAR_START, IMarker.CHAR_END, IMarker.LINE_NUMBER}, //$NON-NLS-1$
			new Object[] { 
				problem.getMessage(),
				new Integer(problem.isError() ? IMarker.SEVERITY_ERROR : IMarker.SEVERITY_WARNING), 
				new Integer(id),
				new Integer(problem.getSourceStart()),
				new Integer(problem.getSourceEnd() + 1),
				new Integer(problem.getSourceLineNumber())
			});

// Do we need to do this?
//@PM WE SHOULD HAVE IT COME FROM THE PROBLEM ITSELF INSTEAD OF POPULATING THE JAVA MODEL
		// compute a user-friendly location
		IJavaElement element = JavaCore.create(resource);
		if (element instanceof org.eclipse.jdt.core.ICompilationUnit) { // try to find a finer grain element
			org.eclipse.jdt.core.ICompilationUnit unit = (org.eclipse.jdt.core.ICompilationUnit) element;
			IJavaElement fragment = unit.getElementAt(problem.getSourceStart());
			if (fragment != null) element = fragment;
		}
		String location = null;
		if (element instanceof JavaElement)
			location = ((JavaElement) element).readableName();
		if (location != null)
			marker.setAttribute(IMarker.LOCATION, location);
		if (classPathIsIncorrect)
			throw new IncompleteClassPathException();
	}
}

