/**
 *	Removes the entry from the entry queue.  If <i>external</i> is true, the entry is removed
 *	without checking if it can be removed.  It is assumed that the client has already closed
 *	the element it is trying to remove (or will close it promptly).
 *
 *	If <i>external</i> is false, and the entry could not be closed, it is not removed and the 
 *	pointers are not changed.
 *
 *	@param shuffle indicates whether we are just shuffling the queue 
 *	(in which case, the entry table is not modified).
 */
protected void privateRemoveEntry(LRUCacheEntry entry, boolean shuffle, boolean external) {

	if (!shuffle) {
		if (external) {
			fEntryTable.remove(entry._fKey);			
			fCurrentSpace -= entry._fSpace;
			privateNotifyDeletionFromCache(entry);
		} else {
			if (!close(entry)) return;
			// buffer close will recursively call #privateRemoveEntry with external==true
			// thus entry will already be removed if reaching this point.
			if (fEntryTable.get(entry._fKey) == null){
				return;
			} else {
				// basic removal
				fEntryTable.remove(entry._fKey);			
				fCurrentSpace -= entry._fSpace;
				privateNotifyDeletionFromCache(entry);
			}
		}
	}
	LRUCacheEntry previous = entry._fPrevious;
	LRUCacheEntry next = entry._fNext;
		
	/* if this was the first entry */
	if (previous == null) {
		fEntryQueue = next;
	} else {
		previous._fNext = next;
	}
	/* if this was the last entry */
	if (next == null) {
		fEntryQueueTail = previous;
	} else {
		next._fPrevious = previous;
	}
}

