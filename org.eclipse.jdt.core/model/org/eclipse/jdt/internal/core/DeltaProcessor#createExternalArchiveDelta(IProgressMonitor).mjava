	/*
	 * Check if external archives have changed and create the corresponding deltas.
	 * Returns whether at least on delta was created.
	 */
	private boolean createExternalArchiveDelta(IProgressMonitor monitor) {
		
		if (this.refreshedElements == null) return false;
			
		HashMap externalArchivesStatus = new HashMap();
		boolean hasDelta = false;
		
		// find JARs to refresh
		HashSet archivePathsToRefresh = new HashSet();
		try {
			Iterator iterator = this.refreshedElements.iterator();
			while (iterator.hasNext()) {
				IJavaElement element = (IJavaElement)iterator.next();
				switch(element.getElementType()){
					case IJavaElement.PACKAGE_FRAGMENT_ROOT :
						archivePathsToRefresh.add(element.getPath());
						break;
					case IJavaElement.JAVA_PROJECT :
						IJavaProject project = (IJavaProject) element;
						if (!JavaProject.hasJavaNature(project.getProject())) {
							// project is not accessible or has lost its Java nature
							break;
						}
						IClasspathEntry[] classpath;
						try {
							classpath = project.getResolvedClasspath(true);
							for (int j = 0, cpLength = classpath.length; j < cpLength; j++){
								if (classpath[j].getEntryKind() == IClasspathEntry.CPE_LIBRARY){
									archivePathsToRefresh.add(classpath[j].getPath());
								}
							}
						} catch (JavaModelException e) {
							// project doesn't exist -> ignore
						}
						break;
					case IJavaElement.JAVA_MODEL :
						IJavaProject[] projects;
						try {
							projects = this.manager.getJavaModel().getOldJavaProjectsList();
						} catch (JavaModelException e1) {
							// cannot retrieve old projects list -> ignore
							continue;
						}
						for (int j = 0, projectsLength = projects.length; j < projectsLength; j++){
							project = projects[j];
							if (!JavaProject.hasJavaNature(project.getProject())) {
								// project is not accessible or has lost its Java nature
								continue;
							}
							try {
								classpath = project.getResolvedClasspath(true);
							} catch (JavaModelException e2) {
								// project doesn't exist -> ignore
								continue;
							}
							for (int k = 0, cpLength = classpath.length; k < cpLength; k++){
								if (classpath[k].getEntryKind() == IClasspathEntry.CPE_LIBRARY){
									archivePathsToRefresh.add(classpath[k].getPath());
								}
							}
						}
						break;
				}
			}
		} finally {
			this.refreshedElements = null;
		}
		
		// perform refresh
		IJavaProject[] projects;
		try {
			projects = this.manager.getJavaModel().getOldJavaProjectsList();
		} catch (JavaModelException e) {
			// cannot retrieve old projects list -> give up
			return false;
		}
		IWorkspaceRoot wksRoot = ResourcesPlugin.getWorkspace().getRoot();
		for (int i = 0, length = projects.length; i < length; i++) {
			
			if (monitor != null && monitor.isCanceled()) break; 
			
			IJavaProject project = projects[i];
			if (!JavaProject.hasJavaNature(project.getProject())) {
				// project is not accessible or has lost its Java nature
				continue;
			}
			IClasspathEntry[] entries;
			try {
				entries = project.getResolvedClasspath(true);
			} catch (JavaModelException e1) {
				// project does not exist -> ignore
				continue;
			}
			for (int j = 0; j < entries.length; j++){
				if (entries[j].getEntryKind() == IClasspathEntry.CPE_LIBRARY) {
					
					IPath entryPath = entries[j].getPath();
					
					if (!archivePathsToRefresh.contains(entryPath)) continue; // not supposed to be refreshed
					
					String status = (String)externalArchivesStatus.get(entryPath); 
					if (status == null){
						
						// compute shared status
						Object targetLibrary = JavaModel.getTarget(wksRoot, entryPath, true);
		
						if (targetLibrary == null){ // missing JAR
							if (this.state.externalTimeStamps.remove(entryPath) != null){
								externalArchivesStatus.put(entryPath, EXTERNAL_JAR_REMOVED);
								// the jar was physically removed: remove the index
								this.manager.indexManager.removeIndex(entryPath);
							}
		
						} else if (targetLibrary instanceof File){ // external JAR
		
							File externalFile = (File)targetLibrary;
							
							// check timestamp to figure if JAR has changed in some way
							Long oldTimestamp =(Long) this.state.externalTimeStamps.get(entryPath);
							long newTimeStamp = getTimeStamp(externalFile);
							if (oldTimestamp != null){
		
								if (newTimeStamp == 0){ // file doesn't exist
									externalArchivesStatus.put(entryPath, EXTERNAL_JAR_REMOVED);
									this.state.externalTimeStamps.remove(entryPath);
									// remove the index
									this.manager.indexManager.removeIndex(entryPath);
		
								} else if (oldTimestamp.longValue() != newTimeStamp){
									externalArchivesStatus.put(entryPath, EXTERNAL_JAR_CHANGED);
									this.state.externalTimeStamps.put(entryPath, new Long(newTimeStamp));
									// first remove the index so that it is forced to be re-indexed
									this.manager.indexManager.removeIndex(entryPath);
									// then index the jar
									this.manager.indexManager.indexLibrary(entryPath, project.getProject());
								} else {
									externalArchivesStatus.put(entryPath, EXTERNAL_JAR_UNCHANGED);
								}
							} else {
								if (newTimeStamp == 0){ // jar still doesn't exist
									externalArchivesStatus.put(entryPath, EXTERNAL_JAR_UNCHANGED);
								} else {
									externalArchivesStatus.put(entryPath, EXTERNAL_JAR_ADDED);
									this.state.externalTimeStamps.put(entryPath, new Long(newTimeStamp));
									// index the new jar
									this.manager.indexManager.indexLibrary(entryPath, project.getProject());
								}
							}
						} else { // internal JAR
							externalArchivesStatus.put(entryPath, INTERNAL_JAR_IGNORE);
						}
					}
					// according to computed status, generate a delta
					status = (String)externalArchivesStatus.get(entryPath); 
					if (status != null){
						if (status == EXTERNAL_JAR_ADDED){
							PackageFragmentRoot root = (PackageFragmentRoot)project.getPackageFragmentRoot(entryPath.toString());
							if (VERBOSE){
								System.out.println("- External JAR ADDED, affecting root: "+root.getElementName()); //$NON-NLS-1$
							} 
							elementAdded(root, null, null);
							hasDelta = true;
						} else if (status == EXTERNAL_JAR_CHANGED) {
							PackageFragmentRoot root = (PackageFragmentRoot)project.getPackageFragmentRoot(entryPath.toString());
							if (VERBOSE){
								System.out.println("- External JAR CHANGED, affecting root: "+root.getElementName()); //$NON-NLS-1$
							}
							// reset the corresponding project built state, since the builder would miss this change
							this.manager.setLastBuiltState(project.getProject(), null /*no state*/);
							contentChanged(root, null);
							hasDelta = true;
						} else if (status == EXTERNAL_JAR_REMOVED) {
							PackageFragmentRoot root = (PackageFragmentRoot)project.getPackageFragmentRoot(entryPath.toString());
							if (VERBOSE){
								System.out.println("- External JAR REMOVED, affecting root: "+root.getElementName()); //$NON-NLS-1$
							}
							elementRemoved(root, null, null);
							hasDelta = true;
						}
					}
				}
			}
		}
		return hasDelta;
	}

