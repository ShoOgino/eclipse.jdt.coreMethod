	/**
	 * Locates and returns source code for the given (binary) type, in this
	 * SourceMapper's ZIP file, or returns <code>null</code> if source
	 * code cannot be found.
	 * The given simpleSourceFileName is the .java file name (without the enclosing
	 * folder) used to create the given type (e.g. "A.java" for x/y/A$Inner.class)
	 */
	public char[] findSource(IType type, String simpleSourceFileName) {
		long time = 0;
		if (VERBOSE) {
			time = System.currentTimeMillis();
		}
		String name = simpleSourceFileName;
		IPackageFragment pkgFrag = type.getPackageFragment();
		if (!pkgFrag.isDefaultPackage()) {
			String pkg = pkgFrag.getElementName().replace('.', '/');
			name = pkg + '/' + name;
		}
	
		char[] source = null;
		
		if (!areRootPathsComputed) {
			computeAllRootPaths((IPackageFragmentRoot) type.getPackageFragment().getParent());
		}
		
		if (this.rootPath != null) {
			source = getSourceForRootPath(this.rootPath, name);
		}

		if (source == null) {
			/*
			 * We should try all existing root paths. If none works, try to recompute it.
			 * If it still doesn't work, then return null
			 */
			if (this.rootPaths != null) {
				loop: for (Iterator iterator = this.rootPaths.iterator(); iterator.hasNext(); ) {
					String currentRootPath = (String) iterator.next();
					if (!currentRootPath.equals(this.rootPath)) {
						source = getSourceForRootPath(currentRootPath, name);
						if (source != null) {
							// remember right root path
							this.rootPath = currentRootPath;
							break loop;
						}
					}
				}
			}
		}
		if (VERBOSE) {
			System.out.println("spent " + (System.currentTimeMillis() - time) + "ms for " + type.getElementName()); //$NON-NLS-1$ //$NON-NLS-2$
		}
		return source;
	}

