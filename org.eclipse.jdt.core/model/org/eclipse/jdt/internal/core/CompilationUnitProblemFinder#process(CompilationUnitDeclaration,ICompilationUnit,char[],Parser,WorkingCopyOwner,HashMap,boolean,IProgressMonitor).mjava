	public static CompilationUnitDeclaration process(
		CompilationUnitDeclaration unit,
		ICompilationUnit unitElement, 
		char[] contents,
		Parser parser,
		WorkingCopyOwner workingCopyOwner,
		HashMap problems,
		boolean creatingAST,
		IProgressMonitor monitor)
		throws JavaModelException {

		JavaProject project = (JavaProject) unitElement.getJavaProject();
		CancelableNameEnvironment environment = null;
		CancelableProblemFactory problemFactory = null;
		CompilationUnitProblemFinder problemFinder = null;
		try {
			environment = new CancelableNameEnvironment(project, workingCopyOwner, monitor);
			problemFactory = new CancelableProblemFactory(monitor);
			problemFinder = new CompilationUnitProblemFinder(
				environment,
				getHandlingPolicy(),
				project.getOptions(true),
				getRequestor(),
				problemFactory,
				!creatingAST); // optimize string literal only if not creating a DOM AST
			if (parser != null) {
				problemFinder.parser = parser;
			}
			PackageFragment packageFragment = (PackageFragment)unitElement.getAncestor(IJavaElement.PACKAGE_FRAGMENT);
			char[][] expectedPackageName = null;
			if (packageFragment != null){
				expectedPackageName = Util.toCharArrays(packageFragment.names);
			}
			if (unit == null) {
				unit = problemFinder.resolve(
					new BasicCompilationUnit(
						contents,
						expectedPackageName,
						unitElement.getPath().toString(),
						unitElement),
					true, // verify methods
					true, // analyze code
					true); // generate code
			} else {
				problemFinder.resolve(
					unit,
					null, // no need for source
					true, // verify methods
					true, // analyze code
					true); // generate code
			}
			CompilationResult unitResult = unit.compilationResult;
			IProblem[] unitProblems = unitResult.getProblems();
			int length = unitProblems == null ? 0 : unitProblems.length;
			if (length > 0) {
				CategorizedProblem[] categorizedProblems = new CategorizedProblem[length];
				System.arraycopy(unitProblems, 0, categorizedProblems, 0, length);
				problems.put(IJavaModelMarker.JAVA_MODEL_PROBLEM_MARKER, categorizedProblems);
			}
			unitProblems = unitResult.getTasks();
			length = unitProblems == null ? 0 : unitProblems.length;
			if (length > 0) {
				CategorizedProblem[] categorizedProblems = new CategorizedProblem[length];
				System.arraycopy(unitProblems, 0, categorizedProblems, 0, length);
				problems.put(IJavaModelMarker.TASK_MARKER, categorizedProblems);
			}
			if (NameLookup.VERBOSE) {
				System.out.println(Thread.currentThread() + " TIME SPENT in NameLoopkup#seekTypesInSourcePackage: " + environment.nameLookup.timeSpentInSeekTypesInSourcePackage + "ms");  //$NON-NLS-1$ //$NON-NLS-2$
				System.out.println(Thread.currentThread() + " TIME SPENT in NameLoopkup#seekTypesInBinaryPackage: " + environment.nameLookup.timeSpentInSeekTypesInBinaryPackage + "ms");  //$NON-NLS-1$ //$NON-NLS-2$
			}
			return unit;
		} catch (OperationCanceledException e) {
			throw e;
		} catch(RuntimeException e) { 
			// avoid breaking other tools due to internal compiler failure (40334)
			Util.log(e, "Exception occurred during problem detection: "); //$NON-NLS-1$ 
			throw new JavaModelException(e, IJavaModelStatusConstants.COMPILER_FAILURE);
		} finally {
			if (environment != null)
				environment.monitor = null; // don't hold a reference to this external object
			if (problemFactory != null)
				problemFactory.monitor = null; // don't hold a reference to this external object
			// NB: unit.cleanUp() is done by caller
			if (problemFinder != null && !creatingAST)
				problemFinder.lookupEnvironment.reset();		
		}
	}

