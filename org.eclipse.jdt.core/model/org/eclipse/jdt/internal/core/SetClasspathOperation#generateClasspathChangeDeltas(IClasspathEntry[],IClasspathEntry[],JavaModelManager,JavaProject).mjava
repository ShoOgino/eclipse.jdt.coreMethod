	/**
	 * Generates the delta of removed/added/reordered roots.
	 * Use three deltas in case the same root is removed/added/reordered (i.e. changed from
	 * K_SOURCE to K_BINARY or visa versa)
	 */
	protected void generateClasspathChangeDeltas(
		IClasspathEntry[] oldResolvedPath,
		IClasspathEntry[] newResolvedPath,
		JavaModelManager manager,
		JavaProject project) {

		boolean hasChangedContentForDependents = false;

		JavaElementDelta delta = new JavaElementDelta(getJavaModel());
		boolean hasDelta = false;
		boolean oldResolvedPathLongest =
			oldResolvedPath.length >= newResolvedPath.length;

		for (int i = 0; i < oldResolvedPath.length; i++) {

			int index = classpathContains(newResolvedPath, oldResolvedPath[i]);
			if (index == -1) {
				IPackageFragmentRoot[] pkgFragmentRoots =
					project.getPackageFragmentRoots(oldResolvedPath[i]);
				addClasspathDeltas(pkgFragmentRoots, IJavaElementDelta.F_REMOVED_FROM_CLASSPATH, delta);

				int changeKind = oldResolvedPath[i].getEntryKind();
				hasChangedContentForDependents |= 
					(changeKind == IClasspathEntry.CPE_SOURCE) || oldResolvedPath[i].isExported();

				// force detach source on jar package fragment roots (source will be lazily computed when needed)
				for (int j = 0, length = pkgFragmentRoots.length; j < length; j++) {
					IPackageFragmentRoot root = pkgFragmentRoots[j];
					if (root instanceof JarPackageFragmentRoot) {
						((JarPackageFragmentRoot) root).setSourceAttachmentProperty(null);// loose info - will be recomputed
					}
				}
				hasDelta = true;

			} else {
				hasChangedContentForDependents |= (oldResolvedPath[i].isExported() != newResolvedPath[index].isExported());
				if (oldResolvedPathLongest && index != i) { //reordering of the classpath
					addClasspathDeltas(
						project.getPackageFragmentRoots(oldResolvedPath[i]),
						IJavaElementDelta.F_CLASSPATH_REORDER,
						delta);
					int changeKind = oldResolvedPath[i].getEntryKind();
					hasChangedContentForDependents |= (changeKind == IClasspathEntry.CPE_SOURCE);
	
					hasDelta = true;
				}
			}
		}

		for (int i = 0; i < newResolvedPath.length; i++) {

			int index = classpathContains(oldResolvedPath, newResolvedPath[i]);
			if (index == -1) {
				addClasspathDeltas(
					project.getPackageFragmentRoots(newResolvedPath[i]),
					IJavaElementDelta.F_ADDED_TO_CLASSPATH,
					delta);
				int changeKind = newResolvedPath[i].getEntryKind();
				
				// Request indexing of the library
				if (changeKind == IClasspathEntry.CPE_LIBRARY) {
					IndexManager indexManager = JavaModelManager.getJavaModelManager().getIndexManager();
					if (indexManager != null) {
						boolean pathHasChanged = true;
						IPath newPath = newResolvedPath[i].getPath();
						for (int j = 0; j < oldResolvedPath.length; j++) {
							IClasspathEntry oldEntry = oldResolvedPath[j];
							if (oldEntry.getPath().equals(newPath)) {
								pathHasChanged = false;
								break;
							}
						}
						if (pathHasChanged) {
							indexManager.indexLibrary(newPath, project.getProject());
						}
					}
				}
				
				hasChangedContentForDependents |= 
					(changeKind == IClasspathEntry.CPE_SOURCE) || newResolvedPath[i].isExported();
				hasDelta = true;

			} else {
				hasChangedContentForDependents |= (newResolvedPath[i].isExported() != oldResolvedPath[index].isExported());
				if (!oldResolvedPathLongest && index != i) { //reordering of the classpath
					addClasspathDeltas(
						project.getPackageFragmentRoots(newResolvedPath[i]),
						IJavaElementDelta.F_CLASSPATH_REORDER,
						delta);
					int changeKind = newResolvedPath[i].getEntryKind();
					hasChangedContentForDependents |= changeKind == IClasspathEntry.CPE_SOURCE;
					hasDelta = true;
				}
			}
		}
		if (hasDelta) {
			try {
				this.hasModifiedResource = project.saveClasspath(this.forceSave);
			} catch (JavaModelException e) {
			}
			this.addDelta(delta);
			// loose all built state - next build will be a full one
			manager.setLastBuiltState(project.getProject(), null);

			if (hasChangedContentForDependents){
				updateAffectedProjects(project.getProject().getFullPath());
			}
		}
	}

