	/**
	 * Maps the given source code to the given binary type and its children.
	 * If a non-null java element is passed, finds the name range for the
	 * given java element without storing it.
	 */
	public synchronized ISourceRange mapSource(
		IType type,
		char[] contents,
		IBinaryType info,
		IJavaElement elementToFind) {

		this.binaryType = (BinaryType) type;

		// check whether it is already mapped
		if (this.sourceRanges.get(type) != null) return (elementToFind != null) ? getNameRange(elementToFind) : null;

		this.importsTable.remove(this.binaryType);
		this.importsCounterTable.remove(this.binaryType);
		this.searchedElement = elementToFind;
		this.types = new IType[1];
		this.typeDeclarationStarts = new int[1];
		this.typeNameRanges = new SourceRange[1];
		this.typeModifiers = new int[1];
		this.typeDepth = -1;
		this.memberDeclarationStart = new int[1];
		this.memberName = new String[1];
		this.memberNameRange = new SourceRange[1];
		this.methodParameterTypes = new char[1][][];
		this.methodParameterNames = new char[1][][];
		this.anonymousCounter = 0;

		HashMap oldSourceRanges = null;
		if (elementToFind != null) {
			oldSourceRanges = (HashMap) this.sourceRanges.clone();
		}
		try {
			IProblemFactory factory = new DefaultProblemFactory();
			SourceElementParser parser = null;
			this.anonymousClassName = 0;
			if (info == null) {
				try {
					info = (IBinaryType) this.binaryType.getElementInfo();
				} catch(JavaModelException e) {
					return null;
				}
			}
			boolean isAnonymousClass = info.isAnonymous();
			char[] fullName = info.getName();
			if (isAnonymousClass) {
				String eltName = this.binaryType.getParent().getElementName();
				eltName = eltName.substring(eltName.lastIndexOf('$') + 1, eltName.length());
				try {
					this.anonymousClassName = Integer.parseInt(eltName);
				} catch(NumberFormatException e) {
					// ignore
				}
			}
			boolean doFullParse = hasToRetrieveSourceRangesForLocalClass(fullName);
			parser = new SourceElementParser(this, factory, new CompilerOptions(this.options), doFullParse, true/*optimize string literals*/);
			parser.javadocParser.checkDocComment = false; // disable javadoc parsing
			IJavaElement javaElement = this.binaryType.getCompilationUnit();
			if (javaElement == null) javaElement = this.binaryType.getParent();
			parser.parseCompilationUnit(
				new BasicCompilationUnit(contents, null, this.binaryType.sourceFileName(info), javaElement),
				doFullParse,
				null/*no progress*/);
			if (elementToFind != null) {
				ISourceRange range = getNameRange(elementToFind);
				return range;
			} else {
				return null;
			}
		} finally {
			if (elementToFind != null) {
				this.sourceRanges = oldSourceRanges;
			}
			this.binaryType = null;
			this.searchedElement = null;
			this.types = null;
			this.typeDeclarationStarts = null;
			this.typeNameRanges = null;
			this.typeDepth = -1;
		}
	}

