	private void computeExpandedClasspath(
		boolean restrainToExportedEntries, 
		boolean ignoreUnresolvedVariable,
		boolean generateMarkerOnError,
		Vector visitedProjects, 
		Vector accumulatedEntries) throws JavaModelException {
		
		if (visitedProjects.contains(this)) return; // break cycles if any
		visitedProjects.add(this);
		
		IClasspathEntry[] immediateClasspath = getResolvedClasspath(ignoreUnresolvedVariable, false);
		for (int i = 0, length = immediateClasspath.length; i < length; i++){
			IClasspathEntry entry = immediateClasspath[i];

			if (!restrainToExportedEntries || entry.isExported()){
				accumulatedEntries.add(entry);
				if (entry.getEntryKind() == ClasspathEntry.CPE_PROJECT) {
						IProject projRsc = (IProject) getWorkspace().getRoot().findMember(entry.getPath());
						if (projRsc != null && projRsc.isOpen()) {				
							JavaProject project = (JavaProject) JavaCore.create(projRsc);
							// recurse in project to get all its indirect exports (only consider exported entries from there on)
							project.computeExpandedClasspath(
								true, 
								ignoreUnresolvedVariable, 
								generateMarkerOnError,
								visitedProjects, 
								accumulatedEntries);
						}
						break;
				}
			}			
		}
	}

