	/**
	 * If a cycle is detected, then cycleParticipants contains all the project involved in this cycle (directly),
	 * no cycle if the set is empty (and started empty)
	 */
	public void updateCycleParticipants(
			IClasspathEntry[] preferredClasspath, 
			ArrayList visited, 
			HashSet cycleParticipants, 
			IWorkspaceRoot workspaceRoot,
			HashSet alreadyTraversed){
				
		visited.add(this);
		try {
			IClasspathEntry[] classpath = preferredClasspath == null ? getResolvedClasspath(true) : preferredClasspath;
			for (int i = 0, length = classpath.length; i < length; i++) {
				IClasspathEntry entry = classpath[i];
				
				if (entry.getEntryKind() == IClasspathEntry.CPE_PROJECT){
					IPath entryPath = entry.getPath();
					IResource member = workspaceRoot.findMember(entryPath);
					if (member != null && member.getType() == IResource.PROJECT){
						JavaProject project = (JavaProject)JavaCore.create((IProject)member);
						int index = visited.indexOf(project);
						if (index == -1 && cycleParticipants.contains(project))
							index = visited.indexOf(this); // another loop in the cycle exists
						if (index >= 0) { // only consider direct participants inside the cycle
							for (int size = visited.size(); index < size; index++)
								cycleParticipants.add(visited.get(index)); 
						} else {
							if (!alreadyTraversed.contains(project)) {
								project.updateCycleParticipants(null, visited, cycleParticipants, workspaceRoot, alreadyTraversed);
							}
						}
					}
				}
			}
		} catch(JavaModelException e){
		}
		visited.remove(this);
		alreadyTraversed.add(this);
	}

