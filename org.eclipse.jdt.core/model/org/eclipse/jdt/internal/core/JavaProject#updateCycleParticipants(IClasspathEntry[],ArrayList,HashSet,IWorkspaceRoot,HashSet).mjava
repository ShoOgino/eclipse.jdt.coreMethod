	/**
	 * If a cycle is detected, then cycleParticipants contains all the project involved in this cycle (directly and indirectly),
	 * no cycle if the set is empty (and started empty)
	 */
	public void updateCycleParticipants(
			IClasspathEntry[] preferredClasspath, 
			ArrayList prereqChain, 
			HashSet cycleParticipants, 
			IWorkspaceRoot workspaceRoot,
			HashSet alreadyTraversed){
				
		prereqChain.add(this);
		try {
			IClasspathEntry[] classpath = preferredClasspath == null ? getResolvedClasspath(true) : preferredClasspath;
			for (int i = 0, length = classpath.length; i < length; i++) {
				IClasspathEntry entry = classpath[i];
				
				if (entry.getEntryKind() == IClasspathEntry.CPE_PROJECT){
					IPath entryPath = entry.getPath();
					IResource member = workspaceRoot.findMember(entryPath);
					if (member != null && member.getType() == IResource.PROJECT){
						JavaProject project = (JavaProject)JavaCore.create((IProject)member);
						int index = cycleParticipants.contains(project) ? 0 : prereqChain.indexOf(project);
						if (index >= 0) { // refer to cycle, or in cycle itself
							for (int size = prereqChain.size(); index < size; index++) {
								cycleParticipants.add(prereqChain.get(index)); 
							}
						} else {
							if (!alreadyTraversed.contains(project)) {
								project.updateCycleParticipants(null, prereqChain, cycleParticipants, workspaceRoot, alreadyTraversed);
							}
						}
					}
				}
			}
		} catch(JavaModelException e){
		}
		prereqChain.remove(this);
		alreadyTraversed.add(this);
	}

