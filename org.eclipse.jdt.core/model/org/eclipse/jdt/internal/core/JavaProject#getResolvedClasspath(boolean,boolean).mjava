	/**
	 * Internal variant which can create marker on project for invalid entries
	 * and caches the resolved classpath on perProjectInfo
	 */
	public IClasspathEntry[] getResolvedClasspath(
		boolean ignoreUnresolvedEntry,
		boolean generateMarkerOnError)
		throws JavaModelException {

		JavaModelManager manager = getJavaModelManager();
		JavaModelManager.PerProjectInfo perProjectInfo = manager.getPerProjectInfoCheckExistence(fProject);
		
		// reuse cache if not needing to refresh markers or checking bound variables
		if (ignoreUnresolvedEntry && !generateMarkerOnError && perProjectInfo != null){
			// resolved path is cached on its info
			IClasspathEntry[] infoPath = perProjectInfo.lastResolvedClasspath;
			if (infoPath != null) return infoPath;
		}

		IClasspathEntry[] resolvedPath = getResolvedClasspath(getRawClasspath(), ignoreUnresolvedEntry, generateMarkerOnError);

		if (perProjectInfo != null){
			if (perProjectInfo.classpath == null // .classpath file could not be read
				&& generateMarkerOnError 
				&& JavaProject.hasJavaNature(fProject)) {
					this.createClasspathProblemMarker(
						Util.bind("classpath.cannotReadClasspathFile", this.getElementName()), //$NON-NLS-1$
						IMarker.SEVERITY_ERROR,
						false,	//  cycle error
						false);	//	file format error
				}

			// remember the timestamps of external libraries
			for (int i = 0, length = resolvedPath.length; i < length; i++) {
				IClasspathEntry entry = resolvedPath[i];
				if (entry.getEntryKind() == IClasspathEntry.CPE_LIBRARY) {
					IPath path = entry.getPath();
					Object target = JavaModel.getTarget(ResourcesPlugin.getWorkspace().getRoot(), path, true);
					if (target instanceof java.io.File) {
						long timestamp = DeltaProcessor.getTimeStamp((java.io.File)target);
						JavaModelManager.getJavaModelManager().deltaProcessor.externalTimeStamps.put(path, new Long(timestamp));							
					}
				}
			}							
		
			perProjectInfo.lastResolvedClasspath = resolvedPath;
		}
		return resolvedPath;
	}

