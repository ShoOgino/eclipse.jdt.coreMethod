	private ResolvedClasspath resolveClasspath(IClasspathEntry[] rawClasspath, boolean usePreviousSession) throws JavaModelException {
		JavaModelManager manager = JavaModelManager.getJavaModelManager();
		ExternalFoldersManager externalFoldersManager = JavaModelManager.getExternalManager();
		ResolvedClasspath result = new ResolvedClasspath();

		ArrayList resolvedEntries = new ArrayList();
		int length = rawClasspath.length;
		for (int i = 0; i < length; i++) {

			IClasspathEntry rawEntry = rawClasspath[i];
			IClasspathEntry resolvedEntry = rawEntry;
			IPath resolvedPath;

			switch (rawEntry.getEntryKind()){

				case IClasspathEntry.CPE_VARIABLE :
					try {
						resolvedEntry = manager.getResolvedClasspathEntry(rawEntry, usePreviousSession);
					} catch (ClasspathEntry.AssertionFailedException e) {
						// Catch the assertion failure and set status instead
						// see bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=55992
						result.unresolvedEntryStatus = new JavaModelStatus(IJavaModelStatusConstants.INVALID_PATH, e.getMessage());
						break;
					}
					if (resolvedEntry == null) {
						result.unresolvedEntryStatus = new JavaModelStatus(IJavaModelStatusConstants.CP_VARIABLE_PATH_UNBOUND, this, rawEntry.getPath());
					} else {
						if (result.rawReverseMap.get(resolvedPath = resolvedEntry.getPath()) == null) {
							result.rawReverseMap.put(resolvedPath , rawEntry);
							result.rootPathToResolvedEntries.put(resolvedPath, resolvedEntry);
						}
						resolvedEntries.add(resolvedEntry);
						if (resolvedEntry.getEntryKind() == IClasspathEntry.CPE_LIBRARY && ExternalFoldersManager.isExternalFolderPath(resolvedPath)) {
							externalFoldersManager.addFolder(resolvedPath); // no-op if not an external folder or if already registered
						}
					}
					break;

				case IClasspathEntry.CPE_CONTAINER :
					IClasspathContainer container = usePreviousSession ? manager.getPreviousSessionContainer(rawEntry.getPath(), this) : JavaCore.getClasspathContainer(rawEntry.getPath(), this);
					if (container == null){
						result.unresolvedEntryStatus = new JavaModelStatus(IJavaModelStatusConstants.CP_CONTAINER_PATH_UNBOUND, this, rawEntry.getPath());
						break;
					}

					IClasspathEntry[] containerEntries = container.getClasspathEntries();
					if (containerEntries == null) {
						if (JavaModelManager.CP_RESOLVE_VERBOSE || JavaModelManager.CP_RESOLVE_VERBOSE_FAILURE) {
							JavaModelManager.getJavaModelManager().verbose_missbehaving_container_null_entries(this, rawEntry.getPath());
						}
						break;
					}

					// container was bound
					for (int j = 0, containerLength = containerEntries.length; j < containerLength; j++){
						ClasspathEntry cEntry = (ClasspathEntry) containerEntries[j];
						if (cEntry == null) {
							if (JavaModelManager.CP_RESOLVE_VERBOSE || JavaModelManager.CP_RESOLVE_VERBOSE_FAILURE) {
								JavaModelManager.getJavaModelManager().verbose_missbehaving_container(this, rawEntry.getPath(), containerEntries);
							}
							break;
						}
						// if container is exported or restricted, then its nested entries must in turn be exported  (21749) and/or propagate restrictions
						cEntry = cEntry.combineWith((ClasspathEntry) rawEntry);
						// resolve ".." in library path
						if (cEntry.getEntryKind() == IClasspathEntry.CPE_LIBRARY) {
							cEntry = cEntry.resolvedDotDot();
						}
						if (result.rawReverseMap.get(resolvedPath = cEntry.getPath()) == null) {
							result.rawReverseMap.put(resolvedPath , rawEntry);
							result.rootPathToResolvedEntries.put(resolvedPath, cEntry);
						}
						resolvedEntries.add(cEntry);
						if (cEntry.getEntryKind() == IClasspathEntry.CPE_LIBRARY && ExternalFoldersManager.isExternalFolderPath(resolvedPath)) {
							externalFoldersManager.addFolder(resolvedPath); // no-op if not an external folder or if already registered
						}
					}
					break;

				case IClasspathEntry.CPE_LIBRARY:
					resolvedEntry = ((ClasspathEntry) rawEntry).resolvedDotDot();
					// $FALL-THROUGH$ use the default code below
				default :
					if (result.rawReverseMap.get(resolvedPath = resolvedEntry.getPath()) == null) {
						result.rawReverseMap.put(resolvedPath , rawEntry);
						result.rootPathToResolvedEntries.put(resolvedPath, resolvedEntry);
					}
					resolvedEntries.add(resolvedEntry);
					if (resolvedEntry.getEntryKind() == IClasspathEntry.CPE_LIBRARY && ExternalFoldersManager.isExternalFolderPath(resolvedPath)) {
						externalFoldersManager.addFolder(resolvedPath); // no-op if not an external folder or if already registered
					}

			}
		}
		result.resolvedClasspath = new IClasspathEntry[resolvedEntries.size()];
		resolvedEntries.toArray(result.resolvedClasspath);
		return result;
	}

