	/*
	 * Returns an element handle corresponding to the given ASTNode in the given parsed unit.
	 * Returns null if the given ASTNode could not be found.
	 */
	public IJavaElement createElement(final ASTNode toBeFound, CompilationUnitDeclaration parsedUnit, Openable openable) {
		class EndVisit extends RuntimeException {
			// marker to stop traversing ast
			private static final long serialVersionUID = 7264372508108115988L; // backward compatible
		}
		class Visitor extends ASTVisitor {
		    ASTNode[] nodeStack = new ASTNode[10];
		    int nodeIndex = -1;
			
		    public void push(ASTNode node) {
		    	if (++this.nodeIndex >= this.nodeStack.length) 
		            System.arraycopy(this.nodeStack, 0, this.nodeStack = new ASTNode[this.nodeStack.length*2], 0, this.nodeIndex-1);
	            this.nodeStack[this.nodeIndex] = node;
		    }
		    
		    public void pop(ASTNode node) {
		    	while (this.nodeIndex >= 0 && this.nodeStack[this.nodeIndex--] != node){/*empty*/}
		    }
		    
			public boolean visit(Argument node, BlockScope scope) {
			    push(node);
				if (node == toBeFound) throw new EndVisit();
				return true;
			}
			public void endVisit(Argument node, BlockScope scope) {
			    pop(node);
            }

			public boolean visit(ConstructorDeclaration node, ClassScope scope) {
			    push(node);
				if (node == toBeFound) throw new EndVisit();
				return true;
			}
			public void endVisit(ConstructorDeclaration node, ClassScope scope) {
				pop(node);
			}
			
			public boolean visit(FieldDeclaration node, MethodScope scope) {
			    push(node);
				if (node == toBeFound) throw new EndVisit();
				return true;
			}
			public void endVisit(FieldDeclaration node, MethodScope scope) {
			    pop(node);
			}

			public boolean visit(Initializer node, MethodScope scope) {
			    push(node);
				if (node == toBeFound) throw new EndVisit();
				return true;
			}
			// don't pop initializers (used to count how many occurrences are in the type)

			public boolean visit(LocalDeclaration node, BlockScope scope) {
			    push(node);
				if (node == toBeFound) throw new EndVisit();
				return true;
			}
			public void endVisit(LocalDeclaration node, BlockScope scope) {
			    pop(node);
            }

			public boolean visit(TypeDeclaration node, BlockScope scope) {
			    push(node);
				if (node == toBeFound) throw new EndVisit();
				return true;
			}
			public void endVisit(TypeDeclaration node, BlockScope scope) {
				if ((node.bits & ASTNode.IsMemberTypeMASK) != 0) {
				    pop(node);
				}
				// don't pop local/anonymous types (used to count how many occurrences are in the method)
			}

			public boolean visit(TypeDeclaration node, ClassScope scope) {
			    push(node);
				if (node == toBeFound) throw new EndVisit();
				return true;
			}
			public void endVisit(TypeDeclaration node, ClassScope scope) {
				if ((node.bits & ASTNode.IsMemberTypeMASK) != 0) {
				    pop(node);
				}
				// don't pop local/anonymous types (used to count how many occurrences are in the initializer)
			}
						
			public boolean visit(MethodDeclaration node, ClassScope scope) {
			    push(node);
				if (node == toBeFound) throw new EndVisit();
				return true;
			}
			public void endVisit(MethodDeclaration node, ClassScope scope) {
				pop(node);
			}
			
			public boolean visit(TypeDeclaration node, CompilationUnitScope scope) {
			    push(node);
				if (node == toBeFound) throw new EndVisit();
				return true;
			}
			public void endVisit(TypeDeclaration node, CompilationUnitScope scope) {
				pop(node);
			}
		}
		Visitor visitor = new Visitor();
		try {
			parsedUnit.traverse(visitor, parsedUnit.scope);
		} catch (EndVisit e) {
		    ASTNode[] nodeStack = visitor.nodeStack;
		    int end = visitor.nodeIndex;
		    int start = 0;
		    
		    // find the inner most type declaration if binary type
		    ASTNode typeDecl = null;
		    if (openable instanceof ClassFile) {
				for (int i = end; i >= 0; i--) {
				    if (nodeStack[i] instanceof TypeDeclaration) {
				        typeDecl = nodeStack[i];
				        start = i;
				        break;
				    }
				}
		    }
			
			// find the openable corresponding to this type declaration
			if (typeDecl != null) {
			    openable = getOpenable(typeDecl, openable);
			}
			
			return createElement(nodeStack, start, end, openable);
		}
		return null;
	}

