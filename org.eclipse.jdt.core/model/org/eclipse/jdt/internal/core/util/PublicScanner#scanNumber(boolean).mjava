public int scanNumber(boolean dotPrefix) throws InvalidInputException {

	//when entering this method the currentCharacter is the firt
	//digit of the number , i.e. it may be preceeded by a . when
	//dotPrefix is true

	boolean floating = dotPrefix;
	if ((!dotPrefix) && (currentCharacter == '0')) {
		if (getNextChar('x', 'X') >= 0) { //----------hexa-----------------
			//force the first char of the hexa number do exist...
			// consume next character
			unicodeAsBackSlash = false;
			if (((currentCharacter = source[currentPosition++]) == '\\')
				&& (source[currentPosition] == 'u')) {
				getNextUnicodeChar();
			} else {
				if (withoutUnicodePtr != 0) {
					withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;
				}
			}
			if (Character.digit(currentCharacter, 16) == -1)
				throw new InvalidInputException(INVALID_HEXA);
			//---end forcing--
			while (getNextCharAsDigit(16)) {};
			if (getNextChar('l', 'L') >= 0)
				return TokenNameLongLiteral;
			else
				return TokenNameIntegerLiteral;
		}

		//there is x or X in the number
		//potential octal ! ... some one may write 000099.0 ! thus 00100 < 00078.0 is true !!!!! crazy language
		if (getNextCharAsDigit()) { //-------------potential octal-----------------
			while (getNextCharAsDigit()) {};

			if (getNextChar('l', 'L') >= 0) {
				return TokenNameLongLiteral;
			}

			if (getNextChar('f', 'F') >= 0) {
				return TokenNameFloatingPointLiteral;
			}

			if (getNextChar('d', 'D') >= 0) {
				return TokenNameDoubleLiteral;
			} else { //make the distinction between octal and float ....
				if (getNextChar('.')) { //bingo ! ....
					while (getNextCharAsDigit()) {};
					if (getNextChar('e', 'E') >= 0) { // consume next character
						unicodeAsBackSlash = false;
						if (((currentCharacter = source[currentPosition++]) == '\\')
							&& (source[currentPosition] == 'u')) {
							getNextUnicodeChar();
						} else {
							if (withoutUnicodePtr != 0) {
								withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;
							}
						}

						if ((currentCharacter == '-')
							|| (currentCharacter == '+')) { // consume next character
							unicodeAsBackSlash = false;
							if (((currentCharacter = source[currentPosition++]) == '\\')
								&& (source[currentPosition] == 'u')) {
								getNextUnicodeChar();
							} else {
								if (withoutUnicodePtr != 0) {
									withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;
								}
							}
						}
						if (!Character.isDigit(currentCharacter))
							throw new InvalidInputException(INVALID_FLOAT);
						while (getNextCharAsDigit()) {};
					}
					if (getNextChar('f', 'F') >= 0)
						return TokenNameFloatingPointLiteral;
					getNextChar('d', 'D'); //jump over potential d or D
					return TokenNameDoubleLiteral;
				} else {
					return TokenNameIntegerLiteral;
				}
			}
		} else {
			/* carry on */
		}
	}

	while (getNextCharAsDigit()) {};

	if ((!dotPrefix) && (getNextChar('l', 'L') >= 0))
		return TokenNameLongLiteral;

	if ((!dotPrefix) && (getNextChar('.'))) { //decimal part that can be empty
		while (getNextCharAsDigit()) {};
		floating = true;
	}

	//if floating is true both exponant and suffix may be optional

	if (getNextChar('e', 'E') >= 0) {
		floating = true;
		// consume next character
		unicodeAsBackSlash = false;
		if (((currentCharacter = source[currentPosition++]) == '\\')
			&& (source[currentPosition] == 'u')) {
			getNextUnicodeChar();
		} else {
			if (withoutUnicodePtr != 0) {
				withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;
			}
		}

		if ((currentCharacter == '-')
			|| (currentCharacter == '+')) { // consume next character
			unicodeAsBackSlash = false;
			if (((currentCharacter = source[currentPosition++]) == '\\')
				&& (source[currentPosition] == 'u')) {
				getNextUnicodeChar();
			} else {
				if (withoutUnicodePtr != 0) {
					withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;
				}
			}
		}
		if (!Character.isDigit(currentCharacter))
			throw new InvalidInputException(INVALID_FLOAT);
		while (getNextCharAsDigit()) {};
	}

	if (getNextChar('d', 'D') >= 0)
		return TokenNameDoubleLiteral;
	if (getNextChar('f', 'F') >= 0)
		return TokenNameFloatingPointLiteral;

	//the long flag has been tested before

	return floating ? TokenNameDoubleLiteral : TokenNameIntegerLiteral;
}

