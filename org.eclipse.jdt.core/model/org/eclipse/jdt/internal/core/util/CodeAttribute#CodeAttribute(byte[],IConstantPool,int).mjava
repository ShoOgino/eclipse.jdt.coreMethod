	CodeAttribute(byte[] classFileBytes, IConstantPool constantPool, int offset) throws ClassFormatException {
		super(classFileBytes, constantPool, offset);
		this.classFileBytes = classFileBytes;
		this.constantPool = constantPool;
		this.maxStack = u2At(classFileBytes, 6, offset);
		this.maxLocals = u2At(classFileBytes, 8, offset);
		this.codeLength = u4At(classFileBytes, 10, offset);
		this.codeOffset = offset + 14;
		int readOffset = (int) (14 + this.codeLength);
		this.exceptionTableLength = u2At(classFileBytes, readOffset, offset);
		readOffset += 2;
		if (this.exceptionTableLength != 0) {
			this.exceptionTableEntries = new ExceptionTableEntry[this.exceptionTableLength];
			for (int i = 0; i < this.exceptionTableLength; i++) {
				this.exceptionTableEntries [i] = new ExceptionTableEntry(classFileBytes, constantPool, offset + readOffset);
				readOffset += 8;
			}
		} else {
			this.exceptionTableEntries = noExceptionTable;
		}
		this.attributesCount = u2At(classFileBytes, readOffset, offset);
		readOffset += 2;
		for (int i = 0; i < this.attributesCount; i++) {
			IConstantPoolEntry constantPoolEntry = constantPool.decodeEntry(u2At(classFileBytes, readOffset, offset));
			if (constantPoolEntry.getKind() != IConstantPoolConstant.CONSTANT_Utf8) {
				throw new ClassFormatException(ClassFormatException.INVALID_CONSTANT_POOL_ENTRY);
			}
			char[] attributeName = constantPoolEntry.getUtf8Value();
			if (equals(attributeName, IAttributeNamesConstants.LINE_NUMBER)) {
				this.lineNumberAttribute = new LineNumberAttribute(classFileBytes, constantPool, offset + readOffset);
			} else if (equals(attributeName, IAttributeNamesConstants.LOCAL_VARIABLE)) {
				this.localVariableAttribute = new LocalVariableAttribute(classFileBytes, constantPool, offset + readOffset);
			}
			readOffset += (6 + u4At(classFileBytes, readOffset + 2, offset));
		}
		
	}

