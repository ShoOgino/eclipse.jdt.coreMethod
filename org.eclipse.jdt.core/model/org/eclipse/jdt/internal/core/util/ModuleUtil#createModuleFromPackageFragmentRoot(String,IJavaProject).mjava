	private static IModuleDescription createModuleFromPackageFragmentRoot(String moduleName, IJavaProject project) throws CoreException {

		ModuleAccumulatorEnvironment environment = new ModuleAccumulatorEnvironment(project);
		Compiler compiler = newCompiler(environment, project);
		LocalModuleImpl module = new LocalModuleImpl(moduleName == null ? project.getElementName() : moduleName);
		List<IModuleDescription.IPackageExport> exports = new ArrayList<>();
		// First go over the binary roots and see if any of them are modules
		List<IModuleDescription.IModuleReference> required = new ArrayList<>();
		Set<org.eclipse.jdt.internal.compiler.env.ICompilationUnit> toCompile = new HashSet<>();
		IPackageFragmentRoot[] roots = project.getPackageFragmentRoots();
		for (IPackageFragmentRoot root : roots) {
			if (root.getKind() == IPackageFragmentRoot.K_SOURCE) {
				IJavaElement[] children = root.getChildren();
				for (IJavaElement child : children) {
					if (child instanceof IPackageFragment) {
						IPackageFragment fragment = (IPackageFragment) child;
						if (fragment.isDefaultPackage()) continue;
						ICompilationUnit[] units = fragment.getCompilationUnits();
						if (units.length != 0) {
							String pack = fragment.getElementName();
							exports.add(new LocalPackageExportImpl(pack, EMPTRY_STRING_ARRAY));
							for (ICompilationUnit iUnit : units) {
								org.eclipse.jdt.internal.compiler.env.ICompilationUnit sourceFile = 
										new BasicCompilationUnit(iUnit.getSource().toCharArray(), CharOperation.splitOn('.', pack.toCharArray()), iUnit.getPath().toOSString());
								toCompile.add(sourceFile);
							}
						}
					}
				}
			}
		}

		org.eclipse.jdt.internal.compiler.env.ICompilationUnit[] sources = new org.eclipse.jdt.internal.compiler.env.ICompilationUnit[toCompile.size()];
		toCompile.toArray(sources);
		compiler.compile(sources);
		Collections.sort(exports, new Comparator<IModuleDescription.IPackageExport>() {
			@Override
			public int compare(IModuleDescription.IPackageExport o1, IModuleDescription.IPackageExport o2) {
				return o1.getPackageName().compareTo(
						o2.getPackageName());
			}
		});
		IModuleDescription.IPackageExport[] packs = new IModuleDescription.IPackageExport[exports.size()];
		packs = exports.toArray(packs);
		module.setExports(packs);
		String[] mods = environment.getModules();
		for (String string : mods) {
			required.add(new LocalModuleReferenceImpl(string, false));
		}
		Collections.sort(required, new Comparator<IModuleDescription.IModuleReference>() {
			@Override
			public int compare(IModuleDescription.IModuleReference o1, IModuleDescription.IModuleReference o2) {
				return new String(o1.getModuleName()).compareTo(new String(o2.getModuleName()));
			}
		});
		IModuleDescription.IModuleReference[] refs = new IModuleDescription.IModuleReference[required.size()];
		refs = required.toArray(refs);
		module.setRequiredModules(refs);
		return module;
	}

