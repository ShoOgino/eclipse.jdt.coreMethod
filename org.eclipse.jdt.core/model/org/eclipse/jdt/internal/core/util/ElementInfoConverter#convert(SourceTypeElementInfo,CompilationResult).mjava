	/*
	 * Convert a source type info into a parsed type declaration
	 */
	private TypeDeclaration convert(SourceTypeElementInfo sourceType, CompilationResult compilationResult) {
		
		/* create type declaration - can be member type, local type or anonymous type */
		TypeDeclaration type = new TypeDeclaration(compilationResult);
		if (sourceType.getEnclosingType() == null) {
			IType typeHandle = sourceType.getHandle();
			try {
				if (typeHandle.isAnonymous()) {
					type.name = TypeDeclaration.ANONYMOUS_EMPTY_NAME;
					type.bits |= ASTNode.AnonymousAndLocalMask;
				} else {
					if (typeHandle.isLocal()) {
						type.bits |= ASTNode.IsLocalTypeMASK;
					}
				}
			} catch (JavaModelException e) {
				// could not figure, assume toplevel
			}
		}  else {
			type.bits |= ASTNode.IsMemberTypeMASK;
		}
		if ((type.bits & ASTNode.IsAnonymousTypeMASK) == 0) {
			type.name = sourceType.getName();
		}
		int start, end; // only positions available
		type.sourceStart = start = sourceType.getNameSourceStart();
		type.sourceEnd = end = sourceType.getNameSourceEnd();
		type.modifiers = sourceType.getModifiers();
		type.declarationSourceStart = sourceType.getDeclarationSourceStart();
		type.declarationSourceEnd = sourceType.getDeclarationSourceEnd();
		type.bodyEnd = type.declarationSourceEnd;

		/* set superclass and superinterfaces */
		if (sourceType.getSuperclassName() != null) {
			type.superclass = createTypeReference(sourceType.getSuperclassName(), start, end);
			type.superclass.bits |= ASTNode.IsSuperType;
		}
		char[][] interfaceNames = sourceType.getInterfaceNames();
		int interfaceCount = interfaceNames == null ? 0 : interfaceNames.length;
		type.superInterfaces = new TypeReference[interfaceCount];
		for (int i = 0; i < interfaceCount; i++) {
			type.superInterfaces[i] = createTypeReference(interfaceNames[i], start, end);
			type.superInterfaces[i].bits |= ASTNode.IsSuperType;
		}
		
		/* convert member types */
		ISourceType[] sourceMemberTypes = sourceType.getMemberTypes();
		int sourceMemberTypeCount =
			sourceMemberTypes == null ? 0 : sourceMemberTypes.length;
		type.memberTypes = new TypeDeclaration[sourceMemberTypeCount];
		for (int i = 0; i < sourceMemberTypeCount; i++) {
			type.memberTypes[i] = convert((SourceTypeElementInfo)sourceMemberTypes[i], compilationResult);
		}
		
		/* convert fields and initializers */
		ISourceField[] sourceFields = sourceType.getFields();
		int sourceFieldCount = sourceFields == null ? 0 : sourceFields.length;
		InitializerElementInfo[] initializers = null;
		int initializerCount = 0;
		if (this.needLocalTypes) {
			initializers = sourceType.getInitializers();
			initializerCount = initializers.length;
			type.fields = new FieldDeclaration[initializerCount + sourceFieldCount];
			for (int i = 0; i < initializerCount; i++) {
				type.fields[i] = convert(initializers[i], compilationResult);
			}
		} else {
			type.fields = new FieldDeclaration[sourceFieldCount];
		}
		int length = initializerCount + sourceFieldCount;
		int index = 0;
		for (int i = initializerCount; i < length; i++) {
			type.fields[i] = convert((SourceFieldElementInfo)sourceFields[index++], compilationResult);
		}

		/* convert methods - need to add default constructor if necessary */
		ISourceMethod[] sourceMethods = sourceType.getMethods();
		int sourceMethodCount = sourceMethods == null ? 0 : sourceMethods.length;

		/* source type has a constructor ?           */
		/* by default, we assume that one is needed. */
		int neededCount = 0;
		if (!type.isInterface()) {
			neededCount = 1;
			for (int i = 0; i < sourceMethodCount; i++) {
				if (sourceMethods[i].isConstructor()) {
					neededCount = 0;
					// Does not need the extra constructor since one constructor already exists.
					break;
				}
			}
		}
		type.methods = new AbstractMethodDeclaration[sourceMethodCount + neededCount];
		if (neededCount != 0) { // add default constructor in first position
			type.methods[0] = type.createsInternalConstructor(false, false);
		}
		boolean isInterface = type.isInterface();
		for (int i = 0; i < sourceMethodCount; i++) {
			AbstractMethodDeclaration method =convert((SourceMethodElementInfo)sourceMethods[i], compilationResult);
			if (isInterface || method.isAbstract()) { // fix-up flag 
				method.modifiers |= AccSemicolonBody;
			}
			type.methods[neededCount + i] = method;
		}

		return type;
	}

