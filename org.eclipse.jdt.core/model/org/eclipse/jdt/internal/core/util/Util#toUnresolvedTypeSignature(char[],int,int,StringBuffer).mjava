	/*
	 * "Ljava/awt/geom/Point2D$Double;" => "QPoint2D.Double;"
	 * "[Ljava/awt/geom/Point2D$Double;" => "[QPoint2D.Double;"
	 * "[La/A$B<Ljava/lang/String;>;" => "[QA.B<QString;>;"
	 */
	private static void toUnresolvedTypeSignature(char[] signature, int start, int length, StringBuffer buffer) {
		int slashPosition = start;
		boolean hasDollar = false;
		boolean record = true;
		for (int i = start; i < length; i++) {
			char currentChar = signature[i];
			switch(currentChar) {
				case Signature.C_TYPE_VARIABLE :
					buffer.append(Signature.C_UNRESOLVED);
					slashPosition = i + 1;
					record = false;
					break;
				case Signature.C_RESOLVED :
					buffer.append(Signature.C_UNRESOLVED);
					slashPosition = i + 1;
					record = false;
					// find the end of the fully qualified name
					break;
				case Signature.C_DOLLAR :
					hasDollar = true;
					break;
				case Signature.C_GENERIC_START :
					// dump last identifier part
					if (hasDollar) {
						for (int j = slashPosition; j < i; j++) {
							char current = signature[j];
							if (current == Signature.C_DOLLAR) {
								buffer.append(Signature.C_DOT);
							} else {
								buffer.append(current);
							}
						}
						hasDollar = false;
					} else {
						buffer.append(signature, slashPosition, i - slashPosition);
					}
					slashPosition = -1;
					// recurse on the generic type
					buffer.append(Signature.C_GENERIC_START);
					break;
				case '/' :
					slashPosition = i + 1;
					break;
				case Signature.C_GENERIC_END :
				case Signature.C_COLON :
				case Signature.C_CAPTURE :
				case Signature.C_EXTENDS :
				case Signature.C_EXCEPTION_START :
				case Signature.C_SUPER :
				case Signature.C_STAR :
					buffer.append(currentChar);
					break;
				case Signature.C_BOOLEAN :
				case Signature.C_BYTE :
				case Signature.C_CHAR :
				case Signature.C_DOUBLE :
				case Signature.C_FLOAT :
				case Signature.C_INT :
				case Signature.C_LONG:
				case Signature.C_SHORT :
					if (record) {
						buffer.append(currentChar);
					}
					break;
				case Signature.C_ARRAY :
					buffer.append(currentChar);
					record = true;
					break;
				case Signature.C_SEMICOLON :
					if (slashPosition != -1) {
						if (hasDollar) {
							for (int j = slashPosition; j < i; j++) {
								char current = signature[j];
								if (current == Signature.C_DOLLAR) {
									buffer.append(Signature.C_DOT);
								} else {
									buffer.append(current);
								}
							}
							hasDollar = false;
						} else {
							buffer.append(signature, slashPosition, i - slashPosition);
						}
						slashPosition = -1;
					}
					buffer.append(currentChar);
					break;
			}
		}
	}

