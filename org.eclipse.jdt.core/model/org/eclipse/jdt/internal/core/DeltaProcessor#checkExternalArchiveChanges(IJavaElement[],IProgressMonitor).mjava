	/**
	 * Check all external archive (referenced by given roots, projects or model) status and issue a corresponding root delta.
	 * Also triggers index updates
	 */
	public void checkExternalArchiveChanges(IJavaElement[] refreshedElements, IProgressMonitor monitor) throws JavaModelException {
		try {
			HashMap externalArchivesStatus = new HashMap();
			JavaModel model = manager.getJavaModel();			
			
			// find JARs to refresh
			HashSet archivePathsToRefresh = new HashSet();
			for (int i = 0, elementsLength = refreshedElements.length; i < elementsLength; i++){
				IJavaElement element = refreshedElements[i];
				switch(element.getElementType()){
					case IJavaElement.PACKAGE_FRAGMENT_ROOT :
						archivePathsToRefresh.add(element.getPath());
						break;
					case IJavaElement.JAVA_PROJECT :
						IClasspathEntry[] classpath = ((IJavaProject) element).getResolvedClasspath(true);
						for (int j = 0, cpLength = classpath.length; j < cpLength; j++){
							if (classpath[j].getEntryKind() == IClasspathEntry.CPE_LIBRARY){
								archivePathsToRefresh.add(classpath[j].getPath());
							}
						}
						break;
					case IJavaElement.JAVA_MODEL :
						IJavaProject[] projects = manager.getJavaModel().getOldJavaProjectsList();
						for (int j = 0, projectsLength = projects.length; j < projectsLength; j++){
							classpath = ((IJavaProject) projects[j]).getResolvedClasspath(true);
							for (int k = 0, cpLength = classpath.length; k < cpLength; k++){
								if (classpath[k].getEntryKind() == IClasspathEntry.CPE_LIBRARY){
									archivePathsToRefresh.add(classpath[k].getPath());
								}
							}
						}
						break;
				}
			}
			// perform refresh
			fCurrentDelta = new JavaElementDelta(model);
			boolean hasDelta = false;

			IJavaProject[] projects = manager.getJavaModel().getOldJavaProjectsList();
			for (int i = 0, length = projects.length; i < length; i++) {
				
				if (monitor != null && monitor.isCanceled()) return; 
				
				IJavaProject project = projects[i];
				IClasspathEntry[] entries = project.getResolvedClasspath(true);
				for (int j = 0; j < entries.length; j++){
					if (entries[j].getEntryKind() == IClasspathEntry.CPE_LIBRARY) {
						
						IPath entryPath = entries[j].getPath();
						
						if (!archivePathsToRefresh.contains(entryPath)) continue; // not supposed to be refreshed
						
						String status = (String)externalArchivesStatus.get(entryPath); 
						if (status == null){
							
							// compute shared status
							Object targetLibrary = JavaModel.getTarget(project.getProject(), entryPath, true);

							if (targetLibrary == null){ // missing JAR
								if (this.externalTimeStamps.containsKey(entryPath)){
									this.externalTimeStamps.remove(entryPath);
									externalArchivesStatus.put(entryPath, EXTERNAL_JAR_REMOVED);
									// the jar was physically removed: remove the index
									indexManager.removeIndex(entryPath);
								}

							} else if (targetLibrary instanceof File){ // external JAR

								File externalFile = (File)targetLibrary;
								
								// check timestamp to figure if JAR has changed in some way
								Long oldTimestamp =(Long) this.externalTimeStamps.get(entryPath);
								long newTimeStamp = getTimeStamp(externalFile);
								if (oldTimestamp != null){

									if (newTimeStamp == 0){ // file doesn't exist
										externalArchivesStatus.put(entryPath, EXTERNAL_JAR_REMOVED);
										this.externalTimeStamps.remove(entryPath);
										// remove the index
										indexManager.removeIndex(entryPath);

									} else if (oldTimestamp.longValue() != newTimeStamp){
										externalArchivesStatus.put(entryPath, EXTERNAL_JAR_CHANGED);
										this.externalTimeStamps.put(entryPath, new Long(newTimeStamp));
										// first remove the index so that it is forced to be re-indexed
										indexManager.removeIndex(entryPath);
										// then index the jar
										indexManager.indexLibrary(entryPath, project.getProject());
									} else {
										externalArchivesStatus.put(entryPath, EXTERNAL_JAR_UNCHANGED);
									}
								} else {
									if (newTimeStamp == 0){ // jar still doesn't exist
										externalArchivesStatus.put(entryPath, EXTERNAL_JAR_UNCHANGED);
									} else {
										externalArchivesStatus.put(entryPath, EXTERNAL_JAR_ADDED);
										this.externalTimeStamps.put(entryPath, new Long(newTimeStamp));
										// index the new jar
										indexManager.indexLibrary(entryPath, project.getProject());
									}
								}
							} else { // internal JAR
								externalArchivesStatus.put(entryPath, INTERNAL_JAR_IGNORE);
							}
						}
						// according to computed status, generate a delta
						status = (String)externalArchivesStatus.get(entryPath); 
						if (status != null){
							PackageFragmentRoot root = (PackageFragmentRoot)project.getPackageFragmentRoot(entryPath.toString());
							if (status == EXTERNAL_JAR_ADDED){
								if (VERBOSE){
									System.out.println("- External JAR ADDED, affecting root: "+root.getElementName()); //$NON-NLS-1$
								} 
								elementAdded(root, null);
								hasDelta = true;
							} else if (status == EXTERNAL_JAR_CHANGED) {
								if (VERBOSE){
									System.out.println("- External JAR CHANGED, affecting root: "+root.getElementName()); //$NON-NLS-1$
								}
								contentChanged(root, null);
								hasDelta = true;
							} else if (status == EXTERNAL_JAR_REMOVED) {
								if (VERBOSE){
									System.out.println("- External JAR REMOVED, affecting root: "+root.getElementName()); //$NON-NLS-1$
								}
								elementRemoved(root, null);
								hasDelta = true;
							}
						}
					}
				}
			}
			if (hasDelta){
				this.manager.fire(fCurrentDelta, JavaModelManager.DEFAULT_CHANGE_EVENT);			
			}
		} finally {
			fCurrentDelta = null;
			if (monitor != null) monitor.done();
		}
	}

