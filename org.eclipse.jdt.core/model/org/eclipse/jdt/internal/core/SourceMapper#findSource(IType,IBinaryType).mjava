	/**
	 * Locates and returns source code for the given (binary) type, in this
	 * SourceMapper's ZIP file, or returns <code>null</code> if source
	 * code cannot be found.
	 */
	public char[] findSource(IType type, IBinaryType info) {
		char[] sourceFileName = info.sourceFileName();
		if (sourceFileName == null)
			return null; // no source file attribute
		String name = new String(sourceFileName);

		IPackageFragment pkgFrag = type.getPackageFragment();
		if (!pkgFrag.isDefaultPackage()) {
			String pkg = type.getPackageFragment().getElementName().replace('.', '/');
			name = pkg + '/' + name;
		}
		// try to get the entry
		ZipEntry entry = null;
		ZipFile zip = null;
		char[] source = null;
		try {
			String fullName;
			//add the root path if specified
			if (!fRootPath.equals(IPackageFragmentRoot.DEFAULT_PACKAGEROOT_PATH)) {
				fullName = fRootPath + '/' + name;
			} else {
				fullName = name;
			}
			zip = getZip();
			entry = zip.getEntry(fullName);
			if (entry != null) {
				// now read the source code
				byte[] bytes = null;
				try {
					bytes = Util.getZipEntryByteContent(entry, zip);
				} catch (IOException e) {
				}
				if (bytes != null) {
					try {
						source = Util.bytesToChar(bytes, this.encoding);
					} catch (IOException e) {
						source = null;
					}
				}
			}
		} catch (CoreException e) {
			return null;
		} finally {
			if (zip != null && JavaModelManager.getJavaModelManager().zipFiles == null) {
				try {
					zip.close();
				} catch (IOException e) {
				}
			}
		}
		return source;
	}

