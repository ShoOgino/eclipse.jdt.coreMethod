/**
 * Locates and returns source code for the given (binary) type, in this
 * SourceMapper's ZIP file, or returns <code>null</code> if source
 * code cannot be found.
 */
public char[] findSource(IType type, IBinaryType info) {
	String name = null;
	// see 1FVVWZT
	if (info instanceof ClassFileReader) {
		char[] sourceFileName = ((ClassFileReader) info).sourceFileName();
		if (sourceFileName == null)
			return null; // no source file attribute
		name = new String(sourceFileName);
	} else {
		return null;
	}

	IPackageFragment pkgFrag = type.getPackageFragment();
	if (!pkgFrag.isDefaultPackage()) {
		String pkg= type.getPackageFragment().getElementName().replace('.', '/');
		name= pkg + '/' + name;
	}
	// try to get the entry
	ZipEntry entry= null;
	ZipFile zip = null;
	char[] source= null;
	try {
		String fullName;
		//add the root path if specified
		if (!fRootPath.equals(IPackageFragmentRoot.DEFAULT_PACKAGEROOT_PATH)) {
			fullName= fRootPath + '/' + name;
		} else {
			fullName= name;
		}
		zip = getZip();
		entry= zip.getEntry(fullName);
		if (entry != null) {
			// now read the source code
			byte[] bytes= readEntry(zip, entry);
			if (bytes != null) {
				try {
					source= BufferManager.bytesToChar(bytes);
				} catch (JavaModelException e) {
					source= null;
				}
			}
		}
	} catch (CoreException e) {
		return null;
	} finally {
		if (zip != null) {
			try {
				zip.close();
			} catch(IOException e) {}
		}
	}
	return source;
}

