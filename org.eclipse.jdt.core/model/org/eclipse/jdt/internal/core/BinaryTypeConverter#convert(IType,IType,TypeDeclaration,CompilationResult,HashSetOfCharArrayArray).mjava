	private static TypeDeclaration convert(IType type, IType alreadyComputedMember,TypeDeclaration alreadyComputedMemberDeclaration, CompilationResult compilationResult, HashSetOfCharArrayArray typeNames) throws JavaModelException {
		/* create type declaration - can be member type */
		TypeDeclaration typeDeclaration = new TypeDeclaration(compilationResult);

		if (type.getDeclaringType() != null) {
			typeDeclaration.bits |= ASTNode.IsMemberType;
		}
		typeDeclaration.name = type.getElementName().toCharArray();
		typeDeclaration.modifiers = type.getFlags();


		/* set superclass and superinterfaces */
		if (type.getSuperclassName() != null) {
			TypeReference typeReference = createTypeReference(type.getSuperclassName().toCharArray(), typeNames);
			if (typeReference != null) {
				typeDeclaration.superclass = typeReference;
				typeDeclaration.superclass.bits |= ASTNode.IsSuperType;
			}
		}
		
		String[] interfaceNames = type.getSuperInterfaceNames();
		int interfaceCount = interfaceNames == null ? 0 : interfaceNames.length;
		typeDeclaration.superInterfaces = new TypeReference[interfaceCount];
		int count = 0;
		for (int i = 0; i < interfaceCount; i++) {
			TypeReference typeReference = createTypeReference(interfaceNames[i].toCharArray(), typeNames);
			if (typeReference != null) {
				typeDeclaration.superInterfaces[count] = typeReference;
				typeDeclaration.superInterfaces[count++].bits |= ASTNode.IsSuperType;
			}
		}
		if (count != interfaceCount) {
			System.arraycopy(typeDeclaration.fields, 0, typeDeclaration.superInterfaces = new TypeReference[interfaceCount], 0, interfaceCount);
		}
		
		/* convert member types */
		IType[] memberTypes = type.getTypes();
		int memberTypeCount =	memberTypes == null ? 0 : memberTypes.length;
		typeDeclaration.memberTypes = new TypeDeclaration[memberTypeCount];
		for (int i = 0; i < memberTypeCount; i++) {
			if(alreadyComputedMember != null && alreadyComputedMember.getFullyQualifiedName().equals(memberTypes[i].getFullyQualifiedName())) {
				typeDeclaration.memberTypes[i] = alreadyComputedMemberDeclaration;
			} else {
				typeDeclaration.memberTypes[i] = convert(memberTypes[i], null, null, compilationResult, typeNames);
			}
		}

		/* convert fields */
		IField[] fields = type.getFields();
		int fieldCount = fields == null ? 0 : fields.length;
		typeDeclaration.fields = new FieldDeclaration[fieldCount];
		count = 0;
		for (int i = 0; i < fieldCount; i++) {
			FieldDeclaration fieldDeclaration = convert(fields[i], type, typeNames);
			if (fieldDeclaration != null) {
				typeDeclaration.fields[count++] = fieldDeclaration;
			}
		}
		if (count != fieldCount) {
			System.arraycopy(typeDeclaration.fields, 0, typeDeclaration.fields = new FieldDeclaration[count], 0, count);
		}

		/* convert methods - need to add default constructor if necessary */
		IMethod[] methods = type.getMethods();
		int methodCount = methods == null ? 0 : methods.length;

		/* source type has a constructor ?           */
		/* by default, we assume that one is needed. */
		int neededCount = 1;
		for (int i = 0; i < methodCount; i++) {
			if (methods[i].isConstructor()) {
				neededCount = 0;
				// Does not need the extra constructor since one constructor already exists.
				break;
			}
		}
		boolean isInterface = type.isInterface();
		neededCount = isInterface ? 0 : neededCount;
		typeDeclaration.methods = new AbstractMethodDeclaration[methodCount + neededCount];
		if (neededCount != 0) { // add default constructor in first position
			typeDeclaration.methods[0] = typeDeclaration.createDefaultConstructor(false, false);
		}
		boolean hasAbstractMethods = false;
		count = 0;
		for (int i = 0; i < methodCount; i++) {
			AbstractMethodDeclaration method = convert(methods[i], type, compilationResult, typeNames);
			if (method != null) {
				boolean isAbstract;
				if ((isAbstract = method.isAbstract()) || isInterface) { // fix-up flag 
					method.modifiers |= ExtraCompilerModifiers.AccSemicolonBody;
				}
				if (isAbstract) {
					hasAbstractMethods = true;
				}
				typeDeclaration.methods[neededCount + (count++)] = method;
			}
		}
		if (count != methodCount) {
			System.arraycopy(typeDeclaration.methods, 0, typeDeclaration.methods = new AbstractMethodDeclaration[count + neededCount], 0, count + neededCount);
		}
		if (hasAbstractMethods) {
			typeDeclaration.bits |= ASTNode.HasAbstractMethods;
		}
		return typeDeclaration;
	}

