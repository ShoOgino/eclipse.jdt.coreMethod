/*
 * Update the bodyStart of the corresponding parse node
 */
public void notifySourceElementRequestor(AbstractMethodDeclaration methodDeclaration) {

	// range check
	boolean isInRange = 
				scanner.initialPosition <= methodDeclaration.declarationSourceStart
				&& scanner.eofPosition >= methodDeclaration.declarationSourceEnd;

	if (methodDeclaration.isClinit()) {
		this.visitIfNeeded(methodDeclaration);
		return;
	}

	if (methodDeclaration.isDefaultConstructor()) {
		if (reportReferenceInfo) {
			ConstructorDeclaration constructorDeclaration = (ConstructorDeclaration) methodDeclaration;
			ExplicitConstructorCall constructorCall = constructorDeclaration.constructorCall;
			if (constructorCall != null) {
				switch(constructorCall.accessMode) {
					case ExplicitConstructorCall.This :
						requestor.acceptConstructorReference(
							typeNames[nestedTypeIndex-1],
							constructorCall.arguments == null ? 0 : constructorCall.arguments.length, 
							constructorCall.sourceStart);
						break;
					case ExplicitConstructorCall.Super :
					case ExplicitConstructorCall.ImplicitSuper :					
						requestor.acceptConstructorReference(
							superTypeNames[nestedTypeIndex-1],
							constructorCall.arguments == null ? 0 : constructorCall.arguments.length, 
							constructorCall.sourceStart);
						break;
				}
			}
		}	
		return;	
	}	
	char[][] argumentTypes = null;
	char[][] argumentNames = null;
	Argument[] arguments = methodDeclaration.arguments;
	if (arguments != null) {
		int argumentLength = arguments.length;
		argumentTypes = new char[argumentLength][];
		argumentNames = new char[argumentLength][];
		for (int i = 0; i < argumentLength; i++) {
			argumentTypes[i] = CharOperation.concatWith(arguments[i].type.getParameterizedTypeName(), '.');
			argumentNames[i] = arguments[i].name;
		}
	}
	char[][] thrownExceptionTypes = null;
	TypeReference[] thrownExceptions = methodDeclaration.thrownExceptions;
	if (thrownExceptions != null) {
		int thrownExceptionLength = thrownExceptions.length;
		thrownExceptionTypes = new char[thrownExceptionLength][];
		for (int i = 0; i < thrownExceptionLength; i++) {
			thrownExceptionTypes[i] = 
				CharOperation.concatWith(thrownExceptions[i].getParameterizedTypeName(), '.'); 
		}
	}
	// by default no selector end position
	int selectorSourceEnd = -1;
	if (methodDeclaration.isConstructor()) {
		if (methodDeclaration instanceof SourceConstructorDeclaration) {
			selectorSourceEnd = 
				((SourceConstructorDeclaration) methodDeclaration).selectorSourceEnd; 
		}
		if (isInRange){
			TypeParameter[] typeParameters = methodDeclaration.typeParameters();
			char[][] typeParameterNames = null;
			char[][][] typeParameterBounds = null;
			if (typeParameters != null) {
				int typeParametersLength = typeParameters.length;
				typeParameterNames = new char[typeParametersLength][];
				typeParameterBounds = new char[typeParametersLength][][];
				for (int i = 0; i < typeParametersLength; i++) {
					typeParameterNames[i] = typeParameters[i].name;
					TypeReference[] bounds = typeParameters[i].bounds;
					if (bounds != null) {
						int boundLength = bounds.length;
						char[][] boundNames = new char[boundLength][];
						for (int j = 0; j < boundLength; j++) {
							boundNames[j] = 
								CharOperation.concatWith(bounds[j].getParameterizedTypeName(), '.'); 
						}
						typeParameterBounds[i] = boundNames;
					}
				}
			}			
			requestor.enterConstructor(
				methodDeclaration.declarationSourceStart, 
				methodDeclaration.modifiers, 
				methodDeclaration.selector, 
				methodDeclaration.sourceStart, 
				selectorSourceEnd, 
				argumentTypes, 
				argumentNames, 
				thrownExceptionTypes,
				typeParameterNames,
				typeParameterBounds);
		}
		if (reportReferenceInfo) {
			ConstructorDeclaration constructorDeclaration = (ConstructorDeclaration) methodDeclaration;
			ExplicitConstructorCall constructorCall = constructorDeclaration.constructorCall;
			if (constructorCall != null) {
				switch(constructorCall.accessMode) {
					case ExplicitConstructorCall.This :
						requestor.acceptConstructorReference(
							typeNames[nestedTypeIndex-1],
							constructorCall.arguments == null ? 0 : constructorCall.arguments.length, 
							constructorCall.sourceStart);
						break;
					case ExplicitConstructorCall.Super :
					case ExplicitConstructorCall.ImplicitSuper :
						requestor.acceptConstructorReference(
							superTypeNames[nestedTypeIndex-1],
							constructorCall.arguments == null ? 0 : constructorCall.arguments.length, 
							constructorCall.sourceStart);
						break;
				}
			}
		}
		this.visitIfNeeded(methodDeclaration);
		if (isInRange){
			requestor.exitConstructor(methodDeclaration.declarationSourceEnd);
		}
		return;
	}
	if (methodDeclaration instanceof SourceMethodDeclaration) {
		selectorSourceEnd = 
			((SourceMethodDeclaration) methodDeclaration).selectorSourceEnd; 
	}
	if (isInRange) {
		TypeParameter[] typeParameters = methodDeclaration.typeParameters();
		char[][] typeParameterNames = null;
		char[][][] typeParameterBounds = null;
		if (typeParameters != null) {
			int typeParametersLength = typeParameters.length;
			typeParameterNames = new char[typeParametersLength][];
			typeParameterBounds = new char[typeParametersLength][][];
			for (int i = 0; i < typeParametersLength; i++) {
				typeParameterNames[i] = typeParameters[i].name;
				TypeReference[] bounds = typeParameters[i].bounds;
				if (bounds != null) {
					int boundLength = bounds.length;
					char[][] boundNames = new char[boundLength][];
					for (int j = 0; j < boundLength; j++) {
						boundNames[j] = 
							CharOperation.concatWith(bounds[j].getParameterizedTypeName(), '.'); 
					}
					typeParameterBounds[i] = boundNames;
				}
			}
		}
		int currentModifiers = methodDeclaration.modifiers;
		boolean deprecated = (currentModifiers & AccDeprecated) != 0; // remember deprecation so as to not lose it below
		if (methodDeclaration instanceof MethodDeclaration) {
			TypeReference returnType = ((MethodDeclaration) methodDeclaration).returnType;
			requestor.enterMethod(
				methodDeclaration.declarationSourceStart, 
				deprecated ? (currentModifiers & AccJustFlag) | AccDeprecated : currentModifiers & AccJustFlag, 
				returnType == null ? null : CharOperation.concatWith(returnType.getParameterizedTypeName(), '.'),
				methodDeclaration.selector, 
				methodDeclaration.sourceStart, 
				selectorSourceEnd, 
				argumentTypes, 
				argumentNames, 
				thrownExceptionTypes,
				typeParameterNames,
				typeParameterBounds);
		} else {
			TypeReference returnType = ((AnnotationTypeMemberDeclaration) methodDeclaration).returnType;
			requestor.enterMethod(
				methodDeclaration.declarationSourceStart, 
				deprecated ? (currentModifiers & AccJustFlag) | AccDeprecated : currentModifiers & AccJustFlag, 
				returnType == null ? null : CharOperation.concatWith(returnType.getParameterizedTypeName(), '.'),
				methodDeclaration.selector, 
				methodDeclaration.sourceStart, 
				selectorSourceEnd, 
				argumentTypes, 
				argumentNames, 
				thrownExceptionTypes,
				typeParameterNames,
				typeParameterBounds);
		}
	}		
		
	this.visitIfNeeded(methodDeclaration);

	if (isInRange){	
		requestor.exitMethod(methodDeclaration.declarationSourceEnd);
	}
}

