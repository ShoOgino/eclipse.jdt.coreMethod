/**
 * INTERNAL USE ONLY
 */
protected TypeReference typeReference(
	int dim,
	int localIdentifierPtr,
	int localIdentifierLengthPtr) {
	/* build a Reference on a variable that may be qualified or not
	 * This variable is a type reference and dim will be its dimensions.
	 * We don't have any side effect on the stacks' pointers.
	 */
	Annotation [][] annotationsOnDimensions = dim == 0 ? null : getAnnotationsOnDimensions(dim);
	int length;
	TypeReference ref;
	if ((length = this.identifierLengthStack[localIdentifierLengthPtr]) == 1) {
		// single variable reference
		if (dim == 0) {
			ref =
				new SingleTypeReference(
					this.identifierStack[localIdentifierPtr],
					this.identifierPositionStack[localIdentifierPtr--]);
		} else {
			ref =
				new ArrayTypeReference(
					this.identifierStack[localIdentifierPtr],
					dim,
					annotationsOnDimensions,
					this.identifierPositionStack[localIdentifierPtr--]);
			ref.sourceEnd = this.endPosition;
		}
	} else {
		if (length < 0) { //flag for precompiled type reference on base types
			ref = TypeReference.baseTypeReference(-length, dim, annotationsOnDimensions);
			ref.sourceStart = this.intStack[this.localIntPtr--];
			if (dim == 0) {
				ref.sourceEnd = this.intStack[this.localIntPtr--];
			} else {
				this.localIntPtr--;
				ref.sourceEnd = this.endPosition;
			}
		} else { //Qualified variable reference
			char[][] tokens = new char[length][];
			localIdentifierPtr -= length;
			long[] positions = new long[length];
			System.arraycopy(this.identifierStack, localIdentifierPtr + 1, tokens, 0, length);
			System.arraycopy(
				this.identifierPositionStack,
				localIdentifierPtr + 1,
				positions,
				0,
				length);
			if (dim == 0)
				ref = new QualifiedTypeReference(tokens, positions);
			else
				ref = new ArrayQualifiedTypeReference(tokens, dim, annotationsOnDimensions, positions);
		}
	}
	return ref;
}

