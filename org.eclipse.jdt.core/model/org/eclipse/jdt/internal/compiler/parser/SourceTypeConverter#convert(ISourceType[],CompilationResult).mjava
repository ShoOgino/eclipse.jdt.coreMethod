	/*
	 * Convert a set of source element types into a parsed compilation unit declaration
	 * The argument types are then all grouped in the same unit. The argument types must 
	 * at least contain one type.
	 */
	private CompilationUnitDeclaration convert(ISourceType[] sourceTypes, CompilationResult compilationResult) {
		this.unit = new CompilationUnitDeclaration(this.problemReporter, compilationResult, 0);
		// not filled at this point

		if (sourceTypes.length == 0) return this.unit;
		SourceTypeElementInfo typeInfo = (SourceTypeElementInfo) sourceTypes[0];
		this.source = (ICompilationUnit) typeInfo.getHandle().getCompilationUnit();

		/* only positions available */
		int start = typeInfo.getNameSourceStart();
		int end = typeInfo.getNameSourceEnd();

		/* convert package and imports */
		if (typeInfo.getPackageName() != null
			&& typeInfo.getPackageName().length > 0)
			// if its null then it is defined in the default package
			this.unit.currentPackage =
				createImportReference(typeInfo.getPackageName(), start, end, false, AccDefault);
		ISourceImport[]  sourceImports = typeInfo.getImports();
		int importCount = sourceImports.length;
		this.unit.imports = new ImportReference[importCount];
		for (int i = 0; i < importCount; i++) {
			ISourceImport sourceImport = sourceImports[i];
			this.unit.imports[i] = createImportReference(
				sourceImport.getName(), 
				sourceImport.getDeclarationSourceStart(),
				sourceImport.getDeclarationSourceEnd(),
				sourceImport.onDemand(),
				sourceImport.getModifiers());
		}
		/* convert type(s) */
		int typeCount = sourceTypes.length;
		this.unit.types = new TypeDeclaration[typeCount];
		for (int i = 0; i < typeCount; i++) {
			this.unit.types[i] =
				convert((SourceTypeElementInfo) sourceTypes[i], compilationResult);
		}
		return this.unit;
	}

