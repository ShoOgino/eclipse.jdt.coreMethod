	/*
	 * Convert a field source element into a parsed field declaration
	 */
	private FieldDeclaration convert(SourceFieldElementInfo fiieldInfo, TypeDeclaration type, CompilationResult compilationResult) {

		FieldDeclaration field = new FieldDeclaration();

		int start = fiieldInfo.getNameSourceStart();
		int end = fiieldInfo.getNameSourceEnd();

		field.name = fiieldInfo.getName();
		field.sourceStart = start;
		field.sourceEnd = end;
		field.declarationSourceStart = fiieldInfo.getDeclarationSourceStart();
		field.declarationSourceEnd = fiieldInfo.getDeclarationSourceEnd();
		int modifiers = fiieldInfo.getModifiers();
		boolean isEnumConstant = (modifiers & AccEnum) != 0;
		if (isEnumConstant) {
			field.modifiers = modifiers & ~Flags.AccEnum; // clear AccEnum bit onto AST (binding will add it)
		} else {
			field.modifiers = modifiers;
			field.type = createTypeReference(fiieldInfo.getTypeName(), start, end);
		}

		/* conversion of field constant */
		if ((this.flags & FIELD_INITIALIZATION) != 0) {
			char[] initializationSource = fiieldInfo.getInitializationSource();
			if (initializationSource != null) {
				if (this.parser == null) {
					this.parser = new Parser(this.problemReporter, true);
				}
				this.parser.parse(field, type, this.unit, initializationSource);
			}
		}
		
		/* conversion of local and anonymous types */
		if ((this.flags & LOCAL_TYPE) != 0) {
			IJavaElement[] children = fiieldInfo.getChildren();
			int childrenLength = children.length;
			if (childrenLength > 0) {
				ArrayInitializer initializer = new ArrayInitializer();
				field.initialization = initializer;
				Expression[] expressions = new Expression[childrenLength];
				initializer.expressions = expressions;
				for (int i = 0; i < childrenLength; i++) {
					IJavaElement localType = children[i];
					try {
						TypeDeclaration anonymousLocalTypeDeclaration = convert((SourceTypeElementInfo)((JavaElement)localType).getElementInfo(), compilationResult);
						QualifiedAllocationExpression expression = new QualifiedAllocationExpression(anonymousLocalTypeDeclaration);
						expression.type = anonymousLocalTypeDeclaration.superclass;
						anonymousLocalTypeDeclaration.superclass = null;
						anonymousLocalTypeDeclaration.superInterfaces = null;
						anonymousLocalTypeDeclaration.allocation = expression;
						anonymousLocalTypeDeclaration.modifiers &= ~AccEnum; // remove tag in case this is the init of an enum constant
						expressions[i] = expression;
					} catch (JavaModelException e) {
						// ignore
					}
				}
			}
		}
		return field;
	}

