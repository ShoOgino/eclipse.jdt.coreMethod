public void notifySourceElementRequestor(TypeDeclaration typeDeclaration, boolean notifyTypePresence) {
   
   // range check
   boolean isInRange = 
            scanner.initialPosition <= typeDeclaration.declarationSourceStart
            && scanner.eofPosition >= typeDeclaration.declarationSourceEnd;
   
   FieldDeclaration[] fields = typeDeclaration.fields;
   AbstractMethodDeclaration[] methods = typeDeclaration.methods;
   TypeDeclaration[] memberTypes = typeDeclaration.memberTypes;
   int fieldCounter = fields == null ? 0 : fields.length;
   int methodCounter = methods == null ? 0 : methods.length;
   int memberTypeCounter = memberTypes == null ? 0 : memberTypes.length;
   int fieldIndex = 0;
   int methodIndex = 0;
   int memberTypeIndex = 0;
 
   if (notifyTypePresence){
      char[][] interfaceNames = null;
      int superInterfacesLength = 0;
      TypeReference[] superInterfaces = typeDeclaration.superInterfaces;
      if (superInterfaces != null) {
         superInterfacesLength = superInterfaces.length;
         interfaceNames = new char[superInterfacesLength][];
      } else {
         if ((typeDeclaration.bits & ASTNode.IsAnonymousTypeMASK) != 0) {
            // see PR 3442
            QualifiedAllocationExpression alloc = typeDeclaration.allocation;
            if (alloc != null && alloc.type != null) {
               superInterfaces = new TypeReference[] { alloc.type};
               superInterfacesLength = 1;
               interfaceNames = new char[1][];
            }
         }
      }
      if (superInterfaces != null) {
         for (int i = 0; i < superInterfacesLength; i++) {
            interfaceNames[i] = 
               CharOperation.concatWith(superInterfaces[i].getParameterizedTypeName(), '.'); 
         }
      }
      switch (typeDeclaration.getKind()) {
         case IGenericType.CLASS :
         case IGenericType.ANNOTATION_TYPE :
            TypeReference superclass = typeDeclaration.superclass;
            if (superclass == null) {
               if (isInRange){
                  requestor.enterClass(
                     typeDeclaration.declarationSourceStart, 
                     typeDeclaration.modifiers, 
                     typeDeclaration.name, 
                     typeDeclaration.sourceStart, 
                     sourceEnd(typeDeclaration), 
                     null, 
                     interfaceNames);
               }
            } else {
               if (isInRange){
                  requestor.enterClass(
                     typeDeclaration.declarationSourceStart, 
                     typeDeclaration.modifiers, 
                     typeDeclaration.name, 
                     typeDeclaration.sourceStart, 
                     sourceEnd(typeDeclaration), 
                     CharOperation.concatWith(superclass.getParameterizedTypeName(), '.'), 
                     interfaceNames);
               }
            }
            notifySourceElementRequestor(typeDeclaration.typeParameters);         
            if (nestedTypeIndex == typeNames.length) {
               // need a resize
               System.arraycopy(typeNames, 0, (typeNames = new char[nestedTypeIndex * 2][]), 0, nestedTypeIndex);
               System.arraycopy(superTypeNames, 0, (superTypeNames = new char[nestedTypeIndex * 2][]), 0, nestedTypeIndex);
            }
            typeNames[nestedTypeIndex] = typeDeclaration.name;
            superTypeNames[nestedTypeIndex++] = superclass == null ? TypeConstants.CharArray_JAVA_LANG_OBJECT : CharOperation.concatWith(superclass.getParameterizedTypeName(), '.');
            break;
 
         case IGenericType.INTERFACE :
            if (isInRange){
               int currentModifiers = typeDeclaration.modifiers;
               boolean deprecated = (currentModifiers & AccDeprecated) != 0; // remember deprecation so as to not lose it below
               requestor.enterInterface(
                  typeDeclaration.declarationSourceStart, 
                  deprecated ? (currentModifiers & AccJustFlag) | AccDeprecated : currentModifiers & AccJustFlag, 
                  typeDeclaration.name, 
                  typeDeclaration.sourceStart, 
                  sourceEnd(typeDeclaration), 
                  interfaceNames);
            }
            notifySourceElementRequestor(typeDeclaration.typeParameters);         
            if (nestedTypeIndex == typeNames.length) {
               // need a resize
               System.arraycopy(typeNames, 0, (typeNames = new char[nestedTypeIndex * 2][]), 0, nestedTypeIndex);
               System.arraycopy(superTypeNames, 0, (superTypeNames = new char[nestedTypeIndex * 2][]), 0, nestedTypeIndex);
            }
            typeNames[nestedTypeIndex] = typeDeclaration.name;
            superTypeNames[nestedTypeIndex++] = TypeConstants.CharArray_JAVA_LANG_OBJECT;
            break;
 
         case IGenericType.ENUM :
 
            if (isInRange){
               int currentModifiers = typeDeclaration.modifiers;
               boolean deprecated = (currentModifiers & AccDeprecated) != 0; // remember deprecation so as to not lose it below
               requestor.enterEnum(
                  typeDeclaration.declarationSourceStart, 
                  deprecated ? (currentModifiers & AccJustFlag) | AccDeprecated : currentModifiers & AccJustFlag, 
                  typeDeclaration.name, 
                  typeDeclaration.sourceStart, 
                  sourceEnd(typeDeclaration), 
                  interfaceNames);
            }
            notifySourceElementRequestor(typeDeclaration.typeParameters);         
            if (nestedTypeIndex == typeNames.length) {
               // need a resize
               System.arraycopy(typeNames, 0, (typeNames = new char[nestedTypeIndex * 2][]), 0, nestedTypeIndex);
               System.arraycopy(superTypeNames, 0, (superTypeNames = new char[nestedTypeIndex * 2][]), 0, nestedTypeIndex);
            }
            typeNames[nestedTypeIndex] = typeDeclaration.name;
            superTypeNames[nestedTypeIndex++] = TypeConstants.CharArray_JAVA_LANG_ENUM;
            break;
 
//         case IGenericType.ANNOTATION_TYPE :
            // TODO need support
//            break;
      }      
   }
   while ((fieldIndex < fieldCounter)
      || (memberTypeIndex < memberTypeCounter)
      || (methodIndex < methodCounter)) {
      FieldDeclaration nextFieldDeclaration = null;
      AbstractMethodDeclaration nextMethodDeclaration = null;
      TypeDeclaration nextMemberDeclaration = null;
 
      int position = Integer.MAX_VALUE;
      int nextDeclarationType = -1;
      if (fieldIndex < fieldCounter) {
         nextFieldDeclaration = fields[fieldIndex];
         if (nextFieldDeclaration.declarationSourceStart < position) {
            position = nextFieldDeclaration.declarationSourceStart;
            nextDeclarationType = 0; // FIELD
         }
      }
      if (methodIndex < methodCounter) {
         nextMethodDeclaration = methods[methodIndex];
         if (nextMethodDeclaration.declarationSourceStart < position) {
            position = nextMethodDeclaration.declarationSourceStart;
            nextDeclarationType = 1; // METHOD
         }
      }
      if (memberTypeIndex < memberTypeCounter) {
         nextMemberDeclaration = memberTypes[memberTypeIndex];
         if (nextMemberDeclaration.declarationSourceStart < position) {
            position = nextMemberDeclaration.declarationSourceStart;
            nextDeclarationType = 2; // MEMBER
         }
      }
      switch (nextDeclarationType) {
         case 0 :
            fieldIndex++;
            notifySourceElementRequestor(nextFieldDeclaration);
            break;
         case 1 :
            methodIndex++;
            notifySourceElementRequestor(nextMethodDeclaration);
            break;
         case 2 :
            memberTypeIndex++;
            notifySourceElementRequestor(nextMemberDeclaration, true);
      }
   }
   if (notifyTypePresence){
      if (isInRange){
         switch (typeDeclaration.getKind()) {
            case IGenericType.CLASS :
            case IGenericType.ANNOTATION_TYPE :
               requestor.exitClass(typeDeclaration.declarationSourceEnd);
               break;
            case IGenericType.INTERFACE :
               requestor.exitInterface(typeDeclaration.declarationSourceEnd);
               break;
            case IGenericType.ENUM :
               requestor.exitEnum(typeDeclaration.declarationSourceEnd);
               break;
/*            case IGenericType.ANNOTATION_TYPE :
               // TODO need support
               //requestor.exitAnnotationType(typeDeclaration.declarationSourceEnd);
               break;*/
         }         
      }
      nestedTypeIndex--;
   }
}

