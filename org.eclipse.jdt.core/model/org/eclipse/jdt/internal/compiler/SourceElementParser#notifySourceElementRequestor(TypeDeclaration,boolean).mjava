public void notifySourceElementRequestor(TypeDeclaration typeDeclaration, boolean notifyTypePresence) {
	
	// range check
	boolean isInRange = 
				scanner.initialPosition <= typeDeclaration.declarationSourceStart
				&& scanner.eofPosition >= typeDeclaration.declarationSourceEnd;
	
	FieldDeclaration[] fields = typeDeclaration.fields;
	AbstractMethodDeclaration[] methods = typeDeclaration.methods;
	TypeDeclaration[] memberTypes = typeDeclaration.memberTypes;
	int fieldCounter = fields == null ? 0 : fields.length;
	int methodCounter = methods == null ? 0 : methods.length;
	int memberTypeCounter = memberTypes == null ? 0 : memberTypes.length;
	int fieldIndex = 0;
	int methodIndex = 0;
	int memberTypeIndex = 0;
	boolean isInterface = typeDeclaration.isInterface();

	if (notifyTypePresence){
		char[][] interfaceNames = null;
		int superInterfacesLength = 0;
		TypeReference[] superInterfaces = typeDeclaration.superInterfaces;
		if (superInterfaces != null) {
			superInterfacesLength = superInterfaces.length;
			interfaceNames = new char[superInterfacesLength][];
		} else {
			if ((typeDeclaration.bits & ASTNode.IsAnonymousTypeMASK) != 0) {
				// see PR 3442
				QualifiedAllocationExpression alloc = typeDeclaration.allocation;
				if (alloc != null && alloc.type != null) {
					superInterfaces = new TypeReference[] { typeDeclaration.allocation.type};
					superInterfacesLength = 1;
					interfaceNames = new char[1][];
				}
			}
		}
		if (superInterfaces != null) {
			for (int i = 0; i < superInterfacesLength; i++) {
				interfaceNames[i] = 
					CharOperation.concatWith(superInterfaces[i].getParameterizedTypeName(), '.'); 
			}
		}
		TypeParameter[] typeParameters = typeDeclaration.typeParameters;
		char[][] typeParameterNames = null;
		char[][][] typeParameterBounds = null;
		if (typeParameters != null) {
			int typeParametersLength = typeParameters.length;
			typeParameterNames = new char[typeParametersLength][];
			typeParameterBounds = new char[typeParametersLength][][];
			for (int i = 0; i < typeParametersLength; i++) {
				typeParameterNames[i] = typeParameters[i].name;
				TypeReference[] bounds = typeParameters[i].bounds;
				if (bounds != null) {
					int boundLength = bounds.length;
					char[][] boundNames = new char[boundLength][];
					for (int j = 0; j < boundLength; j++) {
						boundNames[j] = 
							CharOperation.concatWith(bounds[i].getParameterizedTypeName(), '.'); 
					}
					typeParameterBounds[i] = boundNames;
				}
			}
		}
		if (isInterface) {
			if (isInRange){
				int currentModifiers = typeDeclaration.modifiers;
				boolean deprecated = (currentModifiers & AccDeprecated) != 0; // remember deprecation so as to not lose it below
				requestor.enterInterface(
					typeDeclaration.declarationSourceStart, 
					deprecated ? (currentModifiers & AccJustFlag) | AccDeprecated : currentModifiers & AccJustFlag, 
					typeDeclaration.name, 
					typeDeclaration.sourceStart, 
					sourceEnd(typeDeclaration), 
					interfaceNames,
					typeParameterNames,
					typeParameterBounds);
			}
			if (nestedTypeIndex == typeNames.length) {
				// need a resize
				System.arraycopy(typeNames, 0, (typeNames = new char[nestedTypeIndex * 2][]), 0, nestedTypeIndex);
				System.arraycopy(superTypeNames, 0, (superTypeNames = new char[nestedTypeIndex * 2][]), 0, nestedTypeIndex);
			}
			typeNames[nestedTypeIndex] = typeDeclaration.name;
			superTypeNames[nestedTypeIndex++] = JAVA_LANG_OBJECT;
		} else {
			TypeReference superclass = typeDeclaration.superclass;
			if (superclass == null) {
				if (isInRange){
					requestor.enterClass(
						typeDeclaration.declarationSourceStart, 
						typeDeclaration.modifiers, 
						typeDeclaration.name, 
						typeDeclaration.sourceStart, 
						sourceEnd(typeDeclaration), 
						null, 
						interfaceNames,
						typeParameterNames,
						typeParameterBounds);
				}
			} else {
				if (isInRange){
					requestor.enterClass(
						typeDeclaration.declarationSourceStart, 
						typeDeclaration.modifiers, 
						typeDeclaration.name, 
						typeDeclaration.sourceStart, 
						sourceEnd(typeDeclaration), 
						CharOperation.concatWith(superclass.getParameterizedTypeName(), '.'), 
						interfaceNames,
						typeParameterNames,
						typeParameterBounds);
				}
			}
			if (nestedTypeIndex == typeNames.length) {
				// need a resize
				System.arraycopy(typeNames, 0, (typeNames = new char[nestedTypeIndex * 2][]), 0, nestedTypeIndex);
				System.arraycopy(superTypeNames, 0, (superTypeNames = new char[nestedTypeIndex * 2][]), 0, nestedTypeIndex);
			}
			typeNames[nestedTypeIndex] = typeDeclaration.name;
			superTypeNames[nestedTypeIndex++] = superclass == null ? JAVA_LANG_OBJECT : CharOperation.concatWith(superclass.getParameterizedTypeName(), '.');
		}
	}
	while ((fieldIndex < fieldCounter)
		|| (memberTypeIndex < memberTypeCounter)
		|| (methodIndex < methodCounter)) {
		FieldDeclaration nextFieldDeclaration = null;
		AbstractMethodDeclaration nextMethodDeclaration = null;
		TypeDeclaration nextMemberDeclaration = null;

		int position = Integer.MAX_VALUE;
		int nextDeclarationType = -1;
		if (fieldIndex < fieldCounter) {
			nextFieldDeclaration = fields[fieldIndex];
			if (nextFieldDeclaration.declarationSourceStart < position) {
				position = nextFieldDeclaration.declarationSourceStart;
				nextDeclarationType = 0; // FIELD
			}
		}
		if (methodIndex < methodCounter) {
			nextMethodDeclaration = methods[methodIndex];
			if (nextMethodDeclaration.declarationSourceStart < position) {
				position = nextMethodDeclaration.declarationSourceStart;
				nextDeclarationType = 1; // METHOD
			}
		}
		if (memberTypeIndex < memberTypeCounter) {
			nextMemberDeclaration = memberTypes[memberTypeIndex];
			if (nextMemberDeclaration.declarationSourceStart < position) {
				position = nextMemberDeclaration.declarationSourceStart;
				nextDeclarationType = 2; // MEMBER
			}
		}
		switch (nextDeclarationType) {
			case 0 :
				fieldIndex++;
				notifySourceElementRequestor(nextFieldDeclaration);
				break;
			case 1 :
				methodIndex++;
				notifySourceElementRequestor(nextMethodDeclaration);
				break;
			case 2 :
				memberTypeIndex++;
				notifySourceElementRequestor(nextMemberDeclaration, true);
		}
	}
	if (notifyTypePresence){
		if (isInRange){
			if (isInterface) {
				requestor.exitInterface(typeDeclaration.declarationSourceEnd);
			} else {
				requestor.exitClass(typeDeclaration.declarationSourceEnd);
			}
		}
		nestedTypeIndex--;
	}
}

