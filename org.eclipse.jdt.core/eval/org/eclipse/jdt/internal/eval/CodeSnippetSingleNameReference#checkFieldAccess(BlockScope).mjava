	/**
	 * Check and/or redirect the field access to the delegate receiver if any
	 */
	public TypeBinding checkFieldAccess(BlockScope scope) {

		if (delegateThis == null)
			return super.checkFieldAccess(scope);

		FieldBinding fieldBinding = (FieldBinding) binding;
		bits &= ~RestrictiveFlagMASK; // clear bits
		bits |= FIELD;
		if (!fieldBinding.isStatic()) {
			// must check for the static status....
			if (this.evaluationContext.isStatic) {
				scope.problemReporter().staticFieldAccessToNonStaticVariable(
					this,
					fieldBinding);
				constant = NotAConstant;
				return null;
			}
		}
		constant = FieldReference.getConstantFor(fieldBinding, true, this, 0);
		if (isFieldUseDeprecated(fieldBinding, scope))
			scope.problemReporter().deprecatedField(fieldBinding, this);
		// if the binding declaring class is not visible, need special action
		// for runtime compatibility on 1.2 VMs : change the declaring class of the binding
		if (fieldBinding.declaringClass != null
			&& fieldBinding.constant == NotAConstant
			&& !fieldBinding.declaringClass.canBeSeenBy(scope)) {
			binding = new FieldBinding(fieldBinding, scope.enclosingSourceType());
		}
		return fieldBinding.type;

	}

