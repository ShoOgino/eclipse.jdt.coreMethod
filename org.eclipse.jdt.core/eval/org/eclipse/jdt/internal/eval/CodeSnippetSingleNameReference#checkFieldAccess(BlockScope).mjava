/**
 * Check and/or redirect the field access to the delegate receiver if any
 */
public TypeBinding checkFieldAccess(BlockScope scope) {

	if (delegateThis == null) return super.checkFieldAccess(scope);
	
	FieldBinding fieldBinding = (FieldBinding) binding;
	bits &= ~RestrictiveFlagMASK; // clear bits
	bits |= FIELD;
	if (!fieldBinding.isStatic()) {
		// must check for the static status....
		if (this.evaluationContext.isStatic) {
			scope.problemReporter().staticFieldAccessToNonStaticVariable(
				this,
				fieldBinding);
			constant = NotAConstant;
			return null;
		}
	}
	constant = FieldReference.getConstantFor(fieldBinding, true, this, 0);
	if (isFieldUseDeprecated(fieldBinding, scope))
		scope.problemReporter().deprecatedField(fieldBinding, this);

	// if the binding declaring class is not visible, need special action
	// for runtime compatibility on 1.2 VMs : change the declaring class of the binding
	// NOTE: from 1.4 on, field's declaring class is touched if any different from receiver type
	if (fieldBinding.declaringClass != this.actualReceiverType
		&& fieldBinding.declaringClass != null
		&& fieldBinding.constant == NotAConstant
		&& ((scope.environment().options.complianceLevel >= CompilerOptions.JDK1_4 && !fieldBinding.isStatic())
				//comply to jck lang/BINC/binc02301 (seems a bug)
			|| !fieldBinding.declaringClass.canBeSeenBy(scope))){
		binding = new FieldBinding(fieldBinding, (ReferenceBinding)this.actualReceiverType);
	}

	return fieldBinding.type;

}

