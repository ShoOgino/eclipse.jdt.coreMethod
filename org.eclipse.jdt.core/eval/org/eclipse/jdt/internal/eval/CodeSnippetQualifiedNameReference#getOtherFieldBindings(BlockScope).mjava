public TypeBinding getOtherFieldBindings(BlockScope scope) {
	// At this point restrictiveFlag may ONLY have two potential value : FIELD LOCAL (i.e cast <<(VariableBinding) binding>> is valid)

	if ((bits & FIELD) != 0) {
		if (!((FieldBinding) binding).isStatic()) { //must check for the static status....
			if (indexOfFirstFieldBinding == 1) {
				//the field is the first token of the qualified reference....
				if (scope.methodScope().isStatic) {
					scope.problemReporter().staticFieldAccessToNonStaticVariable(this, (FieldBinding) binding);
					return null;
				}
			} else { //accessing to a field using a type as "receiver" is allowed only with static field	
				scope.problemReporter().staticFieldAccessToNonStaticVariable(this, (FieldBinding) binding);
				return null;
			}
		}
		if (isFieldUseDeprecated((FieldBinding) binding, scope))
			scope.problemReporter().deprecatedField((FieldBinding) binding, this);

		// if the binding declaring class is not visible, need special action
		// for runtime compatibility on 1.2 VMs : change the declaring class of the binding
		// NOTE: from 1.4 on, field's declaring class is touched if any different from receiver type		
		FieldBinding fieldBinding = (FieldBinding)binding;
		if (delegateThis == null) {
			if (fieldBinding.declaringClass != this.actualReceiverType
				&& fieldBinding.declaringClass != null
				&& fieldBinding.constant == NotAConstant
				&& ((scope.environment().options.complianceLevel >= CompilerOptions.JDK1_4
						&& (indexOfFirstFieldBinding > 1 || !fieldBinding.isStatic()))
					|| !fieldBinding.declaringClass.canBeSeenBy(scope))){
				binding = new FieldBinding(fieldBinding, (ReferenceBinding)this.actualReceiverType);
			}
		} else {
			CodeSnippetScope localScope = new CodeSnippetScope(scope);
			if (fieldBinding.declaringClass != delegateThis.type
				&& !delegateThis.type.isArrayType()			
				&& fieldBinding.declaringClass != null
				&& fieldBinding.constant == NotAConstant
				&& ((scope.environment().options.complianceLevel >= CompilerOptions.JDK1_4
						&& (indexOfFirstFieldBinding > 1 || !fieldBinding.isStatic()))
					|| !localScope.canBeSeenByForCodeSnippet(fieldBinding.declaringClass, (ReferenceBinding) delegateThis.type))) {
					binding = new FieldBinding(fieldBinding, (ReferenceBinding) delegateThis.type);
			}
		}
	}

	TypeBinding type = ((VariableBinding) binding).type;
	int index = indexOfFirstFieldBinding;
	int length = tokens.length;
	if (index == length) { //	restrictiveFlag == FIELD
		constant = FieldReference.getConstantFor((FieldBinding) binding, false, this, index - 1);
		return type;
	}

	// allocation of the fieldBindings array	and its respective constants
	int otherBindingsLength = length - index;
	otherBindings = new FieldBinding[otherBindingsLength];
	
	// fill the first constant (the one of the binding)
	constant =
		((bits & FIELD) != 0)
			? FieldReference.getConstantFor((FieldBinding) binding, false, this, index - 1)
			: ((VariableBinding) binding).constant;

	// iteration on each field	
	while (index < length) {
		char[] token = tokens[index];
		if (type == null) return null; // could not resolve type prior to this point
		FieldBinding field = scope.getField(type, token, this);
		int place = index - indexOfFirstFieldBinding;
		otherBindings[place] = field;
		if (!field.isValidBinding()) {
			// try to retrieve the field as private field
			CodeSnippetScope localScope = new CodeSnippetScope(scope);
			if (delegateThis == null) {
				if (this.evaluationContext.declaringTypeName != null) {
					delegateThis = scope.getField(scope.enclosingSourceType(), DELEGATE_THIS, this);
					if (delegateThis == null){ ; // if not found then internal error, field should have been found
						return super.reportError(scope);
					}
				} else {
					return super.reportError(scope);
				}
			}
			field = localScope.getFieldForCodeSnippet(delegateThis.type, token, this);
			otherBindings[place] = field;
		}
		if (field.isValidBinding()) {
			if (isFieldUseDeprecated(field, scope))
				scope.problemReporter().deprecatedField(field, this);
			Constant someConstant = FieldReference.getConstantFor(field, false, this, place);
			// constant propagation can only be performed as long as the previous one is a constant too.
			if (constant != NotAConstant){
				constant = someConstant;
			}
			// if the binding declaring class is not visible, need special action
			// for runtime compatibility on 1.2 VMs : change the declaring class of the binding
			// NOTE: from 1.4 on, field's declaring class is touched if any different from receiver type			
			if (delegateThis == null) {
				if (field.declaringClass != type
					&& !type.isArrayType()				
					&& field.declaringClass != null // array.length
					&& field.constant == NotAConstant
					&& (scope.environment().options.complianceLevel >= CompilerOptions.JDK1_4					
						|| !field.declaringClass.canBeSeenBy(scope))) {
						otherBindings[place] = new FieldBinding(field, (ReferenceBinding)type);
				}
			} else {
				CodeSnippetScope localScope = new CodeSnippetScope(scope);
				if (field.declaringClass != type
					&& !type.isArrayType()
					&& field.declaringClass != null // array.length
					&& field.constant == NotAConstant
					&& (scope.environment().options.complianceLevel >= CompilerOptions.JDK1_4
						|| !localScope.canBeSeenByForCodeSnippet(field.declaringClass, (ReferenceBinding) delegateThis.type))){
					otherBindings[place] = new FieldBinding(field, (ReferenceBinding)type);
				}
			}
			type = field.type;
			index++;
		} else {
			constant = NotAConstant; //don't fill other constants slots...
			scope.problemReporter().invalidField(this, field, index, type);
			return null;
		}
	}
	return (otherBindings[otherBindingsLength - 1]).type;
}

