public TypeBinding resolveType(BlockScope scope) {
	// Propagate the type checking to the arguments, and check if the constructor is defined.
	constant = NotAConstant;
	TypeBinding typeBinding = type.resolveType(scope); // will check for null after args are resolved

	// buffering the arguments' types
	TypeBinding[] argumentTypes = NoParameters;
	if (arguments != null) {
		boolean argHasError = false;
		int length = arguments.length;
		argumentTypes = new TypeBinding[length];
		for (int i = 0; i < length; i++)
			if ((argumentTypes[i] = arguments[i].resolveType(scope)) == null)
				argHasError = true;
		if (argHasError)
			return typeBinding;
	}
	if (typeBinding == null)
		return null;

	if (!typeBinding.canBeInstantiated()) {
		scope.problemReporter().cannotInstantiate(type, typeBinding);
		return typeBinding;
	}
	ReferenceBinding allocatedType = (ReferenceBinding) typeBinding;
	if (!(binding = scope.getConstructor(allocatedType, argumentTypes, this)).isValidBinding()) {
		if (binding instanceof ProblemMethodBinding
			&& ((ProblemMethodBinding) binding).problemId() == NotVisible) {
			if (this.evaluationContext.declaringTypeName != null) {
				delegateThis = scope.getField(scope.enclosingSourceType(), DELEGATE_THIS, this);
				if (delegateThis == null) {
					if (binding.declaringClass == null)
						binding.declaringClass = allocatedType;
					scope.problemReporter().invalidConstructor(this, binding);
					return typeBinding;
				}
			} else {
				if (binding.declaringClass == null)
					binding.declaringClass = allocatedType;
				scope.problemReporter().invalidConstructor(this, binding);
				return typeBinding;
			}
			CodeSnippetScope localScope = new CodeSnippetScope(scope);			
			MethodBinding privateBinding = localScope.getConstructor((ReferenceBinding)delegateThis.type, argumentTypes, this);
			if (!privateBinding.isValidBinding()) {
				if (binding.declaringClass == null)
					binding.declaringClass = allocatedType;
				scope.problemReporter().invalidConstructor(this, binding);
				return typeBinding;
			} else {
				binding = privateBinding;
			}				
		} else {
			if (binding.declaringClass == null)
				binding.declaringClass = allocatedType;
			scope.problemReporter().invalidConstructor(this, binding);
			return typeBinding;
		}
	}
	if (isMethodUseDeprecated(binding, scope))
		scope.problemReporter().deprecatedMethod(binding, this);

	if (arguments != null)
		for (int i = 0; i < arguments.length; i++)
			arguments[i].implicitWidening(binding.parameters[i], argumentTypes[i]);
	return allocatedType;
}

