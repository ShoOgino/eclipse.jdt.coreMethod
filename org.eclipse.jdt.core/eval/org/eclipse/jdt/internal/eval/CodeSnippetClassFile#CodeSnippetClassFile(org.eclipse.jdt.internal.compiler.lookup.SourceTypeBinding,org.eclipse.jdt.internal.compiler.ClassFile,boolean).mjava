	/**
	 * CodeSnippetClassFile constructor comment.
	 * @param aType org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding
	 * @param enclosingClassFile org.eclipse.jdt.internal.compiler.ClassFile
	 * @param creatingProblemType boolean
	 */
	public CodeSnippetClassFile(
		org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding aType,
		org.eclipse.jdt.internal.compiler.ClassFile enclosingClassFile,
		boolean creatingProblemType) {
		/**
		 * INTERNAL USE-ONLY
		 * This methods creates a new instance of the receiver.
		 *
		 * @param aType org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding
		 * @param enclosingClassFile org.eclipse.jdt.internal.compiler.codegen.ClassFile
		 * @param creatingProblemType <CODE>boolean</CODE>
		 */
		referenceBinding = aType;
		header = new byte[INITIAL_HEADER_SIZE];
		// generate the magic numbers inside the header
		header[headerOffset++] = (byte) (0xCAFEBABEL >> 24);
		header[headerOffset++] = (byte) (0xCAFEBABEL >> 16);
		header[headerOffset++] = (byte) (0xCAFEBABEL >> 8);
		header[headerOffset++] = (byte) (0xCAFEBABEL >> 0);
		if (((SourceTypeBinding) referenceBinding)
			.scope
			.environment()
			.options
			.targetJDK
			== CompilerOptions.JDK1_2) {
			// Compatible with JDK 1.2
			header[headerOffset++] = 0;
			// minorVersion = 0 means we just need to offset the current offset by 2
			header[headerOffset++] = 0;
			header[headerOffset++] = 0;
			header[headerOffset++] = 46;
		} else {
			// Compatible with JDK 1.1
			header[headerOffset++] = 0;
			header[headerOffset++] = 3;
			header[headerOffset++] = 0;
			header[headerOffset++] = 45;
		}
		constantPoolOffset = headerOffset;
		headerOffset += 2;
		constantPool = new CodeSnippetConstantPool(this);
		int accessFlags = aType.getAccessFlags() | AccSuper;
		if (aType.isNestedType()) {
			if (aType.isStatic()) {
				// clear Acc_Static
				accessFlags &= ~AccStatic;
			}
			if (aType.isPrivate()) {
				// clear Acc_Private and Acc_Public
				accessFlags &= ~(AccPrivate | AccPublic);
			}
			if (aType.isProtected()) {
				// clear Acc_Protected and set Acc_Public
				accessFlags &= ~AccProtected;
				accessFlags |= AccPublic;
			}
		}
		// clear Acc_Strictfp
		accessFlags &= ~AccStrictfp;

		this.enclosingClassFile = enclosingClassFile;
		// innerclasses get their names computed at code gen time
		if (aType.isLocalType()) {
			((LocalTypeBinding) aType).constantPoolName(
				computeConstantPoolName((LocalTypeBinding) aType));
			ReferenceBinding[] memberTypes = aType.memberTypes();
			for (int i = 0, max = memberTypes.length; i < max; i++) {
				((LocalTypeBinding) memberTypes[i]).constantPoolName(
					computeConstantPoolName((LocalTypeBinding) memberTypes[i]));
			}
		}
		contents = new byte[INITIAL_CONTENTS_SIZE];
		// now we continue to generate the bytes inside the contents array
		contents[contentsOffset++] = (byte) (accessFlags >> 8);
		contents[contentsOffset++] = (byte) accessFlags;
		int classNameIndex = constantPool.literalIndex(aType);
		contents[contentsOffset++] = (byte) (classNameIndex >> 8);
		contents[contentsOffset++] = (byte) classNameIndex;
		int superclassNameIndex;
		if (aType.isInterface()) {
			superclassNameIndex = constantPool.literalIndexForJavaLangObject();
		} else {
			superclassNameIndex =
				(aType.superclass == null ? 0 : constantPool.literalIndex(aType.superclass));
		}
		contents[contentsOffset++] = (byte) (superclassNameIndex >> 8);
		contents[contentsOffset++] = (byte) superclassNameIndex;
		ReferenceBinding[] superInterfacesBinding = aType.superInterfaces();
		int interfacesCount = superInterfacesBinding.length;
		contents[contentsOffset++] = (byte) (interfacesCount >> 8);
		contents[contentsOffset++] = (byte) interfacesCount;
		if (superInterfacesBinding != null) {
			for (int i = 0; i < interfacesCount; i++) {
				int interfaceIndex = constantPool.literalIndex(superInterfacesBinding[i]);
				contents[contentsOffset++] = (byte) (interfaceIndex >> 8);
				contents[contentsOffset++] = (byte) interfaceIndex;
			}
		}
		produceDebugAttributes =
			((SourceTypeBinding) referenceBinding)
				.scope
				.environment()
				.options
				.produceDebugAttributes;
		innerClassesBindings = new ReferenceBinding[INNER_CLASSES_SIZE];
		this.creatingProblemType = creatingProblemType;
		codeStream = new CodeSnippetCodeStream(this);

		// retrieve the enclosing one guaranteed to be the one matching the propagated flow info
		// 1FF9ZBU: LFCOM:ALL - Local variable attributes busted (Sanity check)
		ClassFile outermostClassFile = this.outerMostEnclosingClassFile();
		if (this == outermostClassFile) {
			codeStream.maxFieldCount = aType.scope.referenceType().maxFieldCount;
		} else {
			codeStream.maxFieldCount = outermostClassFile.codeStream.maxFieldCount;
		}
	}

