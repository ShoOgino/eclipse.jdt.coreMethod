public void manageSyntheticAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo) {

	if (!flowInfo.isReachable()) return;

	// if method from parameterized type got found, use the original method at codegen time
	this.codegenBinding = this.binding.original();
	if (this.codegenBinding != this.binding) {
	    // extra cast needed if method return type was type variable
	    if (this.codegenBinding.returnType.isTypeVariable()) {
	        TypeVariableBinding variableReturnType = (TypeVariableBinding) this.codegenBinding.returnType;
	        if (variableReturnType.firstBound != this.binding.returnType) { // no need for extra cast if same as first bound anyway
			    this.valueCast = this.binding.returnType;
	        }
	    }
	} 
	
	// if the binding declaring class is not visible, need special action
	// for runtime compatibility on 1.2 VMs : change the declaring class of the binding
	// NOTE: from target 1.2 on, method's declaring class is touched if any different from receiver type
	// and not from Object or implicit static method call.	
	if (this.binding.declaringClass != this.actualReceiverType
		&& !this.actualReceiverType.isArrayType()
		&& ((currentScope.environment().options.targetJDK >= ClassFileConstants.JDK1_2
				&& (!this.receiver.isImplicitThis() || !this.codegenBinding.isStatic())
				&& this.binding.declaringClass.id != T_Object) // no change for Object methods
			|| !this.codegenBinding.declaringClass.canBeSeenBy(currentScope))) {
		this.codegenBinding = currentScope.enclosingSourceType().getUpdatedMethodBinding(this.codegenBinding, (ReferenceBinding) this.actualReceiverType.erasure());
	}	
}

