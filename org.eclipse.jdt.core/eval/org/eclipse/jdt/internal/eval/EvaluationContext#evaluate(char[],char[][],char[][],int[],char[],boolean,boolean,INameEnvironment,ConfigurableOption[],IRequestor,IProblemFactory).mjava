/**
 * @see org.eclipse.jdt.internal.eval.IEvaluationContext
 * @exception org.eclipse.jdt.internal.eval.InstallException if the code snippet class files could not be deployed.
 */
public void evaluate(
	char[] codeSnippet, 
	char[][] localVariableTypeNames,
	char[][] localVariableNames, 
	int[] localVariableModifiers,
	char[] declaringTypeName,
	boolean isStatic,
	boolean isConstructorCall,
	INameEnvironment environment, 
	ConfigurableOption[] options, 
	final IRequestor requestor, 
	IProblemFactory problemFactory) throws InstallException {

	// Initialialize context
	this.localVariableTypeNames = localVariableTypeNames;
	this.localVariableNames = localVariableNames;
	this.localVariableModifiers = localVariableModifiers;
	this.declaringTypeName = declaringTypeName;
	this.isStatic = isStatic;
	this.isConstructorCall = isConstructorCall;

	this.deployCodeSnippetClassIfNeeded(requestor);

	try {
		// Install new variables if needed
		class ForwardingRequestor implements IRequestor {
			boolean hasErrors = false;
			public boolean acceptClassFiles(ClassFile[] classFiles, char[] codeSnippetClassName) {
				return requestor.acceptClassFiles(classFiles, codeSnippetClassName);
			}
			public void acceptProblem(IProblem problem, char[] fragmentSource, int fragmentKind) {
				requestor.acceptProblem(problem, fragmentSource, fragmentKind);
				if (problem.isError()) {
					hasErrors = true;
				}
			}
		};
		ForwardingRequestor forwardingRequestor = new ForwardingRequestor();
		if (this.varsChanged) {
			evaluateVariables(environment, options, forwardingRequestor, problemFactory);
		}
		
		// Compile code snippet if there was no errors while evaluating the variables
		if (!forwardingRequestor.hasErrors) {
			Evaluator evaluator = 
				new CodeSnippetEvaluator(
					codeSnippet,
					this, 
					environment,
					options, 
					requestor, 
					problemFactory);
			ClassFile[] classes = null;
			if (TIMING) {
				long start = System.currentTimeMillis();
				classes = evaluator.getClasses();
				System.out.println("Time to compile ["/*nonNLS*/ + new String(codeSnippet) + "] was "/*nonNLS*/ + (System.currentTimeMillis() - start) + "ms"/*nonNLS*/);
			} else {
				classes = evaluator.getClasses();
			}
			// Send code snippet on target
			if (classes != null && classes.length > 0) {
				char[] simpleClassName = evaluator.getClassName();
				char[] packageName = this.getPackageName();
				char[] qualifiedClassName =
					packageName.length == 0 ?
						simpleClassName :
						CharOperation.concat(packageName, simpleClassName, '.');
				CODE_SNIPPET_COUNTER++;
				requestor.acceptClassFiles(classes, qualifiedClassName);
			}
		}
	} finally {
		// Reinitialize context to default values
		this.localVariableTypeNames = null;
		this.localVariableNames = null;
		this.localVariableModifiers = null;
		this.declaringTypeName = null;
		this.isStatic = true;
		this.isConstructorCall = false;
	}
}

