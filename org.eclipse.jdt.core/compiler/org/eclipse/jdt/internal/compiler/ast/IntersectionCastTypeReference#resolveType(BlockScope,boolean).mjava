	/* (non-Javadoc)
	 * @see org.eclipse.jdt.internal.compiler.ast.TypeReference#getTypeBinding(org.eclipse.jdt.internal.compiler.lookup.Scope)
	 */
	public TypeBinding resolveType(BlockScope scope, boolean checkBounds) {

		int length = this.typeReferences.length;
		ReferenceBinding[] intersectingTypes = new ReferenceBinding[length];
		boolean hasError = false;
		
		int typeCount = 0;
		nextType:
		for (int i = 0; i < length; i++) {
			final TypeReference typeReference = this.typeReferences[i];
			TypeBinding type = typeReference.resolveType(scope, checkBounds);
			if (type == null || ((type.tagBits & TagBits.HasMissingType) != 0)) {
				hasError = true;
				continue;
			}
			if (i == 0) {
				if (type.isBaseType()) { // rejected in grammar for i > 0
					scope.problemReporter().onlyReferenceTypesInIntersectionCast(typeReference);
					hasError = true;
					continue;
				}
				if (type.isArrayType()) { // javac rejects the pedantic cast: (X[] & Serializable & Cloneable) new X[0], what is good for the goose ...
					scope.problemReporter().illegalArrayTypeInIntersectionCast(typeReference);
					hasError = true;
					continue;
				}
			} else if (!type.isInterface()) {
				scope.problemReporter().boundMustBeAnInterface(typeReference, type);
				hasError = true;
				continue;
			}
			for (int j = 0; j < typeCount; j++) {
				final ReferenceBinding priorType = intersectingTypes[j];
				if (TypeBinding.equalsEquals(priorType, type)) {
					scope.problemReporter().duplicateBoundInIntersectionCast(typeReference);
					hasError = true;
					continue;
				}
				if (!priorType.isInterface())
					continue;
				if (type.findSuperTypeOriginatingFrom(priorType) != null) {
					intersectingTypes[j] = (ReferenceBinding) type;
					continue nextType;
				}
				if (priorType.findSuperTypeOriginatingFrom(type) != null)
					continue nextType;
			}
			intersectingTypes[typeCount++] = (ReferenceBinding) type;
		}
		if (hasError) {
			return null;
		}
		if (typeCount != length) {
			if (typeCount == 1) {
				return this.resolvedType = intersectingTypes[0];
			}
			System.arraycopy(intersectingTypes, 0, intersectingTypes = new ReferenceBinding[typeCount], 0, typeCount);
		}
		return (this.resolvedType = scope.environment().createIntersectionCastType(intersectingTypes));
	}

