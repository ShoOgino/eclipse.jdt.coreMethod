	private void validate(TypeReference serviceInf, TypeReference serviceImpl) {
		ReferenceBinding intf = (ReferenceBinding) serviceInf.resolvedType;
		ReferenceBinding impl = (ReferenceBinding) serviceImpl.resolvedType;
		int problemId = ProblemReasons.NoError;
		if (impl.isAbstract()) {
			problemId = ProblemReasons.ServiceImplCannotbeAbstract;
		} else if(impl.findSuperTypeOriginatingFrom(intf) == null) {
			this.scope.problemReporter().typeMismatchError(impl, intf, serviceImpl, null);
		}
		MethodBinding defaultConstructor = impl.getExactConstructor(new TypeBinding[0]);
		if (defaultConstructor == null || !defaultConstructor.isValidBinding()) {
			problemId = ProblemReasons.DefaultConstructorRequiredForServiceImpl;
		} else if (!defaultConstructor.isPublic()) {
			problemId = ProblemReasons.ServiceImplDefaultConstructorNotPublic;
		}
		if (problemId != ProblemReasons.NoError) {
			this.scope.problemReporter().invalidServiceImpl(problemId, serviceImpl);
		}
	}

