public void generateOptimizedStringBufferCreation(BlockScope blockScope, CodeStream codeStream, int typeID) {
	/* Optimized (java) code generation for string concatenations that involve StringBuffer
	 * creation: going through this path means that there is no need for a new StringBuffer
	 * creation, further operands should rather be only appended to the current one.
	 */

	// Optimization only for integers and strings

	if (typeID == T_Object) {
		// in the case the runtime value of valueOf(Object) returns null, we have to use append(Object) instead of directly valueOf(Object)
		// append(Object) returns append(valueOf(Object)), which means that the null case is handled by append(String).
		codeStream.newStringBuffer();
		codeStream.dup();
		codeStream.invokeStringBufferDefaultConstructor();
		generateCode(blockScope, codeStream, true);
		codeStream.invokeStringBufferAppendForType(T_Object);	
		return;
	}
	codeStream.newStringBuffer();
	codeStream.dup();
	if ((typeID == T_String) || (typeID == T_null)) {
		if (constant != NotAConstant) {
			codeStream.ldc(constant.stringValue());
		} else {
			generateCode(blockScope, codeStream, true);
			codeStream.invokeStringValueOf(T_Object);
		}
	} else {
		generateCode(blockScope, codeStream, true);
		codeStream.invokeStringValueOf(typeID);
	}
	codeStream.invokeStringBufferStringConstructor();
}

