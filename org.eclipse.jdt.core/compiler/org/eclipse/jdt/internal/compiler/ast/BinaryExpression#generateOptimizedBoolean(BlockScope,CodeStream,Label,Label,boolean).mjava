/**
 * Boolean operator code generation
 *	Optimized operations are: <, <=, >, >=, &, |, ^
 */
public void generateOptimizedBoolean(BlockScope currentScope, CodeStream codeStream, Label trueLabel, Label falseLabel, boolean valueRequired) {

	if ((constant != Constant.NotAConstant) && (constant.typeID() == T_boolean)) {
		int pc = codeStream.position;
		if (constant.booleanValue() == true) {
			// constant == true
			if (valueRequired) {
				if (falseLabel == null) {
					// implicit falling through the FALSE case
					if (trueLabel != null) {
						codeStream.goto_(trueLabel);
					}
				}
			}
		} else {
			if (valueRequired) {
				if (falseLabel != null) {
					// implicit falling through the TRUE case
					if (trueLabel == null) {
						codeStream.goto_(falseLabel);
					}
				}
			}
		}
		codeStream.recordPositionsFrom(pc, this);
		return;
	}
	switch((bits & OperatorMASK) >> OperatorSHIFT){
		case LESS : 
					generateOptimizedLessThan(currentScope, codeStream, trueLabel, falseLabel, valueRequired);
					return;
		case LESS_EQUAL : 
					generateOptimizedLessThanOrEqual(currentScope, codeStream, trueLabel, falseLabel, valueRequired);
					return;
		case GREATER : 
					generateOptimizedGreaterThan(currentScope, codeStream, trueLabel, falseLabel, valueRequired);
					return;
		case GREATER_EQUAL : 
					generateOptimizedGreaterThanOrEqual(currentScope, codeStream, trueLabel, falseLabel, valueRequired);
					return;
		case AND :
					generateOptimizedLogicalAnd(currentScope, codeStream, trueLabel, falseLabel, valueRequired);
					return;
		case OR :
					generateOptimizedLogicalOr(currentScope, codeStream, trueLabel, falseLabel, valueRequired);
					return;
		case XOR :
					generateOptimizedLogicalXor(currentScope, codeStream, trueLabel, falseLabel, valueRequired);
					return;
	}
	super.generateOptimizedBoolean(currentScope, codeStream, trueLabel, falseLabel, valueRequired);
}

