	public boolean tIsMoreSpecific(TypeBinding t, TypeBinding s) {
		/* 15.12.2.5 t is more specific than s iff ... Some of the checks here are redundant by the very fact of control reaching here, 
		   but have been left in for completeness/documentation sakes. These should be cheap anyways. 
		*/
		
		// Both t and s are functional interface types ... 
		MethodBinding tSam = t.getSingleAbstractMethod(this.enclosingScope);
		if (tSam == null || !tSam.isValidBinding())
			return false;
		MethodBinding sSam = s.getSingleAbstractMethod(this.enclosingScope);
		if (sSam == null || !sSam.isValidBinding())
			return false;
		
		// t should neither be a subinterface nor a superinterface of s
		if (t.findSuperTypeOriginatingFrom(s) != null || s.findSuperTypeOriginatingFrom(t) != null)
			return false;

		// The descriptor parameter types of t are the same as the descriptor parameter types of s.
		if (tSam.parameters.length != sSam.parameters.length)
			return false;
		for (int i = 0, length = tSam.parameters.length; i < length; i++) {
			if (tSam.parameters[i] != sSam.parameters[i])
				return false;
		}
		
		// Either the descriptor return type of s is void or ...
		if (sSam.returnType.id == TypeIds.T_void)
			return true;
		
		/* ... or the descriptor return type of the capture of T is more specific than the descriptor return type of S for 
		   an invocation expression of the same form as the method reference..
		*/
		Expression resultExpression = (Expression) this.resultExpressions.get(t); // should be same as for s
		
		t = t.capture(this.enclosingScope, this.sourceEnd);
		tSam = t.getSingleAbstractMethod(this.enclosingScope);
		return resultExpression.tIsMoreSpecific(tSam.returnType, sSam.returnType);
	}

