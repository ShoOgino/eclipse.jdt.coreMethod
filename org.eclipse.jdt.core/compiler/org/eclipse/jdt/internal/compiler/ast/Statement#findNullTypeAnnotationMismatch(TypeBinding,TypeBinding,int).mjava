// nullStatus: we are only interested in NULL or NON_NULL, -1 indicates that we are in a recursion, where flow info is ignored
protected static NullAnnotationStatus findNullTypeAnnotationMismatch(TypeBinding requiredType, TypeBinding providedType, int nullStatus) {
	int severity = 0;
	TypeBinding superTypeHint = null;
	if (requiredType instanceof ArrayBinding) {
		long[] requiredDimsTagBits = ((ArrayBinding)requiredType).nullTagBitsPerDimension;
		if (requiredDimsTagBits != null) {
			int dims = requiredType.dimensions();
			if (requiredType.dimensions() == providedType.dimensions()) {
				long[] providedDimsTagBits = ((ArrayBinding)providedType).nullTagBitsPerDimension;
				if (providedDimsTagBits == null) {
					severity = 1; // required is annotated, provided not, need unchecked conversion
				} else {
					for (int i=0; i<dims; i++) {
						long requiredBits = requiredDimsTagBits[i] & TagBits.AnnotationNullMASK;
						long providedBits = providedDimsTagBits[i] & TagBits.AnnotationNullMASK;
						if (i > 0)
							nullStatus = -1; // don't use beyond the outermost dimension
						severity = Math.max(severity, computeNullProblemSeverity(requiredBits, providedBits, nullStatus));
						if (severity == 2)
							return NULL_ANNOTATIONS_MISMATCH;
					}
				}
			} else if (providedType.id == TypeIds.T_null) {
				if (dims > 0 && requiredDimsTagBits[0] == TagBits.AnnotationNonNull)
					return NULL_ANNOTATIONS_MISMATCH;
			}
		}
	} else if (requiredType.hasNullTypeAnnotations() || providedType.hasNullTypeAnnotations()) {
		long requiredBits = requiredType.tagBits & TagBits.AnnotationNullMASK;
		if (requiredBits != TagBits.AnnotationNullable // nullable lhs accepts everything, ...
				|| nullStatus == -1) // only at detail/recursion even nullable must be matched exactly
		{
			long providedBits = providedType.tagBits & TagBits.AnnotationNullMASK;
			severity = computeNullProblemSeverity(requiredBits, providedBits, nullStatus);
		}
		if (severity < 2) {
			TypeBinding providedSuper = providedType.findSuperTypeOriginatingFrom(requiredType);
			if (providedSuper != providedType)
				superTypeHint = providedSuper;
			if (requiredType.isParameterizedType()  && providedSuper instanceof ParameterizedTypeBinding) { // TODO(stephan): handle providedType.isRaw()
				TypeBinding[] requiredArguments = ((ParameterizedTypeBinding) requiredType).arguments;
				TypeBinding[] providedArguments = ((ParameterizedTypeBinding) providedSuper).arguments;
				if (requiredArguments != null && providedArguments != null && requiredArguments.length == providedArguments.length) {
					for (int i = 0; i < requiredArguments.length; i++) {
						NullAnnotationStatus status = findNullTypeAnnotationMismatch(requiredArguments[i], providedArguments[i], -1);
						severity = Math.max(severity, status.severity);
						if (severity == 2)
							return new NullAnnotationStatus(severity, superTypeHint);
					}
				}
			} else 	if (requiredType instanceof WildcardBinding) {
				NullAnnotationStatus status = findNullTypeAnnotationMismatch(((WildcardBinding) requiredType).bound, providedType, nullStatus);
				severity = Math.max(severity, status.severity);
			}
			TypeBinding requiredEnclosing = requiredType.enclosingType();
			TypeBinding providedEnclosing = providedType.enclosingType();
			if (requiredEnclosing != null && providedEnclosing != null) {
				NullAnnotationStatus status = findNullTypeAnnotationMismatch(requiredEnclosing, providedEnclosing, -1);
				severity = Math.max(severity, status.severity);
			}
		}
	}
	if (severity == 0)
		return NULL_ANNOTATIONS_OK;
	return new NullAnnotationStatus(severity, superTypeHint);
}

