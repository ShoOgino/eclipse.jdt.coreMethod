	/*
	 * Type checking for constructor, just another method, except for special check
	 * for recursive constructor invocations.
	 */
	public void resolveStatements(ClassScope upperScope) {
/*
		// checking for recursive constructor call (protection)
		if (!ignoreFurtherInvestigation && constructorCall == null){
			constructorCall = new ExplicitConstructorCall(ExplicitConstructorCall.ImplicitSuper);
			constructorCall.sourceStart = sourceStart;
			constructorCall.sourceEnd = sourceEnd;
		}
*/
		if (!CharOperation.equals(scope.enclosingSourceType().sourceName, selector)){
			scope.problemReporter().missingReturnType(this);
		}

		// if null ==> an error has occurs at parsing time ....
		if (constructorCall != null) {
			// e.g. using super() in java.lang.Object
			if (binding != null
				&& binding.declaringClass.id == T_Object
				&& constructorCall.accessMode != ExplicitConstructorCall.This) {
					if (constructorCall.accessMode == ExplicitConstructorCall.Super) {
						scope.problemReporter().cannotUseSuperInJavaLangObject(constructorCall);
					}
					constructorCall = null;
			} else {
				constructorCall.resolve(scope);
			}
		}
		
		super.resolveStatements(upperScope);

		// indirect reference: increment target constructor reference count
		if (constructorCall != null){
			if (constructorCall.binding != null
				&& !constructorCall.isSuperAccess()
				&& constructorCall.binding.isValidBinding()) {
				((ConstructorDeclaration)
						(upperScope.referenceContext.declarationOf(constructorCall.binding))).referenceCount++;
			}
		}
	}

