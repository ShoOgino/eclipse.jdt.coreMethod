	/**
	 * Return the location for the corresponding annotation inside the type reference, <code>null</code> if none.
	 */
	public static int[] getLocations(
			final TypeReference reference,
			final Annotation[] primaryAnnotation,
			final Annotation annotation,
			final Annotation[][] annotationsOnDimensionsOnExpression) {
		class LocationCollector extends ASTVisitor {
			Stack currentIndexes;
			Annotation currentAnnotation;
			boolean search = true;
			
			public LocationCollector(Annotation currentAnnotation) {
				this.currentIndexes = new Stack();
				this.currentAnnotation = currentAnnotation;
			}
			public boolean visit(ArrayTypeReference typeReference, BlockScope scope) {
				if (!this.search) return false;
				Annotation[][] annotationsOnDimensions = typeReference.annotationsOnDimensions;
				if (annotationsOnDimensions != null) {
					// check if the annotation is located on the first dimension
					Annotation[] annotations = annotationsOnDimensions[0];
					if (annotations != null) {
						for (int j = 0, max2 = annotations.length; j < max2; j++) {
							Annotation current = annotations[j];
							if (current == this.currentAnnotation) {
								this.search = false;
								return false;
							}
						}
					}

					this.currentIndexes.push(new Integer(0));
					for (int i = 1, max = annotationsOnDimensions.length; i < max; i++) {
						annotations = annotationsOnDimensions[i];
						if (annotations != null) {
							for (int j = 0, max2 = annotations.length; j < max2; j++) {
								Annotation current = annotations[j];
								if (current == this.currentAnnotation) {
									this.search = false;
									return false;
								}
							}
						}
						this.currentIndexes.push(new Integer(((Integer) this.currentIndexes.pop()).intValue() + 1));
					}
				}
				Annotation[] annotations = typeReference.annotations;
				if (annotations == null) {
					annotations = primaryAnnotation;
				}
				if (annotations != null) {
					for (int i = 0; i < annotations.length; i++) {
						Annotation current = annotations[i];
						if (current == this.currentAnnotation) {
							this.search = false;
							return false;
						}
					}
				}
				this.currentIndexes.pop();
				return true;
			}
			public boolean visit(ArrayQualifiedTypeReference typeReference, BlockScope scope) {
				if (!this.search) return false;
				Annotation[][] annotationsOnDimensions = typeReference.annotationsOnDimensions;
				if (annotationsOnDimensions != null) {
					// check if the annotation is located on the first dimension
					Annotation[] annotations = annotationsOnDimensions[0];
					if (annotations != null) {
						for (int j = 0, max2 = annotations.length; j < max2; j++) {
							Annotation current = annotations[j];
							if (current == this.currentAnnotation) {
								this.search = false;
								return false;
							}
						}
					}

					this.currentIndexes.push(new Integer(0));
					for (int i = 1, max = annotationsOnDimensions.length; i < max; i++) {
						annotations = annotationsOnDimensions[i];
						if (annotations != null) {
							for (int j = 0, max2 = annotations.length; j < max2; j++) {
								Annotation current = annotations[j];
								if (current == this.currentAnnotation) {
									this.search = false;
									return false;
								}
							}
						}
						this.currentIndexes.push(new Integer(((Integer) this.currentIndexes.pop()).intValue() + 1));
					}
				}
				Annotation[] annotations = typeReference.annotations;
				if (annotations == null) {
					annotations = primaryAnnotation;
				}
				if (annotations != null) {
					for (int i = 0; i < annotations.length; i++) {
						Annotation current = annotations[i];
						if (current == this.currentAnnotation) {
							this.search = false;
							return false;
						}
					}
				}
				this.currentIndexes.pop();
				return true;
			}
			public boolean visit(ParameterizedSingleTypeReference typeReference, BlockScope scope) {
				if (!this.search) return false;
				Annotation[][] annotationsOnDimensions = typeReference.annotationsOnDimensions;
				if (annotationsOnDimensions != null) {
					// check if the annotation is located on the first dimension
					Annotation[] annotations = annotationsOnDimensions[0];
					if (annotations != null) {
						for (int j = 0, max2 = annotations.length; j < max2; j++) {
							Annotation current = annotations[j];
							if (current == this.currentAnnotation) {
								this.search = false;
								return false;
							}
						}
					}

					this.currentIndexes.push(new Integer(0));
					for (int i = 1, max = annotationsOnDimensions.length; i < max; i++) {
						annotations = annotationsOnDimensions[i];
						if (annotations != null) {
							for (int j = 0, max2 = annotations.length; j < max2; j++) {
								Annotation current = annotations[j];
								if (current == this.currentAnnotation) {
									this.search = false;
									return false;
								}
							}
						}
						this.currentIndexes.push(new Integer(((Integer) this.currentIndexes.pop()).intValue() + 1));
					}
				}
				Annotation[] annotations = typeReference.annotations;
				if (annotations == null) {
					annotations = primaryAnnotation;
				}
				if (annotations != null) {
					for (int i = 0; i < annotations.length; i++) {
						Annotation current = annotations[i];
						if (current == this.currentAnnotation) {
							this.search = false;
							return false;
						}
					}
				}
				TypeReference[] typeReferences = typeReference.typeArguments;
				this.currentIndexes.push(new Integer(0));
				for (int i = 0, max = typeReferences.length; i < max; i++) {
					typeReferences[i].traverse(this, scope);
					if (!this.search) return false;
					this.currentIndexes.push(new Integer(((Integer) this.currentIndexes.pop()).intValue() + 1));
				}
				this.currentIndexes.pop();
				return true;
			}
			public boolean visit(ParameterizedQualifiedTypeReference typeReference, BlockScope scope) {
				if (!this.search) return false;
				Annotation[][] annotationsOnDimensions = typeReference.annotationsOnDimensions;
				if (annotationsOnDimensions != null) {
					// check if the annotation is located on the first dimension
					Annotation[] annotations = annotationsOnDimensions[0];
					if (annotations != null) {
						for (int j = 0, max2 = annotations.length; j < max2; j++) {
							Annotation current = annotations[j];
							if (current == this.currentAnnotation) {
								this.search = false;
								return false;
							}
						}
					}

					this.currentIndexes.push(new Integer(0));
					for (int i = 1, max = annotationsOnDimensions.length; i < max; i++) {
						annotations = annotationsOnDimensions[i];
						if (annotations != null) {
							for (int j = 0, max2 = annotations.length; j < max2; j++) {
								Annotation current = annotations[j];
								if (current == this.currentAnnotation) {
									this.search = false;
									return false;
								}
							}
						}
						this.currentIndexes.push(new Integer(((Integer) this.currentIndexes.pop()).intValue() + 1));
					}
				}
				Annotation[] annotations = typeReference.annotations;
				if (annotations == null) {
					annotations = primaryAnnotation;
				}
				if (annotations != null) {
					for (int i = 0; i < annotations.length; i++) {
						Annotation current = annotations[i];
						if (current == this.currentAnnotation) {
							this.search = false;
							return false;
						}
					}
				}
				//TODO it is unclear how to manage annotations located in the first type arguments
				TypeReference[] typeReferences = typeReference.typeArguments[typeReference.typeArguments.length - 1];
				this.currentIndexes.push(new Integer(0));
				for (int i = 0, max = typeReferences.length; i < max; i++) {
					typeReferences[i].traverse(this, scope);
					if (!this.search) return false;
					this.currentIndexes.push(new Integer(((Integer) this.currentIndexes.pop()).intValue() + 1));
				}
				this.currentIndexes.pop();
				return true;
			}
			public boolean visit(SingleTypeReference typeReference, BlockScope scope) {
				if (!this.search) return false;
				Annotation[][] annotationsOnDimensions = annotationsOnDimensionsOnExpression;
				if (annotationsOnDimensions != null) {
					// check if the annotation is located on the first dimension
					Annotation[] annotations = annotationsOnDimensions[0];
					if (annotations != null) {
						for (int j = 0, max2 = annotations.length; j < max2; j++) {
							Annotation current = annotations[j];
							if (current == this.currentAnnotation) {
								this.search = false;
								return false;
							}
						}
					}

					this.currentIndexes.push(new Integer(0));
					for (int i = 1, max = annotationsOnDimensions.length; i < max; i++) {
						annotations = annotationsOnDimensions[i];
						if (annotations != null) {
							for (int j = 0, max2 = annotations.length; j < max2; j++) {
								Annotation current = annotations[j];
								if (current == this.currentAnnotation) {
									this.search = false;
									return false;
								}
							}
						}
						this.currentIndexes.push(new Integer(((Integer) this.currentIndexes.pop()).intValue() + 1));
					}
				}
				Annotation[] annotations = typeReference.annotations;
				if (annotations != null) {
					for (int i = 0; i < annotations.length; i++) {
						Annotation current = annotations[i];
						if (current == this.currentAnnotation) {
							this.search = false;
							return false;
						}
					}
				}
				return false;
			}
			public boolean visit(Wildcard typeReference, BlockScope scope) {
				if (!this.search) return false;
				TypeReference bound = typeReference.bound;
				bound.traverse(this, scope);
				return true;
			}
			public boolean visit(QualifiedTypeReference typeReference, BlockScope scope) {
				if (!this.search) return false;
				Annotation[] annotations = typeReference.annotations;
				if (annotations != null) {
					for (int i = 0; i < annotations.length; i++) {
						Annotation current = annotations[i];
						if (current == this.currentAnnotation) {
							this.search = false;
							return false;
						}
					}
				}
				return true;
			}
			public String toString() {
				StringBuffer buffer = new StringBuffer();
				buffer
					.append("search location for ") //$NON-NLS-1$
					.append(this.currentAnnotation)
					.append("\ncurrent indexes : ") //$NON-NLS-1$
					.append(this.currentIndexes);
				return String.valueOf(buffer);
			}
		}
		if (reference == null) return null;
		LocationCollector collector = new LocationCollector(annotation);
		reference.traverse(collector, (BlockScope) null);
		if (collector.currentIndexes.isEmpty()) {
			return null;
		}
		int size = collector.currentIndexes.size();
		int[] result = new int[size];
		for (int i = 0; i < size; i++) {
			result[size - i - 1] = ((Integer) collector.currentIndexes.pop()).intValue();
		}
		return result;
	}

