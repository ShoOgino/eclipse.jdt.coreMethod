/**
 * Returns the constant intValue or ordinal for enum constants. If constant is NotAConstant, then answers Float.MIN_VALUE
 * Switch Expressions in JLS 12 onwards
 */
@Override
public Constant resolveCase(BlockScope scope, TypeBinding switchExpressionExpressionType, Statement node) {
	boolean isSwitchStatement = node instanceof SwitchStatement;
	// switchExpressionType maybe null in error case
	scope.enclosingCase = this; // record entering in a switch case block

	if (this.constantExpression == null) {
		// remember the default case into the associated switch statement
		if (isSwitchStatement)
			setDefaultCase(scope, (SwitchStatement) node);
		else
			setDefaultCase(scope, (SwitchExpression) node);
		return Constant.NotAConstant;
	}
	// add into the collection of cases of the associated switch statement
	if (isSwitchStatement)
		addNormalCase((SwitchStatement) node);
	else
		addNormalCase((SwitchExpression) node);
	// tag constant name with enum type for privileged access to its members
	if (switchExpressionExpressionType != null && switchExpressionExpressionType.isEnum() && (this.constantExpression instanceof SingleNameReference)) {
		((SingleNameReference) this.constantExpression).setActualReceiverType((ReferenceBinding)switchExpressionExpressionType);
	}
	TypeBinding caseType = this.constantExpression.resolveType(scope);
	if (caseType == null || switchExpressionExpressionType == null) return Constant.NotAConstant;
	if (this.constantExpression.isConstantValueOfTypeAssignableToType(caseType, switchExpressionExpressionType)
			|| caseType.isCompatibleWith(switchExpressionExpressionType)) {
		if (caseType.isEnum()) {
			if (((this.constantExpression.bits & ASTNode.ParenthesizedMASK) >> ASTNode.ParenthesizedSHIFT) != 0) {
				scope.problemReporter().enumConstantsCannotBeSurroundedByParenthesis(this.constantExpression);
			}

			if (this.constantExpression instanceof NameReference
					&& (this.constantExpression.bits & ASTNode.RestrictiveFlagMASK) == Binding.FIELD) {
				NameReference reference = (NameReference) this.constantExpression;
				FieldBinding field = reference.fieldBinding();
				if ((field.modifiers & ClassFileConstants.AccEnum) == 0) {
					 scope.problemReporter().enumSwitchCannotTargetField(reference, field);
				} else 	if (reference instanceof QualifiedNameReference) {
					 scope.problemReporter().cannotUseQualifiedEnumConstantInCaseLabel(reference, field);
				}
				return IntConstant.fromValue(field.original().id + 1); // (ordinal value + 1) zero should not be returned see bug 141810
			}
		} else {
			return this.constantExpression.constant;
		}
	} else if (isBoxingCompatible(caseType, switchExpressionExpressionType, this.constantExpression, scope)) {
		// constantExpression.computeConversion(scope, caseType, switchExpressionType); - do not report boxing/unboxing conversion
		return this.constantExpression.constant;
	}
	Expression expression = isSwitchStatement ? ((SwitchStatement) node).expression : ((SwitchExpression) node).expression;
	scope.problemReporter().typeMismatchError(caseType, switchExpressionExpressionType, this.constantExpression, expression);
	return Constant.NotAConstant;
}

