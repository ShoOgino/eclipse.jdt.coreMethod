public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo) {
	breakLabel = new Label();
	continueLabel = new Label();

	preCondInitStateIndex = currentScope.methodScope().recordInitializationStates(flowInfo);
	LoopingFlowContext condLoopContext;
	FlowInfo postCondInfo = condition.analyseCode(
		currentScope,
		(condLoopContext = new LoopingFlowContext(flowContext, this, null, null, currentScope)),
		flowInfo);

	LoopingFlowContext loopingContext;
	if ((action == null) || action.isEmptyBlock()) {
		condLoopContext.complainOnFinalAssignmentsInLoop(currentScope, postCondInfo);
		if ((condition.constant != NotAConstant) && (condition.constant.booleanValue() == true)) {
			return FlowInfo.DeadEnd;
		} else {
			FlowInfo mergedInfo = postCondInfo.initsWhenFalse().unconditionalInits();
			mergedInitStateIndex = currentScope.methodScope().recordInitializationStates(mergedInfo);
			return mergedInfo;
		}
	} else {
		// in case the condition was inlined to false, record the fact that there is no way to reach any 
		// statement inside the looping action
		loopingContext = new LoopingFlowContext(flowContext, this, breakLabel, continueLabel, currentScope);
		FlowInfo actionInfo =
			((condition.constant != Constant.NotAConstant) && (condition.constant.booleanValue() == false)) ?
				FlowInfo.DeadEnd :
				postCondInfo.initsWhenTrue().copy();
				
		// for computing local var attributes
		condIfTrueInitStateIndex = currentScope.methodScope().recordInitializationStates(postCondInfo.initsWhenTrue());
		
		if (!actionInfo.complainIfUnreachable(action, currentScope)){
			actionInfo = action.analyseCode(currentScope, loopingContext, actionInfo);
		}

		// code generation can be optimized when no need to continue in the loop
		if (((actionInfo == FlowInfo.DeadEnd) || actionInfo.isFakeReachable())
			&& ((loopingContext.initsOnContinue == FlowInfo.DeadEnd) || loopingContext.initsOnContinue.isFakeReachable())){
				continueLabel = null;
		} else {
			condLoopContext.complainOnFinalAssignmentsInLoop(currentScope, postCondInfo);
			loopingContext.complainOnFinalAssignmentsInLoop(currentScope, actionInfo);
		}
	}

	// infinite loop
	FlowInfo mergedInfo;
	if ((condition.constant != Constant.NotAConstant) && (condition.constant.booleanValue() == true)) {
		mergedInitStateIndex = currentScope.methodScope().recordInitializationStates(mergedInfo = loopingContext.initsOnBreak);
		return mergedInfo;
	}

	// end of loop: either condition false or break
	mergedInfo = postCondInfo.initsWhenFalse().unconditionalInits().mergedWith(loopingContext.initsOnBreak);
	mergedInitStateIndex = currentScope.methodScope().recordInitializationStates(mergedInfo);
	return mergedInfo;
}

