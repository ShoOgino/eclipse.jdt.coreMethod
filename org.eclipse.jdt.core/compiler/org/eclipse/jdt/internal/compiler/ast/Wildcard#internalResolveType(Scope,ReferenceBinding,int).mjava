	private TypeBinding internalResolveType(Scope scope, ReferenceBinding genericType, int rank) {
		TypeBinding boundType = null;
		if (this.bound != null) {
			boundType = scope.kind == Scope.CLASS_SCOPE
					? this.bound.resolveType((ClassScope)scope, Binding.DefaultLocationTypeBound)
					: this.bound.resolveType((BlockScope)scope, true /* check bounds*/, Binding.DefaultLocationTypeBound);
			this.bits |= (this.bound.bits & ASTNode.HasTypeAnnotations);
			if (boundType == null) {
				return null;
			}
		}
		this.resolvedType = scope.environment().createWildcard(genericType, rank, boundType, null /*no extra bound*/, this.kind);
		resolveAnnotations(scope, 0); // no defaultNullness for wildcards
		if (boundType != null && boundType.hasNullTypeAnnotations() && this.resolvedType.hasNullTypeAnnotations()) {
			if (((boundType.tagBits | this.resolvedType.tagBits) & TagBits.AnnotationNullMASK) == TagBits.AnnotationNullMASK) { // are both set?
				Annotation annotation = this.bound.findAnnotation(boundType.tagBits & TagBits.AnnotationNullMASK);
				if (annotation == null) { // false alarm, implicit annotation is no conflict, but should be removed:
					TypeBinding newBound = boundType.unannotated(true);
					((WildcardBinding)this.resolvedType).bound = newBound;
					this.bound.resolvedType = newBound;
				} else {
					scope.problemReporter().contradictoryNullAnnotationsOnBounds(annotation, this.resolvedType.tagBits);
				}
			}
		}
		return this.resolvedType;
	}

