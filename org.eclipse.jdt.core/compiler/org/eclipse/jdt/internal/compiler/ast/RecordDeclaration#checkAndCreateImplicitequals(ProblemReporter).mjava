	private void checkAndCreateImplicitequals(ProblemReporter problemReporter) {
		AbstractMethodDeclaration[] ams = getMethod(TypeConstants.EQUALS);
		for (AbstractMethodDeclaration amd : ams) {
			Argument[] args1 = amd.arguments;
			if (args1 == null || args1.length != 1)
				continue;
			char[][] typeRef = args1[0].type != null ? args1[0].type.getTypeName() : null;
			if (typeRef == null)
				continue;
			if (CharOperation.equals(typeRef, JAVA_LANG_OBJECT)) {
				return; // explicit method exists, no need to create an implicit one.
			}
		}
		// In case of just object, we can never be sure - so create one implicit method 
		// and at resolution time, remove the implicit one if there is a conflict.
		// so, at this point we create one anyway.
		MethodDeclaration md = createMethodDeclaration(TypeConstants.EQUALS, TypeReference.baseTypeReference(TypeIds.T_boolean, 0));
		MarkerAnnotation overrideAnnotation = new MarkerAnnotation(new SingleTypeReference(TypeConstants.JAVA_LANG_OVERRIDE[2], 0), 0);
		md.annotations = new Annotation[] { overrideAnnotation };
		TypeReference objectTypeReference = new QualifiedTypeReference(JAVA_LANG_OBJECT, new long[] {0L, 0L, 0L});
		char[] objName = new char[] {'o','b','j'};
		md.arguments = new Argument[] { new Argument(objName, 0, objectTypeReference, 0)};

		List<Statement> stmts = new ArrayList<>();
		// if (!(obj instanceof recordName))
		//    return false;
		InstanceOfExpression ioe = new InstanceOfExpression(new SingleNameReference(objName, 0), new SingleTypeReference(this.name, 0L));
		Expression condition = new UnaryExpression(ioe, OperatorIds.NOT);
		Statement thenStatement = new ReturnStatement(new FalseLiteral(-1, -1), -1, -1);
		IfStatement ifStatement = new IfStatement(condition, thenStatement, -1, -1);
		stmts.add(ifStatement);

		// recordType o = (recordType) obj;
		LocalDeclaration ld = new LocalDeclaration(new char[] {'o'}, -1, -1);
		ld.type = new SingleTypeReference(this.name, -1);
		ld.initialization = new CastExpression(new SingleNameReference(objName, -1), new SingleTypeReference(this.name, 0L));
		stmts.add(ld);

		// check each field - ref javadoc of java.lang.Record#equals
		/*
		 * Impl Spec: The implicitly provided implementation returns true if and only if the argument is an
		 * instance of the same record type as this object, and each component of this record is equal to the
		 * corresponding component of the argument, according to java.util.Objects.equals(Object, Object) for
		 * components whose types are reference types, and according to the semantics of the equals method on
		 * the corresponding primitive wrapper type.
		 */
		if (this.args != null) {
			for (Argument arg : this.args) {
				if (RecordDeclaration.disallowedComponentNames.contains(new String(arg.name)))
					continue;
				FieldReference fr = new FieldReference(arg.name, -1);
				fr.receiver = new ThisReference(-1, -1);
				char [][] qfrName = new char[][] { {'o'}, arg.name };
				long [] qfrPos = {-1, -1};
				QualifiedNameReference ofr = new QualifiedNameReference(qfrName, qfrPos, -1, -1);
				if (arg.type.isBaseTypeReference()) {
					condition = new EqualExpression(fr, ofr, OperatorIds.NOT_EQUAL);
				} else {
					MessageSend messageSend = new MessageSend();
					messageSend.selector = TypeConstants.EQUALS;
					messageSend.arguments = new Expression[] {fr, ofr};
					messageSend.receiver = new QualifiedNameReference(JAVA_UTIL_OBJECTS, new long[] {-1, -1, -1}, -1, -1);
					condition = new UnaryExpression(messageSend, OperatorIds.NOT);
				}
				thenStatement = new ReturnStatement(new FalseLiteral(-1, -1), -1, -1);
				ifStatement = new IfStatement(condition, thenStatement, -1, -1);
				stmts.add(ifStatement);
			}
		}
		stmts.add(new ReturnStatement(new TrueLiteral(-1, -1), -1, -1));
		md.statements = stmts.toArray(new Statement[0]);
		md.isImplicit = true;
	}

