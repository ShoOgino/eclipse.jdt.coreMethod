	public FlowInfo analyseCode(
		BlockScope currentScope,
		FlowContext flowContext,
		FlowInfo flowInfo) {

		// need to stack a context to store explicit label, answer inits in case of normal completion merged
		// with those relative to the exit path from break statement occurring inside the labeled statement.
		if (statement == null) {
			return flowInfo;
		} else {
			LabelFlowContext labelContext;
			FlowInfo statementInfo, mergedInfo;
			if (((statementInfo = statement
					.analyseCode(
						currentScope,
						(labelContext =
							new LabelFlowContext(
								flowContext,
								this,
								label,
								(targetLabel = new BranchLabel()),
								currentScope)),
						flowInfo)).tagBits & FlowInfo.UNREACHABLE) != 0) {
				if ((labelContext.initsOnBreak.tagBits & FlowInfo.UNREACHABLE) == 0) {
					// an embedded loop has had no chance to reinject forgotten null info
					mergedInfo = flowInfo.unconditionalCopy().
						addInitializationsFrom(labelContext.initsOnBreak);
				} else {
					mergedInfo = labelContext.initsOnBreak;
				}
			} else {
				mergedInfo = statementInfo.mergedWith(labelContext.initsOnBreak);
			}
			mergedInitStateIndex =
				currentScope.methodScope().recordInitializationStates(mergedInfo);
			if ((this.bits & ASTNode.LabelUsed) == 0) {
				currentScope.problemReporter().unusedLabel(this);
			}
			return mergedInfo;
		}
	}

