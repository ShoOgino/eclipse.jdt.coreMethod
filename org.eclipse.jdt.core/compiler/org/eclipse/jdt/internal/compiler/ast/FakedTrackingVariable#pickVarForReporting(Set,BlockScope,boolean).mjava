	/** 
	 * Pick tracking variables from 'varsOfScope' to establish a proper order of processing:
	 * As much as possible pick wrapper resources before their inner resources.
	 * Also consider cases of wrappers and their inners being declared at different scopes.
	 */
	public static FakedTrackingVariable pickVarForReporting(Set varsOfScope, BlockScope scope, boolean atExit) {
		if (varsOfScope.isEmpty()) return null;
		FakedTrackingVariable trackingVar = (FakedTrackingVariable) varsOfScope.iterator().next();
		while (trackingVar.outerTracker != null) {
			// resource is wrapped, is wrapper defined in this scope?
			if (varsOfScope.contains(trackingVar.outerTracker)) {
				// resource from same scope, travel up the wrapper chain
				trackingVar = trackingVar.outerTracker;
			} else if (atExit) {
				// at an exit point we report against inner despite a wrapper that may/may not be closed later
				break;
			} else {
				BlockScope outerTrackerScope = trackingVar.outerTracker.binding.declaringScope;
				if (outerTrackerScope == scope) {
					// outerTracker is from same scope and already processed -> pick trackingVar now
					break;
				} else {
					// outer resource is from other (outer?) scope
					Scope currentScope = scope;
					while ((currentScope = currentScope.parent) instanceof BlockScope) {
						if (outerTrackerScope == currentScope) {
							// at end of block pass responsibility for inner resource to outer scope holding a wrapper
							varsOfScope.remove(trackingVar); // drop this one
							// pick a next candidate:
							return pickVarForReporting(varsOfScope, scope, atExit);
						}
					}
					break; // not parent owned -> pick this var
				}
			}
		}
		varsOfScope.remove(trackingVar);
		return trackingVar;
	}

