	/**
	 *	Flow analysis for a local innertype
	 *
	 */
	public FlowInfo analyseCode(
		BlockScope currentScope,
		FlowContext flowContext,
		FlowInfo flowInfo) {

		if (ignoreFurtherInvestigation)
			return flowInfo;
		try {
			// remember local types binding for innerclass emulation propagation
			currentScope.referenceCompilationUnit().record((LocalTypeBinding) binding);

			ReferenceBinding[] defaultHandledExceptions = new ReferenceBinding[] { scope.getJavaLangThrowable()}; // tolerate any kind of exception
			InitializationFlowContext initializerContext =
				new InitializationFlowContext(null, this, initializerScope);
			
			updateMaxFieldCount(); // propagate down the max field count
			FlowInfo fieldInfo = flowInfo.copy(); // so as not to propagate changes outside this type
			if (fields != null) {
				for (int i = 0, count = fields.length; i < count; i++) {
					FieldDeclaration field = fields[i];
					if (field.isField() && !this.binding.isAnonymousType()){
						initializerContext.handledExceptions = NoExceptions; // no exception is allowed jls8.3.2, except for anonymous
					} else {
						initializerContext.handledExceptions = defaultHandledExceptions; // tolerate them all, and record them
					}
					fieldInfo = field.analyseCode(initializerScope, initializerContext, fieldInfo);
					if (fieldInfo == FlowInfo.DEAD_END) {
						// in case the initializer is not reachable, use a reinitialized flowInfo and enter a fake reachable
						// branch, since the previous initializer already got the blame.
						initializerScope.problemReporter().initializerMustCompleteNormally(field);
						fieldInfo = FlowInfo.initial(maxFieldCount).setReachMode(FlowInfo.UNREACHABLE);
					}
				}
			}
			if (memberTypes != null) {
				for (int i = 0, count = memberTypes.length; i < count; i++) {
					memberTypes[i].analyseCode(scope, flowContext, fieldInfo.copy());
				}
			}
			if (methods != null) {
				for (int i = 0, count = methods.length; i < count; i++) {
					AbstractMethodDeclaration method = methods[i];
					if (method.ignoreFurtherInvestigation)
						continue;
					if (method.isConstructor()) { // constructor
						((ConstructorDeclaration)method).analyseCode(
							scope, 
							initializerContext, 
							flowInfo.copy().unconditionalInits().addInitializationsFrom(fieldInfo.copy().unconditionalInits().discardNonFieldInitializations()));
					} else { // regular method
						method.analyseCode(scope, null, flowInfo.copy());
					}
				}
			}
		} catch (AbortType e) {
			this.ignoreFurtherInvestigation = true;
		}
		return flowInfo;
	}

