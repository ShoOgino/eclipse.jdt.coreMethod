	/*
	 * Resolve @param tags for type parameters
	 */
	private void resolveTypeParameterTags(Scope scope, boolean reportMissing) {
		int paramTypeParamLength = this.paramTypeParameters == null ? 0 : this.paramTypeParameters.length;

		// Get declaration infos
		TypeDeclaration typeDeclaration = null;
		AbstractMethodDeclaration methodDeclaration = null;
		TypeVariableBinding[] typeVariables = null;
		int modifiers = -1;
		switch (scope.kind) {
			case Scope.METHOD_SCOPE:
				methodDeclaration = ((MethodScope)scope).referenceMethod();
				// If no referenced method (field initializer for example) then report a problem for each param tag
				if (methodDeclaration == null) {
					for (int i = 0; i < paramTypeParamLength; i++) {
						JavadocSingleNameReference param = this.paramReferences[i];
						scope.problemReporter().javadocUnexpectedTag(param.tagSourceStart, param.tagSourceEnd);
					}
					return;
				}
				typeVariables = methodDeclaration.binding.typeVariables;
				modifiers = methodDeclaration.binding.modifiers;
				break;
			case Scope.CLASS_SCOPE:
				typeDeclaration = ((ClassScope) scope).referenceContext;
				typeVariables = typeDeclaration.binding.typeVariables;
				modifiers = typeDeclaration.binding.modifiers;
				break;
		}

		// If no type variables then report a problem for each param type parameter tag
		if (typeVariables == null || typeVariables.length == 0) {
			for (int i = 0; i < paramTypeParamLength; i++) {
				JavadocSingleTypeReference param = this.paramTypeParameters[i];
				scope.problemReporter().javadocUnexpectedTag(param.tagSourceStart, param.tagSourceEnd);
			}
			return;
		}
		
		// If no param tags then report a problem for each declaration type parameter
		TypeParameter[] parameters = typeDeclaration==null ? methodDeclaration.typeParameters() : typeDeclaration.typeParameters;
		int typeParametersLength = parameters == null ? 0 : parameters.length;
		if (paramTypeParamLength == 0) {
			if (reportMissing) {
				for (int i = 0, l=parameters.length; i<l; i++) {
					scope.problemReporter().javadocMissingParamTag(parameters[i].name, parameters[i].sourceStart, parameters[i].sourceEnd, modifiers);
				}
			}
		// Otherwise verify that all param tags match type parameters
		} else if (typeVariables.length == typeParametersLength) {
			TypeVariableBinding[] bindings = new TypeVariableBinding[paramTypeParamLength];
			int maxBindings = 0;

			// Scan all @param tags
			for (int i = 0; i < paramTypeParamLength; i++) {
				JavadocSingleTypeReference param = this.paramTypeParameters[i];
				TypeBinding paramBindind = param.internalResolveType(scope);
				if (paramBindind != null && paramBindind.isValidBinding()) {
					if (paramBindind.isTypeVariable()) {
						// Verify duplicated tags
						boolean duplicate = false;
						for (int j = 0; j < maxBindings && !duplicate; j++) {
							if (bindings[j] == param.resolvedType) {
								scope.problemReporter().javadocDuplicatedParamTag(param.token, param.sourceStart, param.sourceEnd, modifiers);
								duplicate = true;
							}
						}
						if (!duplicate) {
							bindings[maxBindings++] = (TypeVariableBinding) param.resolvedType;
						}
					} else {
						scope.problemReporter().javadocUndeclaredParamTagName(param.token, param.sourceStart, param.sourceEnd, modifiers);
					}
				}
			}

			// Look for undocumented type parameters
			if (reportMissing) {
				for (int i = 0; i < typeParametersLength; i++) {
					TypeParameter parameter = parameters[i];
					boolean found = false;
					for (int j = 0; j < maxBindings && !found; j++) {
						if (parameter.binding == bindings[j]) {
							found = true;
						}
					}
					if (!found) {
						scope.problemReporter().javadocMissingParamTag(parameter.name, parameter.sourceStart, parameter.sourceEnd, modifiers);
					}
				}
			}
		}
	}

