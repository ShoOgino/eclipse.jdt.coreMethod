	public void manageSyntheticAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo) {

		if ((flowInfo.tagBits & FlowInfo.UNREACHABLE) == 0)	{
		// if constructor from parameterized type got found, use the original constructor at codegen time
		this.codegenBinding = this.binding.original();
		
		// perform some emulation work in case there is some and we are inside a local type only
		if (binding.isPrivate() && accessMode != This) {
			ReferenceBinding declaringClass = this.codegenBinding.declaringClass;
			// optionally, local type constructor can lose their private flag to ease emulation
			if ((declaringClass.tagBits & (TagBits.IsAnonymousType|TagBits.IsLocalType)) != 0
					&& currentScope.compilerOptions().isPrivateConstructorAccessChangingVisibility) {
				// constructor will not be dumped as private, no emulation required thus
				this.codegenBinding.modifiers |= ExtraCompilerModifiers.AccClearPrivateModifier;
			} else {
				syntheticAccessor = ((SourceTypeBinding) declaringClass).addSyntheticMethod(this.codegenBinding, isSuperAccess());
				currentScope.problemReporter().needToEmulateMethodAccess(this.codegenBinding, this);
			}
		}
		}
	}

