	public void resolve() {

		if (binding == null) {
			ignoreFurtherInvestigation = true;
			return;
		}

		try {
			// check superclass & interfaces
			if (binding.superclass != null) // watch out for Object ! (and other roots)	
				if (isTypeUseDeprecated(binding.superclass, scope))
					scope.problemReporter().deprecatedType(binding.superclass, superclass);
			if (superInterfaces != null)
				for (int i = superInterfaces.length; --i >= 0;)
					if (superInterfaces[i].binding != null)
						if (isTypeUseDeprecated(superInterfaces[i].binding, scope))
							scope.problemReporter().deprecatedType(
								superInterfaces[i].binding,
								superInterfaces[i]);
			maxFieldCount = 0;
			int lastFieldID = -1;
			if (fields != null) {
				for (int i = 0, count = fields.length; i < count; i++) {
					FieldDeclaration field = fields[i];
					if (field.isField()) {
						if (field.binding == null) {
							ignoreFurtherInvestigation = true;
							continue;
						}
						maxFieldCount++;
						lastFieldID = field.binding.id;
					} else { // initializer
						 ((Initializer) field).lastFieldID = lastFieldID + 1;
					}
					field.resolve(field.isStatic() ? staticInitializerScope : initializerScope);
				}
			}
			if (memberTypes != null)
				for (int i = 0, count = memberTypes.length; i < count; i++)
					memberTypes[i].resolve(scope);
			if (methods != null)
				for (int i = 0, count = methods.length; i < count; i++)
					methods[i].resolve(scope);
		} catch (AbortType e) {
			this.ignoreFurtherInvestigation = true;
			return;
		};
	}

