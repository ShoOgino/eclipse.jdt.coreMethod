	public void resolve() {

		if (this.binding == null) {
			this.ignoreFurtherInvestigation = true;
			return;
		}
		try {
			if ((this.bits & UndocumentedEmptyBlockMASK) != 0) {
				this.scope.problemReporter().undocumentedEmptyBlock(this.bodyStart-1, this.bodyEnd);
			}
			// check superclass & interfaces
			if (this.binding.superclass != null) // watch out for Object ! (and other roots)	
				if (isTypeUseDeprecated(this.binding.superclass, this.scope))
					this.scope.problemReporter().deprecatedType(this.binding.superclass, this.superclass);
			if (this.superInterfaces != null)
				for (int i = this.superInterfaces.length; --i >= 0;)
					if (this.superInterfaces[i].resolvedType != null)
						if (isTypeUseDeprecated(this.superInterfaces[i].resolvedType, this.scope))
							this.scope.problemReporter().deprecatedType(
								this.superInterfaces[i].resolvedType,
								this.superInterfaces[i]);
			this.maxFieldCount = 0;
			int lastVisibleFieldID = -1;
			if (this.fields != null) {
				for (int i = 0, count = this.fields.length; i < count; i++) {
					FieldDeclaration field = this.fields[i];
					if (field.isField()) {
						if (field.binding == null) {
							// still discover secondary errors
							if (field.initialization != null) field.initialization.resolve(field.isStatic() ? this.staticInitializerScope : this.initializerScope);
							this.ignoreFurtherInvestigation = true;
							continue;
						}
						this.maxFieldCount++;
						lastVisibleFieldID = field.binding.id;
					} else { // initializer
						 ((Initializer) field).lastVisibleFieldID = lastVisibleFieldID + 1;
					}
					field.resolve(field.isStatic() ? this.staticInitializerScope : this.initializerScope);
				}
			}
			if (this.memberTypes != null) {
				for (int i = 0, count = this.memberTypes.length; i < count; i++) {
					this.memberTypes[i].resolve(this.scope);
				}
			}
			int missingAbstractMethodslength = this.missingAbstractMethods == null ? 0 : this.missingAbstractMethods.length;
			int methodsLength = this.methods == null ? 0 : this.methods.length;
			if ((methodsLength + missingAbstractMethodslength) > 0xFFFF) {
				this.scope.problemReporter().tooManyMethods(this);
			}
			
			if (this.methods != null) {
				for (int i = 0, count = this.methods.length; i < count; i++) {
					this.methods[i].resolve(this.scope);
				}
			}
			// Resolve javadoc
			if (this.javadoc != null) {
				if (this.scope != null) {
					this.javadoc.resolve(this.scope);
				}
			} else if (this.binding != null && !this.binding.isLocalType()) {
				this.scope.problemReporter().javadocMissing(this.sourceStart, this.sourceEnd, this.binding.modifiers);
			}
			
		} catch (AbortType e) {
			this.ignoreFurtherInvestigation = true;
			return;
		}
	}

