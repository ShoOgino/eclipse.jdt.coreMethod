public void resolve() {
	SourceTypeBinding sourceType = this.binding;
	if (sourceType == null) {
		this.ignoreFurtherInvestigation = true;
		return;
	}
	try {
		boolean old = this.staticInitializerScope.insideTypeAnnotation;
		try {
			this.staticInitializerScope.insideTypeAnnotation = true;
			resolveAnnotations(this.staticInitializerScope, this.annotations, sourceType);
		} finally {
			this.staticInitializerScope.insideTypeAnnotation = old;
		}
		// check @Deprecated annotation
		if ((sourceType.getAnnotationTagBits() & TagBits.AnnotationDeprecated) == 0
				&& (sourceType.modifiers & ClassFileConstants.AccDeprecated) != 0 
				&& this.scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5) {
			this.scope.problemReporter().missingDeprecatedAnnotationForType(this);
		}			
		if ((this.bits & ASTNode.UndocumentedEmptyBlock) != 0) {
			this.scope.problemReporter().undocumentedEmptyBlock(this.bodyStart-1, this.bodyEnd);
		}
		boolean needSerialVersion = 
						this.scope.compilerOptions().getSeverity(CompilerOptions.MissingSerialVersion) != ProblemSeverities.Ignore
						&& sourceType.isClass() 
						&& !sourceType.isAbstract() 
						&& sourceType.findSuperTypeErasingTo(TypeIds.T_JavaIoExternalizable, false /*Serializable is not a class*/) == null
						&& sourceType.findSuperTypeErasingTo(TypeIds.T_JavaIoSerializable, false /*Serializable is not a class*/) != null;

		if (needSerialVersion) {
			// if Object writeReplace() throws java.io.ObjectStreamException is present, then no serialVersionUID is needed
			// see https://bugs.eclipse.org/bugs/show_bug.cgi?id=101476
    		CompilationUnitScope compilationUnitScope = this.scope.compilationUnitScope();
			MethodBinding methodBinding = sourceType.getExactMethod(TypeConstants.WRITEREPLACE, new TypeBinding[0], compilationUnitScope);
   			ReferenceBinding[] throwsExceptions;
			needSerialVersion = 
				methodBinding == null
    				|| !methodBinding.isValidBinding()
    				|| methodBinding.returnType.id != TypeIds.T_JavaLangObject
    				|| (throwsExceptions = methodBinding.thrownExceptions).length != 1
    				|| throwsExceptions[0].id != TypeIds.T_JavaIoObjectStreamException;
    		if (needSerialVersion) {
    			// check the presence of an implementation of the methods
    			// private void writeObject(java.io.ObjectOutputStream out) throws IOException
    			// private void readObject(java.io.ObjectInputStream out) throws IOException
    			boolean hasWriteObjectMethod = false;
    			boolean hasReadObjectMethod = false;
    			TypeBinding argumentTypeBinding = this.scope.getType(TypeConstants.JAVA_IO_OBJECTOUTPUTSTREAM, 3);
     			if (argumentTypeBinding.isValidBinding()) {
            		methodBinding = sourceType.getExactMethod(TypeConstants.WRITEOBJECT, new TypeBinding[] { argumentTypeBinding }, compilationUnitScope);
            		hasWriteObjectMethod = methodBinding != null
            				&& methodBinding.isValidBinding()
            				&& methodBinding.modifiers == ClassFileConstants.AccPrivate
            				&& methodBinding.returnType == TypeBinding.VOID
            				&& (throwsExceptions = methodBinding.thrownExceptions).length == 1
            				&& throwsExceptions[0].id == TypeIds.T_JavaIoException;
    			}
    			argumentTypeBinding = this.scope.getType(TypeConstants.JAVA_IO_OBJECTINPUTSTREAM, 3);
     			if (argumentTypeBinding.isValidBinding()) {
            		methodBinding = sourceType.getExactMethod(TypeConstants.READOBJECT, new TypeBinding[] { argumentTypeBinding }, compilationUnitScope);
            		hasReadObjectMethod = methodBinding != null
            				&& methodBinding.isValidBinding()
            				&& methodBinding.modifiers == ClassFileConstants.AccPrivate
            				&& methodBinding.returnType == TypeBinding.VOID
            				&& (throwsExceptions = methodBinding.thrownExceptions).length == 1
            				&& throwsExceptions[0].id == TypeIds.T_JavaIoException;
    			}
    			needSerialVersion = !hasWriteObjectMethod || !hasReadObjectMethod;
    		}
		}
		// generics (and non static generic members) cannot extend Throwable
		if (sourceType.findSuperTypeErasingTo(TypeIds.T_JavaLangThrowable, true) != null) {
			ReferenceBinding current = sourceType;
			checkEnclosedInGeneric : do {
				if (current.isGenericType()) {
					this.scope.problemReporter().genericTypeCannotExtendThrowable(this);
					break checkEnclosedInGeneric;						
				}
				if (current.isStatic()) break checkEnclosedInGeneric;
				if (current.isLocalType()) {
					NestedTypeBinding nestedType = (NestedTypeBinding) current.erasure();
					if (nestedType.scope.methodScope().isStatic) break checkEnclosedInGeneric;
				}				
			} while ((current = current.enclosingType()) != null);
		}
		this.maxFieldCount = 0;
		int lastVisibleFieldID = -1;
		boolean hasEnumConstants = false;
		boolean hasEnumConstantsWithoutBody = false;
		
		if (this.typeParameters != null) {
			for (int i = 0, count = this.typeParameters.length; i < count; i++) {
				this.typeParameters[i].resolve(this.scope);
			}
		}
		if (this.memberTypes != null) {
			for (int i = 0, count = this.memberTypes.length; i < count; i++) {
				this.memberTypes[i].resolve(this.scope);
			}
		}
		if (this.fields != null) {
			for (int i = 0, count = this.fields.length; i < count; i++) {
				FieldDeclaration field = this.fields[i];
				switch(field.getKind()) {
					case AbstractVariableDeclaration.ENUM_CONSTANT:
						hasEnumConstants = true;
						if (!(field.initialization instanceof QualifiedAllocationExpression))
							hasEnumConstantsWithoutBody = true;
					case AbstractVariableDeclaration.FIELD:
						FieldBinding fieldBinding = field.binding;
						if (fieldBinding == null) {
							// still discover secondary errors
							if (field.initialization != null) field.initialization.resolve(field.isStatic() ? this.staticInitializerScope : this.initializerScope);
							this.ignoreFurtherInvestigation = true;
							continue;
						}
						if (needSerialVersion
								&& ((fieldBinding.modifiers & (ClassFileConstants.AccStatic | ClassFileConstants.AccFinal)) == (ClassFileConstants.AccStatic | ClassFileConstants.AccFinal))
								&& CharOperation.equals(TypeConstants.SERIALVERSIONUID, fieldBinding.name)
								&& TypeBinding.LONG == fieldBinding.type) {
							needSerialVersion = false;
						}
						this.maxFieldCount++;
						lastVisibleFieldID = field.binding.id;
						break;

					case AbstractVariableDeclaration.INITIALIZER:
						 ((Initializer) field).lastVisibleFieldID = lastVisibleFieldID + 1;
						break;
				}
				field.resolve(field.isStatic() ? this.staticInitializerScope : this.initializerScope);
			}
		}
		if (needSerialVersion) {
			this.scope.problemReporter().missingSerialVersion(this);
		}
		// check extends/implements for annotation type
		switch(kind(this.modifiers)) {
			case TypeDeclaration.ANNOTATION_TYPE_DECL :
				if (this.superclass != null) {
					this.scope.problemReporter().annotationTypeDeclarationCannotHaveSuperclass(this);
				}
				if (this.superInterfaces != null) {
					this.scope.problemReporter().annotationTypeDeclarationCannotHaveSuperinterfaces(this);
				}		
				break;
			case TypeDeclaration.ENUM_DECL :
				// check enum abstract methods
				if (this.binding.isAbstract()) {
					if (!hasEnumConstants || hasEnumConstantsWithoutBody) {
						for (int i = 0, count = this.methods.length; i < count; i++) {
							final AbstractMethodDeclaration methodDeclaration = this.methods[i];
							if (methodDeclaration.isAbstract() && methodDeclaration.binding != null) {
								this.scope.problemReporter().enumAbstractMethodMustBeImplemented(methodDeclaration);
							}
						}
					}
				}
				break;
		}
		
		int missingAbstractMethodslength = this.missingAbstractMethods == null ? 0 : this.missingAbstractMethods.length;
		int methodsLength = this.methods == null ? 0 : this.methods.length;
		if ((methodsLength + missingAbstractMethodslength) > 0xFFFF) {
			this.scope.problemReporter().tooManyMethods(this);
		}
		if (this.methods != null) {
			for (int i = 0, count = this.methods.length; i < count; i++) {
				this.methods[i].resolve(this.scope);
			}
		}
		// Resolve javadoc
		if (this.javadoc != null) {
			if (this.scope != null) {
				this.javadoc.resolve(this.scope);
			}
		} else if (sourceType != null && !sourceType.isLocalType()) {
			this.scope.problemReporter().javadocMissing(this.sourceStart, this.sourceEnd, sourceType.modifiers);
		}
		
	} catch (AbortType e) {
		this.ignoreFurtherInvestigation = true;
		return;
	}
}

