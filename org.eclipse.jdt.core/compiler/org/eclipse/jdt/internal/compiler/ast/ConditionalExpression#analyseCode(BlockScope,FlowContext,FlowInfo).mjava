public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo) {
	Constant inlinedCondition;
	if ((inlinedCondition = condition.constant) != NotAConstant) {
		if (inlinedCondition.booleanValue()) {
			FlowInfo resultInfo = valueIfTrue.analyseCode(currentScope, flowContext, flowInfo);
			// analyse valueIfFalse, but do not take into account any of its infos
			valueIfFalse.analyseCode(currentScope, flowContext, flowInfo.copy());
			mergedInitStateIndex = currentScope.methodScope().recordInitializationStates(resultInfo);
			return resultInfo;
		} else {
			// analyse valueIfTrue, but do not take into account any of its infos			
			valueIfTrue.analyseCode(currentScope, flowContext, flowInfo.copy());
			FlowInfo mergeInfo = valueIfFalse.analyseCode(currentScope, flowContext, flowInfo);
			mergedInitStateIndex = currentScope.methodScope().recordInitializationStates(mergeInfo);
			return mergeInfo;
		}
	}
	// notice that the receiver investigation is not performed in the previous case, since there is
	// not a chance it is worth trying to check anything on a constant expression.

	flowInfo = condition.analyseCode(currentScope, flowContext, flowInfo);

	// store a copy of the merged info, so as to compute the local variable attributes afterwards
	thenInitStateIndex = currentScope.methodScope().recordInitializationStates(flowInfo.initsWhenTrue());
	elseInitStateIndex = currentScope.methodScope().recordInitializationStates(flowInfo.initsWhenFalse());
	FlowInfo mergedInfo = valueIfTrue.analyseCode(
		currentScope,
		flowContext,
		flowInfo.initsWhenTrue().copy()).
			unconditionalInits().
				mergedWith(
					valueIfFalse.analyseCode(
						currentScope,
						flowContext,
						flowInfo.initsWhenFalse().copy()).
							unconditionalInits());
	mergedInitStateIndex = currentScope.methodScope().recordInitializationStates(mergedInfo);
	return mergedInfo;
}

