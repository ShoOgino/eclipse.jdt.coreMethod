	public FlowInfo analyseCode(
		BlockScope currentScope,
		FlowContext flowContext,
		FlowInfo flowInfo) {

		Constant cst = this.condition.constant;
		boolean isConditionTrue = cst != NotAConstant && cst.booleanValue() == true;
		boolean isConditionFalse = cst != NotAConstant && cst.booleanValue() == false;

		cst = this.condition.optimizedBooleanConstant();
		boolean isConditionOptimizedTrue = cst != NotAConstant && cst.booleanValue() == true;
		boolean isConditionOptimizedFalse = cst != NotAConstant && cst.booleanValue() == false;

		flowInfo = condition.analyseCode(currentScope, flowContext, flowInfo, cst == NotAConstant);

		if (isConditionTrue) {
			// TRUE ? left : right
			FlowInfo resultInfo =
				valueIfTrue.analyseCode(currentScope, flowContext, flowInfo.initsWhenTrue().unconditionalInits());
			// analyse valueIfFalse, but do not take into account any of its infos
			valueIfFalse.analyseCode(
				currentScope,
				flowContext,
				flowInfo.initsWhenFalse().copy().unconditionalInits().setReachMode(FlowInfo.SILENT_FAKE_REACHABLE));
			mergedInitStateIndex =
				currentScope.methodScope().recordInitializationStates(resultInfo);
			return resultInfo;
		} else if (isConditionFalse) {
			// FALSE ? left : right
			// analyse valueIfTrue, but do not take into account any of its infos			
			valueIfTrue.analyseCode(
				currentScope,
				flowContext,
				flowInfo.initsWhenTrue().copy().unconditionalInits().setReachMode(FlowInfo.SILENT_FAKE_REACHABLE));
			FlowInfo mergeInfo =
				valueIfFalse.analyseCode(currentScope, flowContext, flowInfo.initsWhenFalse().unconditionalInits());
			mergedInitStateIndex =
				currentScope.methodScope().recordInitializationStates(mergeInfo);
			return mergeInfo;
		}

		// store a copy of the merged info, so as to compute the local variable attributes afterwards
		FlowInfo trueInfo = flowInfo.initsWhenTrue().copy();
		if (isConditionOptimizedFalse) trueInfo.setReachMode(FlowInfo.CHECK_POT_INIT_FAKE_REACHABLE);
		thenInitStateIndex = currentScope.methodScope().recordInitializationStates(trueInfo);
		FlowInfo falseInfo = flowInfo.initsWhenFalse().copy();
		if (isConditionOptimizedTrue) falseInfo.setReachMode(FlowInfo.CHECK_POT_INIT_FAKE_REACHABLE);
		elseInitStateIndex = currentScope.methodScope().recordInitializationStates(falseInfo);

		// propagate analysis
		trueInfo = valueIfTrue.analyseCode(currentScope, flowContext, trueInfo);
		falseInfo = valueIfFalse.analyseCode(currentScope, flowContext, falseInfo);

		// merge using a conditional info -  1GK2BLM
		// if ((t && (v = t)) ? t : t && (v = f)) r = v;  -- ok
		FlowInfo mergedInfo =
			FlowInfo.conditional(
				trueInfo.initsWhenTrue().copy().unconditionalInits().mergedWith( // must copy, since could be shared with trueInfo.initsWhenFalse()...
					falseInfo.initsWhenTrue().copy().unconditionalInits()),
				trueInfo.initsWhenFalse().unconditionalInits().mergedWith(
					falseInfo.initsWhenFalse().unconditionalInits()));

		mergedInitStateIndex =
			currentScope.methodScope().recordInitializationStates(mergedInfo);
		return mergedInfo;
	}

