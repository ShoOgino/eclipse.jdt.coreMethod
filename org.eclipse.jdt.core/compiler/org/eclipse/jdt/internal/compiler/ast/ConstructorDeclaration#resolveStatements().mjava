	/*
	 * Type checking for constructor, just another method, except for special check
	 * for recursive constructor invocations.
	 */
	public void resolveStatements() {

		if (!CharOperation.equals(this.scope.enclosingSourceType().sourceName, selector)){
			this.scope.problemReporter().missingReturnType(this);
		}

		if (this.typeParameters != null) {
			for (int i = 0, length = this.typeParameters.length; i < length; i++) {
				this.typeParameters[i].resolve(this.scope);
			}
		}
		
		if (this.binding != null && this.binding.declaringClass.isAnnotationType()) {
			this.scope.problemReporter().annotationTypeDeclarationCannotHaveConstructor(this);
		}
		// if null ==> an error has occurs at parsing time ....
		if (this.constructorCall != null) {
			// e.g. using super() in java.lang.Object
			if (this.binding != null
				&& this.binding.declaringClass.id == T_JavaLangObject
				&& this.constructorCall.accessMode != ExplicitConstructorCall.This) {
					if (this.constructorCall.accessMode == ExplicitConstructorCall.Super) {
						this.scope.problemReporter().cannotUseSuperInJavaLangObject(this.constructorCall);
					}
					this.constructorCall = null;
			} else {
				this.constructorCall.resolve(this.scope);
			}
		}
		if ((modifiers & AccSemicolonBody) != 0) {
			this.scope.problemReporter().methodNeedBody(this);		
		}
		super.resolveStatements();
	}

