	public void resolve() {
		int startingTypeIndex = 0;
		boolean isPackageInfo = isPackageInfo();
		if (this.types != null && isPackageInfo) {
            // resolve synthetic type declaration
			final TypeDeclaration syntheticTypeDeclaration = types[0];
			// set empty javadoc to avoid missing warning (see bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=95286)
			syntheticTypeDeclaration.javadoc = new Javadoc(syntheticTypeDeclaration.declarationSourceStart, syntheticTypeDeclaration.declarationSourceStart);
			syntheticTypeDeclaration.resolve(this.scope);
			// resolve annotations if any
			if (this.currentPackage.annotations != null) {
				resolveAnnotations(syntheticTypeDeclaration.staticInitializerScope, this.currentPackage.annotations, this.scope.fPackage);
			}
			// resolve javadoc package if any
			if (this.javadoc != null) {
				this.javadoc.resolve(syntheticTypeDeclaration.staticInitializerScope);
    		}
			startingTypeIndex = 1;
		}
		if (this.currentPackage != null && this.currentPackage.annotations != null && !isPackageInfo) {
			scope.problemReporter().invalidFileNameForPackageAnnotations(this.currentPackage.annotations[0]);
		}
		try {
			if (types != null) {
				for (int i = startingTypeIndex, count = types.length; i < count; i++) {
					types[i].resolve(scope);
				}
			}
			if (!this.compilationResult.hasErrors()) checkUnusedImports();
			if (this.nlsTags != null || this.stringLiterals != null) {
				final int stringLiteralsLength = this.stringLiteralsPtr;
				final int nlsTagsLength = this.nlsTags == null ? 0 : this.nlsTags.length;
				if (stringLiteralsLength == 0) {
					if (nlsTagsLength != 0) {
						for (int i = 0; i < nlsTagsLength; i++) {
							NLSTag tag = this.nlsTags[i];
							if (tag != null) {
								scope.problemReporter().unnecessaryNLSTags(tag.start, tag.end);
							}
						}
					}
				} else if (nlsTagsLength == 0) {
					// resize string literals
					if (this.stringLiterals.length != stringLiteralsLength) {
						System.arraycopy(this.stringLiterals, 0, (stringLiterals = new StringLiteral[stringLiteralsLength]), 0, stringLiteralsLength);
					}
					Arrays.sort(this.stringLiterals, STRING_LITERAL_COMPARATOR);
					for (int i = 0; i < stringLiteralsLength; i++) {
						scope.problemReporter().nonExternalizedStringLiteral(this.stringLiterals[i]);
					}
				} else {
					// need to iterate both arrays to find non matching elements
					if (this.stringLiterals.length != stringLiteralsLength) {
						System.arraycopy(this.stringLiterals, 0, (stringLiterals = new StringLiteral[stringLiteralsLength]), 0, stringLiteralsLength);
					}
					Arrays.sort(this.stringLiterals, STRING_LITERAL_COMPARATOR);
					int indexInLine = 1;
					int lastLineNumber = -1;
					StringLiteral literal = null;
					int index = 0;
					int i = 0;
					stringLiteralsLoop: for (; i < stringLiteralsLength; i++) {
						literal = this.stringLiterals[i];
						final int literalLineNumber = literal.lineNumber;
						if (lastLineNumber != literalLineNumber) {
							indexInLine = 1;
							lastLineNumber = literalLineNumber;
						} else {
							indexInLine++;
						}
						if (index < nlsTagsLength) {
							nlsTagsLoop: for (; index < nlsTagsLength; index++) {
								NLSTag tag = this.nlsTags[index];
								if (tag == null) continue nlsTagsLoop;
								int tagLineNumber = tag.lineNumber;
								if (literalLineNumber < tagLineNumber) {
									scope.problemReporter().nonExternalizedStringLiteral(literal);
									continue stringLiteralsLoop;
								} else if (literalLineNumber == tagLineNumber) {
									if (tag.index == indexInLine) {
										this.nlsTags[index] = null;
										index++;
										continue stringLiteralsLoop;
									} else {
										nlsTagsLoop2: for (int index2 = index + 1; index2 < nlsTagsLength; index2++) {
											NLSTag tag2 = this.nlsTags[index2];
											if (tag2 == null) continue nlsTagsLoop2;
											int tagLineNumber2 = tag2.lineNumber;
											if (literalLineNumber == tagLineNumber2) {
												if (tag2.index == indexInLine) {
													this.nlsTags[index2] = null;
													continue stringLiteralsLoop;
												} else {
													continue nlsTagsLoop2;
												}
											} else {
												scope.problemReporter().nonExternalizedStringLiteral(literal);
												continue stringLiteralsLoop;
											}
										}
										scope.problemReporter().nonExternalizedStringLiteral(literal);
										continue stringLiteralsLoop;
									}
								} else {
									scope.problemReporter().unnecessaryNLSTags(tag.start, tag.end);
									continue nlsTagsLoop;
								}
							}
						}
						// all nls tags have been processed, so remaining string literals are not externalized
						break stringLiteralsLoop;
					}
					for (; i < stringLiteralsLength; i++) {
						scope.problemReporter().nonExternalizedStringLiteral(this.stringLiterals[i]);
					}
					if (index < nlsTagsLength) {
						for (; index < nlsTagsLength; index++) {
							NLSTag tag = this.nlsTags[index];
							if (tag != null) {
								scope.problemReporter().unnecessaryNLSTags(tag.start, tag.end);
							}
						}						
					}
				}
			}
		} catch (AbortCompilationUnit e) {
			this.ignoreFurtherInvestigation = true;
			return;
		}
	}

