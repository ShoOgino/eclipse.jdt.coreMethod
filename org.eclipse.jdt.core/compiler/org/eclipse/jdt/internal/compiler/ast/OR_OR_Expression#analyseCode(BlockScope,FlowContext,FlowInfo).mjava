public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo) {

	Constant opConstant;
	if ((opConstant = left.constant) != NotAConstant) {
		if (opConstant.booleanValue() == false) { 
			// FALSE || anything
			return right.analyseCode(currentScope, flowContext, flowInfo);
		} else { 
			// TRUE || anything
			return flowInfo;
		}
	}
	if ((opConstant = right.constant) != NotAConstant) {
		if (opConstant.booleanValue() == true) { 
			// anything || TRUE
			// whatever is on the left, we will succeed, so the result must merge the left inits when answering
			// initsWhenTrue.
			// the initsWhenFalse are undetermined, since this path will be fake reachable...
			FlowInfo mergedInfo = left.analyseCode(currentScope, flowContext, flowInfo).unconditionalInits();
			mergedInitStateIndex = currentScope.methodScope().recordInitializationStates(mergedInfo);
			return mergedInfo;			
		} else { 
			// anything || FALSE
			// ignore the right part
			FlowInfo mergedInfo = left.analyseCode(currentScope, flowContext, flowInfo);
			mergedInitStateIndex = currentScope.methodScope().recordInitializationStates(mergedInfo);
			return mergedInfo;			
		}
	}
	if ((opConstant = left.conditionalConstant()) != NotAConstant) {
		if (opConstant.booleanValue() == true){ 
			// TRUE || anything
			FlowInfo mergedInfo = left.analyseCode(currentScope, flowContext, flowInfo);
			mergedInitStateIndex = currentScope.methodScope().recordInitializationStates(mergedInfo);
			right.analyseCode(currentScope, flowContext, mergedInfo.copy().markAsFakeReachable(true));
			return mergedInfo;
		} 
	}
	FlowInfo leftInfo, rightInfo;	leftInfo = left.analyseCode(currentScope, flowContext, flowInfo);
	rightInfo = leftInfo.initsWhenFalse().copy();
	rightInitStateIndex = currentScope.methodScope().recordInitializationStates(rightInfo);
	rightInfo = right.analyseCode(currentScope, flowContext, rightInfo);
	FlowInfo mergedInfo = FlowInfo.conditional(
		// merging two true initInfos for such a negative case: if ((t && (b = t)) || f) r = b; // b may not have been initialized
		leftInfo.initsWhenTrue().unconditionalInits().mergedWith(rightInfo.initsWhenTrue().copy().unconditionalInits()), 
		rightInfo.initsWhenFalse());
	mergedInitStateIndex = currentScope.methodScope().recordInitializationStates(mergedInfo);
	return mergedInfo;
}

