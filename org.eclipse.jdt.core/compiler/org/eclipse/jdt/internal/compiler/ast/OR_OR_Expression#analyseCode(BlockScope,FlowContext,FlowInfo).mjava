	public FlowInfo analyseCode(
		BlockScope currentScope,
		FlowContext flowContext,
		FlowInfo flowInfo) {

		if (left.constant != NotAConstant) {
			if (!left.constant.booleanValue()) { // false || anything
				// in this case only, we are sure that local inits performed in 
				// the argument <anything> will be executed even though it was 
				// a conditional operation
				return right.analyseCode(currentScope, flowContext, flowInfo);
			} else { // true || anything
				// in this case only, we are sure that local inits performed in 
				// the argument <anything> will *not* be executed even though it 
				// was a conditional operation
				return flowInfo;
			}
		}
		if (right.constant != NotAConstant) {
			if (right.constant.booleanValue()) { // anything || true
				// whatever is on the left, we will succeed, so the result must merge the left inits when answering
				// initsWhenTrue.
				// the initsWhenFalse are undetermined, since this path will be fake reachable...
				FlowInfo mergedInfo =
					left.analyseCode(currentScope, flowContext, flowInfo).unconditionalInits();
				mergedInitStateIndex =
					currentScope.methodScope().recordInitializationStates(mergedInfo);
				return mergedInfo;
			} else { // anything || false
				// ignore the right part
				FlowInfo mergedInfo = left.analyseCode(currentScope, flowContext, flowInfo);
				mergedInitStateIndex =
					currentScope.methodScope().recordInitializationStates(mergedInfo);
				return mergedInfo;
			}
		}

		if (right.constant != NotAConstant) {
			// anything && true/false
			// in this case only, we are sure that local inits performed in 
			// the argument <anything> will be executed even though it was 
			// a conditional operation
			FlowInfo mergedInfo = left.analyseCode(currentScope, flowContext, flowInfo);
			mergedInitStateIndex =
				currentScope.methodScope().recordInitializationStates(mergedInfo);
			return mergedInfo;
		}

		FlowInfo leftInfo, rightInfo;
		leftInfo = left.analyseCode(currentScope, flowContext, flowInfo);
		rightInfo = leftInfo.initsWhenFalse().copy();
		rightInitStateIndex =
			currentScope.methodScope().recordInitializationStates(rightInfo);
		rightInfo = right.analyseCode(currentScope, flowContext, rightInfo);
		FlowInfo mergedInfo = FlowInfo.conditional(
			// merging two true initInfos for such a negative case: if ((t && (b = t)) || f) r = b; // b may not have been initialized
	leftInfo.initsWhenTrue().unconditionalInits().mergedWith(
		rightInfo.initsWhenTrue().copy().unconditionalInits()),
		rightInfo.initsWhenFalse());
		mergedInitStateIndex =
			currentScope.methodScope().recordInitializationStates(mergedInfo);
		return mergedInfo;
	}

