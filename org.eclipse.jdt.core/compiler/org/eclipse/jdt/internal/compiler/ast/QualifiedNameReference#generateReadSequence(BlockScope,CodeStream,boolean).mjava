	/*
	 * Generate code for all bindings (local and fields) excluding the last one, which may then be generated code
	 * for a read or write access.
	 */
	public void generateReadSequence(
		BlockScope currentScope,
		CodeStream codeStream,
		boolean valueRequired) {
		// determine the rank until which we now we do not need any actual value for the field access
		int otherBindingsCount = this.otherCodegenBindings == null ? 0 : otherCodegenBindings.length;
		int indexOfFirstValueRequired;
		if (valueRequired) {
			indexOfFirstValueRequired = otherBindingsCount;
			while (indexOfFirstValueRequired > 0) {
				FieldBinding otherBinding = this.otherCodegenBindings[indexOfFirstValueRequired - 1];
				if (otherBinding.isStatic() || otherBinding.constant != NotAConstant)
					break; // no longer need any value before this point
				indexOfFirstValueRequired--;
			}
		} else {
			indexOfFirstValueRequired = otherBindingsCount + 1;
		}
		if (indexOfFirstValueRequired == 0) {
			switch (bits & RestrictiveFlagMASK) {
				case FIELD :
					lastFieldBinding = (FieldBinding) this.codegenBinding;
					// if first field is actually constant, we can inline it
					if (lastFieldBinding.constant != NotAConstant) {
						codeStream.generateConstant(lastFieldBinding.constant, 0);
						// no implicit conversion
						lastFieldBinding = null; // will not generate it again
						break;
					}
					if (!lastFieldBinding.isStatic()) {
						if ((bits & DepthMASK) != 0) {
							Object[] emulationPath =
								currentScope.getExactEmulationPath(
									currentScope.enclosingSourceType().enclosingTypeAt(
										(bits & DepthMASK) >> DepthSHIFT));
							if (emulationPath == null) {
								// internal error, per construction we should have found it
								currentScope.problemReporter().needImplementation();
							} else {
								codeStream.generateOuterAccess(emulationPath, this, currentScope);
							}
						} else {
							generateReceiver(codeStream);
						}
					}
					break;
				case LOCAL : // reading the first local variable
					lastFieldBinding = null;
					LocalVariableBinding localBinding = (LocalVariableBinding) this.codegenBinding;
					// regular local variable read
					if (localBinding.constant != NotAConstant) {
						codeStream.generateConstant(localBinding.constant, 0);
						// no implicit conversion
					} else {
						// outer local?
						if ((bits & DepthMASK) != 0) {
							// outer local can be reached either through a synthetic arg or a synthetic field
							VariableBinding[] path = currentScope.getEmulationPath(localBinding);
							if (path == null) {
								// emulation was not possible (should not happen per construction)
								currentScope.problemReporter().needImplementation();
							} else {
								codeStream.generateOuterAccess(path, this, currentScope);
							}
						} else {
							codeStream.load(localBinding);
						}
					}
			}
		} else {
			lastFieldBinding = null;
		}
		// all intermediate field accesses are read accesses
		// only the last field binding is a write access
		if (this.otherCodegenBindings != null) {
			int start = indexOfFirstValueRequired == 0 ? 0 : indexOfFirstValueRequired - 1;
			for (int i = start; i < otherBindingsCount; i++) {
				if (lastFieldBinding != null) {
					MethodBinding accessor =
						syntheticReadAccessors == null ? null : syntheticReadAccessors[i];
					if (accessor == null)
						if (lastFieldBinding.isStatic())
							codeStream.getstatic(lastFieldBinding);
						else
							codeStream.getfield(lastFieldBinding);
					else
						codeStream.invokestatic(accessor);
				}
				lastFieldBinding = otherCodegenBindings[i];
			}
		}
	}

