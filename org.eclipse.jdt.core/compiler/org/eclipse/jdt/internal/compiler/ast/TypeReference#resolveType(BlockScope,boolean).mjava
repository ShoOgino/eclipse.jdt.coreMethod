public TypeBinding resolveType(BlockScope scope, boolean checkBounds) {
	// handle the error here
	this.constant = Constant.NotAConstant;
	if (this.resolvedType != null) // is a shared type reference which was already resolved
		return this.resolvedType.isValidBinding() ? this.resolvedType : null; // already reported error

	TypeBinding type = this.resolvedType = getTypeBinding(scope);
	if (type == null)
		return null; // detected cycle while resolving hierarchy	
	if (!type.isValidBinding()) {
		reportInvalidType(scope);
		return null;
	}
	if (type.isArrayType() && ((ArrayBinding) type).leafComponentType == TypeBinding.VOID) {
		scope.problemReporter().cannotAllocateVoidArray(this);
		return null;
	}

	if (isTypeUseDeprecated(type, scope))
		reportDeprecatedType(type, scope);
	
	type = scope.environment().convertToRawType(type, false /*do not force conversion of enclosing types*/);
	if (type.leafComponentType().isRawType() 
			&& (this.bits & ASTNode.IgnoreRawTypeCheck) == 0 
			&& scope.compilerOptions().getSeverity(CompilerOptions.RawTypeReference) != ProblemSeverities.Ignore) {	
		scope.problemReporter().rawTypeReference(this, type);
	}			
	return this.resolvedType = type;
}

