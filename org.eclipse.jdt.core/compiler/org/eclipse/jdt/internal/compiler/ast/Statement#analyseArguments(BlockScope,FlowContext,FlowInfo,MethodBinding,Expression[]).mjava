/** Analysing arguments of MessageSend, ExplicitConstructorCall, AllocationExpression. */
protected void analyseArguments(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo, MethodBinding methodBinding, Expression[] arguments)
{
	// compare actual null-status against parameter annotations of the called method:
	if (arguments != null && methodBinding.parameterNonNullness != null) {

		// check if varargs need special treatment:
		int numParamsToCheck = methodBinding.parameters.length;
		boolean passThrough = false;
		if (methodBinding.isVarargs()) {
			int varArgPos = numParamsToCheck-1;
			// this if-block essentially copied from generateArguments(..):
			if (numParamsToCheck == arguments.length) {
				TypeBinding varArgsType = methodBinding.parameters[varArgPos];
				TypeBinding lastType = arguments[varArgPos].resolvedType;
				if (lastType == TypeBinding.NULL
						|| (varArgsType.dimensions() == lastType.dimensions()
						&& lastType.isCompatibleWith(varArgsType)))
					passThrough = true; // pass directly as-is
			}
			if (!passThrough)
				numParamsToCheck--; // with non-passthrough varargs last param is fed from individual args -> don't check
		}

		for (int i = 0; i < numParamsToCheck; i++) {
			if (methodBinding.parameterNonNullness[i] == Boolean.TRUE) {
				TypeBinding expectedType = methodBinding.parameters[i];
				Expression argument = arguments[i];
				int nullStatus = argument.nullStatus(flowInfo); // slight loss of precision: should also use the null info from the receiver.
				if (nullStatus != FlowInfo.NON_NULL) // if required non-null is not provided
					flowContext.recordNullityMismatch(currentScope, argument, nullStatus, expectedType);
			}
		}
	}
}

