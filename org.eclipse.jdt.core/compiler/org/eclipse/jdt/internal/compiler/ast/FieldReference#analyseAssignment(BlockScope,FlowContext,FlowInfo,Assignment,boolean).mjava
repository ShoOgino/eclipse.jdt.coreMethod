public FlowInfo analyseAssignment(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo, Assignment assignment, boolean isCompound) {

	// compound assignment extra work
	if (isCompound) { // check the variable part is initialized if blank final
		if (binding.isFinal() && receiver.isThis() && currentScope.allowBlankFinalFieldAssignment(binding) && (!flowInfo.isDefinitelyAssigned(binding))) {
			currentScope.problemReporter().uninitializedBlankFinalField(binding, this);
			// we could improve error msg here telling "cannot use compound assignment on final blank field"
		}
		manageSyntheticReadAccessIfNecessary(currentScope);
	}
	if (assignment.expression != null) {
		flowInfo = assignment.expression.analyseCode(currentScope, flowContext, flowInfo).unconditionalInits();
	}
	flowInfo = receiver.analyseCode(currentScope, flowContext, flowInfo, !binding.isStatic()).unconditionalInits();
	manageSyntheticWriteAccessIfNecessary(currentScope);

	// check if assigning a final field 
	if (binding.isFinal()) {
		// in a context where it can be assigned?
		if (receiver.isThis() && currentScope.allowBlankFinalFieldAssignment(binding)) {
			if (flowInfo.isPotentiallyAssigned(binding)) {
				currentScope.problemReporter().duplicateInitializationOfBlankFinalField(binding, this);
			}
			flowInfo.markAsDefinitelyAssigned(binding);
			flowContext.recordSettingFinal(binding, this);
		} else {
			// assigning a final field outside an initializer or constructor
			currentScope.problemReporter().cannotAssignToFinalField(binding, this);
		}
	}
	return flowInfo;
}

