	public TypeBinding resolveForCatch(BlockScope scope) {

		// resolution on an argument of a catch clause
		// provide the scope with a side effect : insertion of a LOCAL
		// that represents the argument. The type must be from JavaThrowable

		TypeBinding tb = type.resolveTypeExpecting(scope, scope.getJavaLangThrowable());
		if (tb == null)
			return null;
		if ((binding = scope.duplicateName(name)) != null) {
			// the name already exists....may carry on with the first binding ....
			scope.problemReporter().redefineArgument(this);
			return null;
		}
		binding = new LocalVariableBinding(this, tb, modifiers, false); // argument decl, but local var  (i.e. isArgument = false)
		scope.addLocalVariable(binding);
		binding.constant = NotAConstant;
		return tb;
	}

