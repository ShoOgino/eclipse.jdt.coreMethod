	@Override
	public void resolve() {
		//
		if (this.binding == null) {
			this.ignoreFurtherInvestigation = true;
			return;
		}
		this.moduleBinding = this.scope.environment().getModule(this.moduleName);
		Set<ModuleBinding> requiredModules = new HashSet<ModuleBinding>();
		for(int i = 0; i < this.requiresCount; i++) {
			RequiresStatement ref = this.requires[i];
			if (ref != null && ref.resolve(this.scope) != null) {
				if (!requiredModules.add(ref.resolvedBinding)) {
					this.scope.problemReporter().duplicateModuleReference(IProblem.DuplicateRequires, ref.module);
				}
				Collection<ModuleBinding> deps = ref.resolvedBinding.dependencyGraphCollector().get();
				if (deps.contains(this.moduleBinding))
					this.scope.problemReporter().cyclicModuleDependency(this.moduleBinding, ref.module);
			}
		}
		Set<PackageBinding> exportedPkgs = new HashSet<>();
		for (int i = 0; i < this.exportsCount; i++) {
			ExportsStatement ref = this.exports[i];
 			if (ref != null && ref.resolve(this.scope)) {
				if (!exportedPkgs.add(ref.resolvedPackage)) {
					this.scope.problemReporter().invalidPackageReference(IProblem.DuplicateExports, ref);
				}
			}
		}
		Set<PackageBinding> openedPkgs = new HashSet<>();
		for (int i = 0; i < this.opensCount; i++) {
			OpensStatement ref = this.opens[i];
			if (isOpen()) {
				this.scope.problemReporter().invalidOpensStatement(ref, this);
			} else {
				if (ref.resolve(this.scope)) {
					if (!openedPkgs.add(ref.resolvedPackage)) {
						this.scope.problemReporter().invalidPackageReference(IProblem.DuplicateOpens, ref);
					}
				}
			}
		}
		Set<TypeBinding> allTypes = new HashSet<TypeBinding>();
		for(int i = 0; i < this.usesCount; i++) {
			TypeBinding serviceBinding = this.uses[i].serviceInterface.resolveType(this.scope);
			if (serviceBinding != null && serviceBinding.isValidBinding()) {
				if (!(serviceBinding.isClass() || serviceBinding.isInterface() || serviceBinding.isAnnotationType())) {
					this.scope.problemReporter().invalidServiceRef(IProblem.InvalidServiceIntfType, this.uses[i].serviceInterface);
				}
				if (!allTypes.add(this.uses[i].serviceInterface.resolvedType)) {
					this.scope.problemReporter().duplicateTypeReference(IProblem.DuplicateUses, this.uses[i].serviceInterface);
				}
			}
		}
		Set<TypeBinding> interfaces = new HashSet<>();
		for(int i = 0; i < this.servicesCount; i++) {
			this.services[i].resolve(this.scope);
			TypeBinding infBinding = this.services[i].serviceInterface.resolvedType;
			if (infBinding != null && infBinding.isValidBinding()) {
				if (!interfaces.add(this.services[i].serviceInterface.resolvedType)) { 
					this.scope.problemReporter().duplicateTypeReference(IProblem.DuplicateServices,
							this.services[i].serviceInterface);
				}
			}
		}
	}

