	@Override
	public ConstructorDeclaration createDefaultConstructor(	boolean needExplicitConstructorCall, boolean needToInsert) {
		//Add to method'set, the default constuctor that just recall the
		//super constructor with no arguments
		//The arguments' type will be positionned by the TC so just use
		//the default int instead of just null (consistency purpose)

		CompactConstructorDeclaration ccd = new CompactConstructorDeclaration(this.compilationResult);
//		constructor.bits |= ASTNode.IsDefaultConstructor;
		ccd.selector = this.name;
		ccd.modifiers = this.modifiers & ExtraCompilerModifiers.AccVisibilityMASK;
		ccd.isImplicit = true;

		//if you change this setting, please update the
		//SourceIndexer2.buildTypeDeclaration(TypeDeclaration,char[]) method
		ccd.declarationSourceStart = ccd.sourceStart = this.sourceStart;
		ccd.declarationSourceEnd =
			ccd.sourceEnd = ccd.bodyEnd = this.sourceEnd;

		//the super call inside the constructor
		if (needExplicitConstructorCall) {
			ccd.constructorCall = SuperReference.implicitSuperConstructorCall();
			ccd.constructorCall.sourceStart = this.sourceStart;
			ccd.constructorCall.sourceEnd = this.sourceEnd;
		}

		//adding the constructor in the methods list: rank is not critical since bindings will be sorted
		if (needToInsert) {
			if (this.methods == null) {
				this.methods = new AbstractMethodDeclaration[] { ccd };
			} else {
				AbstractMethodDeclaration[] newMethods;
				System.arraycopy(
					this.methods,
					0,
					newMethods = new AbstractMethodDeclaration[this.methods.length + 1],
					1,
					this.methods.length);
				newMethods[0] = ccd;
				this.methods = newMethods;
			}
		}
		return ccd;
	}

