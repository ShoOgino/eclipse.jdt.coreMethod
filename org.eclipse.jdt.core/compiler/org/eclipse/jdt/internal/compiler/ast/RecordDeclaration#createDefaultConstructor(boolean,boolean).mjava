	@Override
	public ConstructorDeclaration createDefaultConstructor(boolean needExplicitConstructorCall, boolean needToInsert) {
		//Add to method'set, the default constuctor that just recall the
		//super constructor with no arguments
		//The arguments' type will be positionned by the TC so just use
		//the default int instead of just null (consistency purpose)

		ConstructorDeclaration constructor = new ConstructorDeclaration(this.compilationResult);
		constructor.bits |= ASTNode.IsCanonicalConstructor | ASTNode.IsImplicit;
		constructor.selector = this.name;
		constructor.modifiers = this.modifiers & ExtraCompilerModifiers.AccVisibilityMASK;
		constructor.modifiers |= ClassFileConstants.AccPublic; // JLS 14 8.10.5
		constructor.arguments = this.args;

		constructor.declarationSourceStart = constructor.sourceStart =
				constructor.bodyStart = this.sourceStart;
		constructor.declarationSourceEnd =
			constructor.sourceEnd = constructor.bodyEnd =  this.sourceStart - 1;

		//the super call inside the constructor
		// needExplicitConstructorCall is ignored for RecordDeclaration.

		/* The body of the implicitly declared canonical constructor initializes each field corresponding
		 * to a record component with the corresponding formal parameter in the order that they appear
		 * in the record component list.*/
		Statement[] statements = new Statement[this.args.length];
		for (int i = 0, l = this.args.length; i < l; ++i) {
			Argument arg = this.args[i];
			FieldReference lhs = new FieldReference(arg.name, 0);
			lhs.receiver = ThisReference.implicitThis();
			statements[i] =  new Assignment(lhs, new SingleNameReference(arg.name, 0), 0);
		}
		constructor.statements = statements;

		//adding the constructor in the methods list: rank is not critical since bindings will be sorted
		if (needToInsert) {
			if (this.methods == null) {
				this.methods = new AbstractMethodDeclaration[] { constructor };
			} else {
				AbstractMethodDeclaration[] newMethods;
				System.arraycopy(
					this.methods,
					0,
					newMethods = new AbstractMethodDeclaration[this.methods.length + 1],
					1,
					this.methods.length);
				newMethods[0] = constructor;
				this.methods = newMethods;
			}
		}
		return constructor;
	}

