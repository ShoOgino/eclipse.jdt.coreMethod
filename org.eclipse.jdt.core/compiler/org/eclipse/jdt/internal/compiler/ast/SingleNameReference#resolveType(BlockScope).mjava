	public TypeBinding resolveType(BlockScope scope) {
		// for code gen, harm the restrictiveFlag 	
	
		if (this.actualReceiverType != null) {
			this.binding = scope.getField(this.actualReceiverType, token, this);
		} else {
			this.actualReceiverType = scope.enclosingSourceType();
			this.binding = scope.getBinding(token, bits & RestrictiveFlagMASK, this, true /*resolve*/);
		}
		this.codegenBinding = this.binding;
		if (this.binding.isValidBinding()) {
			switch (bits & RestrictiveFlagMASK) {
				case Binding.VARIABLE : // =========only variable============
				case Binding.VARIABLE | Binding.TYPE : //====both variable and type============
					if (binding instanceof VariableBinding) {
						VariableBinding variable = (VariableBinding) binding;
						if (binding instanceof LocalVariableBinding) {
							bits &= ~RestrictiveFlagMASK;  // clear bits
							bits |= Binding.LOCAL;
							if (!variable.isFinal() && (bits & DepthMASK) != 0) {
								scope.problemReporter().cannotReferToNonFinalOuterLocal((LocalVariableBinding)variable, this);
							}
							TypeBinding fieldType = variable.type;
							if ((this.bits & IsStrictlyAssignedMASK) == 0) {
								constant = variable.constant();
								if (fieldType != null) 
									fieldType = fieldType.capture(scope, this.sourceEnd); // perform capture conversion if read access
							} else {
								constant = NotAConstant;
							}
							return this.resolvedType = fieldType;
						}
						// a field
						FieldBinding field = (FieldBinding) this.binding;
						if (!field.isStatic() && scope.environment().options.getSeverity(CompilerOptions.UnqualifiedFieldAccess) != ProblemSeverities.Ignore) {
							scope.problemReporter().unqualifiedFieldAccess(this, field);
						}
						// perform capture conversion if read access
						TypeBinding fieldType = checkFieldAccess(scope);
						return this.resolvedType = 
							(((this.bits & IsStrictlyAssignedMASK) == 0) 
								? fieldType.capture(scope, this.sourceEnd)
								: fieldType);
					}
	
					// thus it was a type
					bits &= ~RestrictiveFlagMASK;  // clear bits
					bits |= Binding.TYPE;
				case Binding.TYPE : //========only type==============
					constant = Constant.NotAConstant;
					//deprecated test
					TypeBinding type = (TypeBinding)binding;
					if (isTypeUseDeprecated(type, scope))
						scope.problemReporter().deprecatedType(type, this);
					return this.resolvedType = scope.convertToRawType(type);
			}
		}
	
		// error scenarii
		return this.resolvedType = this.reportError(scope);
	}

