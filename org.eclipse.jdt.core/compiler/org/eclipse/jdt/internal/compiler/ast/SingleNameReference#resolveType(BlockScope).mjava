	public TypeBinding resolveType(BlockScope scope) {
		// for code gen, harm the restrictiveFlag 	
	
		this.actualReceiverType = this.receiverType = scope.enclosingSourceType();
		
		if ((this.codegenBinding = this.binding = scope.getBinding(token, bits & RestrictiveFlagMASK, this)).isValidBinding()) {
			switch (bits & RestrictiveFlagMASK) {
				case VARIABLE : // =========only variable============
				case VARIABLE | TYPE : //====both variable and type============
					if (binding instanceof VariableBinding) {
						VariableBinding variable = (VariableBinding) binding;
						if (binding instanceof LocalVariableBinding) {
							bits &= ~RestrictiveFlagMASK;  // clear bits
							bits |= LOCAL;
							if ((this.bits & IsStrictlyAssignedMASK) == 0) {
								constant = variable.constant;
							} else {
								constant = NotAConstant;
							}
							if (!variable.isFinal() && (bits & DepthMASK) != 0) {
								scope.problemReporter().cannotReferToNonFinalOuterLocal((LocalVariableBinding)variable, this);
							}
							return this.resolvedType = variable.type;
						}
						// a field
						FieldBinding field = (FieldBinding) this.binding;
						if (!field.isStatic() && scope.environment().options.getSeverity(CompilerOptions.UnqualifiedFieldAccess) != ProblemSeverities.Ignore) {
							scope.problemReporter().unqualifiedFieldAccess(this, field);
						}
						return this.resolvedType = checkFieldAccess(scope);
					}
	
					// thus it was a type
					bits &= ~RestrictiveFlagMASK;  // clear bits
					bits |= TYPE;
				case TYPE : //========only type==============
					constant = Constant.NotAConstant;
					//deprecated test
					if (isTypeUseDeprecated((TypeBinding) binding, scope))
						scope.problemReporter().deprecatedType((TypeBinding) binding, this);
					return this.resolvedType = (TypeBinding) binding;
			}
		}
	
		// error scenarii
		return this.resolvedType = this.reportError(scope);
	}

