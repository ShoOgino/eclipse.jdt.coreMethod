	/* (non-Javadoc)
	 * @see org.eclipse.jdt.internal.compiler.ast.SubRoutineStatement#generateSubRoutineInvocation(org.eclipse.jdt.internal.compiler.lookup.BlockScope, org.eclipse.jdt.internal.compiler.codegen.CodeStream)
	 */
	public void generateSubRoutineInvocation(
			BlockScope currentScope,
			CodeStream codeStream) {
	
		if (isSubRoutineEscaping()) {
				codeStream.goto_(this.subRoutineStartLabel);
		} else {
			if (currentScope.compilerOptions().inlineJsrBytecode) {
				// cannot use jsr bytecode, then simply inline the subroutine
				this.exitAnyExceptionHandler();
				// inside try block, ensure to deactivate all catch block exception handlers while inlining finally block
				for (int i = 0, length = this.enclosingExceptionLabels == null ? 0 : this.enclosingExceptionLabels.length; i < length; i++) {
					this.enclosingExceptionLabels[i].placeEnd();
				}
				this.finallyBlock.generateCode(currentScope, codeStream);
				this.enterAnyExceptionHandler(codeStream);
				// inside try block, ensure to reactivate all catch block exception handlers after inlining finally block
				for (int i = 0, length = this.enclosingExceptionLabels == null ? 0 : this.enclosingExceptionLabels.length; i < length; i++) {
					this.enclosingExceptionLabels[i].placeStart();
				}
			} else {
				// classic subroutine invocation, distinguish case of non-returning subroutine
				codeStream.jsr(this.subRoutineStartLabel);
			}
		}
	}

