	public void generateCode(
		BlockScope currentScope,
		CodeStream codeStream,
		boolean valueRequired) {
		int pc = codeStream.position;
		ReferenceBinding allocatedType = binding.declaringClass;
		if (allocatedType.isLocalType()) {
			LocalTypeBinding localType = (LocalTypeBinding) allocatedType;
			localType.constantPoolName(
				codeStream.classFile.outerMostEnclosingClassFile().computeConstantPoolName(
					localType));
		}
		if (syntheticAccessor == null) {
			codeStream.new_(allocatedType);
			if (valueRequired) {
				codeStream.dup();
			}
			// better highlight for allocation: display the type individually
			codeStream.recordPositionsFrom(pc, type);
		}
		// handling innerclass instance allocation
		if (allocatedType.isNestedType()) {
			// make sure its name is computed before arguments, since may be necessary for argument emulation
			codeStream.generateSyntheticArgumentValues(
				currentScope,
				allocatedType,
				enclosingInstance(),
				this);
		}
		// generate the arguments for constructor
		if (arguments != null) {
			for (int i = 0, count = arguments.length; i < count; i++) {
				arguments[i].generateCode(currentScope, codeStream, true);
			}
		}
		// invoke constructor
		if (syntheticAccessor == null) {
			codeStream.invokespecial(binding);
		} else {
			codeStream.invokestatic(syntheticAccessor);
		}
		codeStream.recordPositionsFrom(pc, this);
		if (anonymousType != null) {
			anonymousType.generateCode(currentScope, codeStream);
		}
	}

