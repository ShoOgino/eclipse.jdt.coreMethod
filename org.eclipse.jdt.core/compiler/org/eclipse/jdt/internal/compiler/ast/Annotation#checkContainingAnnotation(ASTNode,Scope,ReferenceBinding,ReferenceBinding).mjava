	public static void checkContainingAnnotation(ASTNode markerNode, Scope scope, ReferenceBinding container, ReferenceBinding repeatableAnnotation) {
		MethodBinding[] annotationMethods = container.methods();
		boolean sawValue = false;
		for (int i = 0, length = annotationMethods.length; i < length; ++i) {
			MethodBinding method = annotationMethods[i];
			if (CharOperation.equals(method.selector, TypeConstants.VALUE)) {
				sawValue = true;
				if (method.returnType.isArrayType() && method.returnType.dimensions() == 1) {
					ArrayBinding array = (ArrayBinding) method.returnType;
					if (TypeBinding.equalsEquals(array.elementsType(), repeatableAnnotation)) continue;
				}
				scope.problemReporter().containingAnnotationHasWrongValueType(markerNode, container, repeatableAnnotation, method.returnType);
			} else {
				// Not the value() - must have default (or else isn't suitable as container
				if ((method.modifiers & ClassFileConstants.AccAnnotationDefault) == 0) {
					scope.problemReporter().containingAnnotationHasNonDefaultMembers(markerNode, container, method.selector);
				}
			}
		}
		if (!sawValue) {
			scope.problemReporter().containingAnnotationMustHaveValue(markerNode, container);
		}
		
		checkContainingAnnotationRetention(markerNode, scope, container, repeatableAnnotation);
		if (markerNode instanceof Annotation)
			checkContainingAnnotationTarget((Annotation) markerNode, (BlockScope) scope, (TypeBinding) container, repeatableAnnotation);
		else
			checkContainingAnnotationTarget(markerNode, scope, container, repeatableAnnotation);
		checkContaintAnnotationDocumented(markerNode, scope, container, repeatableAnnotation);
		checkContaintAnnotationInherited(markerNode, scope, container, repeatableAnnotation);
	}

