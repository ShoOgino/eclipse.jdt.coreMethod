	/* 
	 * Access emulation for a local type
	 * force to emulation of access to direct enclosing instance.
	 * By using the initializer scope, we actually only request an argument emulation, the
	 * field is not added until actually used. However we will force allocations to be qualified
	 * with an enclosing instance.
	 * 15.9.2
	 */
	public void manageEnclosingInstanceAccessIfNecessary(BlockScope currentScope) {

		NestedTypeBinding nestedType = (NestedTypeBinding) binding;
		
		MethodScope methodScope = currentScope.methodScope();
		if (!methodScope.isStatic && !methodScope.isConstructorCall){

			nestedType.addSyntheticArgumentAndField(binding.enclosingType());	
		}
		// add superclass enclosing instance arg for anonymous types (if necessary)
		if (binding.isAnonymousType()) { 
			ReferenceBinding superclass = binding.superclass;
			if (superclass.enclosingType() != null && !superclass.isStatic()) {
				if (!binding.superclass.isLocalType()
						|| ((NestedTypeBinding)binding.superclass).getSyntheticField(superclass.enclosingType(), true) != null){

					nestedType.addSyntheticArgument(superclass.enclosingType());	
				}
			}
		}
	}

