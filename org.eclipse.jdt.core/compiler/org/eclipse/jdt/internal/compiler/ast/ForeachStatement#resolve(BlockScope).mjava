	public void resolve(BlockScope upperScope) {
		// use the scope that will hold the init declarations
		this.scope = new BlockScope(upperScope);
		this.elementVariable.resolve(this.scope); // collection expression can see itemVariable
		TypeBinding elementType = this.elementVariable.type.resolvedType;
		TypeBinding collectionType = this.collection == null ? null : this.collection.resolveType(this.scope);

		TypeBinding expectedCollectionType = null;
		if (elementType != null && collectionType != null) {
			if (collectionType.isArrayType()) { // for(E e : E[])
				this.kind = ARRAY;
				this.collectionElementType = ((ArrayBinding) collectionType).elementsType();
				if (!this.collectionElementType.isCompatibleWith(elementType)
						&& !this.scope.isBoxingCompatibleWith(this.collectionElementType, elementType)) {
					this.scope.problemReporter().notCompatibleTypesErrorInForeach(this.collection, this.collectionElementType, elementType);
				}
				// in case we need to do a conversion
				int compileTimeTypeID = this.collectionElementType.id;
				if (elementType.isBaseType()) {
					this.collection.computeConversion(this.scope, collectionType, collectionType);
					if (!this.collectionElementType.isBaseType()) {
						compileTimeTypeID = this.scope.environment().computeBoxingType(this.collectionElementType).id;
						this.elementVariableImplicitWidening = UNBOXING;
						if (elementType.isBaseType()) {
							this.elementVariableImplicitWidening |= (elementType.id << 4) + compileTimeTypeID;
							this.scope.problemReporter().autoboxing(this.collection, this.collectionElementType, elementType);
						}
					} else {
						this.elementVariableImplicitWidening = (elementType.id << 4) + compileTimeTypeID;
					}
				} else if (this.collectionElementType.isBaseType()) {
					this.collection.computeConversion(this.scope, collectionType, collectionType);
					int boxedID = this.scope.environment().computeBoxingType(this.collectionElementType).id;
					this.elementVariableImplicitWidening = BOXING | (compileTimeTypeID << 4) | compileTimeTypeID; // use primitive type in implicit conversion
					compileTimeTypeID = boxedID;
					this.scope.problemReporter().autoboxing(this.collection, this.collectionElementType, elementType);
				} else {
					expectedCollectionType = upperScope.createArrayType(elementType, 1);
					this.collection.computeConversion(this.scope, expectedCollectionType, collectionType);
				}
			} else if (collectionType instanceof ReferenceBinding) {
				ReferenceBinding iterableType = ((ReferenceBinding)collectionType).findSuperTypeOriginatingFrom(T_JavaLangIterable, false /*Iterable is not a class*/);
				checkIterable: {
					if (iterableType == null) break checkIterable;

					this.iteratorReceiverType = collectionType.erasure();
					if (((ReferenceBinding)this.iteratorReceiverType).findSuperTypeOriginatingFrom(T_JavaLangIterable, false) == null) {
						this.iteratorReceiverType = iterableType; // handle indirect inheritance thru variable secondary bound
						this.collection.computeConversion(this.scope, iterableType, collectionType);
					} else {
						this.collection.computeConversion(this.scope, collectionType, collectionType);
					}

					TypeBinding[] arguments = null;
					switch (iterableType.kind()) {
						case Binding.RAW_TYPE : // for(Object o : Iterable)
							this.kind = RAW_ITERABLE;
							this.collectionElementType = this.scope.getJavaLangObject();
							if (!this.collectionElementType.isCompatibleWith(elementType)
									&& !this.scope.isBoxingCompatibleWith(this.collectionElementType, elementType)) {
								this.scope.problemReporter().notCompatibleTypesErrorInForeach(this.collection, this.collectionElementType, elementType);
							}
							// no conversion needed as only for reference types
							break checkIterable;

						case Binding.GENERIC_TYPE : // for (T t : Iterable<T>) - in case used inside Iterable itself
							arguments = iterableType.typeVariables();
							break;

						case Binding.PARAMETERIZED_TYPE : // for(E e : Iterable<E>)
							arguments = ((ParameterizedTypeBinding)iterableType).arguments;
							break;

						default:
							break checkIterable;
					}
					// generic or parameterized case
					if (arguments.length != 1) break checkIterable; // per construction can only be one
					this.kind = GENERIC_ITERABLE;

					this.collectionElementType = arguments[0];
					if (!this.collectionElementType.isCompatibleWith(elementType)
							&& !this.scope.isBoxingCompatibleWith(this.collectionElementType, elementType)) {
						this.scope.problemReporter().notCompatibleTypesErrorInForeach(this.collection, this.collectionElementType, elementType);
					}
					int compileTimeTypeID = this.collectionElementType.id;
					// no conversion needed as only for reference types
					if (elementType.isBaseType()) {
						if (!this.collectionElementType.isBaseType()) {
							compileTimeTypeID = this.scope.environment().computeBoxingType(this.collectionElementType).id;
							this.elementVariableImplicitWidening = UNBOXING;
							if (elementType.isBaseType()) {
								this.elementVariableImplicitWidening |= (elementType.id << 4) + compileTimeTypeID;
							}
						} else {
							this.elementVariableImplicitWidening = (elementType.id << 4) + compileTimeTypeID;
						}
					} else {
						if (this.collectionElementType.isBaseType()) {
							int boxedID = this.scope.environment().computeBoxingType(this.collectionElementType).id;
							this.elementVariableImplicitWidening = BOXING | (compileTimeTypeID << 4) | compileTimeTypeID; // use primitive type in implicit conversion
							compileTimeTypeID = boxedID;
						}
					}
				}
			}
			switch(this.kind) {
				case ARRAY :
					// allocate #index secret variable (of type int)
					this.indexVariable = new LocalVariableBinding(SecretIndexVariableName, TypeBinding.INT, ClassFileConstants.AccDefault, false);
					this.scope.addLocalVariable(this.indexVariable);
					this.indexVariable.setConstant(Constant.NotAConstant); // not inlinable
					// allocate #max secret variable
					this.maxVariable = new LocalVariableBinding(SecretMaxVariableName, TypeBinding.INT, ClassFileConstants.AccDefault, false);
					this.scope.addLocalVariable(this.maxVariable);
					this.maxVariable.setConstant(Constant.NotAConstant); // not inlinable
					// add #array secret variable (of collection type)
					if (expectedCollectionType == null) {
						this.collectionVariable = new LocalVariableBinding(SecretCollectionVariableName, collectionType, ClassFileConstants.AccDefault, false);
					} else {
						this.collectionVariable = new LocalVariableBinding(SecretCollectionVariableName, expectedCollectionType, ClassFileConstants.AccDefault, false);
					}
					this.scope.addLocalVariable(this.collectionVariable);
					this.collectionVariable.setConstant(Constant.NotAConstant); // not inlinable
					break;
				case RAW_ITERABLE :
				case GENERIC_ITERABLE :
					// allocate #index secret variable (of type Iterator)
					this.indexVariable = new LocalVariableBinding(SecretIteratorVariableName, this.scope.getJavaUtilIterator(), ClassFileConstants.AccDefault, false);
					this.scope.addLocalVariable(this.indexVariable);
					this.indexVariable.setConstant(Constant.NotAConstant); // not inlinable
					break;
				default :
					this.scope.problemReporter().invalidTypeForCollection(this.collection);
			}
		}
		if (this.action != null) {
			this.action.resolve(this.scope);
		}
	}

