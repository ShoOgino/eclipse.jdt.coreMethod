	/**
	 * For statement code generation
	 *
	 * @param currentScope org.eclipse.jdt.internal.compiler.lookup.BlockScope
	 * @param codeStream org.eclipse.jdt.internal.compiler.codegen.CodeStream
	 */
	public void generateCode(BlockScope currentScope, CodeStream codeStream) {
	    
		if ((bits & IsReachable) == 0) {
			return;
		}
		int pc = codeStream.position;
		final boolean hasEmptyAction = this.action == null
			|| this.action.isEmptyBlock()
			|| ((this.action.bits & IsUsefulEmptyStatement) != 0);

		// generate the initializations
		switch(this.kind) {
			case ARRAY :
				if (hasEmptyAction) {
					collection.generateCode(scope, codeStream, false);
					break;
				}
				collection.generateCode(scope, codeStream, true);
				codeStream.store(this.collectionVariable, false);
				codeStream.iconst_0();
				codeStream.store(this.indexVariable, false);
				codeStream.load(this.collectionVariable);
				codeStream.arraylength();
				codeStream.store(this.maxVariable, false);
				break;
			case RAW_ITERABLE :
			case GENERIC_ITERABLE :
				collection.generateCode(scope, codeStream, true);
				// declaringClass.iterator();
				MethodBinding iteratorMethodBinding =
					new MethodBinding(
							ClassFileConstants.AccPublic,
							"iterator".toCharArray(),//$NON-NLS-1$
							scope.getJavaUtilIterator(),
							Binding.NO_PARAMETERS,
							Binding.NO_EXCEPTIONS,
							(ReferenceBinding) this.iteratorReceiverType.erasure());
				if (this.iteratorReceiverType.isInterface()) {
					codeStream.invokeinterface(iteratorMethodBinding);
				} else {
					codeStream.invokevirtual(iteratorMethodBinding);
				}
				codeStream.store(this.indexVariable, false);
				break;
		}
		// label management
		BranchLabel actionLabel = new BranchLabel(codeStream);
		actionLabel.tagBits |= BranchLabel.USED;
		BranchLabel conditionLabel = new BranchLabel(codeStream);
		conditionLabel.tagBits |= BranchLabel.USED;
		breakLabel.initialize(codeStream);
		if (this.continueLabel != null) {
			this.continueLabel.initialize(codeStream);
			this.continueLabel.tagBits |= BranchLabel.USED;
		}
		// jump over the actionBlock
		codeStream.goto_(conditionLabel);

		// generate the loop action
		actionLabel.place();

		// generate the loop action
		switch(this.kind) {
			case ARRAY :
				if (this.elementVariable.binding.resolvedPosition == -1) break;
				codeStream.load(this.collectionVariable);
				codeStream.load(this.indexVariable);
				codeStream.arrayAt(this.collectionElementType.id);
				if (this.elementVariableImplicitWidening != -1) {
					codeStream.generateImplicitConversion(this.elementVariableImplicitWidening);
				}
				codeStream.store(this.elementVariable.binding, false);
				break;
			case RAW_ITERABLE :
			case GENERIC_ITERABLE :
				codeStream.load(this.indexVariable);
				codeStream.invokeJavaUtilIteratorNext();
				if (this.elementVariable.binding.resolvedPosition == -1) {
					codeStream.pop();
				} else {
					if (this.elementVariable.binding.type.id != T_JavaLangObject) {
						if (this.elementVariableImplicitWidening != -1) {
							codeStream.checkcast(this.collectionElementType);
							codeStream.generateImplicitConversion(this.elementVariableImplicitWidening);
						} else {
							codeStream.checkcast(this.elementVariable.binding.type);
						}
					}
					codeStream.store(this.elementVariable.binding, false);
				}
				break;
		}
		codeStream.addVisibleLocalVariable(this.elementVariable.binding);
		if (this.postCollectionInitStateIndex != -1) {
			codeStream.addDefinitelyAssignedVariables(
				currentScope,
				this.postCollectionInitStateIndex);
		}

		if (!hasEmptyAction) {
			this.action.generateCode(scope, codeStream);
		}

		// continuation point
		if (this.continueLabel != null) {
			this.continueLabel.place();
			int continuationPC = codeStream.position;
			// generate the increments for next iteration
			switch(this.kind) {
				case ARRAY :
					if (hasEmptyAction) break;
					codeStream.iinc(this.indexVariable.resolvedPosition, 1);
					break;
				case RAW_ITERABLE :
				case GENERIC_ITERABLE :
					break;
			}
			codeStream.recordPositionsFrom(continuationPC, this.elementVariable.sourceStart);
		}
		
		if (this.postCollectionInitStateIndex != -1) {
			codeStream.removeNotDefinitelyAssignedVariables(currentScope, postCollectionInitStateIndex);
		}
		// generate the condition
		conditionLabel.place();
		int conditionPC = codeStream.position;
		switch(this.kind) {
			case ARRAY :
				if (hasEmptyAction) break;
				codeStream.load(this.indexVariable);
				codeStream.load(this.maxVariable);
				codeStream.if_icmplt(actionLabel);
				break;
			case RAW_ITERABLE :
			case GENERIC_ITERABLE :
				codeStream.load(this.indexVariable);
				codeStream.invokeJavaUtilIteratorHasNext();
				codeStream.ifne(actionLabel);
				break;
		}
		codeStream.recordPositionsFrom(conditionPC, this.elementVariable.sourceStart);

		codeStream.exitUserScope(scope);
		if (mergedInitStateIndex != -1) {
			codeStream.removeNotDefinitelyAssignedVariables(currentScope, mergedInitStateIndex);
			codeStream.addDefinitelyAssignedVariables(currentScope, mergedInitStateIndex);			
		}
		breakLabel.place();
		codeStream.recordPositionsFrom(pc, this.sourceStart);
	}

