	public void resolveStatements() {

		// ========= abort on fatal error =============
		if (this.returnType != null && this.binding != null) {
			this.returnType.resolvedType = this.binding.returnType;
			// record the return type binding
		}
		// check if method with constructor name
		if (CharOperation.equals(scope.enclosingSourceType().sourceName, selector)) {
			scope.problemReporter().methodWithConstructorName(this);
		}
		
		// check @Override annotation
		if (this.binding != null) {
			int bindingModifiers = this.binding.modifiers;
			if ((this.binding.tagBits & TagBits.AnnotationOverride) != 0 
					&& (bindingModifiers & AccOverriding) == 0) {
				// claims to override, and doesn't actually do so
				scope.problemReporter().methodMustOverride(this);
			} else	if ((this.binding.tagBits & TagBits.AnnotationOverride) == 0 
						&& (this.binding.declaringClass.modifiers & AccInterface) == 0
						&& (bindingModifiers & (AccStatic|AccOverriding)) == AccOverriding
						&& scope.compilerOptions().sourceLevel >= JDK1_5) {
				// actually overrides, but did not claim to do so
				scope.problemReporter().missingOverrideAnnotation(this);
			}
		}
				
		// by grammatical construction, interface methods are always abstract
		switch (scope.referenceType().kind()) {
			case IGenericType.ENUM_DECL :
				if (this.selector == TypeConstants.VALUES) break;
				if (this.selector == TypeConstants.VALUEOF) break;
			case IGenericType.CLASS_DECL :
				// if a method has an semicolon body and is not declared as abstract==>error
				// native methods may have a semicolon body 
				if ((this.modifiers & AccSemicolonBody) != 0) {
					if ((this.modifiers & AccNative) == 0)
						if ((this.modifiers & AccAbstract) == 0)
							scope.problemReporter().methodNeedBody(this);
				} else {
					// the method HAS a body --> abstract native modifiers are forbiden
					if (((this.modifiers & AccNative) != 0) || ((this.modifiers & AccAbstract) != 0))
						scope.problemReporter().methodNeedingNoBody(this);
				}
		}
		super.resolveStatements(); 
	}

