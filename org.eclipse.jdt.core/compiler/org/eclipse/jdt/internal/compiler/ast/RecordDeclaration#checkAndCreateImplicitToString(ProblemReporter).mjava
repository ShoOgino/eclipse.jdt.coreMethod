	private void checkAndCreateImplicitToString(ProblemReporter problemReporter) {
		if (null != getMethodByName(TypeConstants.TOSTRING))
			return;
		QualifiedTypeReference returnType = new QualifiedTypeReference(JAVA_LANG_STRING, this.default_long_pos);
		MethodDeclaration md = createMethodDeclaration(TypeConstants.TOSTRING, returnType);
		MarkerAnnotation overrideAnnotation = new MarkerAnnotation(new SingleTypeReference(TypeConstants.JAVA_LANG_OVERRIDE[2], 0), 0);
		md.annotations = new Annotation[] { overrideAnnotation };
		// getClass().getName() + "@" + Integer.toHexString(hashCode())
		Expression left = new StringLiteral(this.name, -1, -1, -1);
		Expression right = new StringLiteral(new char[] {'@'}, -1, -1, -1);
		left = new BinaryExpression(left, right, OperatorIds.PLUS);
		MessageSend m = new MessageSend();
		m.receiver = new QualifiedNameReference(
				TypeConstants.JAVA_LANG_INTEGER,
				this.default_long_pos, -1, -1);
		m.selector = "toHexString".toCharArray(); //$NON-NLS-1$
		MessageSend hc = new MessageSend();
		hc.receiver = new ThisReference(-1, -1);
		hc.selector = TypeConstants.HASHCODE;
		m.arguments = new Expression[] {hc};
		right = m;
		CombinedBinaryExpression cbe = new CombinedBinaryExpression(left, right, OperatorIds.PLUS, 1);
		md.statements = new Statement[] { new ReturnStatement(cbe, -1, -1) };
		md.isImplicit = true;
	}

