public TypeBinding[] inferElidedTypes(ReferenceBinding allocationType, ReferenceBinding enclosingType, TypeBinding[] argumentTypes, final BlockScope scope) {
	/* Given the allocation type and the arguments to the constructor, see if we can synthesize a generic static factory
	   method that would, given the argument types and the invocation site, manufacture a parameterized object of type allocationType.
	   If we are successful then by design and construction, the parameterization of the return type of the factory method is identical
	   to the types elided in the <>.
	 */   
	MethodBinding factory = scope.getStaticFactory(allocationType, enclosingType, argumentTypes, this);
	if (factory instanceof ParameterizedGenericMethodBinding && factory.isValidBinding()) {
		ParameterizedGenericMethodBinding genericFactory = (ParameterizedGenericMethodBinding) factory;
		this.inferredReturnType = genericFactory.inferredReturnType;
		// this is our last chance to inspect the result of the inference that is connected to the throw-away factory binding
		InferenceContext18 infCtx18 = getInferenceContext(genericFactory);
		if (infCtx18 != null && infCtx18.stepCompleted == InferenceContext18.BINDINGS_UPDATED) {
			// refresh argumentTypes from updated bindings in arguments:
			// (this shouldn't be strictly necessary, as FunctionExpression.isCompatibleWith() should give the same result,
			//  but it's probably be a good idea to avoid the necessity to call isCompatibleWith() in the first place). 
			for (int i = 0; i < argumentTypes.length; i++) {
				if (argumentTypes[i] instanceof PolyTypeBinding)
					argumentTypes[i] = this.arguments[i].resolvedType;
			}
		}
		return ((ParameterizedTypeBinding)factory.returnType).arguments;
	}
	return null;
}

