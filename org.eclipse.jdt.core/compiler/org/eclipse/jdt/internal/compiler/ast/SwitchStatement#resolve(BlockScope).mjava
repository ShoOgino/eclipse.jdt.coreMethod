	public void resolve(BlockScope upperScope) {
	
	    try {
			boolean isEnumSwitch = false;
			TypeBinding expressionType = expression.resolveType(upperScope);
			if (expressionType == null)
				return;
			expression.computeConversion(upperScope, expressionType, expressionType);
			checkType: {
				if (expressionType.isBaseType()) {
					if (expression.isConstantValueOfTypeAssignableToType(expressionType, IntBinding))
						break checkType;
					if (expressionType.isCompatibleWith(IntBinding))
						break checkType;
				} else if (expressionType.isEnum()) {
					isEnumSwitch = true;
					break checkType;
				} else if (upperScope.isBoxingCompatibleWith(expressionType, IntBinding)) {
					expression.computeConversion(upperScope, IntBinding, expressionType);
					break checkType;
				}
				upperScope.problemReporter().incorrectSwitchType(expression, expressionType);
				// TODO (philippe) could keep analyzing switch statements in case of error
				return;
			}
			if (statements != null) {
				scope = /*explicitDeclarations == 0 ? upperScope : */new BlockScope(upperScope);
				int length;
				// collection of cases is too big but we will only iterate until caseCount
				cases = new CaseStatement[length = statements.length];
				this.constants = new int[length];
				CaseStatement[] duplicateCaseStatements = null;
				int duplicateCaseStatementsCounter = 0;
				int counter = 0;
				for (int i = 0; i < length; i++) {
					Constant constant;
					final Statement statement = statements[i];
					if ((constant = statement.resolveCase(scope, expressionType, this)) != Constant.NotAConstant) {
						int key = constant.intValue();
						//----check for duplicate case statement------------
						for (int j = 0; j < counter; j++) {
							if (this.constants[j] == key) {
								final CaseStatement currentCaseStatement = (CaseStatement) statement;
								if (duplicateCaseStatements == null) {
									scope.problemReporter().duplicateCase(cases[j]);
									scope.problemReporter().duplicateCase(currentCaseStatement);
									duplicateCaseStatements = new CaseStatement[length];
									duplicateCaseStatements[duplicateCaseStatementsCounter++] = cases[j];
									duplicateCaseStatements[duplicateCaseStatementsCounter++] = currentCaseStatement;
								} else {
									boolean found = false;
									searchReportedDuplicate: for (int k = 2; k < duplicateCaseStatementsCounter; k++) {
										if (duplicateCaseStatements[k] == statement) {
											found = true;
											break searchReportedDuplicate;
										}
									}
									if (!found) {
										scope.problemReporter().duplicateCase(currentCaseStatement);
										duplicateCaseStatements[duplicateCaseStatementsCounter++] = currentCaseStatement;
									}
								}
							}
						}
						this.constants[counter++] = key;
					}
				}
				if (length != counter) { // resize constants array
					System.arraycopy(this.constants, 0, this.constants = new int[counter], 0, counter);
				}
			} else {
				if ((this.bits & UndocumentedEmptyBlock) != 0) {
					upperScope.problemReporter().undocumentedEmptyBlock(this.blockStart, this.sourceEnd);
				}
			}
			// for enum switch, check if all constants are accounted for (if no default) 
			if (isEnumSwitch && defaultCase == null 
					&& upperScope.compilerOptions().getSeverity(CompilerOptions.IncompleteEnumSwitch) != ProblemSeverities.Ignore) {
				int constantCount = this.constants == null ? 0 : this.constants.length; // could be null if no case statement
				if (constantCount == caseCount // ignore diagnosis if unresolved constants
						&& caseCount != ((ReferenceBinding)expressionType).enumConstantCount()) {
					FieldBinding[] enumFields = ((ReferenceBinding)expressionType.erasure()).fields();
					for (int i = 0, max = enumFields.length; i <max; i++) {
						FieldBinding enumConstant = enumFields[i];
						if ((enumConstant.modifiers & ClassFileConstants.AccEnum) == 0) continue;
						findConstant : {
							for (int j = 0; j < caseCount; j++) {
								if (enumConstant.id == this.constants[j]) break findConstant;
							}
							// enum constant did not get referenced from switch
							upperScope.problemReporter().missingEnumConstantCase(this, enumConstant);
						}
					}
				}
			}
	    } finally {
	        if (this.scope != null) this.scope.enclosingCase = null; // no longer inside switch case block
	    }
	}

