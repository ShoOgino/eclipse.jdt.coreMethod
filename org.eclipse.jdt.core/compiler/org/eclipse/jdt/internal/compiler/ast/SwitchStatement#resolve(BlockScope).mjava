	public void resolve(BlockScope upperScope) {

		TypeBinding testType = testExpression.resolveType(upperScope);
		if (testType == null)
			return;
		testExpression.implicitWidening(testType, testType);
		if (!(testExpression.isConstantValueOfTypeAssignableToType(testType, IntBinding))) {
			if (!testType.isCompatibleWith(IntBinding)) {
				upperScope.problemReporter().incorrectSwitchType(testExpression, testType);
				return;
			}
		}
		if (statements != null) {
			scope = explicitDeclarations == 0 ? upperScope : new BlockScope(upperScope);
			int length;
			// collection of cases is too big but we will only iterate until caseCount
			cases = new CaseStatement[length = statements.length];
			int[] casesValues = new int[length];
			int counter = 0;
			for (int i = 0; i < length; i++) {
				Constant cst;
				if ((cst = statements[i].resolveCase(scope, testType, this)) != null) {
					//----check for duplicate case statement------------
					if (cst != NotAConstant) {
						int key = cst.intValue();
						for (int j = 0; j < counter; j++) {
							if (casesValues[j] == key) {
								scope.problemReporter().duplicateCase((CaseStatement) statements[i], cst); //TODO: (philippe) could improve diagnosis to indicate colliding case
							}
						}
						casesValues[counter++] = key;
					}
				}
			}
		}
	}

