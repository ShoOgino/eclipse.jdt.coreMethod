	public TypeBinding resolveType(BlockScope scope) {

		// Propagate the type checking to the arguments, and check if the constructor is defined.
		constant = NotAConstant;
		TypeBinding typeBinding = type.resolveType(scope);
		// will check for null after args are resolved

		// buffering the arguments' types
		TypeBinding[] argumentTypes = NoParameters;
		if (arguments != null) {
			boolean argHasError = false;
			int length = arguments.length;
			argumentTypes = new TypeBinding[length];
			for (int i = 0; i < length; i++)
				if ((argumentTypes[i] = arguments[i].resolveType(scope)) == null)
					argHasError = true;
			if (argHasError)
				return typeBinding;
		}
		if (typeBinding == null)
			return null;

		if (!typeBinding.canBeInstantiated()) {
			scope.problemReporter().cannotInstantiate(type, typeBinding);
			return typeBinding;
		}
		ReferenceBinding allocatedType = (ReferenceBinding) typeBinding;
		if (!(binding = scope.getConstructor(allocatedType, argumentTypes, this))
			.isValidBinding()) {
			if (binding.declaringClass == null)
				binding.declaringClass = allocatedType;
			scope.problemReporter().invalidConstructor(this, binding);
			return typeBinding;
		}
		if (isMethodUseDeprecated(binding, scope))
			scope.problemReporter().deprecatedMethod(binding, this);

		if (arguments != null)
			for (int i = 0; i < arguments.length; i++)
				arguments[i].implicitWidening(binding.parameters[i], argumentTypes[i]);
		return allocatedType;
	}

