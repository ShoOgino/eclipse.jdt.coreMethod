	public TypeBinding resolveType(BlockScope scope) {
		// Answer the signature return type
		// Base type promotion

		constant = NotAConstant;
		TypeBinding receiverType = receiver.resolveType(scope);
		// will check for null after args are resolved
		TypeBinding[] argumentTypes = NoParameters;
		if (arguments != null) {
			boolean argHasError = false; // typeChecks all arguments 
			int length = arguments.length;
			argumentTypes = new TypeBinding[length];
			for (int i = 0; i < length; i++)
				if ((argumentTypes[i] = arguments[i].resolveType(scope)) == null)
					argHasError = true;
			if (argHasError)
				return null;
		}
		if (receiverType == null)
			return null;

		// base type cannot receive any message
		if (receiverType.isBaseType()) {
			scope.problemReporter().errorNoMethodFor(this, receiverType, argumentTypes);
			return null;
		}

		binding =
			receiver == ThisReference.ThisImplicit
				? scope.getImplicitMethod(selector, argumentTypes, this)
				: scope.getMethod(receiverType, selector, argumentTypes, this);
		if (!binding.isValidBinding()) {
			if (binding.declaringClass == null) {
				if (receiverType instanceof ReferenceBinding) {
					binding.declaringClass = (ReferenceBinding) receiverType;
				} else { // really bad error ....
					scope.problemReporter().errorNoMethodFor(this, receiverType, argumentTypes);
					return null;
				}
			}
			scope.problemReporter().invalidMethod(this, binding);
			return null;
		}
		if (!binding.isStatic()) {
			// the "receiver" must not be a type, i.e. a NameReference that the TC has bound to a Type
			if (receiver instanceof NameReference) {
				if ((((NameReference) receiver).bits & BindingIds.TYPE) != 0) {
					scope.problemReporter().mustUseAStaticMethod(this, binding);
					return null;
				}
			}
		}
		if (arguments != null)
			for (int i = 0; i < arguments.length; i++)
				arguments[i].implicitWidening(binding.parameters[i], argumentTypes[i]);

		//-------message send that are known to fail at compile time-----------
		if (binding.isAbstract()) {
			if (receiver.isSuper()) {
				scope.problemReporter().cannotDireclyInvokeAbstractMethod(this, binding);
				return null;
			}
			// abstract private methods cannot occur nor abstract static............
		}
		if (isMethodUseDeprecated(binding, scope))
			scope.problemReporter().deprecatedMethod(binding, this);
		// if the binding declaring class is not visible, need special action
		// for runtime compatibility on 1.2 VMs : change the declaring class of the binding
		if (binding.declaringClass != receiverType
			&& !binding.declaringClass.canBeSeenBy(scope))
			binding = new MethodBinding(binding, (ReferenceBinding) receiverType);
		return binding.returnType;
	}

