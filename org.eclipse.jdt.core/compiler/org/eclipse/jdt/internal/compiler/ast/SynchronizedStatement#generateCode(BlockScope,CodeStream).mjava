/**
 * Synchronized statement code generation
 *
 * @param currentScope org.eclipse.jdt.internal.compiler.lookup.BlockScope
 * @param codeStream org.eclipse.jdt.internal.compiler.codegen.CodeStream
 */ 
public void generateCode(BlockScope currentScope, CodeStream codeStream) {
	if ((bits & IsReachableMASK) == 0) {
		return;
	}
	int pc = codeStream.position;

	// generate the synchronization expression
	expression.generateCode(scope, codeStream, true);
	if (block.isEmptyBlock()) {
		if ((synchroVariable.type == LongBinding) || (synchroVariable.type == DoubleBinding)) {
			codeStream.dup2();
		} else {
			codeStream.dup();
		}
		// only take the lock
		codeStream.monitorenter();
		codeStream.monitorexit();
	} else {
		// enter the monitor
		codeStream.store(synchroVariable, true);
		codeStream.monitorenter();

		// generate  the body of the synchronized block
		ExceptionLabel anyExceptionHandler = new ExceptionLabel(codeStream, null); //'null' denotes any kind of exception
		block.generateCode(scope, codeStream);
		Label endLabel = new Label(codeStream);
		if (!blockExit) {
			codeStream.load(synchroVariable);
			codeStream.monitorexit();
			codeStream.goto_(endLabel);
		}
		// generate the body of the exception handler
		anyExceptionHandler.placeEnd();
		anyExceptionHandler.place();
		codeStream.incrStackSize(1);
		codeStream.load(synchroVariable);
		codeStream.monitorexit();
		codeStream.athrow();
		if (!blockExit) {
			endLabel.place();
		}
	}
	if (scope != currentScope) {
		codeStream.exitUserScope(scope);
	}		
	codeStream.recordPositionsFrom(pc, this);
}

