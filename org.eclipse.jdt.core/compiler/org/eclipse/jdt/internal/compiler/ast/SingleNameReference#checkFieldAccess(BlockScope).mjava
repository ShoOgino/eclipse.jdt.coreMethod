public TypeBinding checkFieldAccess(BlockScope scope) {

	FieldBinding fieldBinding = (FieldBinding) binding;
	
	bits &= ~RestrictiveFlagMASK; // clear bits
	bits |= FIELD;
	if (!((FieldBinding) binding).isStatic()) {
		// must check for the static status....
		if (scope.methodScope().isStatic) {
			scope.problemReporter().staticFieldAccessToNonStaticVariable(
				this,
				fieldBinding);
			constant = NotAConstant;
			return null;
		}
	}
	constant = FieldReference.getConstantFor(fieldBinding, true, this, 0);
	if (isFieldUseDeprecated(fieldBinding, scope))
		scope.problemReporter().deprecatedField(fieldBinding, this);

	// if the binding declaring class is not visible, need special action
	// for runtime compatibility on 1.2 VMs : change the declaring class of the binding
	// NOTE: from 1.4 on, field's declaring class is touched if any different from receiver type
	if (fieldBinding.declaringClass != this.actualReceiverType
		&& fieldBinding.declaringClass != null
		&& fieldBinding.constant == NotAConstant
		&& (/*scope.environment().options.complianceLevel >= CompilerOptions.JDK1_4
				comply to jck lang/BINC/binc02301 (seems a bug)
			||*/ !fieldBinding.declaringClass.canBeSeenBy(scope))){
		binding = new FieldBinding(fieldBinding, (ReferenceBinding)this.actualReceiverType);
	}

	//===============================================
	//cycle are forbidden ONLY within the same class...why ?????? (poor javac....)
	//Cycle can be done using cross class ref but not direct into a same class reference ????
	//class A {	static int k = B.k+1;}
	//class B {	static int k = A.k+2;}
	//The k-cycle in this example is valid.

	//class C { static int k = k + 1 ;}
	//here it is forbidden ! ????
	//but the next one is valid !!!
	//class C { static int k = C.k + 1;}

	//notice that the next one is also valid ?!?!
	//class A {	static int k = foo().k+1 ; static A foo(){return new A();}}

	//for all these reasons, the next piece of code is only here and not
	//commun for all FieldRef and QualifiedNameRef....(i.e. in the getField(..) API.....

	//instance field may refer to forward static field, like in
	//int i = staticI;
	//static int staticI = 2 ;

	MethodScope ms = scope.methodScope();
	if (ms.enclosingSourceType() == fieldBinding.declaringClass
		&& ms.fieldDeclarationIndex != ms.NotInFieldDecl
		&& fieldBinding.id >= ms.fieldDeclarationIndex) {
		//if the field is static and ms is not .... then it is valid
		if (!fieldBinding.isStatic() || ms.isStatic)
			scope.problemReporter().forwardReference(this, 0, scope.enclosingSourceType());
	}
	//====================================================

	return fieldBinding.type;

}

