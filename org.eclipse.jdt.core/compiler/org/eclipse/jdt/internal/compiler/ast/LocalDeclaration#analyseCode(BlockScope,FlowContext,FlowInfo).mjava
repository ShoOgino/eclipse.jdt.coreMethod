public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo) {
	// record variable initialization if any
	if ((flowInfo.tagBits & FlowInfo.UNREACHABLE_OR_DEAD) == 0) {
		this.bits |= ASTNode.IsLocalDeclarationReachable; // only set if actually reached
	}
	if (this.binding != null && this.type.resolvedType instanceof TypeVariableBinding) {
		TypeVariableBinding typeVariableBinding = (TypeVariableBinding) this.type.resolvedType;
		MethodScope methodScope= this.binding.declaringScope.methodScope();
		if (methodScope != null && methodScope.referenceContext instanceof TypeDeclaration) {
			// initialization scope
			methodScope = methodScope.enclosingMethodScope();
		}
		AbstractMethodDeclaration methodDeclaration = (methodScope != null) ? methodScope.referenceMethod() : null;
		if (methodDeclaration != null && methodDeclaration.binding != null) {
			TypeVariableBinding[] typeVariables = methodDeclaration.binding.typeVariables();
			if (typeVariables == null) typeVariables = Binding.NO_TYPE_VARIABLES;
			if (typeVariables == Binding.NO_TYPE_VARIABLES) {
				// Method declares no type variables.
				if (typeVariableBinding != null && typeVariableBinding.declaringElement instanceof TypeBinding)
					currentScope.resetDeclaringClassMethodStaticFlag((TypeBinding) typeVariableBinding.declaringElement);
				else
					currentScope.resetEnclosingMethodStaticFlag();
			} else {
				// to check whether the resolved type for this is declared by enclosing method as a type variable
				boolean usesEnclosingTypeVar = false; 
				for (int i = 0; i < typeVariables.length ; i ++) {
					if (typeVariables[i] == this.type.resolvedType){
						usesEnclosingTypeVar = true;
						break;
					}
				}
				if (!usesEnclosingTypeVar) {
					// uses a type variable not declared by enclosing method
					if (typeVariableBinding != null && typeVariableBinding.declaringElement instanceof TypeBinding)
						currentScope.resetDeclaringClassMethodStaticFlag((TypeBinding) typeVariableBinding.declaringElement);
					else
						currentScope.resetEnclosingMethodStaticFlag();
				}
			}
		}
	}
	if (this.initialization == null) {
		return flowInfo;
	}
	if ((this.initialization.implicitConversion & TypeIds.UNBOXING) != 0) {
		this.initialization.checkNPE(currentScope, flowContext, flowInfo);
	}
	
	FlowInfo preInitInfo = null;
	boolean shouldAnalyseResource = this.binding != null 
			&& flowInfo.reachMode() == FlowInfo.REACHABLE
			&& currentScope.compilerOptions().analyseResourceLeaks
			&& FakedTrackingVariable.isAnyCloseable(this.initialization.resolvedType);
	if (shouldAnalyseResource) {
		preInitInfo = flowInfo.unconditionalCopy();
		// analysis of resource leaks needs additional context while analyzing the RHS:
		FakedTrackingVariable.preConnectTrackerAcrossAssignment(this, this.binding, this.initialization);
	}

	flowInfo =
		this.initialization
			.analyseCode(currentScope, flowContext, flowInfo)
			.unconditionalInits();

	if (shouldAnalyseResource)
		FakedTrackingVariable.handleResourceAssignment(currentScope, preInitInfo, flowInfo, flowContext, this, this.initialization, this.binding);
	else
		FakedTrackingVariable.cleanUpAfterAssignment(currentScope, Binding.LOCAL, this.initialization);

	int nullStatus = this.initialization.nullStatus(flowInfo);
	if (!flowInfo.isDefinitelyAssigned(this.binding)){// for local variable debug attributes
		this.bits |= FirstAssignmentToLocal;
	} else {
		this.bits &= ~FirstAssignmentToLocal;  // int i = (i = 0);
	}
	flowInfo.markAsDefinitelyAssigned(this.binding);
	nullStatus = checkAssignmentAgainstNullAnnotation(currentScope, flowContext, this.binding, nullStatus, this.initialization, this.initialization.resolvedType);
	if ((this.binding.type.tagBits & TagBits.IsBaseType) == 0) {
		flowInfo.markNullStatus(this.binding, nullStatus);
		// no need to inform enclosing try block since its locals won't get
		// known by the finally block
	}
	return flowInfo;
}

