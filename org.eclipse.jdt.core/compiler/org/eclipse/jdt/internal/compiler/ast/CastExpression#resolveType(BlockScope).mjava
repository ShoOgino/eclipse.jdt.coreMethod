	public TypeBinding resolveType(BlockScope scope) {
		// compute a new constant if the cast is effective

		// due to the fact an expression may start with ( and that a cast can also start with (
		// the field is an expression....it can be a TypeReference OR a NameReference Or
		// any kind of Expression <-- this last one is invalid.......

		constant = Constant.NotAConstant;
		implicitConversion = T_undefined;
		if ((type instanceof TypeReference) || (type instanceof NameReference)) {
			TypeBinding castTypeBinding = type.resolveType(scope);
			if(castTypeBinding == null)
				return null;
			TypeBinding expressionTb = expression.resolveType(scope);
			if (expressionTb == null)
				return null;
			areTypesCastCompatible(scope, castTypeBinding, expressionTb);
			return this.expressionType = castTb = castTypeBinding;
		} else { // expression as a cast !!!!!!!!
			TypeBinding expressionTb = expression.resolveType(scope);
			if (expressionTb == null)
				return null;
			scope.problemReporter().invalidTypeReference(type);
			return null;
		}
	}

