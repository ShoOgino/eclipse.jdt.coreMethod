	public TypeBinding resolveType(BlockScope scope) {
		// compute a new constant if the cast is effective

		// due to the fact an expression may start with ( and that a cast can also start with (
		// the field is an expression....it can be a TypeReference OR a NameReference Or
		// any kind of Expression <-- this last one is invalid.......

		constant = Constant.NotAConstant;
		implicitConversion = T_undefined;
		if ((type instanceof TypeReference) || (type instanceof NameReference)
				&& ((type.bits & AstNode.ParenthesizedMASK) >> AstNode.ParenthesizedSHIFT) == 0) { // no extra parenthesis around type: ((A))exp
			this.resolvedType = type.resolveType(scope);
			TypeBinding castedExpressionType = expression.resolveType(scope);
			if (this.resolvedType != null && castedExpressionType != null) {
				areTypesCastCompatible(scope, this.resolvedType, castedExpressionType);
			}
			return this.resolvedType;
		} else { // expression as a cast !!!!!!!!
			TypeBinding castedExpressionType = expression.resolveType(scope);
			if (castedExpressionType == null) return null;
			scope.problemReporter().invalidTypeReference(type);
			return null;
		}
	}

