public TypeBinding resolveType(BlockScope scope) {
	// compute a new constant if the cast is effective

	this.constant = Constant.NotAConstant;
	this.implicitConversion = TypeIds.T_undefined;

	boolean exprContainCast = false;

	TypeBinding castType = this.resolvedType = this.type.resolveType(scope);
	if (scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_8) {
		this.expression.setExpressionContext(CASTING_CONTEXT);
		if (this.expression instanceof FunctionalExpression) {
			this.expression.setExpectedType(this.resolvedType);
			this.bits |= ASTNode.DisableUnnecessaryCastCheck;
		}
	}
	if (this.expression instanceof CastExpression) {
		this.expression.bits |= ASTNode.DisableUnnecessaryCastCheck;
		exprContainCast = true;
	}
	TypeBinding expressionType = this.expression.resolveType(scope);
	if (this.expression instanceof MessageSend) {
		MessageSend messageSend = (MessageSend) this.expression;
		MethodBinding methodBinding = messageSend.binding;
		if (methodBinding != null && methodBinding.isPolymorphic()) {
			messageSend.binding = scope.environment().updatePolymorphicMethodReturnType((PolymorphicMethodBinding) methodBinding, castType);
			if (expressionType != castType) {
				expressionType = castType;
				this.bits |= ASTNode.DisableUnnecessaryCastCheck;
			}
		}
	}
	if (castType != null) {
		if (expressionType != null) {

			// internally for type checking use the unannotated types:
			TypeBinding unannotatedCastType = castType.unannotated();
			boolean nullAnnotationMismatch = findNullTypeAnnotationMismatch(castType, expressionType, -1).isAnyMismatch();
			if (nullAnnotationMismatch)
				castType = unannotatedCastType; // problem exists, so use the unannotated type also externally
			expressionType = expressionType.unannotated();

			boolean isLegal = checkCastTypesCompatibility(scope, unannotatedCastType, expressionType, this.expression);
			if (isLegal) {
				this.expression.computeConversion(scope, unannotatedCastType, expressionType);
				if ((this.bits & ASTNode.UnsafeCast) != 0) { // unsafe cast
					if (scope.compilerOptions().reportUnavoidableGenericTypeProblems
							|| !(expressionType.isRawType() && this.expression.forcedToBeRaw(scope.referenceContext()))) {
						scope.problemReporter().unsafeCast(this, scope);
					}
				} else if (nullAnnotationMismatch) {
					// report null annotation issue at medium priority
					scope.problemReporter().unsafeNullnessCast(this, scope);
				} else {
					if (unannotatedCastType.isRawType() && scope.compilerOptions().getSeverity(CompilerOptions.RawTypeReference) != ProblemSeverities.Ignore){
						scope.problemReporter().rawTypeReference(this.type, unannotatedCastType);
					}
					if ((this.bits & (ASTNode.UnnecessaryCast|ASTNode.DisableUnnecessaryCastCheck)) == ASTNode.UnnecessaryCast) { // unnecessary cast
						if (!isIndirectlyUsed()) // used for generic type inference or boxing ?
							scope.problemReporter().unnecessaryCast(this);
					}
				}
			} else { // illegal cast
				if ((unannotatedCastType.tagBits & TagBits.HasMissingType) == 0) { // no complaint if secondary error
					scope.problemReporter().typeCastError(this, unannotatedCastType, expressionType);
				}
				this.bits |= ASTNode.DisableUnnecessaryCastCheck; // disable further secondary diagnosis
			}
		}
		this.resolvedType = castType.capture(scope, this.sourceEnd);
		if (exprContainCast) {
			checkNeedForCastCast(scope, this);
		}
	}
	return this.resolvedType;
}

