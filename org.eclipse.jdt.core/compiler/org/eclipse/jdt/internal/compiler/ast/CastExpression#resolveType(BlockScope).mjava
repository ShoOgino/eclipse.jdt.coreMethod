	public TypeBinding resolveType(BlockScope scope) {
		// compute a new constant if the cast is effective

		// due to the fact an expression may start with ( and that a cast can also start with (
		// the field is an expression....it can be a TypeReference OR a NameReference Or
		// any kind of Expression <-- this last one is invalid.......

		constant = Constant.NotAConstant;
		implicitConversion = T_undefined;

		if ((type instanceof TypeReference) || (type instanceof NameReference)
				&& ((type.bits & ASTNode.ParenthesizedMASK) >> ASTNode.ParenthesizedSHIFT) == 0) { // no extra parenthesis around type: ((A))exp

			this.resolvedType = type.resolveType(scope);
			expression.setExpectedType(this.resolvedType); // needed in case of generic method invocation			
			TypeBinding expressionType = expression.resolveType(scope);
			if (this.resolvedType != null && expressionType != null) {
				boolean isLegal = checkCastTypesCompatibility(scope, this.resolvedType, expressionType, this.expression);
				this.expression.computeConversion(scope, this.resolvedType, expressionType);
				if (isLegal) {
					if ((this.bits & UnsafeCastMask) != 0) { // unsafe cast
						scope.problemReporter().unsafeCast(this, scope);
					} else if ((this.bits & (UnnecessaryCastMASK|IgnoreNeedForCastCheckMASK)) == UnnecessaryCastMASK) { // unnecessary cast 
						if (!usedForGenericMethodReturnTypeInference()) // used for generic type inference ?
							scope.problemReporter().unnecessaryCast(this);
					}
				} else { // illegal cast
					scope.problemReporter().typeCastError(this,  this.resolvedType, expressionType);
				}
			}
			return this.resolvedType;
		} else { // expression as a cast
			TypeBinding expressionType = expression.resolveType(scope);
			if (expressionType == null) return null;
			scope.problemReporter().invalidTypeReference(type);
			return null;
		}
	}

