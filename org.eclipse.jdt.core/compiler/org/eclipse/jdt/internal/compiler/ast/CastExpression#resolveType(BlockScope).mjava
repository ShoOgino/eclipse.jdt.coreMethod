	public TypeBinding resolveType(BlockScope scope) {
		// compute a new constant if the cast is effective

		// due to the fact an expression may start with ( and that a cast can also start with (
		// the field is an expression....it can be a TypeReference OR a NameReference Or
		// any kind of Expression <-- this last one is invalid.......

		constant = Constant.NotAConstant;
		implicitConversion = T_undefined;
		TypeBinding expressionTb = expression.resolveType(scope);
		if (expressionTb == null)
			return null;

		if ((type instanceof TypeReference) || (type instanceof NameReference)) {
			if ((castTb = type.resolveType(scope)) == null)
				return null;
			areTypesCastCompatible(scope, castTb, expressionTb);
			return castTb;
		} else { // expression as a cast !!!!!!!! 
			scope.problemReporter().invalidTypeReference(type);
			return null;
		}
	}

