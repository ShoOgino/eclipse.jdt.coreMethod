	public TypeBinding resolveType(BlockScope scope) {
		// compute a new constant if the cast is effective

		// due to the fact an expression may start with ( and that a cast can also start with (
		// the field is an expression....it can be a TypeReference OR a NameReference Or
		// any kind of Expression <-- this last one is invalid.......

		constant = Constant.NotAConstant;
		implicitConversion = T_undefined;

		if ((type instanceof TypeReference) || (type instanceof NameReference)
				&& ((type.bits & ASTNode.ParenthesizedMASK) >> ASTNode.ParenthesizedSHIFT) == 0) { // no extra parenthesis around type: ((A))exp

			TypeBinding castType = this.resolvedType = type.resolveType(scope);
			//expression.setExpectedType(this.resolvedType); // needed in case of generic method invocation			
			TypeBinding expressionType = expression.resolveType(scope);
			if (castType != null) {
				if (expressionType != null) {
					boolean isLegal = checkCastTypesCompatibility(scope, castType, expressionType, this.expression);
					if (isLegal) {
						this.expression.computeConversion(scope, castType, expressionType);
						if ((this.bits & UnsafeCast) != 0) { // unsafe cast
							scope.problemReporter().unsafeCast(this, scope);
						} else {
//							if (castType.isRawType() && scope.compilerOptions().reportRawTypeReference){
//								scope.problemReporter().rawTypeReference(this.type, castType);			
//							}
							if ((this.bits & (UnnecessaryCast|DisableUnnecessaryCastCheck)) == UnnecessaryCast) { // unnecessary cast 
								if (!isIndirectlyUsed()) // used for generic type inference or boxing ?
									scope.problemReporter().unnecessaryCast(this);
							}
						}
					} else { // illegal cast
						scope.problemReporter().typeCastError(this, castType, expressionType);
					}
				}
				this.resolvedType = castType.capture(scope, this.sourceEnd);
			}
			return this.resolvedType;
		} else { // expression as a cast
			TypeBinding expressionType = expression.resolveType(scope);
			if (expressionType == null) return null;
			scope.problemReporter().invalidTypeReference(type);
			return null;
		}
	}

