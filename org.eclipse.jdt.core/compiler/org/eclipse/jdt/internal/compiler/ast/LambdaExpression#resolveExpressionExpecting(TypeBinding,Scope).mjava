	/**
	 * Get a resolved copy of this lambda for use by type inference, as to avoid spilling any premature
	 * type results into the original lambda.
	 * 
	 * @param targetType the target functional type against which inference is attempted, must be a non-null valid functional type 
	 * @return a resolved copy of 'this' or null if significant errors where encountered
	 */
	public LambdaExpression resolveExpressionExpecting(TypeBinding targetType, Scope skope) {
		LambdaExpression copy = null;
		try {
			copy = cachedResolvedCopy(targetType, false);
		} catch (CopyFailureException cfe) {
			return null;
		}
		if (copy == null) {
			return null;
		}
		
		/* copy is potentially compatible with the target type and has its shape fully computed: i.e value/void compatibility is determined and 
		   result expressions have been gathered. Proceed with flow analysis to gather precise thrown exceptions. However, we can do this only
		   if resolve encountered no errors - if it did, we will miss precise exceptions, but that is OK.
		*/
		if (!copy.hasIgnoredMandatoryErrors && !enclosingScopesHaveErrors()) {
			final CompilerOptions compilerOptions = this.enclosingScope.compilerOptions();
			boolean analyzeNPE = compilerOptions.isAnnotationBasedNullAnalysisEnabled;
			IErrorHandlingPolicy oldPolicy = this.enclosingScope.problemReporter().switchErrorHandlingPolicy(silentErrorHandlingPolicy);
			try {
				compilerOptions.isAnnotationBasedNullAnalysisEnabled = false;
				copy.analyzeExceptions();
			} finally {
				compilerOptions.isAnnotationBasedNullAnalysisEnabled = analyzeNPE;
				this.enclosingScope.problemReporter().switchErrorHandlingPolicy(oldPolicy);
			}
		}
		return copy;
	}

