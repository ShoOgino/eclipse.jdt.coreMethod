	/**
	 * Get a resolved copy of this lambda for use by type inference, as to avoid spilling any premature
	 * type results into the original lambda.
	 * 
	 * @param targetType the target functional type against which inference is attempted, must be a non-null valid functional type 
	 * @return a resolved copy of 'this' or null if significant errors where encountered
	 */
	public LambdaExpression resolveExpressionExpecting(TypeBinding targetType, Scope skope) {
		LambdaExpression copy = null;
		try {
			copy = cachedResolvedCopy(targetType, false);
		} catch (CopyFailureException cfe) {
			return null;
		}
		if (copy == null) {
			return null;
		}
		final CompilerOptions compilerOptions = this.enclosingScope.compilerOptions();
		boolean analyzeNPE = compilerOptions.isAnnotationBasedNullAnalysisEnabled;
		IErrorHandlingPolicy oldPolicy = this.enclosingScope.problemReporter().switchErrorHandlingPolicy(silentErrorHandlingPolicy);
		try {
			compilerOptions.isAnnotationBasedNullAnalysisEnabled = false;
			// Do not proceed with data/control flow analysis if resolve encountered errors.
			if (!copy.hasIgnoredMandatoryErrors && !enclosingScopesHaveErrors()) {
				// value compatibility of block lambda's is the only open question.
				copy.valueCompatible |= copy.doesNotCompleteNormally();
			} else {
				if (!copy.returnsVoid)
					copy.valueCompatible = true; // optimistically, TODO: is this OK??
			}
		} finally {
			compilerOptions.isAnnotationBasedNullAnalysisEnabled = analyzeNPE;
			this.enclosingScope.problemReporter().switchErrorHandlingPolicy(oldPolicy);
		}
		return copy;
	}

