	private void verifyTypeReference(Expression reference, Expression typeReference, Scope scope, boolean source15, ReferenceBinding resolvedType, int modifiers) {
		if (resolvedType.isValidBinding()) {
			int scopeModifiers = -1;

			// reference must have enough visibility to be used
			if (!canBeSeen(scope.problemReporter().options.reportInvalidJavadocTagsVisibility, modifiers)) {
//				if (scopeModifiers == -1) scopeModifiers = scope.getDeclarationModifiers();
				scope.problemReporter().javadocHiddenReference(typeReference.sourceStart, reference.sourceEnd, scope, modifiers);
				return;
			}

			// type reference must have enough visibility to be used
			if (reference != typeReference) {
				if (!canBeSeen(scope.problemReporter().options.reportInvalidJavadocTagsVisibility, resolvedType.modifiers)) {
//					if (scopeModifiers == -1) scopeModifiers = scope.getDeclarationModifiers();
					scope.problemReporter().javadocHiddenReference(typeReference.sourceStart, typeReference.sourceEnd, scope, resolvedType.modifiers);
					return;
				}
			}

			// member types
			if (resolvedType.isMemberType()) {
				ReferenceBinding topLevelType = resolvedType;
				int depth = 0;
				while (topLevelType.enclosingType() != null) {
					topLevelType = topLevelType.enclosingType();
					depth++;
				}
				ClassScope topLevelScope = scope.classScope();
				// when scope is not on compilation unit type, then inner class may not be visible...
				if (topLevelScope.parent.kind != Scope.COMPILATION_UNIT_SCOPE ||
					!CharOperation.equals(topLevelType.sourceName, topLevelScope.referenceContext.name)) {
					topLevelScope = topLevelScope.outerMostClassScope();
					if (typeReference instanceof JavadocSingleTypeReference) {
						// inner class single reference can only be done in same unit
						if ((!source15 && depth == 1) || topLevelType != topLevelScope.referenceContext.binding) {
							if (scopeModifiers == -1) scopeModifiers = scope.getDeclarationModifiers();
							scope.problemReporter().javadocInvalidMemberTypeQualification(typeReference.sourceStart, typeReference.sourceEnd, scopeModifiers);
							return;
						}
					}
					/*
					if (typeReference instanceof JavadocQualifiedTypeReference) {
						JavadocQualifiedTypeReference qualifiedTypeReference = (JavadocQualifiedTypeReference) typeReference;
						// inner class qualified reference can only be done in same package
						if ((qualifiedTypeReference.tokens.length != resolvedType.enclosingType().compoundName.length+1) && topLevelType.getPackage() != topLevelScope.referenceContext.binding.getPackage()) {
							if (scopeModifiers == -1) scopeModifiers = scope.getDeclarationModifiers();
							scope.problemReporter().javadocInvalidMemberTypeQualification(typeReference.sourceStart, typeReference.sourceEnd, scopeModifiers);
							return;
						}
					}
					*/
				}
			}
		}
	}

