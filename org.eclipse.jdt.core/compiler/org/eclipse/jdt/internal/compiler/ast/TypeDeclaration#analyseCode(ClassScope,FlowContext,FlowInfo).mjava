	/**
	 *	Flow analysis for a local member innertype
	 *
	 */
	public void analyseCode(
		ClassScope currentScope,
		FlowContext flowContext,
		FlowInfo flowInfo) {

		if (ignoreFurtherInvestigation)
			return;
		try {
			LocalTypeBinding localType = (LocalTypeBinding) binding;

			// remember local types binding for innerclass emulation propagation
			currentScope.referenceCompilationUnit().record(localType);
			localType.setConstantPoolName(currentScope.compilationUnitScope().computeConstantPoolName(localType));
			manageEnclosingInstanceAccessIfNecessary(currentScope);
			
			updateMaxFieldCount(); // propagate down the max field count
			internalAnalyseCode(flowContext, flowInfo);

//			ReferenceBinding[] defaultHandledExceptions = new ReferenceBinding[] { scope.getJavaLangThrowable()}; // tolerate any kind of exception
//			InitializationFlowContext initializerContext =
//				new InitializationFlowContext(null, this, initializerScope);
//
//			FlowInfo fieldInfo = flowInfo.copy().unconditionalInits().discardFieldInitializations();
//			if (fields != null) {
//				for (int i = 0, count = fields.length; i < count; i++) {
//					FieldDeclaration field = fields[i];
//					/*if (field.isField()){
//						initializerContext.handledExceptions = NoExceptions; // no exception is allowed jls8.3.2
//					} else {*/
//					initializerContext.handledExceptions = defaultHandledExceptions; // tolerate them all, and record them
//					/*}*/
//					if (!fields[i].isStatic()) {
//						fieldInfo =
//							field.analyseCode(initializerScope, initializerContext, fieldInfo);
//						if (fieldInfo == FlowInfo.DEAD_END) {
//							// in case the initializer is not reachable, use a reinitialized flowInfo and enter a fake reachable
//							// branch, since the previous initializer already got the blame.
//							initializerScope.problemReporter().initializerMustCompleteNormally(field);
//							fieldInfo = FlowInfo.initial(maxFieldCount).setReachMode(FlowInfo.UNREACHABLE);
//						}
//					}
//				}
//			}
//			if (memberTypes != null) {
//				for (int i = 0, count = memberTypes.length; i < count; i++) {
//					memberTypes[i].analyseCode(scope, flowContext, fieldInfo.copy());
//				}
//			}
//			if (methods != null) {
//				UnconditionalFlowInfo outerInfo = flowInfo.copy().unconditionalInits().discardFieldInitializations();
//				FlowInfo constructorInfo = fieldInfo.unconditionalInits().discardNonFieldInitializations().addInitializationsFrom(outerInfo);
//				for (int i = 0, count = methods.length; i < count; i++) {
//					AbstractMethodDeclaration method = methods[i];
//					if (method.ignoreFurtherInvestigation)
//						continue;
//
//					if (method.isConstructor()) { // constructor
//						((ConstructorDeclaration)method).analyseCode(scope, initializerContext, constructorInfo.copy());
//					} else { // regular method
//						method.analyseCode(scope, null, flowInfo.copy());
//					}
//				}
//			}
		} catch (AbortType e) {
			this.ignoreFurtherInvestigation = true;
		}
	}

