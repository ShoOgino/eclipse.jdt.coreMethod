	/**
	 *	Flow analysis for a local member innertype
	 *
	 */
	public void analyseCode(
		ClassScope currentScope,
		FlowContext flowContext,
		FlowInfo flowInfo) {

		if (ignoreFurtherInvestigation)
			return;
		try {
			// remember local types binding for innerclass emulation propagation
			currentScope.referenceCompilationUnit().record((LocalTypeBinding) binding);

			/* force to emulation of access to direct enclosing instance: only for local members.
			 * By using the initializer scope, we actually only request an argument emulation, the
			 * field is not added until actually used. However we will force allocations to be qualified
			 * with an enclosing instance.
			 */
			initializerScope.emulateOuterAccess(
				(SourceTypeBinding) binding.enclosingType(),
				false);

			ReferenceBinding[] defaultHandledExceptions = new ReferenceBinding[] { scope.getJavaLangThrowable()}; // tolerate any kind of exception
			InitializationFlowContext initializerContext =
				new InitializationFlowContext(null, this, initializerScope);

			updateMaxFieldCount(); // propagate down the max field count
			FlowInfo fieldInfo = flowInfo.copy();// so as not to propagate changes outside this type
			if (fields != null) {
				for (int i = 0, count = fields.length; i < count; i++) {
					FieldDeclaration field = fields[i];
					if (field.isField()){
						initializerContext.handledExceptions = NoExceptions; // no exception is allowed jls8.3.2
					} else {
						initializerContext.handledExceptions = defaultHandledExceptions; // tolerate them all, and record them
					}
					if (!fields[i].isStatic()) {
						fieldInfo =
							field.analyseCode(initializerScope, initializerContext, fieldInfo);
						if (fieldInfo == FlowInfo.DeadEnd) {
							// in case the initializer is not reachable, use a reinitialized flowInfo and enter a fake reachable
							// branch, since the previous initializer already got the blame.
							initializerScope.problemReporter().initializerMustCompleteNormally(field);
							fieldInfo = FlowInfo.initial(maxFieldCount).markAsFakeReachable(true);
						}
					}
				}
			}
			if (memberTypes != null) {
				for (int i = 0, count = memberTypes.length; i < count; i++) {
					memberTypes[i].analyseCode(scope, flowContext, fieldInfo.copy());
				}
			}
			if (methods != null) {
				int recursionBalance = 0; // check constructor recursions			
				for (int i = 0, count = methods.length; i < count; i++) {
					AbstractMethodDeclaration method = methods[i];
					if (method.ignoreFurtherInvestigation)
						continue;
					if (method.isConstructor()) { // constructor
						ConstructorDeclaration constructor = (ConstructorDeclaration) method;
						constructor.analyseCode(scope, initializerContext, fieldInfo.copy());
						// compute the recursive invocation balance:
						//   how many thisReferences vs. superReferences to constructors
						int refCount;
						if ((refCount = constructor.referenceCount) > 0) {
							if ((constructor.constructorCall == null)
								|| constructor.constructorCall.isSuperAccess()
								|| !constructor.constructorCall.binding.isValidBinding()) {
								recursionBalance -= refCount;
								constructor.referenceCount = -1; // for error reporting propagation								
							} else {
								recursionBalance += refCount;
							}
						}
					} else { // regular method
						method.analyseCode(scope, null, flowInfo.copy());
					}
				}
				if (recursionBalance > 0) {
					// there is one or more cycle(s) amongst constructor invocations
					scope.problemReporter().recursiveConstructorInvocation(this);
				}
			}
		} catch (AbortType e) {
			this.ignoreFurtherInvestigation = true;
		};
	}

