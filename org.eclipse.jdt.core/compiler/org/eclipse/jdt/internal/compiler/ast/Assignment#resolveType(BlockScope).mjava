	public TypeBinding resolveType(BlockScope scope) {
		// due to syntax lhs may be only a NameReference, a FieldReference or an ArrayReference

		constant = NotAConstant;
		TypeBinding lhsTb = lhs.resolveType(scope);
		TypeBinding expressionTb = expression.resolveType(scope);
		if (lhsTb == null || expressionTb == null)
			return null;

		// Compile-time conversion of base-types : implicit narrowing integer into byte/short/character
		// may require to widen the rhs expression at runtime
		if ((expression.isConstantValueOfTypeAssignableToType(expressionTb, lhsTb)
			|| (lhsTb.isBaseType() && BaseTypeBinding.isWidening(lhsTb.id, expressionTb.id)))
			|| (scope.areTypesCompatible(expressionTb, lhsTb))) {
			expression.implicitWidening(lhsTb, expressionTb);
			return lhsTb;
		}
		scope.problemReporter().typeMismatchErrorActualTypeExpectedType(
			expression,
			expressionTb,
			lhsTb);
		return null;

		/*------------code deported to the flow analysis-------------------
		if (lhs.isFieldReference()) {
			// cover also the case of a nameReference that refers to a field...(of course !...)
			if (lhsTb.isFinal()) {
				// if the field is final, then the assignment may be done only in constructors/initializers
				// (this does not insure that the assignment is valid....the flow analysis will tell so)
				if (scope.enclosingType() == lhs.fieldBinding().declaringClass) {
					scope.problemReporter().cannotAssignToFinalField(this, lhs.fieldBinding());
					return null;
				}
				if (!scope.enclosingMethod().isConstructorOrInintilizer()) {
					scope.problemReporter().cannotAssignToFinalField(this, lhs.fieldBinding());
					return null;
				}
			}
		}
		-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- * /
		
		/*----------------------------------------------------------------
		the code that test if the local is an outer local (it is by definition final)
		and thus cannot be assigned , has been moved to flow analysis		
		------------------------------------------------------------------*/

		/*-----------------------------------------------------------------
		The code that detect the a.b = a.b + 1 ; is done by the flow analysis too
		-------------------------------------------------------------------*/
	}

