	public void resolve(BlockScope scope) {
		// the return type should be void for a constructor.
		// the test is made into getConstructor

		// mark the fact that we are in a constructor call.....
		// unmark at all returns
		MethodScope methodScope = scope.methodScope();
		try {
			AbstractMethodDeclaration methodDeclaration = methodScope.referenceMethod();
			if (methodDeclaration == null 
					|| !methodDeclaration.isConstructor()
					|| ((ConstructorDeclaration) methodDeclaration).constructorCall != this) {
				scope.problemReporter().invalidExplicitConstructorCall(this);
				return;
			}
			methodScope.isConstructorCall = true;
			ReferenceBinding receiverType = scope.enclosingSourceType();
			if (accessMode != This)
				receiverType = receiverType.superclass();

			if (receiverType == null) {
				return;
			}

			// qualification should be from the type of the enclosingType
			if (qualification != null) {
				if (accessMode != Super) {
					scope.problemReporter().unnecessaryEnclosingInstanceSpecification(
						qualification,
						receiverType);
				}
				ReferenceBinding enclosingType = receiverType.enclosingType();
				if (enclosingType == null) {
					scope.problemReporter().unnecessaryEnclosingInstanceSpecification(
						qualification,
						receiverType);
					discardEnclosingInstance = true;
				} else {
					TypeBinding qTb = qualification.resolveTypeExpecting(scope, enclosingType);
					qualification.implicitWidening(qTb, qTb);
				}
			}

			// arguments buffering for the method lookup
			TypeBinding[] argumentTypes = NoParameters;
			boolean argsContainCast = false;
			if (arguments != null) {
				boolean argHasError = false; // typeChecks all arguments
				int length = arguments.length;
				argumentTypes = new TypeBinding[length];
				for (int i = 0; i < length; i++) {
					Expression argument = this.arguments[i];
					if (argument instanceof CastExpression) {
						argument.bits |= IgnoreNeedForCastCheckMASK; // will check later on
						argsContainCast = true;
					}
					if ((argumentTypes[i] = argument.resolveType(scope)) == null) {
						argHasError = true;
					}
				}
				if (argHasError) {
					return;
				}
			}
			if ((binding = scope.getConstructor(receiverType, argumentTypes, this)).isValidBinding()) {
				if (isMethodUseDeprecated(binding, scope))
					scope.problemReporter().deprecatedMethod(binding, this);

				// see for user-implicit widening conversion 
				if (arguments != null) {
					int length = arguments.length;
					TypeBinding[] paramTypes = binding.parameters;
					for (int i = 0; i < length; i++) {
						arguments[i].implicitWidening(paramTypes[i], argumentTypes[i]);
					}
					if (argsContainCast) {
						CastExpression.checkNeedForArgumentCasts(scope, null, receiverType, binding, this.arguments, argumentTypes, this);
					}
				}
				if (binding.isPrivate()) {
					binding.modifiers |= AccPrivateUsed;
				}				
			} else {
				if (binding.declaringClass == null)
					binding.declaringClass = receiverType;
				scope.problemReporter().invalidConstructor(this, binding);
			}
		} finally {
			methodScope.isConstructorCall = false;
		}
	}

