	public void bind(MethodScope scope, TypeBinding typeBinding, boolean used) {

		if (this.type != null)
			this.type.resolvedType = typeBinding;
		// record the resolved type into the type reference
		int modifierFlag = this.modifiers;

		Binding existingVariable = scope.getBinding(name, BindingIds.VARIABLE, this);
		if (existingVariable != null && existingVariable.isValidBinding()){
			if (existingVariable instanceof LocalVariableBinding && this.hiddenVariableDepth == 0) {
				scope.problemReporter().redefineArgument(this);
				return;
			} else {
				scope.problemReporter().localVariableHiding(this, existingVariable, scope.isInsideConstructor() && existingVariable instanceof FieldBinding);
			}
		}

		scope.addLocalVariable(
			this.binding =
				new LocalVariableBinding(this, typeBinding, modifierFlag, true));
		//true stand for argument instead of just local
		if (typeBinding != null && isTypeUseDeprecated(typeBinding, scope))
			scope.problemReporter().deprecatedType(typeBinding, this.type);
		this.binding.declaration = this;
		this.binding.useFlag = used ? LocalVariableBinding.USED : LocalVariableBinding.UNUSED;
	}

