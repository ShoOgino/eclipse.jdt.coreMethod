	public static void checkInvocationArguments(BlockScope scope, Expression receiver, TypeBinding receiverType, MethodBinding method, Expression[] arguments, TypeBinding[] argumentTypes, boolean argsContainCast, InvocationSite invocationSite) {
		boolean unsafeWildcardInvocation = false;
		TypeBinding[] params = method.parameters;
		if (method.isVararg()) {
			// 4 possibilities exist for a call to the vararg method foo(int i, long ... value) : foo(1), foo(1, 2), foo(1, 2, 3, 4) & foo(1, new long[] {1, 2})
			int lastIndex = params.length - 1;
			for (int i = 0; i < lastIndex; i++)
			    if (checkInvocationArgument(scope, arguments[i], params[i], argumentTypes[i]))
				    unsafeWildcardInvocation = true;
		   int argLength = arguments.length;
		   if (lastIndex < argLength) { // vararg argument was provided
			   	TypeBinding parameterType = params[lastIndex];
			    if (params.length != argLength || parameterType.dimensions() != argumentTypes[lastIndex].dimensions())
			    	parameterType = ((ArrayBinding) parameterType).elementsType(); // single element was provided for vararg parameter
				for (int i = lastIndex; i < argLength; i++)
				    if (checkInvocationArgument(scope, arguments[i], parameterType, argumentTypes[i]))
					    unsafeWildcardInvocation = true;
			}
		} else {
			for (int i = 0, argLength = arguments.length; i < argLength; i++)
			    if (checkInvocationArgument(scope, arguments[i], params[i], argumentTypes[i]))
				    unsafeWildcardInvocation = true;
		}
		if (argsContainCast) {
			CastExpression.checkNeedForArgumentCasts(scope, receiver, receiverType, method, arguments, argumentTypes, invocationSite);
		}
		if (unsafeWildcardInvocation) {
		    scope.problemReporter().wildcardInvocation((ASTNode)invocationSite, receiverType, method, argumentTypes);
		} else if (receiverType.isRawType() && method.hasSubstitutedParameters()) {
		    scope.problemReporter().unsafeRawInvocation((ASTNode)invocationSite, receiverType, method);
		}
	}

