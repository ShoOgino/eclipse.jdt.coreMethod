	public static void checkInvocationArguments(BlockScope scope, Expression receiver, TypeBinding receiverType, MethodBinding method, Expression[] arguments, TypeBinding[] argumentTypes, boolean argsContainCast, InvocationSite invocationSite) {
		boolean unsafeWildcardInvocation = false;
		TypeBinding[] params = method.parameters;
		if (method.isVarargs()) {
			// 4 possibilities exist for a call to the vararg method foo(int i, long ... value) : foo(1), foo(1, 2), foo(1, 2, 3, 4) & foo(1, new long[] {1, 2})
			int lastIndex = params.length - 1;
			for (int i = 0; i < lastIndex; i++)
			    if (checkInvocationArgument(scope, arguments[i], params[i], argumentTypes[i]))
				    unsafeWildcardInvocation = true;
		   int argLength = arguments.length;
		   if (lastIndex < argLength) { // vararg argument was provided
			   	TypeBinding parameterType = params[lastIndex];
			    if (params.length != argLength || parameterType.dimensions() != argumentTypes[lastIndex].dimensions())
			    	parameterType = ((ArrayBinding) parameterType).elementsType(); // single element was provided for vararg parameter
				for (int i = lastIndex; i < argLength; i++)
				    if (checkInvocationArgument(scope, arguments[i], parameterType, argumentTypes[i]))
					    unsafeWildcardInvocation = true;
			}

		   if (method.parameters.length == argumentTypes.length) { // 70056
				int varargIndex = method.parameters.length - 1;
				ArrayBinding varargType = (ArrayBinding) method.parameters[varargIndex];
				TypeBinding lastArgType = argumentTypes[varargIndex];
				if (lastArgType == NullBinding) {
					if (!(varargType.leafComponentType().isBaseType() && varargType.dimensions() == 1))
						scope.problemReporter().inexactParameterToVarargsMethod(method, invocationSite);
				} else if (varargType.dimensions <= lastArgType.dimensions()) {
					int dimensions = lastArgType.dimensions();
					if (lastArgType.leafComponentType().isBaseType())
						dimensions--;
					if (varargType.dimensions < dimensions)
						scope.problemReporter().inexactParameterToVarargsMethod(method, invocationSite);
					else if (varargType.dimensions == dimensions && varargType.leafComponentType != lastArgType.leafComponentType())
						scope.problemReporter().inexactParameterToVarargsMethod(method, invocationSite);
				}
			}
		} else {
			for (int i = 0, argLength = arguments.length; i < argLength; i++)
			    if (checkInvocationArgument(scope, arguments[i], params[i], argumentTypes[i]))
				    unsafeWildcardInvocation = true;
		}
		if (argsContainCast) {
			CastExpression.checkNeedForArgumentCasts(scope, receiver, receiverType, method, arguments, argumentTypes, invocationSite);
		}
		if (unsafeWildcardInvocation) {
		    scope.problemReporter().wildcardInvocation((ASTNode)invocationSite, receiverType, method, argumentTypes);
		} else if (receiverType.isRawType() && method.hasSubstitutedParameters()) {
		    scope.problemReporter().unsafeRawInvocation((ASTNode)invocationSite, receiverType, method);
		}
	}

