	private AbstractMethodDeclaration createNewMethod(FieldDeclaration f) {
		MethodDeclaration m = new MethodDeclaration(this.compilationResult);
		m.selector = f.name;
		m.bits |= ASTNode.IsSynthetic;
		m.modifiers = ClassFileConstants.AccPublic;

		m.returnType = f.type;
		FieldReference fr = new FieldReference(f.name, -1);
		fr.receiver = new ThisReference(-1, -1);
		ReturnStatement ret = new ReturnStatement(fr, -1, -1);
		m.statements = new Statement[] { ret };
		m.isImplicit = true;
		/*
		 * JLS 14 Sec 8.10.3 Item 2 states that:
		 * "The implicitly declared accessor method is annotated with the annotation
		 * that appears on the corresponding record component, if this annotation type
		 * is applicable to a method declaration or type context."
		 * 
		 * However, at this point in compilation, sufficient information to determine
		 * the ElementType targeted by the annotation doesn't exist and hence a blanket 
		 * copy of annotation is done for now, and later (binding stage) irrelevant ones
		 * are weeded out.
		 */
		m.annotations = f.annotations;

		if (this.methods == null) { // Where is the constructor?
			this.methods = new AbstractMethodDeclaration[] { m };
		} else {
			AbstractMethodDeclaration[] newMethods;
			System.arraycopy(
				this.methods,
				0,
				newMethods = new AbstractMethodDeclaration[this.methods.length + 1],
				1,
				this.methods.length);
			newMethods[0] = m;
			this.methods = newMethods;
		}
		return m;
	}

