public TypeBinding resolveType(BlockScope scope) {

	if (left instanceof CastExpression) left.bits |= IgnoreNeedForCastCheckMASK; // will check later on
	TypeBinding leftType = left.resolveType(scope);

	if (right instanceof CastExpression) right.bits |= IgnoreNeedForCastCheckMASK; // will check later on
	TypeBinding rightType = right.resolveType(scope);

	// always return BooleanBinding
	if (leftType == null || rightType == null){
		constant = NotAConstant;		
		return null;
	}

	// both base type
	if (leftType.isBaseType() && rightType.isBaseType()) {
		// the code is an int
		// (cast)  left   == (cast)  right --> result
		//  0000   0000       0000   0000      0000
		//  <<16   <<12       <<8    <<4       <<0
		int result = ResolveTypeTables[EQUAL_EQUAL][ (leftType.id << 4) + rightType.id];
		left.implicitConversion = result >>> 12;
		right.implicitConversion = (result >>> 4) & 0x000FF;
		bits |= result & 0xF;		
		if ((result & 0x0000F) == T_undefined) {
			constant = Constant.NotAConstant;
			scope.problemReporter().invalidOperator(this, leftType, rightType);
			return null;
		}
		// check need for operand cast
		boolean unnecessaryLeftCast = (left.bits & UnnecessaryCastMask) != 0;
		boolean unnecessaryRightCast = (right.bits & UnnecessaryCastMask) != 0;
		if (unnecessaryLeftCast || unnecessaryRightCast) {
			int alternateLeftId = unnecessaryLeftCast ? ((CastExpression)left).expression.resolvedType.id : leftType.id;
			int alternateRightId = unnecessaryRightCast ? ((CastExpression)right).expression.resolvedType.id : rightType.id;
			int alternateResult = ResolveTypeTables[EQUAL_EQUAL][(alternateLeftId << 4) + alternateRightId];
			// (cast)  left   Op (cast)  right --> result
			//  1111   0000       1111   0000     1111
			//  <<16   <<12       <<8    <<4       <<0
			final int CompareMASK = (0xF<<16) + (0xF<<8) + 0xF; // mask hiding compile-time types
			if ((result & CompareMASK) == (alternateResult & CompareMASK)) { // same promotions and result
				if (unnecessaryLeftCast) scope.problemReporter().unnecessaryCast((CastExpression)left); 
				if (unnecessaryRightCast) scope.problemReporter().unnecessaryCast((CastExpression)right);
			}
		}		
		computeConstant(leftType, rightType);
		return this.resolvedType = BooleanBinding;
	}

	// Object references 
	// spec 15.20.3
	if (areTypesCastCompatible(scope, rightType, leftType) || areTypesCastCompatible(scope, leftType, rightType)) {
		// (special case for String)
		if ((rightType.id == T_String) && (leftType.id == T_String)) {
			computeConstant(leftType, rightType);
		} else {
			constant = NotAConstant;
		}
		if (rightType.id == T_String) {
			right.implicitConversion = String2String;
		}
		if (leftType.id == T_String) {
			left.implicitConversion = String2String;
		}
		// check need for operand cast
		boolean unnecessaryLeftCast = (left.bits & UnnecessaryCastMask) != 0;
		boolean unnecessaryRightCast = (right.bits & UnnecessaryCastMask) != 0;
		if (unnecessaryLeftCast || unnecessaryRightCast) {
			TypeBinding alternateLeftType = unnecessaryLeftCast ? ((CastExpression)left).expression.resolvedType : leftType;
			TypeBinding alternateRightType = unnecessaryRightCast ? ((CastExpression)right).expression.resolvedType : rightType;
			if (areTypesCastCompatible(scope, alternateLeftType, alternateRightType)
					|| areTypesCastCompatible(scope, alternateRightType, alternateLeftType)) {
				if (unnecessaryLeftCast) scope.problemReporter().unnecessaryCast((CastExpression)left); 
				if (unnecessaryRightCast) scope.problemReporter().unnecessaryCast((CastExpression)right);
			}
		}
		return this.resolvedType = BooleanBinding;
	}
	constant = NotAConstant;
	scope.problemReporter().notCompatibleTypesError(this, leftType, rightType);
	return null;
}

