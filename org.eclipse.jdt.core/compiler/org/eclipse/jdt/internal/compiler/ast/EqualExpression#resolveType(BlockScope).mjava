	public TypeBinding resolveType(BlockScope scope) {
	
			boolean leftIsCast, rightIsCast;
			if ((leftIsCast = left instanceof CastExpression) == true) left.bits |= IgnoreNeedForCastCheckMASK; // will check later on
			TypeBinding leftType = left.resolveType(scope);
	
			if ((rightIsCast = right instanceof CastExpression) == true) right.bits |= IgnoreNeedForCastCheckMASK; // will check later on
			TypeBinding rightType = right.resolveType(scope);
	
		// always return BooleanBinding
		if (leftType == null || rightType == null){
			constant = NotAConstant;		
			return null;
		}
	
		// autoboxing support
		boolean use15specifics = scope.environment().options.sourceLevel >= JDK1_5;
		boolean unboxedLeft = false, unboxedRight = false;
		if (use15specifics) {
			if (leftType.isBaseType()) {
				if (!rightType.isBaseType()) {
					TypeBinding unboxedType = scope.computeBoxingType(rightType);
					if (unboxedType != rightType) {
						rightType = unboxedType;
						unboxedRight = true;
					}
				}
			} else {
				if (rightType.isBaseType()) {
					TypeBinding unboxedType = scope.computeBoxingType(leftType);
					if (unboxedType != leftType) {
						leftType = unboxedType;
						unboxedLeft = true;
					}
				}
			}
		}
		// both base type
		if (leftType.isBaseType() && rightType.isBaseType()) {
			int leftTypeID = leftType.id;
			int rightTypeID = rightType.id;
	
			// the code is an int
			// (cast)  left   == (cast)  right --> result
			//  0000   0000       0000   0000      0000
			//  <<16   <<12       <<8    <<4       <<0
			int operatorSignature = OperatorSignatures[EQUAL_EQUAL][ (leftTypeID << 4) + rightTypeID];
			left.implicitConversion =  (unboxedLeft ? UNBOXING : 0) | (operatorSignature >>> 12);
			right.implicitConversion =  (unboxedRight ? UNBOXING : 0) | ((operatorSignature >>> 4) & 0x000FF);
			bits |= operatorSignature & 0xF;		
			if ((operatorSignature & 0x0000F) == T_undefined) {
				constant = Constant.NotAConstant;
				scope.problemReporter().invalidOperator(this, leftType, rightType);
				return null;
			}
			// check need for operand cast
			if (leftIsCast || rightIsCast) {
				CastExpression.checkNeedForArgumentCasts(scope, EQUAL_EQUAL, operatorSignature, left, leftType.id, leftIsCast, right, rightType.id, rightIsCast);
			}
			computeConstant(leftType, rightType);
			return this.resolvedType = BooleanBinding;
		}
	
		// Object references 
		// spec 15.20.3
		if (this.checkCastTypesCompatibility(scope, leftType, rightType, null) 
				|| this.checkCastTypesCompatibility(scope, rightType, leftType, null)) {

			// (special case for String)
			if ((rightType.id == T_JavaLangString) && (leftType.id == T_JavaLangString)) {
				computeConstant(leftType, rightType);
			} else {
				constant = NotAConstant;
			}
			if (rightType.id == T_JavaLangString) {
				right.implicitConversion = String2String;
			}
			if (leftType.id == T_JavaLangString) {
				left.implicitConversion = String2String;
			}
			// check need for operand cast
			boolean unnecessaryLeftCast = (left.bits & UnnecessaryCastMask) != 0;
			boolean unnecessaryRightCast = (right.bits & UnnecessaryCastMask) != 0;
			if (unnecessaryLeftCast || unnecessaryRightCast) {
				TypeBinding alternateLeftType = unnecessaryLeftCast ? ((CastExpression)left).expression.resolvedType : leftType;
				TypeBinding alternateRightType = unnecessaryRightCast ? ((CastExpression)right).expression.resolvedType : rightType;
				if (this.checkCastTypesCompatibility(scope, alternateLeftType, alternateRightType, null) 
						|| this.checkCastTypesCompatibility(scope, alternateRightType, alternateLeftType, null)) {
					if (unnecessaryLeftCast) scope.problemReporter().unnecessaryCast((CastExpression)left); 
					if (unnecessaryRightCast) scope.problemReporter().unnecessaryCast((CastExpression)right);
				}
			}
			return this.resolvedType = BooleanBinding;
		}
		constant = NotAConstant;
		scope.problemReporter().notCompatibleTypesError(this, leftType, rightType);
		return null;
	}

