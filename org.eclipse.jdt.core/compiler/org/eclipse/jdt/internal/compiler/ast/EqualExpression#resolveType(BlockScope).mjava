public TypeBinding resolveType(BlockScope scope) {
	// always return BooleanBinding
	TypeBinding leftType = left.resolveType(scope);
	TypeBinding rightType = right.resolveType(scope);
	if (leftType == null || rightType == null){
		constant = NotAConstant;		
		return null;
	}

	// both base type
	if (leftType.isBaseType() && rightType.isBaseType()) {
		// the code is an int
		// (cast)  left   == (cast)  rigth --> result
		//  0000   0000       0000   0000      0000
		//  <<16   <<12       <<8    <<4       <<0
		int result = ResolveTypeTables[EQUAL_EQUAL][ (leftType.id << 4) + rightType.id];
		left.implicitConversion = result >>> 12;
		right.implicitConversion = (result >>> 4) & 0x000FF;
		bits |= result & 0xF;		
		if ((result & 0x0000F) == T_undefined) {
			constant = Constant.NotAConstant;
			scope.problemReporter().invalidOperator(this, leftType, rightType);
			return null;
		}
		computeConstant(leftType, rightType);
		this.resolvedType = BooleanBinding;
		return BooleanBinding;
	}

	// Object references 
	// spec 15.20.3
	if (areTypesCastCompatible(scope, rightType, leftType) || areTypesCastCompatible(scope, leftType, rightType)) {
		// (special case for String)
		if ((rightType.id == T_String) && (leftType.id == T_String))
			computeConstant(leftType, rightType);
		else
			constant = NotAConstant;
		if (rightType.id == T_String)
			right.implicitConversion = String2String;
		if (leftType.id == T_String)
			left.implicitConversion = String2String;
		this.resolvedType = BooleanBinding;
		return BooleanBinding;
	}
	constant = NotAConstant;
	scope.problemReporter().notCompatibleTypesError(this, leftType, rightType);
	return null;
}

