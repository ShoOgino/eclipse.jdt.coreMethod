public TypeBinding resolveType(BlockScope scope) {
	// always return BooleanBinding
	TypeBinding leftTb = left.resolveType(scope);
	TypeBinding rightTb = right.resolveType(scope);
	if (leftTb == null || rightTb == null){
		constant = NotAConstant;		
		return null;
	}

	// both base type
	if (leftTb.isBaseType() && rightTb.isBaseType()) {
		// the code is an int
		// (cast)  left   == (cast)  rigth --> result
		//  0000   0000       0000   0000      0000
		//  <<16   <<12       <<8    <<4       <<0
		int result = ResolveTypeTables[EQUAL_EQUAL][ (leftTb.id << 4) + rightTb.id];
		left.implicitConversion = result >>> 12;
		right.implicitConversion = (result >>> 4) & 0x000FF;
		bits |= result & 0xF;		
		if ((result & 0x0000F) == T_undefined) {
			constant = Constant.NotAConstant;
			scope.problemReporter().invalidOperator(this, leftTb, rightTb);
			return null;
		}
		computeConstant(leftTb, rightTb);
		this.expressionType = BooleanBinding;
		return BooleanBinding;
	}

	// Object references 
	// spec 15.20.3
	if (areTypesCastCompatible(scope, rightTb, leftTb) || areTypesCastCompatible(scope, leftTb, rightTb)) {
		// (special case for String)
		if ((rightTb.id == T_String) && (leftTb.id == T_String))
			computeConstant(leftTb, rightTb);
		else
			constant = NotAConstant;
		if (rightTb.id == T_String)
			right.implicitConversion = String2String;
		if (leftTb.id == T_String)
			left.implicitConversion = String2String;
		this.expressionType = BooleanBinding;
		return BooleanBinding;
	}
	constant = NotAConstant;
	scope.problemReporter().notCompatibleTypesError(this, leftTb, rightTb);
	return null;
}

