	public final void areTypesCastCompatible(
		BlockScope scope,
		TypeBinding castType,
		TypeBinding expressionType) {

		// see specifications p.68
		// handle errors and process constant when needed

		// if either one of the type is null ==>
		// some error has been already reported some where ==>
		// we then do not report an obvious-cascade-error.

		needRuntimeCheckcast = false;
		if (castType == null || expressionType == null) return;
		
		if (castType.isBaseType()) {
			if (expressionType.isBaseType()) {
				if (expressionType == castType) {
					expression.implicitWidening(castType, expressionType);
					constant = expression.constant; //use the same constant
					return;
				}
				if (Scope.areTypesCompatible(expressionType, castType)
					|| BaseTypeBinding.isNarrowing(castType.id, expressionType.id)) {
					expression.implicitConversion = (castType.id << 4) + expressionType.id;
					if (expression.constant != Constant.NotAConstant)
						constant = expression.constant.castTo(expression.implicitConversion);
					return;
				}
			}
			scope.problemReporter().typeCastError(this, castType, expressionType);
			return;
		}

		//-----------cast to something which is NOT a base type--------------------------	
		if (expressionType == NullBinding) 
			return; //null is compatible with every thing

		if (expressionType.isBaseType()) {
			scope.problemReporter().typeCastError(this, castType, expressionType);
			return;
		}

		if (expressionType.isArrayType()) {
			if (castType.isArrayType()) {
				//------- (castType.isArray) expressionType.isArray -----------
				TypeBinding exprElementType = ((ArrayBinding) expressionType).elementsType(scope);
				if (exprElementType.isBaseType()) {
					// <---stop the recursion------- 
					if (((ArrayBinding) castType).elementsType(scope) == exprElementType)
						needRuntimeCheckcast = true;
					else
						scope.problemReporter().typeCastError(this, castType, expressionType);
					return;
				}
				// recursively on the elements...
				areTypesCastCompatible(
					scope,
					((ArrayBinding) castType).elementsType(scope),
					exprElementType);
				return;
			} else if (
				castType.isClass()) {
				//------(castType.isClass) expressionType.isArray ---------------	
				if (scope.isJavaLangObject(castType))
					return;
			} else { //------- (castType.isInterface) expressionType.isArray -----------
				if (scope.isJavaLangCloneable(castType) || scope.isJavaIoSerializable(castType)) {
					needRuntimeCheckcast = true;
					return;
				}
			}
			scope.problemReporter().typeCastError(this, castType, expressionType);
			return;
		}

		if (expressionType.isClass()) {
			if (castType.isArrayType()) {
				// ---- (castType.isArray) expressionType.isClass -------
				if (scope.isJavaLangObject(expressionType)) { // potential runtime error
					needRuntimeCheckcast = true;
					return;
				}
			} else if (
				castType.isClass()) { // ----- (castType.isClass) expressionType.isClass ------
				if (Scope.areTypesCompatible(expressionType, castType)){ // no runtime error
					if (castType.id == T_String) constant = expression.constant; // (String) cst is still a constant
					return;
				}
				if (Scope.areTypesCompatible(castType, expressionType)) {
					// potential runtime  error
					needRuntimeCheckcast = true;
					return;
				}
			} else { // ----- (castType.isInterface) expressionType.isClass -------  
				if (((ReferenceBinding) expressionType).isFinal()) {
					// no subclass for expressionType, thus compile-time check is valid
					if (Scope.areTypesCompatible(expressionType, castType)) 
						return;
				} else { // a subclass may implement the interface ==> no check at compile time
					needRuntimeCheckcast = true;
					return;
				}
			}
			scope.problemReporter().typeCastError(this, castType, expressionType);
			return;
		}

		//	if (expressionType.isInterface()) { cannot be anything else
		if (castType.isArrayType()) {
			// ----- (castType.isArray) expressionType.isInterface ------
			if (scope.isJavaLangCloneable(expressionType)
				|| scope.isJavaIoSerializable(expressionType)) // potential runtime error
				needRuntimeCheckcast = true;
			else
				scope.problemReporter().typeCastError(this, castType, expressionType);
			return;
		} else if (castType.isClass()) { // ----- (castType.isClass) expressionType.isInterface --------
			if (scope.isJavaLangObject(castType)) // no runtime error
				return;
			if (((ReferenceBinding) castType).isFinal()) {
				// no subclass for castType, thus compile-time check is valid
				if (!Scope.areTypesCompatible(castType, expressionType)) {
					// potential runtime error
					scope.problemReporter().typeCastError(this, castType, expressionType);
					return;
				}
			}
		} else { // ----- (castType.isInterface) expressionType.isInterface -------
			if (castType != expressionType
					&& (Scope.compareTypes(castType, expressionType) == NotRelated)) {
				MethodBinding[] castTypeMethods = ((ReferenceBinding) castType).methods();
				MethodBinding[] expressionTypeMethods =
					((ReferenceBinding) expressionType).methods();
				int exprMethodsLength = expressionTypeMethods.length;
				for (int i = 0, castMethodsLength = castTypeMethods.length; i < castMethodsLength; i++)
					for (int j = 0; j < exprMethodsLength; j++) {
						if ((castTypeMethods[i].returnType != expressionTypeMethods[j].returnType)
								&& (castTypeMethods[i].selector == expressionTypeMethods[j].selector)
								&& castTypeMethods[i].areParametersEqual(expressionTypeMethods[j])) {
							scope.problemReporter().typeCastError(this, castType, expressionType);
						}
					}
			}
			return;
		}
		needRuntimeCheckcast = true;
		return;
	}

