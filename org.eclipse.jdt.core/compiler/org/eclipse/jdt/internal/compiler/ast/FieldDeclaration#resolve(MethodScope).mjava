	public void resolve(MethodScope initializationScope) {

		// the two <constant = Constant.NotAConstant> could be regrouped into
		// a single line but it is clearer to have two lines while the reason of their
		// existence is not at all the same. See comment for the second one.

		//--------------------------------------------------------
		if (!this.hasBeenResolved && binding != null && this.binding.isValidBinding()) {

			this.hasBeenResolved = true;

			// check if field is hiding some variable - issue is that field binding already got inserted in scope
			ClassScope classScope = initializationScope.enclosingClassScope();
			if (classScope != null) {
				SourceTypeBinding declaringType = classScope.enclosingSourceType();
				boolean checkLocal = true;
				if (declaringType.superclass != null) {
					Binding existingVariable = classScope.findField(declaringType.superclass, name, this, true /*resolve*/);
					if (existingVariable != null && existingVariable.isValidBinding()) {
						initializationScope.problemReporter().fieldHiding(this, existingVariable);
						checkLocal = false; // already found a matching field
					}
				}
				if (checkLocal) {
					Scope outerScope = classScope.parent;
					Binding existingVariable = outerScope.getBinding(name, BindingIds.VARIABLE, this, false /*do not resolve hidden field*/);
					if (existingVariable != null && existingVariable.isValidBinding()){
						initializationScope.problemReporter().fieldHiding(this, existingVariable);
					}
				}
			}
			
			this.type.resolvedType = this.binding.type; // update binding for type reference

			int previous = initializationScope.fieldDeclarationIndex;
			try {
				initializationScope.fieldDeclarationIndex = this.binding.id;

				if (isTypeUseDeprecated(this.binding.type, initializationScope)) {
					initializationScope.problemReporter().deprecatedType(this.binding.type, this.type);
				}
				// the resolution of the initialization hasn't been done
				if (this.initialization == null) {
					this.binding.constant = Constant.NotAConstant;
				} else {
					// break dead-lock cycles by forcing constant to NotAConstant
					this.binding.constant = Constant.NotAConstant;
					
					TypeBinding typeBinding = this.binding.type;
					TypeBinding initializationTypeBinding;
					
					if (initialization instanceof ArrayInitializer) {

						if ((initializationTypeBinding = this.initialization.resolveTypeExpecting(initializationScope, typeBinding)) != null) {
							((ArrayInitializer) this.initialization).binding = (ArrayBinding) initializationTypeBinding;
							this.initialization.implicitWidening(typeBinding, initializationTypeBinding);
						}
					} else if ((initializationTypeBinding = initialization.resolveType(initializationScope)) != null) {

						if (this.initialization.isConstantValueOfTypeAssignableToType(initializationTypeBinding, typeBinding)
							|| (typeBinding.isBaseType() && BaseTypeBinding.isWidening(typeBinding.id, initializationTypeBinding.id))) {

							this.initialization.implicitWidening(typeBinding, initializationTypeBinding);

						}	else if (initializationTypeBinding.isCompatibleWith(typeBinding)) {
							this.initialization.implicitWidening(typeBinding, initializationTypeBinding);

						} else {
							initializationScope.problemReporter().typeMismatchError(initializationTypeBinding, typeBinding, this);
						}
						if (this.binding.isFinal()){ // cast from constant actual type to variable type
							this.binding.constant =
								this.initialization.constant.castTo(
									(this.binding.type.id << 4) + this.initialization.constant.typeID());
						}
					} else {
						this.binding.constant = NotAConstant;
					}
				}
				// Resolve Javadoc comment if one is present
				if (this.javadoc != null) {
					if (classScope != null) {
						this.javadoc.resolve(classScope);
					}
				} else if ((this.binding != null) && this.binding.isPublic()) {
					initializationScope.problemReporter().javadocMissing(this.sourceStart, this.sourceEnd);
				}
			} finally {
				initializationScope.fieldDeclarationIndex = previous;
				if (this.binding.constant == null)
					this.binding.constant = Constant.NotAConstant;
			}
		}
	}

