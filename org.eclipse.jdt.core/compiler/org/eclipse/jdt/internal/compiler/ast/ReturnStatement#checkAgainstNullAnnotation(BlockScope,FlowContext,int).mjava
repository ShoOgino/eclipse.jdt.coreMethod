void checkAgainstNullAnnotation(BlockScope scope, FlowContext flowContext, int nullStatus) {
	long tagBits;
	MethodBinding methodBinding = null;
	boolean useTypeAnnotations = scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_8;
	try {
		methodBinding = scope.methodScope().referenceMethodBinding();
		tagBits = (useTypeAnnotations) ? methodBinding.returnType.tagBits : methodBinding.tagBits;
	} catch (NullPointerException npe) {
		// chain of references in try-block has several potential nulls;
		// any null means we cannot perform the following check
		return;			
	}
	if (useTypeAnnotations) {
		NullAnnotationMatching annotationStatus = NullAnnotationMatching.analyse(methodBinding.returnType, this.expression.resolvedType, nullStatus);
		if (annotationStatus.isDefiniteMismatch()) {
			scope.problemReporter().nullityMismatchingTypeAnnotation(this.expression, this.expression.resolvedType, methodBinding.returnType, annotationStatus);
		} else if (annotationStatus.isUnchecked()) {
			flowContext.recordNullityMismatch(scope, this.expression, this.expression.resolvedType, methodBinding.returnType, nullStatus);
		}
	} else if (nullStatus != FlowInfo.NON_NULL) {
		// if we can't prove non-null check against declared null-ness of the enclosing method:
		if ((tagBits & TagBits.AnnotationNonNull) != 0) {
			flowContext.recordNullityMismatch(scope, this.expression, this.expression.resolvedType, methodBinding.returnType, nullStatus);
		}
	}
}

