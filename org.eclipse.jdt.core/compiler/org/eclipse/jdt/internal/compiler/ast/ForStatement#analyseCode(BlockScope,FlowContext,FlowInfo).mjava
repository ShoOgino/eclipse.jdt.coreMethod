	public FlowInfo analyseCode(
		BlockScope currentScope,
		FlowContext flowContext,
		FlowInfo flowInfo) {
			
		breakLabel = new Label();
		continueLabel = new Label();

		// process the initializations
		if (initializations != null) {
			int count = initializations.length, i = 0;
			while (i < count) {
				flowInfo = initializations[i++].analyseCode(scope, flowContext, flowInfo);
			}
		}
		preCondInitStateIndex =
			currentScope.methodScope().recordInitializationStates(flowInfo);

		boolean conditionIsInlinedToTrue = 
			condition == null || (condition.constant != NotAConstant && condition.constant.booleanValue() == true);
		boolean conditionIsInlinedToFalse = 
			! conditionIsInlinedToTrue && (condition.constant != NotAConstant && condition.constant.booleanValue() == false);
		
		// process the condition
		LoopingFlowContext condLoopContext = null;
		if (condition != null) {
			if (!conditionIsInlinedToTrue) {
				flowInfo =
					condition.analyseCode(
						scope,
						(condLoopContext =
							new LoopingFlowContext(flowContext, this, null, null, scope)),
						flowInfo);
			}
		}

		// process the action
		LoopingFlowContext loopingContext;
		FlowInfo actionInfo;
		if ((action == null) || action.isEmptyBlock()) {
			if (condLoopContext != null)
				condLoopContext.complainOnFinalAssignmentsInLoop(scope, flowInfo);
			if (conditionIsInlinedToTrue) {
				return FlowInfo.DeadEnd;
			} else {
				if (conditionIsInlinedToFalse){
					continueLabel = null; // for(;false;p());
				}
				actionInfo = flowInfo.initsWhenTrue().copy();
				loopingContext =
					new LoopingFlowContext(flowContext, this, breakLabel, continueLabel, scope);
			}
		} else {
			loopingContext =
				new LoopingFlowContext(flowContext, this, breakLabel, continueLabel, scope);
			FlowInfo initsWhenTrue = flowInfo.initsWhenTrue();
			condIfTrueInitStateIndex =
				currentScope.methodScope().recordInitializationStates(initsWhenTrue);

				actionInfo = conditionIsInlinedToFalse
					? FlowInfo.DeadEnd  // unreachable when condition inlined to false
					: initsWhenTrue.copy();
			if (!actionInfo.complainIfUnreachable(action, scope, false)) {
				actionInfo = action.analyseCode(scope, loopingContext, actionInfo);
			}

			// code generation can be optimized when no need to continue in the loop
			if (((actionInfo == FlowInfo.DeadEnd) || actionInfo.isFakeReachable())
				&& ((loopingContext.initsOnContinue == FlowInfo.DeadEnd)
					|| loopingContext.initsOnContinue.isFakeReachable())) {
				continueLabel = null;
			} else {
				if (condLoopContext != null)
					condLoopContext.complainOnFinalAssignmentsInLoop(scope, flowInfo);
				loopingContext.complainOnFinalAssignmentsInLoop(scope, actionInfo);
				actionInfo =
					actionInfo.mergedWith(loopingContext.initsOnContinue.unconditionalInits());
				// for increments
			}
		}
		if ((continueLabel != null) && (increments != null)) {
			LoopingFlowContext loopContext =
				new LoopingFlowContext(flowContext, this, null, null, scope);
			int i = 0, count = increments.length;
			while (i < count)
				actionInfo = increments[i++].analyseCode(scope, loopContext, actionInfo);
			loopContext.complainOnFinalAssignmentsInLoop(scope, flowInfo);
		}

		// infinite loop
		FlowInfo mergedInfo;
		if (conditionIsInlinedToTrue) {
			mergedInitStateIndex =
				currentScope.methodScope().recordInitializationStates(
					mergedInfo = loopingContext.initsOnBreak);
			return mergedInfo;
		}

		//end of loop: either condition false or break
		mergedInfo =
			flowInfo.initsWhenFalse().unconditionalInits().mergedWith(
				loopingContext.initsOnBreak.unconditionalInits());
		mergedInitStateIndex =
			currentScope.methodScope().recordInitializationStates(mergedInfo);
		return mergedInfo;
	}

