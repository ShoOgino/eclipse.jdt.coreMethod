/**
 * MessageSend code generation
 *
 * @param currentScope org.eclipse.jdt.internal.compiler.lookup.BlockScope
 * @param codeStream org.eclipse.jdt.internal.compiler.codegen.CodeStream
 * @param valueRequired boolean
 */ 
public void generateCode(BlockScope currentScope, CodeStream codeStream, boolean valueRequired) {

	int pc = codeStream.position;

	// generate receiver/enclosing instance access
	boolean isStatic = this.codegenBinding.isStatic();
	// outer access ?
	if (!isStatic && ((bits & DepthMASK) != 0) && receiver.isImplicitThis()){
		// outer method can be reached through emulation if implicit access
		ReferenceBinding targetType = currentScope.enclosingSourceType().enclosingTypeAt((bits & DepthMASK) >> DepthSHIFT);		
		Object[] path = currentScope.getEmulationPath(targetType, true /*only exact match*/, false/*consider enclosing arg*/);
		codeStream.generateOuterAccess(path, this, targetType, currentScope);
	} else {
		receiver.generateCode(currentScope, codeStream, !isStatic);
	}
	// generate arguments
	if (binding.isVararg()) {
		// 4 possibilities exist for a call to the vararg method foo(int i, int ... value) : foo(1), foo(1, 2), foo(1, 2, 3, 4) & foo(1, new int[] {1, 2})
		TypeBinding[] params = binding.parameters;
		int lastIndex = params.length - 1;
		for (int i = 0; i < lastIndex; i++) {
			arguments[i].generateCode(currentScope, codeStream, true);
		}

		ArrayBinding varArgsType = (ArrayBinding) params[lastIndex]; // parameterType has to be an array type
		int argLength = arguments == null ? 0 : arguments.length;
		if (lastIndex < argLength) { // vararg argument was provided
			if (params.length == argLength && varArgsType.dimensions() == arguments[lastIndex].resolvedType.dimensions()) {
				// called with matching array : foo(1, new int[] {1, 2}
				arguments[lastIndex].generateCode(currentScope, codeStream, true);
			} else {
				// called with (argLength - lastIndex) elements : foo(1, 2) or foo(1, 2, 3, 4)
				// need to gen elements into an array, then gen each remaining element into created array
				codeStream.generateInlinedValue(argLength - lastIndex);
				codeStream.newArray(currentScope, varArgsType); // create a mono-dimensional array
				int elementsTypeID = varArgsType.elementsType().id;
				for (int i = 0, max = argLength - lastIndex; i < max; i++) {
					codeStream.dup();
					codeStream.generateInlinedValue(i);
					arguments[i + lastIndex].generateCode(currentScope, codeStream, true);
					codeStream.arrayAtPut(elementsTypeID, false);
				}
			}
		} else {
			// generate code for an empty array of parameterType
			codeStream.generateInlinedValue(0);
			codeStream.newArray(currentScope, varArgsType); // create a mono-dimensional array
		}
	} else if (arguments != null){
		for (int i = 0, max = arguments.length; i < max; i++){
			arguments[i].generateCode(currentScope, codeStream, true);
		}
	}
	// actual message invocation
	if (syntheticAccessor == null){
		if (isStatic){
			codeStream.invokestatic(this.codegenBinding);
		} else {
			if( (receiver.isSuper()) || this.codegenBinding.isPrivate()){
				codeStream.invokespecial(this.codegenBinding);
			} else {
				if (this.codegenBinding.declaringClass.isInterface()){
					codeStream.invokeinterface(this.codegenBinding);
				} else {
					codeStream.invokevirtual(this.codegenBinding);
				}
			}
		}
	} else {
		codeStream.invokestatic(syntheticAccessor);
	}
	// operation on the returned value
	if (valueRequired){
		// implicit conversion if necessary
		codeStream.generateImplicitConversion(implicitConversion);
		if (this.genericCast != null) codeStream.checkcast(this.genericCast);
	} else {
		// pop return value if any
		switch(binding.returnType.id){
			case T_long :
			case T_double :
				codeStream.pop2();
				break;
			case T_void :
				break;
			default:
				codeStream.pop();
		}
	}
	codeStream.recordPositionsFrom(pc, (int)(this.nameSourcePosition >>> 32)); // highlight selector
}

