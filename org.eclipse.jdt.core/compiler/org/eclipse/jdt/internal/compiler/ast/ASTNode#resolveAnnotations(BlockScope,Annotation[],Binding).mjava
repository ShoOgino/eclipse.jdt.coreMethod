	/**
	 * Resolve annotations, and check duplicates, answers combined tagBits
	 * for recognized standard annotations
	 */
	public static void resolveAnnotations(BlockScope scope, Annotation[] annotations, Binding recipient) {
		AnnotationBinding[] instances = null;
		int length = annotations == null ? 0 : annotations.length;
		if (recipient != null) {
			switch (recipient.kind()) {
				case Binding.PACKAGE :
					PackageBinding packageBinding = (PackageBinding) recipient;
					if ((packageBinding.tagBits & TagBits.AnnotationResolved) != 0) return;
					packageBinding.tagBits |= (TagBits.AnnotationResolved | TagBits.DeprecatedAnnotationResolved);
					break;
				case Binding.TYPE :
				case Binding.GENERIC_TYPE :
					ReferenceBinding type = (ReferenceBinding) recipient;
					if ((type.tagBits & TagBits.AnnotationResolved) != 0) return;
					type.tagBits |= (TagBits.AnnotationResolved | TagBits.DeprecatedAnnotationResolved);
					if (length > 0) {
						instances = new AnnotationBinding[length];
						type.setAnnotations(instances);
					}
					break;
				case Binding.METHOD :
					MethodBinding method = (MethodBinding) recipient;
					if ((method.tagBits & TagBits.AnnotationResolved) != 0) return;
					method.tagBits |= (TagBits.AnnotationResolved | TagBits.DeprecatedAnnotationResolved);
					if (length > 0) {
						instances = new AnnotationBinding[length];
						method.setAnnotations(instances);
					}
					break;
				case Binding.FIELD :
					FieldBinding field = (FieldBinding) recipient;
					if ((field.tagBits & TagBits.AnnotationResolved) != 0) return;
					field.tagBits |= (TagBits.AnnotationResolved | TagBits.DeprecatedAnnotationResolved);
					if (length > 0) {
						instances = new AnnotationBinding[length];
						field.setAnnotations(instances);
					}
					break;
				case Binding.LOCAL :
					LocalVariableBinding local = (LocalVariableBinding) recipient;
					if ((local.tagBits & TagBits.AnnotationResolved) != 0) return;
					local.tagBits |= (TagBits.AnnotationResolved | TagBits.DeprecatedAnnotationResolved);
					if (length > 0) {
						instances = new AnnotationBinding[length];
						local.setAnnotations(instances);
					}
					break;
				default :
					return;
			}
		}
		if (annotations == null)
			return;
		TypeBinding[] annotationTypes = new TypeBinding[length];
		for (int i = 0; i < length; i++) {
			Annotation annotation = annotations[i];
			final Binding annotationRecipient = annotation.recipient;
			if (annotationRecipient != null && recipient != null) {
				// only local and field can share annnotations
				switch (recipient.kind()) {
					case Binding.FIELD :
						FieldBinding field = (FieldBinding) recipient;
						field.tagBits = ((FieldBinding) annotationRecipient).tagBits;
						break;
					case Binding.LOCAL :
						LocalVariableBinding local = (LocalVariableBinding) recipient;
						local.tagBits = ((LocalVariableBinding) annotationRecipient).tagBits;
						break;
				}
				if (instances != null) {
					// need to fill the instances array
					instances[0] = annotation.getCompilerAnnotation();
					for (int j = 1; j < length; j++) {
						Annotation annot = annotations[j];
						instances[j] = annot.getCompilerAnnotation();
					}
				}
				return;
			} else {
				annotation.recipient = recipient;
				annotationTypes[i] = annotation.resolveType(scope);
				// null if receiver is a package binding
				if (instances != null) {
					instances[i] = annotation.getCompilerAnnotation();
				}
			}
		}
		// check duplicate annotations
		for (int i = 0; i < length; i++) {
			TypeBinding annotationType = annotationTypes[i];
			if (annotationType == null) continue;
			boolean foundDuplicate = false;
			for (int j = i+1; j < length; j++) {
				if (annotationTypes[j] == annotationType) {
					foundDuplicate = true;
					annotationTypes[j] = null; // report it only once
					scope.problemReporter().duplicateAnnotation(annotations[j]);
				}
			}
			if (foundDuplicate) {
				scope.problemReporter().duplicateAnnotation(annotations[i]);
			}
		}
	}

