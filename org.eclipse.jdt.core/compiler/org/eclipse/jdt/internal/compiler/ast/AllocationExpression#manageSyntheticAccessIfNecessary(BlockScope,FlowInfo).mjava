public void manageSyntheticAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo) {
	if ((flowInfo.tagBits & FlowInfo.UNREACHABLE) != 0) return;
	// if constructor from parameterized type got found, use the original constructor at codegen time
	this.codegenBinding = this.binding.original();

	ReferenceBinding declaringClass;
	if (this.codegenBinding.isPrivate() && currentScope.enclosingSourceType() != (declaringClass = this.codegenBinding.declaringClass)) {

		// optionally, local type constructor can lose their private flag to ease emulation
		if ((declaringClass.tagBits & (TagBits.IsAnonymousType|TagBits.IsLocalType)) != 0
				&& currentScope.compilerOptions().isPrivateConstructorAccessChangingVisibility) {
			// constructor will not be dumped as private, no emulation required thus
			this.codegenBinding.tagBits |= TagBits.ClearPrivateModifier;
		} else {
			syntheticAccessor = ((SourceTypeBinding) declaringClass).addSyntheticMethod(this.codegenBinding, isSuperAccess());
			currentScope.problemReporter().needToEmulateMethodAccess(this.codegenBinding, this);
		}
	}
}

