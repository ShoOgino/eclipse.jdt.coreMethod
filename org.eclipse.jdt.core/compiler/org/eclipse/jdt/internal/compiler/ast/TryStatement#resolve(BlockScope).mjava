public void resolve(BlockScope upperScope) {

	// special scope for secret locals optimization.	
	scope = new BlockScope(upperScope);
	if (finallyBlock != null && finallyBlock.statements != null) { // provision for returning and forcing the finally block to run
		returnAddressVariable = new LocalVariableBinding(SecretReturnName, upperScope.getJavaLangObject(), 0); // the type does not matter as long as its not a normal base type
		scope.addLocalVariable(returnAddressVariable);
		returnAddressVariable.constant = NotAConstant; // not inlinable
		subRoutineStartLabel = new Label();

		BlockScope finallyScope = new BlockScope(scope);
		anyExceptionVariable = new LocalVariableBinding(SecretAnyHandlerName, scope.getJavaLangThrowable(), 0);
		finallyScope.addLocalVariable(anyExceptionVariable);
		anyExceptionVariable.constant = NotAConstant; // not inlinable
		finallyBlock.resolveUsing(finallyScope);
	}
	tryBlock.resolve(scope);

	// arguments type are checked against JavaLangThrowable in resolveForCatch(..)
	if (catchBlocks != null) {
		int length = catchArguments.length;
		TypeBinding[] argumentTypes = new TypeBinding[length];
		for (int i = 0; i < length; i++) {
			BlockScope catchScope = new BlockScope(scope);
			// side effect on catchScope in resolveForCatch(..)
			if ((argumentTypes[i] = catchArguments[i].resolveForCatch(catchScope)) == null)
				return;
			catchBlocks[i].resolveUsing(catchScope);
		}

		// Verify that the catch clause are ordered in the right way:
		// more specialized first.
		caughtExceptionTypes = new ReferenceBinding[length];
		for (int i = 0; i < length; i++) {
			caughtExceptionTypes[i] = (ReferenceBinding) argumentTypes[i];
			for (int j = 0; j < i; j++) {
				if (scope.areTypesCompatible(caughtExceptionTypes[i], argumentTypes[j])) {
					scope.problemReporter().wrongSequenceOfExceptionTypesError(this, i, j);
					return;
				}
			}
		}
	} else {
		caughtExceptionTypes = new ReferenceBinding[0];
	}
}

