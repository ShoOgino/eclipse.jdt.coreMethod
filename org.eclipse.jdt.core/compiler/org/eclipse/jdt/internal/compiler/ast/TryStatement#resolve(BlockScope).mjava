	public void resolve(BlockScope upperScope) {

		// special scope for secret locals optimization.	
		scope = new BlockScope(upperScope);

		BlockScope tryScope = new BlockScope(scope);
		BlockScope finallyScope = null;
		if (finallyBlock != null
			&& finallyBlock.statements != null) {
			// provision for returning and forcing the finally block to run
			MethodScope methodScope = scope.methodScope();

			returnAddressVariable =
				new LocalVariableBinding(SecretReturnName, upperScope.getJavaLangObject(), 0);
			// the type does not matter as long as its not a normal base type
			methodScope.addLocalVariable(returnAddressVariable);
			returnAddressVariable.constant = NotAConstant; // not inlinable
			subRoutineStartLabel = new Label();

			finallyScope = new BlockScope(scope);
			this.anyExceptionVariable =
				new LocalVariableBinding(SecretAnyHandlerName, scope.getJavaLangThrowable(), 0);
			finallyScope.addLocalVariable(this.anyExceptionVariable);
			this.anyExceptionVariable.constant = NotAConstant; // not inlinable

			if (!methodScope.isInsideInitializer()) {
				MethodBinding methodBinding =
					((AbstractMethodDeclaration) methodScope.referenceContext).binding;
				if (methodBinding != null) {
					TypeBinding methodReturnType = methodBinding.returnType;
					if (methodReturnType.id != T_void) {
						this.secretReturnValue =
							new LocalVariableBinding(
								SecretLocalDeclarationName,
								methodReturnType,
								AccDefault);
						finallyScope.addLocalVariable(this.secretReturnValue);
						this.secretReturnValue.constant = NotAConstant; // not inlinable
					}
				}
			}
			finallyBlock.resolveUsing(finallyScope);
			// force the finally scope to have variable positions shifted after its try scope.
			finallyScope.shiftScope = tryScope;
		}
		tryBlock.resolveUsing(tryScope);

		// arguments type are checked against JavaLangThrowable in resolveForCatch(..)
		if (catchBlocks != null) {
			int length = catchArguments.length;
			TypeBinding[] argumentTypes = new TypeBinding[length];
			for (int i = 0; i < length; i++) {
				BlockScope catchScope = new BlockScope(scope);
				// side effect on catchScope in resolveForCatch(..)
				if ((argumentTypes[i] = catchArguments[i].resolveForCatch(catchScope)) == null)
					return;
				catchBlocks[i].resolveUsing(catchScope);
			}

			// Verify that the catch clause are ordered in the right way:
			// more specialized first.
			caughtExceptionTypes = new ReferenceBinding[length];
			for (int i = 0; i < length; i++) {
				caughtExceptionTypes[i] = (ReferenceBinding) argumentTypes[i];
				for (int j = 0; j < i; j++) {
					if (scope.areTypesCompatible(caughtExceptionTypes[i], argumentTypes[j])) {
						scope.problemReporter().wrongSequenceOfExceptionTypesError(this, i, j);
						return;
					}
				}
			}
		} else {
			caughtExceptionTypes = new ReferenceBinding[0];
		}
	}

