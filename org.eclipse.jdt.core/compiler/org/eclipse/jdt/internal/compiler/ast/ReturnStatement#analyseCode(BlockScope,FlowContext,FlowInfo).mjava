public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo) {	// here requires to generate a sequence of finally blocks invocations depending corresponding
	// to each of the traversed try statements, so that execution will terminate properly.

	// lookup the label, this should answer the returnContext

	if (expression != null) {
		flowInfo = expression.analyseCode(currentScope, flowContext, flowInfo);
	}
	// compute the return sequence (running the finally blocks)
	FlowContext traversedContext = flowContext;
	int subIndex = 0, maxSub = 5;
	boolean saveValueNeeded = false;
	boolean hasValueToSave = expression != null && expression.constant == NotAConstant;
	while (true) {
		AstNode sub;
		if ((sub = traversedContext.subRoutine()) != null) {
			if (this.subroutines == null){
				this.subroutines = new AstNode[maxSub];
			}
			if (subIndex == maxSub) {
				System.arraycopy(this.subroutines, 0, (this.subroutines = new AstNode[maxSub *= 2]), 0, subIndex); // grow
			}
			this.subroutines[subIndex++] = sub;
			if (sub.cannotReturn()) {
				saveValueNeeded = false;
				break;
			}
		}
		AstNode node;

		if ((node = traversedContext.associatedNode) instanceof SynchronizedStatement) {
			isSynchronized = true;

		} else if (node instanceof TryStatement && hasValueToSave) {
				if (this.saveValueVariable == null){ // closest subroutine secret variable is used
					prepareSaveValueLocation((TryStatement)node);
				}
				saveValueNeeded = true;

		} else if (traversedContext instanceof InitializationFlowContext) {
				currentScope.problemReporter().cannotReturnInInitializer(this);
				return FlowInfo.DeadEnd;
		}

		// remember the initialization at this
		// point for dealing with blank final variables.
		traversedContext.recordReturnFrom(flowInfo.unconditionalInits());

		FlowContext parentContext;
		if ((parentContext = traversedContext.parent) == null) { // top-context
			break;
		} else {
			traversedContext = parentContext;
		}
	}
	// resize subroutines
	if ((subroutines != null) && (subIndex != maxSub)) {
		System.arraycopy(subroutines, 0, (subroutines = new AstNode[subIndex]), 0, subIndex);
	}

	// secret local variable for return value (note that this can only occur in a real method)
	if (saveValueNeeded) {
		if (this.saveValueVariable != null) {
			this.saveValueVariable.used = true;
		}
	} else {
		this.saveValueVariable = null;
		if ((!isSynchronized) && (expressionType == BooleanBinding)) {
			this.expression.bits |= ValueForReturnMASK;
		}
	}
	return FlowInfo.DeadEnd;
}

