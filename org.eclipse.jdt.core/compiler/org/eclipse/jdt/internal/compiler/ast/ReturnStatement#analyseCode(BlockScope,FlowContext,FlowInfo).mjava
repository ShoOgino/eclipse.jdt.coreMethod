public FlowInfo analyseCode(BlockScope currentScope, FlowContext flowContext, FlowInfo flowInfo) {

	// here requires to generate a sequence of finally blocks invocations depending corresponding
	// to each of the traversed try statements, so that execution will terminate properly.

	// lookup the label, this should answer the returnContext

	if (expression != null) {
		flowInfo = expression.analyseCode(currentScope, flowContext, flowInfo);
	}
	// compute the return sequence (running the finally blocks)
	FlowContext traversedContext = flowContext;
	int subIndex = 0, maxSub = 5;
	boolean saveValueNeeded = false;
	while (true) {
		AstNode sub;
		if ((sub = traversedContext.subRoutine()) != null) {
			if (subroutines == null){
				subroutines = new AstNode[maxSub];
			}
			if (subIndex == maxSub) {
				System.arraycopy(subroutines, 0, (subroutines = new AstNode[maxSub *= 2]), 0, subIndex); // grow
			}
			subroutines[subIndex++] = sub;
			if (sub.cannotReturn()) {
				saveValueNeeded = false;
				break;
			}
		}
		AstNode node;
		if ((node = traversedContext.associatedNode) instanceof SynchronizedStatement) {
			isSynchronized = true;
		} else {
			if ((expression != null) && (node instanceof TryStatement)) {
				saveValueNeeded = true;
			} else {
				if (traversedContext instanceof InitializationFlowContext) {
					currentScope.problemReporter().cannotReturnInInitializer(this);
					return FlowInfo.DeadEnd;
				}
			}
		}
		// remember the initialization at this
		// point for dealing with blank final variables.
		traversedContext.recordReturnFrom(flowInfo.unconditionalInits());

		FlowContext parentContext;
		if ((parentContext = traversedContext.parent) == null) { // top-context
			break;
		} else {
			traversedContext = parentContext;
		}
	}
	// resize subroutines
	if ((subroutines != null) && (subIndex != maxSub)) {
		System.arraycopy(subroutines, 0, (subroutines = new AstNode[subIndex]), 0, subIndex);
	}

	// no need to save a constant value
	if((expression != null) && (expression.constant != NotAConstant)){
		saveValueNeeded = false;
	}
	// secret local variable for return value (note that this can only occur in a real method)
	if (saveValueNeeded) {
		prepareSaveValueLocation(currentScope);
	} else {
		if ((!isSynchronized) && (expressionType == BooleanBinding)) {
			expression.bits |= ValueForReturnMASK;
		}
	}
	return FlowInfo.DeadEnd;
}

