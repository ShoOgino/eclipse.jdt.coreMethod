public final boolean areTypesCastCompatible(BlockScope scope, TypeBinding castType, TypeBinding expressionType) {
	//see specifications 5.5
	//A more complete version of this method is provided on
	//CastExpression (it deals with constant and need runtime checkcast)

	if (castType == expressionType) return true;

	//========ARRAY===============
	if (expressionType.isArrayType()) {
		if (castType.isArrayType()) { //------- (castTb.isArray) expressionTb.isArray -----------
			TypeBinding expressionEltType = ((ArrayBinding) expressionType).elementsType(scope);
			if (expressionEltType.isBaseType())
				// <---stop the recursion------- 
				return ((ArrayBinding) castType).elementsType(scope) == expressionEltType;
			//recursivly on the elts...
			return areTypesCastCompatible(scope, ((ArrayBinding) castType).elementsType(scope), expressionEltType);
		}
		if (castType.isBaseType()) {
			return false;
		}
		if (castType.isClass()) { //------(castTb.isClass) expressionTb.isArray ---------------	
			if (scope.isJavaLangObject(castType))
				return true;
			return false;
		}
		if (castType.isInterface()) { //------- (castTb.isInterface) expressionTb.isArray -----------
			if (scope.isJavaLangCloneable(castType) || scope.isJavaIoSerializable(castType)) {
				return true;
			}
			return false;
		}

		return false;
	}

	//------------(castType) null--------------
	if (expressionType == NullBinding) {
		return !castType.isBaseType();
	}

	//========BASETYPE==============
	if (expressionType.isBaseType()) {
		return false;
	}


	//========REFERENCE TYPE===================

	if (expressionType.isClass()) {
		if (castType.isArrayType()) { // ---- (castTb.isArray) expressionTb.isClass -------
			if (scope.isJavaLangObject(expressionType))
				return true;
		}
		if (castType.isBaseType()) {
			return false;
		}
		if (castType.isClass()) { // ----- (castTb.isClass) expressionTb.isClass ------ 
			if (expressionType.isCompatibleWith(castType))
				return true;
			else {
				if (castType.isCompatibleWith(expressionType)) {
					return true;
				}
				return false;
			}
		}
		if (castType.isInterface()) { // ----- (castTb.isInterface) expressionTb.isClass -------  
			if (((ReferenceBinding) expressionType).isFinal()) { //no subclass for expressionTb, thus compile-time check is valid
				if (expressionType.isCompatibleWith(castType))
					return true;
				return false;
			} else {
				return true;
			}
		}

		return false;
	}
	if (expressionType.isInterface()) {
		if (castType.isArrayType()) { // ----- (castTb.isArray) expressionTb.isInterface ------
			if (scope.isJavaLangCloneable(expressionType) || scope.isJavaIoSerializable(expressionType))
				//potential runtime error
				{
				return true;
			}
			return false;
		}
		if (castType.isBaseType()) {
			return false;
		}
		if (castType.isClass()) { // ----- (castTb.isClass) expressionTb.isInterface --------
			if (scope.isJavaLangObject(castType))
				return true;
			if (((ReferenceBinding) castType).isFinal()) { //no subclass for castTb, thus compile-time check is valid
				if (castType.isCompatibleWith(expressionType)) {
					return true;
				}
				return false;
			}
			return true;
		}
		if (castType.isInterface()) { // ----- (castTb.isInterface) expressionTb.isInterface -------
			if (Scope.compareTypes(castType, expressionType) == NotRelated) {
				MethodBinding[] castTbMethods = ((ReferenceBinding) castType).methods();
				int castTbMethodsLength = castTbMethods.length;
				MethodBinding[] expressionTbMethods = ((ReferenceBinding) expressionType).methods();
				int expressionTbMethodsLength = expressionTbMethods.length;
				for (int i = 0; i < castTbMethodsLength; i++) {
					for (int j = 0; j < expressionTbMethodsLength; j++) {
						if (CharOperation.equals(castTbMethods[i].selector, expressionTbMethods[j].selector)) {
							if (castTbMethods[i].returnType != expressionTbMethods[j].returnType) {
								if (castTbMethods[i].areParametersEqual(expressionTbMethods[j])) {
									return false;
								}
							}
						}
					}
				}
			}
			return true;
		}

		return false;
	}

	return false;
}

