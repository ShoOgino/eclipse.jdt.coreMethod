public final boolean areTypesCastCompatible(BlockScope scope, TypeBinding castTb, TypeBinding expressionTb) {
	//see specifications p.68
	//A more complete version of this method is provided on
	//CastExpression (it deals with constant and need runtime checkcast)


	//========ARRAY===============
	if (expressionTb.isArrayType()) {
		if (castTb.isArrayType()) { //------- (castTb.isArray) expressionTb.isArray -----------
			TypeBinding expressionEltTb = ((ArrayBinding) expressionTb).elementsType(scope);
			if (expressionEltTb.isBaseType())
				// <---stop the recursion------- 
				return ((ArrayBinding) castTb).elementsType(scope) == expressionEltTb;
			//recursivly on the elts...
			return areTypesCastCompatible(scope, ((ArrayBinding) castTb).elementsType(scope), expressionEltTb);
		}
		if (castTb.isBaseType()) {
			return false;
		}
		if (castTb.isClass()) { //------(castTb.isClass) expressionTb.isArray ---------------	
			if (scope.isJavaLangObject(castTb))
				return true;
			return false;
		}
		if (castTb.isInterface()) { //------- (castTb.isInterface) expressionTb.isArray -----------
			if (scope.isJavaLangCloneable(castTb) || scope.isJavaIoSerializable(castTb)) {
				return true;
			}
			return false;
		}

		return false;
	}

	//------------(castType) null--------------
	if (expressionTb == NullBinding) {
		return !castTb.isBaseType();
	}

	//========BASETYPE==============
	if (expressionTb.isBaseType()) {
		return false;
	}


	//========REFERENCE TYPE===================

	if (expressionTb.isClass()) {
		if (castTb.isArrayType()) { // ---- (castTb.isArray) expressionTb.isClass -------
			if (scope.isJavaLangObject(expressionTb))
				return true;
		}
		if (castTb.isBaseType()) {
			return false;
		}
		if (castTb.isClass()) { // ----- (castTb.isClass) expressionTb.isClass ------ 
			if (scope.areTypesCompatible(expressionTb, castTb))
				return true;
			else {
				if (scope.areTypesCompatible(castTb, expressionTb)) {
					return true;
				}
				return false;
			}
		}
		if (castTb.isInterface()) { // ----- (castTb.isInterface) expressionTb.isClass -------  
			if (((ReferenceBinding) expressionTb).isFinal()) { //no subclass for expressionTb, thus compile-time check is valid
				if (scope.areTypesCompatible(expressionTb, castTb))
					return true;
				return false;
			} else {
				return true;
			}
		}

		return false;
	}
	if (expressionTb.isInterface()) {
		if (castTb.isArrayType()) { // ----- (castTb.isArray) expressionTb.isInterface ------
			if (scope.isJavaLangCloneable(expressionTb) || scope.isJavaIoSerializable(expressionTb))
				//potential runtime error
				{
				return true;
			}
			return false;
		}
		if (castTb.isBaseType()) {
			return false;
		}
		if (castTb.isClass()) { // ----- (castTb.isClass) expressionTb.isInterface --------
			if (scope.isJavaLangObject(castTb))
				return true;
			if (((ReferenceBinding) castTb).isFinal()) { //no subclass for castTb, thus compile-time check is valid
				if (scope.areTypesCompatible(castTb, expressionTb)) {
					return true;
				}
				return false;
			}
			return true;
		}
		if (castTb.isInterface()) { // ----- (castTb.isInterface) expressionTb.isInterface -------
			if (castTb != expressionTb && (Scope.compareTypes(castTb, expressionTb) == NotRelated)) {
				MethodBinding[] castTbMethods = ((ReferenceBinding) castTb).methods();
				int castTbMethodsLength = castTbMethods.length;
				MethodBinding[] expressionTbMethods = ((ReferenceBinding) expressionTb).methods();
				int expressionTbMethodsLength = expressionTbMethods.length;
				for (int i = 0; i < castTbMethodsLength; i++) {
					for (int j = 0; j < expressionTbMethodsLength; j++) {
						if (castTbMethods[i].selector == expressionTbMethods[j].selector) {
							if (castTbMethods[i].returnType != expressionTbMethods[j].returnType) {
								if (castTbMethods[i].areParametersEqual(expressionTbMethods[j])) {
									return false;
								}
							}
						}
					}
				}
			}
			return true;
		}

		return false;
	}

	return false;
}

