	public boolean sIsMoreSpecific(TypeBinding s, TypeBinding t) {
		
		// 15.12.2.5 
		
		if (TypeBinding.equalsEquals(s,  t))
			return true;
		
		if (argumentsTypeElided() || t.findSuperTypeOriginatingFrom(s) != null)
			return false;
		
		s = s.capture(this.enclosingScope, this.sourceEnd);
		MethodBinding sSam = s.getSingleAbstractMethod(this.enclosingScope, true);
		if (sSam == null || !sSam.isValidBinding())
			return false;
		TypeBinding r1 = sSam.returnType;
		MethodBinding tSam = t.getSingleAbstractMethod(this.enclosingScope, true);
		if (tSam == null || !tSam.isValidBinding())
			return false;
		TypeBinding r2 = tSam.returnType;
		
		if (r2.id == TypeIds.T_void)
			return true;
		
		if (r1.id == TypeIds.T_void)
			return false;
		
		// r1 <: r2
		if (r1.isCompatibleWith(r2))
			return true;
		
		Expression [] returnExpressions = this.resultExpressions;
		int returnExpressionsLength = returnExpressions == null ? 0 : returnExpressions.length;
		
		int i;
		// r1 is a primitive type, r2 is a reference type, and each result expression is a standalone expression (15.2) of a primitive type
		if (r1.isBaseType() && !r2.isBaseType()) {
			for (i = 0; i < returnExpressionsLength; i++) {
				if (returnExpressions[i].isPolyExpression() || !returnExpressions[i].resolvedType.isBaseType())
					break;
			}
			if (i == returnExpressionsLength)
				return true;
		}
		if (!r1.isBaseType() && r2.isBaseType()) {
			for (i = 0; i < returnExpressionsLength; i++) {
				if (returnExpressions[i].resolvedType.isBaseType())
					break;
			}
			if (i == returnExpressionsLength)
				return true;
		}
		if (r1.isFunctionalInterface(this.enclosingScope) && r2.isFunctionalInterface(this.enclosingScope)) {
			for (i = 0; i < returnExpressionsLength; i++) {
				Expression resultExpression = returnExpressions[i];
				if (!resultExpression.sIsMoreSpecific(r1, r2))
					break;
			}
			if (i == returnExpressionsLength)
				return true;
		}
		return false;
	}

