	public boolean sIsMoreSpecific(TypeBinding s, TypeBinding t) {
		
		// 15.12.2.5 
		
		if (TypeBinding.equalsEquals(s,  t))
			return true;
		
		if (argumentsTypeElided() || t.findSuperTypeOriginatingFrom(s) != null)
			return false;
		
		s = s.capture(this.enclosingScope, this.sourceEnd);
		MethodBinding sSam = s.getSingleAbstractMethod(this.enclosingScope);
		if (sSam == null || !sSam.isValidBinding())
			return false;
		TypeBinding r1 = sSam.returnType;
		MethodBinding tSam = t.getSingleAbstractMethod(this.enclosingScope);
		if (tSam == null || !tSam.isValidBinding())
			return false;
		TypeBinding r2 = tSam.returnType;
		
		if (r2.id == TypeIds.T_void)
			return true;
		
		if (r1.id == TypeIds.T_void)
			return false;
		
		if (r1.findSuperTypeOriginatingFrom(r2) != null)
			return true;
		
		Expression [] returnExpressions = this.resultExpressions;
		int returnExpressionsLength = returnExpressions == null ? 0 : returnExpressions.length;
		
		// r1 is a primitive type, r2 is a reference type, and each result expression is a standalone expression (15.2) of a primitive type
		if (r1.isBaseType() && !r2.isBaseType()) {
			for (int i = 0; i < returnExpressionsLength; i++) {
				if (returnExpressions[i].isPolyExpression() || !returnExpressions[i].resolvedType.isBaseType())
					break;
			}
			return true;
		}
		if (returnExpressionsLength == 0)
			return false;
		
		sSam = s.getSingleAbstractMethod(this.enclosingScope);
		for (int i = 0; i < returnExpressionsLength; i++) {
			Expression resultExpression = returnExpressions[i];
			if (!resultExpression.sIsMoreSpecific(sSam.returnType, tSam.returnType))
				return false;
		}
		return true;
	}

