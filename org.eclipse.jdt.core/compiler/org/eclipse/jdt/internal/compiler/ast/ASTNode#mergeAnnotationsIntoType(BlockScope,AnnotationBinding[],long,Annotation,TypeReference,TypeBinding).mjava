	private static TypeBinding mergeAnnotationsIntoType(BlockScope scope, AnnotationBinding[] se8Annotations, long se8nullBits, Annotation se8NullAnnotation,
			TypeReference typeRef, TypeBinding existingType) 
	{
		if (existingType == null || !existingType.isValidBinding()) return existingType;
		TypeReference unionRef = typeRef.isUnionType() ? ((UnionTypeReference) typeRef).typeReferences[0] : null;
		
		// for arrays: @T X[] SE7 associates @T to the type, but in SE8 it affects the leaf component type
		long prevNullBits = existingType.leafComponentType().tagBits & TagBits.AnnotationNullMASK;
		if (se8nullBits != 0 && prevNullBits != se8nullBits && ((prevNullBits | se8nullBits) == TagBits.AnnotationNullMASK)) {
			scope.problemReporter().contradictoryNullAnnotations(se8NullAnnotation);
		}
		TypeBinding oldLeafType = (unionRef == null) ? existingType.leafComponentType() : unionRef.resolvedType;
		AnnotationBinding [][] goodies = new AnnotationBinding[typeRef.getAnnotatableLevels()][];
		goodies[0] = se8Annotations;  // @T X.Y.Z local; ==> @T should annotate X
		TypeBinding newLeafType = scope.environment().createAnnotatedType(oldLeafType, goodies);

		if (unionRef == null) {
			typeRef.resolvedType = existingType.isArrayType() ? scope.environment().createArrayType(newLeafType, existingType.dimensions(), existingType.getTypeAnnotations()) : newLeafType;
		} else {
			unionRef.resolvedType = newLeafType;
			unionRef.bits |= HasTypeAnnotations;
		}
		return typeRef.resolvedType;
	}

