	public boolean isCompatibleWith(TypeBinding left, final Scope someScope) {
		if (!(left instanceof ReferenceBinding))
			return false;

		left = left.uncapture(this.enclosingScope);
		shapeAnalysis: if (!this.shapeAnalysisComplete) {
			IErrorHandlingPolicy oldPolicy = this.enclosingScope.problemReporter().switchErrorHandlingPolicy(silentErrorHandlingPolicy);
			final CompilerOptions compilerOptions = this.enclosingScope.compilerOptions();
			boolean analyzeNPE = compilerOptions.isAnnotationBasedNullAnalysisEnabled;
			compilerOptions.isAnnotationBasedNullAnalysisEnabled = false;
			try {
				final LambdaExpression copy = copy();
				if (copy == null) {
					if (this.assistNode) {
						analyzeShape(); // not on terra firma here !
// FIXME: we don't yet have the same, should we compute it here & now?
//						if (sam.returnType.id == TypeIds.T_void) {
//							if (!this.voidCompatible)
//								return false;
//						} else {
//							if (!this.valueCompatible)
//								return false;
//						}
					}
					return !isPertinentToApplicability(left, null);
				}
				copy.setExpressionContext(this.expressionContext);
				copy.setExpectedType(left);
				this.hasIgnoredMandatoryErrors = false;
				TypeBinding type = copy.resolveType(this.enclosingScope);
				if (this.body instanceof Block) {
					if (this.returnsVoid) {
						this.shapeAnalysisComplete = true;
					}
				} else {
					this.voidCompatible = ((Expression) this.body).statementExpression();
					// TODO: in getResolvedCopyForInferenceTargeting() we need to check if the expression
					//        *could* also produce a value and set valueCompatible accordingly.
					//        Is that needed also here?
					this.shapeAnalysisComplete = true;
				}
				// Do not proceed with data/control flow analysis if resolve encountered errors.
				if (type == null || !type.isValidBinding() || this.hasIgnoredMandatoryErrors || enclosingScopesHaveErrors()) {
					if (!isPertinentToApplicability(left, null))
						break shapeAnalysis;
					if (this.arguments.length != 0) // error not because of the target type imposition, but is inherent. Just say compatible since errors in body aren't to influence applicability.
						return false;
					break shapeAnalysis;
				}
				
				// value compatibility of block lambda's is the only open question.
				if (!this.shapeAnalysisComplete)
					this.valueCompatible = copy.doesNotCompleteNormally();
				
				this.shapeAnalysisComplete = true;
			} finally {
				compilerOptions.isAnnotationBasedNullAnalysisEnabled = analyzeNPE;
				this.hasIgnoredMandatoryErrors = false;
				this.enclosingScope.problemReporter().switchErrorHandlingPolicy(oldPolicy);
			}
		}

		ReferenceBinding expectedSAMType = null;
		if (left instanceof IntersectionCastTypeBinding)
			expectedSAMType = (ReferenceBinding) ((IntersectionCastTypeBinding) left).getSAMType(this.enclosingScope); 
		else if (left instanceof ReferenceBinding)
			expectedSAMType = (ReferenceBinding) left;
		ReferenceBinding groundTargetType = expectedSAMType != null ? findGroundTargetType(this.enclosingScope, expectedSAMType, argumentsTypeElided()) : null;
		if (groundTargetType == null)
			return false;
		
		MethodBinding sam = groundTargetType.getSingleAbstractMethod(this.enclosingScope, true);
		if (sam == null || !sam.isValidBinding())
			return false;
		if (sam.parameters.length != this.arguments.length)
			return false;

		if (!isPertinentToApplicability(left, null))  // This check should happen after return type check below, but for buggy javac compatibility we have left it in.
			return true;

		if (sam.returnType.id == TypeIds.T_void) {
			if (!this.voidCompatible)
				return false;
		} else {
			if (!this.valueCompatible)
				return false;
		}
		Expression [] returnExpressions = this.resultExpressions;
		for (int i = 0, length = returnExpressions.length; i < length; i++) {
			if (returnExpressions[i] instanceof FunctionalExpression) { // don't want to use the resolvedType - polluted from some other overload resolution candidate
				if (!returnExpressions[i].isCompatibleWith(sam.returnType, this.enclosingScope))
					return false;
			} else {
				if (this.enclosingScope.parameterCompatibilityLevel(returnExpressions[i].resolvedType, sam.returnType) == Scope.NOT_COMPATIBLE) {
					if (!returnExpressions[i].isConstantValueOfTypeAssignableToType(returnExpressions[i].resolvedType, sam.returnType))
						if (sam.returnType.id != TypeIds.T_void || this.body instanceof Block)
							return false;
				}
			}
		}
	
		TypeBinding [] samPararameterTypes = sam.parameters;
		for (int i = 0, length = samPararameterTypes.length; i < length; i++) { // lengths known to be equal.
			if (TypeBinding.notEquals(samPararameterTypes[i], this.argumentTypes[i]))
				return false;
		}

		return true;
	}

