	public boolean isCompatibleWith(final TypeBinding left, final Scope someScope) {
		
		final MethodBinding sam = left.getSingleAbstractMethod(this.enclosingScope, true);
		
		if (sam == null || !sam.isValidBinding())
			return false;
		if (sam.parameters.length != this.arguments.length)
			return false;
		
		if (!this.shapeAnalysisComplete) {
			IErrorHandlingPolicy oldPolicy = this.enclosingScope.problemReporter().switchErrorHandlingPolicy(silentErrorHandlingPolicy);
			final CompilerOptions compilerOptions = this.enclosingScope.compilerOptions();
			boolean analyzeNPE = compilerOptions.isAnnotationBasedNullAnalysisEnabled;
			compilerOptions.isAnnotationBasedNullAnalysisEnabled = false;
			try {
				final LambdaExpression copy = copy();
				if (copy == null) {
					if (this.assistNode) {
						analyzeShape(); // not on terra firma here !
						if (sam.returnType.id == TypeIds.T_void) {
							if (!this.voidCompatible)
								return false;
						} else {
							if (!this.valueCompatible)
								return false;
						}
					}
					return !isPertinentToApplicability(left, null);
				}
				copy.setExpressionContext(this.expressionContext);
				copy.setExpectedType(left);
				this.hasIgnoredMandatoryErrors = false;
				TypeBinding type = copy.resolveType(this.enclosingScope);
				if (!argumentsTypeElided()) {
					this.argumentTypes = copy.argumentTypes;
				}
				if (this.body instanceof Block) {
					if (this.returnsVoid) {
						this.shapeAnalysisComplete = true;
					}
				} else {
					this.voidCompatible = ((Expression) this.body).statementExpression();
					// TODO: in getResolvedCopyForInferenceTargeting() we need to check if the expression
					//        *could* also procude a value and set valueCompatible accordingly.
					//        Is that needed also here?
					this.shapeAnalysisComplete = true;
				}
				// Do not proceed with data/control flow analysis if resolve encountered errors.
				if (type == null || !type.isValidBinding() || this.hasIgnoredMandatoryErrors || enclosingScopesHaveErrors()) {
					if (!isPertinentToApplicability(left, null))
						return true;
					return this.arguments.length == 0; // error not because of the target type imposition, but is inherent. Just say compatible since errors in body aren't to influence applicability.
				}
				
				// value compatibility of block lambda's is the only open question.
				if (!this.shapeAnalysisComplete)
					this.valueCompatible = copy.doesNotCompleteNormally();
				
				this.shapeAnalysisComplete = true;
			} finally {
				compilerOptions.isAnnotationBasedNullAnalysisEnabled = analyzeNPE;
				this.hasIgnoredMandatoryErrors = false;
				this.enclosingScope.problemReporter().switchErrorHandlingPolicy(oldPolicy);
			}
		}

		if (!isPertinentToApplicability(left, null))  // This check should happen after return type check below, but for buggy javac compatibility we have left it in.
			return true;

		if (sam.returnType.id == TypeIds.T_void) {
			if (!this.voidCompatible)
				return false;
		} else {
			if (!this.valueCompatible)
				return false;
		}
		Expression [] returnExpressions = this.resultExpressions;
		for (int i = 0, length = returnExpressions.length; i < length; i++) {
			if (returnExpressions[i] instanceof FunctionalExpression) { // don't want to use the resolvedType - polluted from some other overload resolution candidate
				if (!returnExpressions[i].isCompatibleWith(sam.returnType, this.enclosingScope))
					return false;
			} else {
				if (this.enclosingScope.parameterCompatibilityLevel(returnExpressions[i].resolvedType, sam.returnType) == Scope.NOT_COMPATIBLE) {
					if (sam.returnType.id != TypeIds.T_void || this.body instanceof Block)
						return false;
				}
			}
		}
	
		TypeBinding [] samPararameterTypes = sam.parameters;
		for (int i = 0, length = samPararameterTypes.length; i < length; i++) { // lengths known to be equal.
			if (TypeBinding.notEquals(samPararameterTypes[i], this.argumentTypes[i]))
				return false;
		}

		return true;
	}

