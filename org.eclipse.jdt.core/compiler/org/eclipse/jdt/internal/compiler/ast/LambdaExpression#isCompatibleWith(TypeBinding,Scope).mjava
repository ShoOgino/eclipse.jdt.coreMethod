	public boolean isCompatibleWith(TypeBinding targetType, final Scope skope) {
		
		if (!super.isPertinentToApplicability(targetType, null))
			return true;
		
		LambdaExpression copy = null;
		try {
			copy = cachedResolvedCopy(targetType, argumentsTypeElided(), false, null); // if argument types are elided, we don't care for result expressions against *this* target, any valid target is OK.
		} catch (CopyFailureException cfe) {
			if (this.assistNode)
				return true; // can't type check result expressions, just say yes.
			return !isPertinentToApplicability(targetType, null); // don't expect to hit this ever.
		}
		if (copy == null)
			return false;
		
		// copy here is potentially compatible with the target type and has its shape fully computed: i.e value/void compatibility is determined and result expressions have been gathered.
		targetType = findGroundTargetType(this.enclosingScope, targetType, targetType, argumentsTypeElided());
		MethodBinding sam = targetType.getSingleAbstractMethod(this.enclosingScope, true);
		if (sam == null || sam.problemId() == ProblemReasons.NoSuchSingleAbstractMethod) {
			return false;
		}
		if (sam.returnType.id == TypeIds.T_void) {
			if (!copy.voidCompatible)
				return false;
		} else {
			if (!copy.valueCompatible)
				return false;
		}

		if (!isPertinentToApplicability(targetType, null))
			return true;

		// catch up on one check deferred via skipKosherCheck=true (only if pertinent for applicability)
		if (!kosherDescriptor(this.enclosingScope, sam, false))
			return false;

		Expression [] returnExpressions = copy.resultExpressions;
		for (int i = 0, length = returnExpressions.length; i < length; i++) {
			if (sam.returnType.isProperType(true) // inference variables can reach here during nested inference
					&& this.enclosingScope.parameterCompatibilityLevel(returnExpressions[i].resolvedType, sam.returnType) == Scope.NOT_COMPATIBLE) {
				if (!returnExpressions[i].isConstantValueOfTypeAssignableToType(returnExpressions[i].resolvedType, sam.returnType))
					if (sam.returnType.id != TypeIds.T_void || this.body instanceof Block)
						return false;
			}
		}
		return true;
	}

