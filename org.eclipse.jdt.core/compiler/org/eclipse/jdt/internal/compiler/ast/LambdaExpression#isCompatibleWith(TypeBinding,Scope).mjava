	public boolean isCompatibleWith(final TypeBinding left, final Scope someScope) {
		
		final MethodBinding sam = left.getSingleAbstractMethod(this.enclosingScope);
		
		if (sam == null || !sam.isValidBinding())
			return false;
		if (sam.parameters.length != this.arguments.length)
			return false;
		
		IErrorHandlingPolicy oldPolicy = this.scope.problemReporter().switchErrorHandlingPolicy(silentErrorHandlingPolicy);

		try {
			if (this.shapeAnalysisComplete) {
				if (squarePegInRoundHole(sam))
					return false;
			} else {
				LambdaExpression copy = copy();
				if (copy == null)
					return false;
				copy.setExpressionContext(this.expressionContext);
				copy.setExpectedType(left);
				copy.resolveType(this.enclosingScope);
				this.valueCompatible = copy.valueCompatible = copy.doesNotCompleteNormally();
				this.shapeAnalysisComplete = copy.shapeAnalysisComplete = true;
				if (squarePegInRoundHole(sam))
					return false;
			}
		
			final LambdaExpression copy = copy();
			if (copy == null)
				return false;
			copy.setExpressionContext(this.expressionContext);
			copy.setExpectedType(left);
			copy.resolveType(this.enclosingScope);
			
			if (!argumentsTypeElided()) {
				for (int i = 0, length = sam.parameters.length; i < length; i++) {
					TypeBinding argumentType = copy.arguments[i].binding.type;
					if (sam.parameters[i] != argumentType)
						return false;
				}
			}

			if (this.returnExpressionsTally > 0) {
				final TypeBinding returnType = sam.returnType;
				if (this.resultExpressions == null)
					this.resultExpressions = new SimpleLookupTable(); // gather for more specific analysis later.
				if (this.body instanceof Block) {
					ASTVisitor visitor = new ASTVisitor() {
						Expression [] returnExpressions = new Expression[LambdaExpression.this.returnExpressionsTally];
						int returnExpressionsCount = 0;
						public boolean visit(ReturnStatement returnStatement, BlockScope blockScope) {
							Expression expression = returnStatement.expression;
							if (expression != null && !expression.isAssignmentCompatible(returnType, blockScope))
								throw new IncongruentLambdaException();
							this.returnExpressions[this.returnExpressionsCount++] = expression;
							return false; // should not analyze any lambda returns.m
						}
						public void endVisit(Block block, BlockScope blockScope) {
							if (block == copy.body)
								LambdaExpression.this.resultExpressions.put(left, this.returnExpressions);
						}
					};
					copy.body.traverse(visitor, copy.scope);
				} else if (this.body instanceof Expression){
					Expression expression = (Expression) copy.body;
					if (!expression.isAssignmentCompatible(returnType, copy.scope))
						throw new IncongruentLambdaException();
					this.resultExpressions.put(left, new Expression [] { expression });
				}
			}
		} catch (IncongruentLambdaException e) {
			return false;
		} finally {
			this.scope.problemReporter().switchErrorHandlingPolicy(oldPolicy);
		}
		return true;
	}

