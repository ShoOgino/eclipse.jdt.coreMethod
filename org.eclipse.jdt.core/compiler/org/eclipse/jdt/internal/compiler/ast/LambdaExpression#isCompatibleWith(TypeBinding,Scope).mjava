	public boolean isCompatibleWith(TypeBinding targetType, final Scope skope) {
		
		if (!super.isPertinentToApplicability(targetType, null))
			return true;
		
		LambdaExpression copy = null;
		try {
			copy = cachedResolvedCopy(targetType, argumentsTypeElided()); // if argument types are elided, we don't care for result expressions against *this* target, any port in a storm is ok.
		} catch (CopyFailureException cfe) {
			if (this.assistNode)
				return true; // can't type check result expressions, just say yes.
			return !isPertinentToApplicability(targetType, null); // don't expect to hit this ever.
		}
		if (copy == null)
			return false;
		
		IErrorHandlingPolicy oldPolicy = this.enclosingScope.problemReporter().switchErrorHandlingPolicy(silentErrorHandlingPolicy);
		final CompilerOptions compilerOptions = this.enclosingScope.compilerOptions();
		boolean analyzeNPE = compilerOptions.isAnnotationBasedNullAnalysisEnabled;
		compilerOptions.isAnnotationBasedNullAnalysisEnabled = false;
		try {
			/* At this point, shape analysis is complete for ((see returnsExpression(...))
			       - a lambda with an expression body,
				   - a lambda with a block body in which we saw a return statement naked or otherwise.
			*/
			if (copy.body instanceof Block && !copy.returnsVoid && !copy.returnsValue && !copy.valueCompatible) {
				// Do not proceed with data/control flow analysis if resolve encountered errors.
				if (copy.hasIgnoredMandatoryErrors || enclosingScopesHaveErrors()) {
					if (isPertinentToApplicability(targetType, null))
						if (copy.arguments.length != 0) // ?? Needs check. 
							return false;
				} else {
					copy.valueCompatible = copy.doesNotCompleteNormally();
				}
			}
		} finally {
			compilerOptions.isAnnotationBasedNullAnalysisEnabled = analyzeNPE;
			this.enclosingScope.problemReporter().switchErrorHandlingPolicy(oldPolicy);
		}

		targetType = findGroundTargetType(this.enclosingScope, targetType, argumentsTypeElided());
		MethodBinding sam = targetType.getSingleAbstractMethod(this.enclosingScope, true);
		if (sam.returnType.id == TypeIds.T_void) {
			if (!copy.voidCompatible)
				return false;
		} else {
			if (!copy.valueCompatible)
				return false;
		}

		if (!isPertinentToApplicability(targetType, null))
			return true;

		Expression [] returnExpressions = copy.resultExpressions;
		for (int i = 0, length = returnExpressions.length; i < length; i++) {
			if (this.enclosingScope.parameterCompatibilityLevel(returnExpressions[i].resolvedType, sam.returnType) == Scope.NOT_COMPATIBLE) {
				if (!returnExpressions[i].isConstantValueOfTypeAssignableToType(returnExpressions[i].resolvedType, sam.returnType))
					if (sam.returnType.id != TypeIds.T_void || this.body instanceof Block)
						return false;
			}
		}
		return true;
	}

