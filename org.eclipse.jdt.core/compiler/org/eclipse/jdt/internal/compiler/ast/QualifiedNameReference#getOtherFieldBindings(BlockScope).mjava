	public TypeBinding getOtherFieldBindings(BlockScope scope) {
		// At this point restrictiveFlag may ONLY have two potential value : FIELD LOCAL (i.e cast <<(VariableBinding) binding>> is valid)
		if ((bits & FIELD) != 0) {
			if (!((FieldBinding) binding).isStatic()) {
				//must check for the static status....
				if (indexOfFirstFieldBinding == 1) {
					//the field is the first token of the qualified reference....
					if (scope.methodScope().isStatic) {
						scope.problemReporter().staticFieldAccessToNonStaticVariable(
							this,
							(FieldBinding) binding);
						return null;
					}
				} else { //accessing to a field using a type as "receiver" is allowed only with static field	
					scope.problemReporter().staticFieldAccessToNonStaticVariable(
						this,
						(FieldBinding) binding);
					return null;
				}
			}
			if (isFieldUseDeprecated((FieldBinding) binding, scope))
				scope.problemReporter().deprecatedField((FieldBinding) binding, this);
		}
		TypeBinding type = ((VariableBinding) binding).type;
		int index = indexOfFirstFieldBinding;
		int length = tokens.length;
		if (index == length) { //	restrictiveFlag == FIELD
			this.constant = FieldReference.getConstantFor((FieldBinding) binding, this, false, scope);
			return type;
		}
		// allocation of the fieldBindings array	and its respective constants
		int otherBindingsLength = length - index;
		otherCodegenBindings = otherBindings = new FieldBinding[otherBindingsLength];
		otherDepths = new int[otherBindingsLength];
		
		// fill the first constant (the one of the binding)
		this.constant =
			((bits & FIELD) != 0)
				? FieldReference.getConstantFor((FieldBinding) binding, this, false, scope)
				: ((VariableBinding) binding).constant;
		// save first depth, since will be updated by visibility checks of other bindings
		int firstDepth = (bits & DepthMASK) >> DepthSHIFT;
		// iteration on each field	
		while (index < length) {
			char[] token = tokens[index];
			if (type == null)
				return null; // could not resolve type prior to this point

			bits &= ~DepthMASK; // flush previous depth if any			
			FieldBinding field = scope.getField(type, token, this);
			int place = index - indexOfFirstFieldBinding;
			otherBindings[place] = field;
			otherDepths[place] = (bits & DepthMASK) >> DepthSHIFT;
			if (field.isValidBinding()) {
				if (isFieldUseDeprecated(field, scope))
					scope.problemReporter().deprecatedField(field, this);
				Constant someConstant = FieldReference.getConstantFor(field, this, false, scope);
				// constant propagation can only be performed as long as the previous one is a constant too.
				if (this.constant != NotAConstant) {
					this.constant = someConstant;					
				}

				type = field.type;
				index++;
				
				if (field.isStatic()) {
					// static field accessed through receiver? legal but unoptimal (optional warning)
					scope.problemReporter().unnecessaryReceiverForStaticField(this, field);
				}
				
			} else {
				constant = NotAConstant; //don't fill other constants slots...
				scope.problemReporter().invalidField(this, field, index, type);
				setDepth(firstDepth);
				return null;
			}
		}
		setDepth(firstDepth);
		return (otherBindings[otherBindingsLength - 1]).type;
	}

