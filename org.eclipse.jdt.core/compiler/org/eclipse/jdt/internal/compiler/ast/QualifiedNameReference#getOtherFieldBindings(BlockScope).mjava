	public TypeBinding getOtherFieldBindings(BlockScope scope) {

		// At this point restrictiveFlag may ONLY have two potential value : FIELD LOCAL (i.e cast <<(VariableBinding) binding>> is valid)
		if ((bits & FIELD) != 0) {
			if (!((FieldBinding) binding).isStatic()) {
				//must check for the static status....
				if (indexOfFirstFieldBinding == 1) {
					//the field is the first token of the qualified reference....
					if (scope.methodScope().isStatic) {
						scope.problemReporter().staticFieldAccessToNonStaticVariable(
							this,
							(FieldBinding) binding);
						return null;
					}
				} else { //accessing to a field using a type as "receiver" is allowed only with static field	
					scope.problemReporter().staticFieldAccessToNonStaticVariable(
						this,
						(FieldBinding) binding);
					return null;
				}
			}
			if (isFieldUseDeprecated((FieldBinding) binding, scope))
				scope.problemReporter().deprecatedField((FieldBinding) binding, this);

			// if the binding declaring class is not visible, need special action
			// for runtime compatibility on 1.2 VMs : change the declaring class of the binding
			// NOTE: from 1.4 on, field's declaring class is touched if any different from receiver type
			FieldBinding fieldBinding = (FieldBinding) binding;
			if (fieldBinding.declaringClass != this.actualReceiverType
				&& !this.actualReceiverType.isArrayType()			
				&& fieldBinding.declaringClass != null
				&& fieldBinding.constant == NotAConstant
				&& ((scope.environment().options.complianceLevel >= CompilerOptions.JDK1_4
						&& (indexOfFirstFieldBinding > 1 || !fieldBinding.isStatic()))
					|| !fieldBinding.declaringClass.canBeSeenBy(scope))){
				binding = new FieldBinding(fieldBinding, (ReferenceBinding)this.actualReceiverType);
			}
		}

		TypeBinding type = ((VariableBinding) binding).type;
		int index = indexOfFirstFieldBinding;
		int length = tokens.length;
		if (index == length) { //	restrictiveFlag == FIELD
			constant =
				FieldReference.getConstantFor((FieldBinding) binding, false, this, index - 1);
			return type;
		}

		// allocation of the fieldBindings array	and its respective constants
		int otherBindingsLength = length - index;
		otherBindings = new FieldBinding[otherBindingsLength];
		otherDepths = new int[otherBindingsLength];
		
		// fill the first constant (the one of the binding)
		constant =
			((bits & FIELD) != 0)
				? FieldReference.getConstantFor((FieldBinding) binding, false, this, index - 1)
				: ((VariableBinding) binding).constant;
		// save first depth, since will be updated by visibility checks of other bindings
		int firstDepth = (bits & DepthMASK) >> DepthSHIFT;

		// iteration on each field	
		while (index < length) {
			char[] token = tokens[index];
			if (type == null)
				return null; // could not resolve type prior to this point
			FieldBinding field = scope.getField(type, token, this);
			int place = index - indexOfFirstFieldBinding;
			otherBindings[place] = field;
			otherDepths[place] = (bits & DepthMASK) >> DepthSHIFT;
			if (field.isValidBinding()) {
				if (isFieldUseDeprecated(field, scope))
					scope.problemReporter().deprecatedField(field, this);
				Constant someConstant =
					FieldReference.getConstantFor(field, false, this, place);
				// constant propagation can only be performed as long as the previous one is a constant too.
				if (constant != NotAConstant) {
					constant = someConstant;
				}
				
				// if the binding declaring class is not visible, need special action
				// for runtime compatibility on 1.2 VMs : change the declaring class of the binding
				// NOTE: from 1.4 on, field's declaring class is touched if any different from receiver type
				if (field.declaringClass != type
					&& !this.actualReceiverType.isArrayType()				
					&& field.declaringClass != null // array.length
					&& field.constant == NotAConstant
					&& (scope.environment().options.complianceLevel >= CompilerOptions.JDK1_4
						|| !field.declaringClass.canBeSeenBy(scope))){
					otherBindings[place] = new FieldBinding(field, (ReferenceBinding) type);
				}
				type = field.type;
				index++;
			} else {
				constant = NotAConstant; //don't fill other constants slots...
				scope.problemReporter().invalidField(this, field, index, type);
				setDepth(firstDepth);
				return null;
			}
		}
		setDepth(firstDepth);
		return (otherBindings[otherBindingsLength - 1]).type;
	}

