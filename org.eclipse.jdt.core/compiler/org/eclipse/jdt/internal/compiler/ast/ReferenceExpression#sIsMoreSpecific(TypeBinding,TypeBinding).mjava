	public boolean sIsMoreSpecific(TypeBinding s, TypeBinding t) {
		/* 15.12.2.5 t is more specific than s iff ... Some of the checks here are redundant by the very fact of control reaching here, 
		   but have been left in for completeness/documentation sakes. These should be cheap anyways. 
		*/
		
		// Both t and s are functional interface types ... 
		MethodBinding sSam = s.getSingleAbstractMethod(this.enclosingScope);
		if (sSam == null || !sSam.isValidBinding())
			return false;
		MethodBinding tSam = t.getSingleAbstractMethod(this.enclosingScope);
		if (tSam == null || !tSam.isValidBinding())
			return false;
		
		// t should neither be a subinterface nor a superinterface of s
		if (s.findSuperTypeOriginatingFrom(t) != null || t.findSuperTypeOriginatingFrom(s) != null)
			return false;

		// The descriptor parameter types of t are the same as the descriptor parameter types of s.
		if (sSam.parameters.length != tSam.parameters.length)
			return false;
		for (int i = 0, length = sSam.parameters.length; i < length; i++) {
			if (TypeBinding.notEquals(sSam.parameters[i], tSam.parameters[i]))
				return false;
		}
		
		// Either the descriptor return type of s is void or ...
		if (tSam.returnType.id == TypeIds.T_void)
			return true;
		
		return true;
		
		/* ... or the descriptor return type of the capture of T is more specific than the descriptor return type of S for 
		   an invocation expression of the same form as the method reference..
		*/
	//	Expression resultExpression = (Expression) this.resultExpressions.get(s); // should be same as for s
		
//		s = s.capture(this.enclosingScope, this.sourceEnd);
//		sSam = s.getSingleAbstractMethod(this.enclosingScope);
//		return resultExpression.sIsMoreSpecific(sSam.returnType, tSam.returnType);
	}

