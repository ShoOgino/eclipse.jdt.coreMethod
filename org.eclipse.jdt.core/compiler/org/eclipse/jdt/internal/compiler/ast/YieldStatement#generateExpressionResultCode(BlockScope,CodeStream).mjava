@Override
protected void generateExpressionResultCode(BlockScope currentScope, CodeStream codeStream) {
	SwitchExpression se = this.switchExpression;
	if (se != null && se.containsTry && se.resolvedType != null ) {
		addSecretYieldResultValue(this.scope);
		assert this.secretYieldResultValue != null;
		codeStream.record(this.secretYieldResultValue);
		SingleNameReference lhs = new SingleNameReference(this.secretYieldResultValue.name, 0);
		lhs.binding = this.secretYieldResultValue;
		lhs.bits &= ~ASTNode.RestrictiveFlagMASK;  // clear bits
		lhs.bits |= Binding.LOCAL;
		lhs.bits |= ASTNode.IsSecretYieldValueUsage;
		((LocalVariableBinding) lhs.binding).markReferenced(); // TODO : Can be skipped?
		Assignment assignment = new Assignment(lhs, this.expression, 0);
		assignment.generateCode(this.scope, codeStream);
		int l = this.subroutines == null ? 0 : this.subroutines.length;
		boolean foundFinally = false;
		if (l > 0) {
			for (int i = 0; i < l; ++i) {
				SubRoutineStatement srs = this.subroutines[i];
				srs.exitAnyExceptionHandler();
				srs.exitDeclaredExceptionHandlers(codeStream);
				if (srs instanceof TryStatement) {
					TryStatement ts = (TryStatement) srs;
					if (ts.finallyBlock != null) {
						foundFinally = true;
					}
				}
			}
		}
		if (!foundFinally) {
			 // no finally - TODO: Check for SynSta?
			se.loadStoredTypesAndKeep(codeStream);
			codeStream.load(this.secretYieldResultValue);
		}
		codeStream.removeVariable(this.secretYieldResultValue);
	} else {
		this.expression.generateCode(this.scope, codeStream, se != null);
	}
}

