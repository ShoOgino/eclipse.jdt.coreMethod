public void manageEnclosingInstanceAccessIfNecessary(BlockScope currentScope) {
	//If inlinable field, forget the access emulation, the code gen will directly target it
	if (((bits & DepthMASK) == 0) || (constant != NotAConstant)) {
		return;
	}
	switch (bits & RestrictiveFlagMASK) {
		case FIELD :
			FieldBinding fieldBinding;
			if ((fieldBinding = (FieldBinding)binding).isStatic() || (fieldBinding.constant != NotAConstant)) return;		
			ReferenceBinding compatibleType = currentScope.enclosingSourceType();
			// the declaringClass of the target binding must be compatible with the enclosing
			// type at <depth> levels outside
			for (int i = 0, depth = (bits & DepthMASK) >> DepthSHIFT; i < depth; i++) {
				compatibleType = compatibleType.enclosingType();
			}
			currentScope.emulateOuterAccess(compatibleType, false); // request cascade of accesses
			break;
		case LOCAL :
			currentScope.emulateOuterAccess((LocalVariableBinding) binding);
	}
}

