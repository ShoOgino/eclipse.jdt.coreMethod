public TypeBinding resolveType(BlockScope scope) {
	// Answer the signature type of the field.
	// constants are propaged when the field is final
	// and initialized with a (compile time) constant 

	// regular receiver reference 
	this.receiverType = receiver.resolveType(scope);
	if (this.receiverType == null){
		constant = NotAConstant;
		return null;
	}
	// the case receiverType.isArrayType and token = 'length' is handled by the scope API
	binding = scope.getField(this.receiverType, token, this);
	if (!binding.isValidBinding()) {
		constant = NotAConstant;
		scope.problemReporter().invalidField(this, this.receiverType);
		return null;
	}

	if (isFieldUseDeprecated(binding, scope))
		scope.problemReporter().deprecatedField(binding, this);

	// check for this.x in static is done in the resolution of the receiver
	constant = FieldReference.getConstantFor(binding, receiver == ThisReference.ThisImplicit, this, 0);
	if (!receiver.isThis())
		constant = NotAConstant;

	// if the binding declaring class is not visible, need special action
	// for runtime compatibility on 1.2 VMs : change the declaring class of the binding
	// NOTE: from 1.4 on, field's declaring class is touched if any different from receiver type
	if (binding.declaringClass != this.receiverType
		&& !this.receiverType.isArrayType()
		&& binding.declaringClass != null // array.length
		&& binding.constant == NotAConstant
		&& (scope.environment().options.complianceLevel >= CompilerOptions.JDK1_4
			|| !binding.declaringClass.canBeSeenBy(scope))){
			binding = new FieldBinding(binding, (ReferenceBinding) this.receiverType);
	}
	return binding.type;
}

