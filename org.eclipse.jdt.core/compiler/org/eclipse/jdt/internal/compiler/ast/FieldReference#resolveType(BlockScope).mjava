	public TypeBinding resolveType(BlockScope scope) {

		// Answer the signature type of the field.
		// constants are propaged when the field is final
		// and initialized with a (compile time) constant 

		//always ignore receiver cast, since may affect constant pool reference
		boolean receiverCast = false;
		if (this.receiver instanceof CastExpression) {
			this.receiver.bits |= DisableUnnecessaryCastCheck; // will check later on
			receiverCast = true;
		}
		this.receiverType = receiver.resolveType(scope);
		if (this.receiverType == null) {
			constant = NotAConstant;
			return null;
		}
		if (receiverCast) {
			 // due to change of declaring class with receiver type, only identity cast should be notified
			if (((CastExpression)this.receiver).expression.resolvedType == this.receiverType) { 
						scope.problemReporter().unnecessaryCast((CastExpression)this.receiver);		
			}
		}		
		// the case receiverType.isArrayType and token = 'length' is handled by the scope API
		FieldBinding fieldBinding = this.codegenBinding = this.binding = scope.getField(this.receiverType, token, this);
		if (!fieldBinding.isValidBinding()) {
			constant = NotAConstant;
			scope.problemReporter().invalidField(this, this.receiverType);
			return null;
		}
		TypeBinding receiverErasure = this.receiverType.erasure();
		if (receiverErasure instanceof ReferenceBinding) {
			ReferenceBinding match = ((ReferenceBinding)receiverErasure).findSuperTypeWithSameErasure(fieldBinding.declaringClass);
			if (match == null) {
				this.receiverType = fieldBinding.declaringClass; // handle indirect inheritance thru variable secondary bound
			}
		}
		this.receiver.computeConversion(scope, this.receiverType, this.receiverType);
		if (isFieldUseDeprecated(fieldBinding, scope, (this.bits & IsStrictlyAssigned) !=0)) {
			scope.problemReporter().deprecatedField(fieldBinding, this);
		}
		boolean isImplicitThisRcv = receiver.isImplicitThis();
		constant = FieldReference.getConstantFor(fieldBinding, this, isImplicitThisRcv, scope);
		if (!isImplicitThisRcv) {
			constant = NotAConstant;
		}
		if (fieldBinding.isStatic()) {
			// static field accessed through receiver? legal but unoptimal (optional warning)
			if (!(isImplicitThisRcv
					|| (receiver instanceof NameReference 
						&& (((NameReference) receiver).bits & Binding.TYPE) != 0))) {
				scope.problemReporter().nonStaticAccessToStaticField(this, fieldBinding);
			}
			if (!isImplicitThisRcv && fieldBinding.declaringClass != receiverType) {
				scope.problemReporter().indirectAccessToStaticField(this, fieldBinding);
			}
		}
		// perform capture conversion if read access
		return this.resolvedType = 
			(((this.bits & IsStrictlyAssigned) == 0) 
				? fieldBinding.type.capture(scope, this.sourceEnd)
				: fieldBinding.type);
	}

