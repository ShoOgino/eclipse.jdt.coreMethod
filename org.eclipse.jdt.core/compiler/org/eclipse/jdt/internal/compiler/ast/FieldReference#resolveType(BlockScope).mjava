	public TypeBinding resolveType(BlockScope scope) {

		// Answer the signature type of the field.
		// constants are propaged when the field is final
		// and initialized with a (compile time) constant 

		// regular receiver reference 
		this.receiverType = receiver.resolveType(scope);
		if (this.receiverType == null) {
			constant = NotAConstant;
			return null;
		}
		// the case receiverType.isArrayType and token = 'length' is handled by the scope API
		this.codegenBinding =
			this.binding = scope.getField(this.receiverType, token, this);
		if (!binding.isValidBinding()) {
			constant = NotAConstant;
			scope.problemReporter().invalidField(this, this.receiverType);
			return null;
		}

		if (isFieldUseDeprecated(binding, scope))
			scope.problemReporter().deprecatedField(binding, this);

		// check for this.x in static is done in the resolution of the receiver
		constant =
			FieldReference.getConstantFor(
				binding,
				receiver == ThisReference.ThisImplicit,
				this,
				scope,
				0);
		if (receiver != ThisReference.ThisImplicit)
			constant = NotAConstant;

		if (binding.isStatic()) {
			// static field accessed through receiver? legal but unoptimal (optional warning)
			if (!(receiver == ThisReference.ThisImplicit
					|| receiver.isSuper()
					|| (receiver instanceof NameReference 
						&& (((NameReference) receiver).bits & BindingIds.TYPE) != 0))) {
				scope.problemReporter().unnecessaryReceiverForStaticField(this, binding);
			}
		}
		return this.resolvedType = binding.type;
	}

