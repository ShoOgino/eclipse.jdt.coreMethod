	public void createImplicitAccessors(ProblemReporter problemReporter) {
		// JLS 14 8.10.3 Item 2 create the accessors for the fields if required
		/* 
		 * An implicitly declared public accessor method with the same name as the record component,
		 * whose return type is the declared type of the record component,
		 * unless a public method with the same signature is explicitly declared in the body of the declaration of R. 
		 */

		if (this.fields == null)
			return;
		Map<String, Set<AbstractMethodDeclaration>> accessors = new HashMap<>();
		for (int i = 0; i < this.nRecordComponents; i++) {
			FieldDeclaration f = this.fields[i] ;
			if (f != null && f.name != null && f.name.length > 0) {
				accessors.put(new String(f.name), new HashSet<>());
			}
		}
		if (this.methods != null) {
			for (int i = 0; i < this.methods.length; i++) {
				AbstractMethodDeclaration m = this.methods[i]; 
				if (m != null && m.selector != null & m.selector.length > 0) {
					String name1 = new String(m.selector);
					Set<AbstractMethodDeclaration> acc = accessors.get(name1);
					if (acc != null)
						acc.add(m);
				}
			}
		}
		for (int i = this.nRecordComponents - 1; i >= 0; i--) {
			FieldDeclaration f = this.fields[i] ;
			if (f != null && f.name != null && f.name.length > 0) {
				String name1 = new String(f.name);
				Set<AbstractMethodDeclaration> acc = accessors.get(name1);
				MethodDeclaration m = null;
				if (acc.size() > 0) {
					for (AbstractMethodDeclaration amd : acc) {
						m = (MethodDeclaration) amd;
						/* JLS 14 Sec 8.10.3 Item 1, Subitem 2
						 * An implicitly declared public accessor method with the same name as the record component, whose return
						 * type is the declared type of the record component, unless a public method with the same signature is
						 * explicitly declared in the body of the declaration of R
						 */
						// Here the assumption is method signature implies the method signature in source ie the return type
						// is not being considered - Given this, type resolution is not required and hence its a simple name and
						// parameter number check.
						if (m.arguments == null || m.arguments.length == 0) {
							// found the explicitly declared accessor.
							/*
							 *  JLS 14 Sec 8.10.3 Item 1 Sub-item 2 Para 3
							 *  It is a compile-time error if an explicitly declared accessor method has a throws clause.
							 */
							if (m.thrownExceptions != null && m.thrownExceptions.length > 0)
								problemReporter.recordAccessorMethodHasThrowsClause(m);
							break; // found
						}
						m = null;
					}
				}
				if (m == null) // no explicit accessor method found - declare one.
					createNewMethod(f);
			}
		}
	}

