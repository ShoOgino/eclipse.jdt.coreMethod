	public void generateCode(BlockScope currentScope, CodeStream codeStream, boolean valueRequired) {
		int pc = codeStream.position;
		if (constant != Constant.NotAConstant) {
			if (valueRequired) {
				codeStream.generateConstant(constant, implicitConversion);
			}
			codeStream.recordPositionsFrom(pc, this.sourceStart);
			return;
		} else {
			switch (bits & RestrictiveFlagMASK) {
				case Binding.FIELD : // reading a field
					FieldBinding fieldBinding = (FieldBinding) this.codegenBinding;
					Constant fieldConstant = fieldBinding.constant();
					if (fieldConstant != Constant.NotAConstant) {
						// directly use inlined value for constant fields
						if (valueRequired) {
							codeStream.generateConstant(fieldConstant, implicitConversion);
						}
						codeStream.recordPositionsFrom(pc, this.sourceStart);
						return;
					}
					if (fieldBinding.isStatic()) {
						if (!valueRequired
							// if no valueRequired, still need possible side-effects of <clinit> invocation, if field belongs to different class
							&& ((FieldBinding)binding).original().declaringClass == this.actualReceiverType.erasure()
							&& ((implicitConversion & TypeIds.UNBOXING) == 0)
							&& this.genericCast == null) {
							// if no valueRequired, optimize out entire gen
							codeStream.recordPositionsFrom(pc, this.sourceStart);
							return;
						}
						// managing private access							
						if ((syntheticAccessors == null) || (syntheticAccessors[READ] == null)) {
							codeStream.getstatic(fieldBinding);
						} else {
							codeStream.invokestatic(syntheticAccessors[READ]);
						}
					} else {
						if (!valueRequired
								&& (implicitConversion & TypeIds.UNBOXING) == 0 
								&& this.genericCast == null) {
							// if no valueRequired, optimize out entire gen
							codeStream.recordPositionsFrom(pc, this.sourceStart);
							return;
						}
						// managing enclosing instance access
						if ((bits & DepthMASK) != 0) {
							ReferenceBinding targetType = currentScope.enclosingSourceType().enclosingTypeAt((bits & DepthMASK) >> DepthSHIFT);
							Object[] emulationPath = currentScope.getEmulationPath(targetType, true /*only exact match*/, false/*consider enclosing arg*/);
							codeStream.generateOuterAccess(emulationPath, this, targetType, currentScope);
						} else {
							generateReceiver(codeStream);
						}
						// managing private access							
						if ((syntheticAccessors == null) || (syntheticAccessors[READ] == null)) {
							codeStream.getfield(fieldBinding);
						} else {
							codeStream.invokestatic(syntheticAccessors[READ]);
						}
					}
					break;
				case Binding.LOCAL : // reading a local
					LocalVariableBinding localBinding = (LocalVariableBinding) this.codegenBinding;
					if (!valueRequired && (implicitConversion & TypeIds.UNBOXING) == 0) {
						// if no valueRequired, optimize out entire gen
						codeStream.recordPositionsFrom(pc, this.sourceStart);
						return;
					}
					// outer local?
					if ((bits & DepthMASK) != 0) {
						// outer local can be reached either through a synthetic arg or a synthetic field
						VariableBinding[] path = currentScope.getEmulationPath(localBinding);
						codeStream.generateOuterAccess(path, this, localBinding, currentScope);
					} else {
						// regular local variable read
						codeStream.load(localBinding);
					}
					break;
				default: // type
					codeStream.recordPositionsFrom(pc, this.sourceStart);
					return;					
			}
		}
		// required cast must occur even if no value is required
		if (this.genericCast != null) codeStream.checkcast(this.genericCast);
		if (valueRequired) {
			codeStream.generateImplicitConversion(implicitConversion);
		} else {
			boolean isUnboxing = (implicitConversion & TypeIds.UNBOXING) != 0;
			// conversion only generated if unboxing
			if (isUnboxing) codeStream.generateImplicitConversion(implicitConversion);
			switch (isUnboxing ? postConversionType(currentScope).id : this.resolvedType.id) {
				case T_long :
				case T_double :
					codeStream.pop2();
					break;
				default :
					codeStream.pop();
			}
		}							
		codeStream.recordPositionsFrom(pc, this.sourceStart);
	}

