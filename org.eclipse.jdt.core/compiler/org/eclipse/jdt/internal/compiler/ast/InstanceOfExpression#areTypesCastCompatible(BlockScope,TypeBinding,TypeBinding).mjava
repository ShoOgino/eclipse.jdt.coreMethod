	public final boolean areTypesCastCompatible(
		BlockScope scope,
		TypeBinding castType,
		TypeBinding expressionType) {

		//	see specifications p.68
		//A more cpmplete version of this method is provided on
		//CastExpression (it deals with constant and need runtime checkcast)

		if (castType == expressionType) return true;
		
		//by grammatical construction, the first test is ALWAYS false
		//if (castTb.isBaseType())
		//{	if (expressionTb.isBaseType())
		//	{	if (expression.isConstantValueOfTypeAssignableToType(expressionTb,castTb))
		//		{	return true;}
		//		else
		//		{	if (expressionTb==castTb)
		//			{	return true;}
		//			else 
		//			{	if (scope.areTypesCompatible(expressionTb,castTb))
		//				{	return true; }
		//				
		//				if (BaseTypeBinding.isNarrowing(castTb.id,expressionTb.id))
		//				{	return true;}
		//				return false;}}}
		//	else
		//	{	return false; }}
		//else
		{ //-------------checkcast to something which is NOT a basetype----------------------------------	

			//null is compatible with every thing .... 
			if (NullBinding == expressionType) {
				return true;
			}
			if (expressionType.isArrayType()) {
				if (castType.isArrayType()) {
					//------- (castTb.isArray) expressionTb.isArray -----------
					TypeBinding expressionEltTb = ((ArrayBinding) expressionType).elementsType(scope);
					if (expressionEltTb.isBaseType())
						// <---stop the recursion------- 
						return ((ArrayBinding) castType).elementsType(scope) == expressionEltTb;
					//recursivly on the elts...
					return areTypesCastCompatible(
						scope,
						((ArrayBinding) castType).elementsType(scope),
						expressionEltTb);
				}
				if (castType.isClass()) {
					//------(castTb.isClass) expressionTb.isArray ---------------	
					if (scope.isJavaLangObject(castType))
						return true;
					return false;
				}
				if (castType.isInterface()) {
					//------- (castTb.isInterface) expressionTb.isArray -----------
					if (scope.isJavaLangCloneable(castType) || scope.isJavaIoSerializable(castType)) {
						return true;
					}
					return false;
				}

				return false;
			}
			if (expressionType.isBaseType()) {
				return false;
			}
			if (expressionType.isClass()) {
				if (castType.isArrayType()) {
					// ---- (castTb.isArray) expressionTb.isClass -------
					if (scope.isJavaLangObject(expressionType)) {
						return true;
					} else {
						return false;
					}
				}
				if (castType.isClass()) { // ----- (castTb.isClass) expressionTb.isClass ------ 
					if (expressionType.isCompatibleWith(castType))
						return true;
					else {
						if (castType.isCompatibleWith(expressionType)) {
							return true;
						}
						return false;
					}
				}
				if (castType.isInterface()) {
					// ----- (castTb.isInterface) expressionTb.isClass -------  
					if (((ReferenceBinding) expressionType).isFinal()) {
						//no subclass for expressionTb, thus compile-time check is valid
						if (expressionType.isCompatibleWith(castType))
							return true;
						return false;
					} else {
						return true;
					}
				}

				return false;
			}
			if (expressionType.isInterface()) {
				if (castType.isArrayType()) {
					// ----- (castTb.isArray) expressionTb.isInterface ------
					if (scope.isJavaLangCloneable(expressionType)
						|| scope.isJavaIoSerializable(expressionType))
						//potential runtime error
						{
						return true;
					}
					return false;
				}
				if (castType.isClass()) {
					// ----- (castTb.isClass) expressionTb.isInterface --------
					if (scope.isJavaLangObject(castType))
						return true;
					if (((ReferenceBinding) castType).isFinal()) {
						//no subclass for castTb, thus compile-time check is valid
						if (castType.isCompatibleWith(expressionType)) {
							return true;
						}
						return false;
					}
					return true;
				}
				if (castType.isInterface()) {
					// ----- (castTb.isInterface) expressionTb.isInterface -------
					if ((Scope.compareTypes(castType, expressionType) == NotRelated)) {
						MethodBinding[] castTbMethods = ((ReferenceBinding) castType).methods();
						int castTbMethodsLength = castTbMethods.length;
						MethodBinding[] expressionTbMethods =
							((ReferenceBinding) expressionType).methods();
						int expressionTbMethodsLength = expressionTbMethods.length;
						for (int i = 0; i < castTbMethodsLength; i++) {
							for (int j = 0; j < expressionTbMethodsLength; j++) {
								if (castTbMethods[i].selector == expressionTbMethods[j].selector) {
									if (castTbMethods[i].returnType != expressionTbMethods[j].returnType) {
										if (castTbMethods[i].areParametersEqual(expressionTbMethods[j])) {
											return false;
										}
									}
								}
							}
						}
					}
					return true;
				}

				return false;
			} 

			return false;
		}
	}

