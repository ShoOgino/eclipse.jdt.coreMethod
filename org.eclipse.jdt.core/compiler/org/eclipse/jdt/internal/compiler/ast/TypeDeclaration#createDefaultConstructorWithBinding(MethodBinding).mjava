// anonymous type constructor creation
public MethodBinding createDefaultConstructorWithBinding(MethodBinding inheritedConstructorBinding) {
	//Add to method'set, the default constuctor that just recall the
	//super constructor with the same arguments
	String baseName = "$anonymous"; //$NON-NLS-1$
	TypeBinding[] argumentTypes = inheritedConstructorBinding.parameters;
	int argumentsLength = argumentTypes.length;
	//the constructor
	ConstructorDeclaration cd = new ConstructorDeclaration(this.compilationResult);
	cd.selector = new char[] { 'x' }; //no maining
	cd.sourceStart = this.sourceStart;
	cd.sourceEnd = this.sourceEnd;
	int newModifiers = this.modifiers & ExtraCompilerModifiers.AccVisibilityMASK;
	if (inheritedConstructorBinding.isVarargs()) {
		newModifiers |= ClassFileConstants.AccVarargs;
	}
	cd.modifiers = newModifiers;
	cd.isDefaultConstructor = true;

	if (argumentsLength > 0) {
		Argument[] arguments = (cd.arguments = new Argument[argumentsLength]);
		for (int i = argumentsLength; --i >= 0;) {
			arguments[i] = new Argument((baseName + i).toCharArray(), 0L, null /*type ref*/, ClassFileConstants.AccDefault);
		}
	}
	//the super call inside the constructor
	cd.constructorCall = SuperReference.implicitSuperConstructorCall();
	cd.constructorCall.sourceStart = this.sourceStart;
	cd.constructorCall.sourceEnd = this.sourceEnd;

	if (argumentsLength > 0) {
		Expression[] args;
		args = cd.constructorCall.arguments = new Expression[argumentsLength];
		for (int i = argumentsLength; --i >= 0;) {
			args[i] = new SingleNameReference((baseName + i).toCharArray(), 0L);
		}
	}

	//adding the constructor in the methods list
	if (this.methods == null) {
		this.methods = new AbstractMethodDeclaration[] { cd };
	} else {
		AbstractMethodDeclaration[] newMethods;
		System.arraycopy(
			this.methods,
			0,
			newMethods = new AbstractMethodDeclaration[this.methods.length + 1],
			1,
			this.methods.length);
		newMethods[0] = cd;
		this.methods = newMethods;
	}

	//============BINDING UPDATE==========================
	cd.binding = new MethodBinding(
			cd.modifiers, //methodDeclaration
			argumentsLength == 0 ? Binding.NO_PARAMETERS : argumentTypes, //arguments bindings
			inheritedConstructorBinding.thrownExceptions, //exceptions
			this.binding); //declaringClass
			
	cd.scope = new MethodScope(this.scope, cd, true);
	cd.bindArguments();
	cd.constructorCall.resolve(cd.scope);

	if (this.binding.methods == null) {
		this.binding.methods = new MethodBinding[] { cd.binding };
	} else {
		MethodBinding[] newMethods;
		System.arraycopy(
			this.binding.methods,
			0,
			newMethods = new MethodBinding[this.binding.methods.length + 1],
			1,
			this.binding.methods.length);
		newMethods[0] = cd.binding;
		this.binding.methods = newMethods;
	}
	//===================================================

	return cd.binding;
}

