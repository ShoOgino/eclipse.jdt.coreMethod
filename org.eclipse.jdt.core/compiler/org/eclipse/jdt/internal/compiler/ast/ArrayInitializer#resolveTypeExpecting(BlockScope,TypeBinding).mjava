public TypeBinding resolveTypeExpecting(BlockScope scope, TypeBinding expectedTb) {
	// Array initializers can only occur on the right hand side of an assignment
	// expression, therefore the expected type contains the valid information
	// concerning the type that must be enforced by the elements of the array initializer.

	// this method is recursive... (the test on isArrayType is the stop case)

	constant = NotAConstant;
	if (expectedTb.isArrayType()) {
		binding = (ArrayBinding) expectedTb;
		if (expressions == null)
			return binding;
		TypeBinding expectedElementsTb = binding.elementsType(scope);
		if (expectedElementsTb.isBaseType()) {
			for (int i = 0, length = expressions.length; i < length; i++) {
				Expression expression = expressions[i];
				TypeBinding expressionTb =
					(expression instanceof ArrayInitializer)
						? expression.resolveTypeExpecting(scope, expectedElementsTb)
						: expression.resolveType(scope);
				if (expressionTb == null)
					return null;

				// Compile-time conversion required?
				if (expression.isConstantValueOfTypeAssignableToType(expressionTb, expectedElementsTb)) {
					expression.implicitWidening(expectedElementsTb, expressionTb);
				} else if (BaseTypeBinding.isWidening(expectedElementsTb.id, expressionTb.id)) {
					expression.implicitWidening(expectedElementsTb, expressionTb);
				} else {
					scope.problemReporter().typeMismatchErrorActualTypeExpectedType(expression, expressionTb, expectedElementsTb);
					return null;
				}
			}
		} else {
			for (int i = 0, length = expressions.length; i < length; i++)
				if (expressions[i].resolveTypeExpecting(scope, expectedElementsTb) == null)
					return null;
		}
		return binding;
	}

	TypeBinding elementTb = (expressions == null) ? scope.getJavaLangObject() : expressions[0].resolveType(scope);
	if (elementTb != null) {
		TypeBinding probableTb = scope.createArray(elementTb, 1);
		scope.problemReporter().typeMismatchErrorActualTypeExpectedType(this, probableTb, expectedTb);
	}
	return null;
}

