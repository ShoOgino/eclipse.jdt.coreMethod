	/**
	 * Returns false if cast is not legal. 
	 */
	public final boolean checkCastTypesCompatibility(
		Scope scope,
		TypeBinding castType,
		TypeBinding expressionType,
		Expression expression) {
	
		// see specifications 5.5
		// handle errors and process constant when needed
	
		// if either one of the type is null ==>
		// some error has been already reported some where ==>
		// we then do not report an obvious-cascade-error.
	
		if (castType == null || expressionType == null) return true;
	
		// identity conversion cannot be performed upfront, due to side-effects
		// like constant propagation
		boolean use15specifics = scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5;
		if (castType.isBaseType()) {
			if (expressionType.isBaseType()) {
				if (expressionType == castType) {
					if (expression != null) {
						this.constant = expression.constant; //use the same constant
					}
					tagAsUnnecessaryCast(scope, castType);
					return true;
				}
				boolean necessary = false;
				if (expressionType.isCompatibleWith(castType)
						|| (necessary = BaseTypeBinding.isNarrowing(castType.id, expressionType.id))) {
					if (expression != null) {
						expression.implicitConversion = (castType.id << 4) + expressionType.id;
						if (expression.constant != Constant.NotAConstant) {
							constant = expression.constant.castTo(expression.implicitConversion);
						}
					}
					if (!necessary) tagAsUnnecessaryCast(scope, castType);
					return true;
					
				}
			} else if (use15specifics 
								&& scope.environment().computeBoxingType(expressionType).isCompatibleWith(castType)) { // unboxing - only widening match is allowed
				tagAsUnnecessaryCast(scope, castType);  
				return true;
			}
			return false;
		} else if (use15specifics 
							&& expressionType.isBaseType() 
							&& scope.environment().computeBoxingType(expressionType).isCompatibleWith(castType)) { // boxing - only widening match is allowed
			tagAsUnnecessaryCast(scope, castType);  
			return true;
		}
	
		switch(expressionType.kind()) {
			case Binding.BASE_TYPE :
				//-----------cast to something which is NOT a base type--------------------------	
				if (expressionType == TypeBinding.NULL) {
					tagAsUnnecessaryCast(scope, castType);
					return true; //null is compatible with every thing
				}
				return false;
				
			case Binding.ARRAY_TYPE :
				if (castType == expressionType) {
					tagAsUnnecessaryCast(scope, castType);
					return true; // identity conversion
				}
				switch (castType.kind()) {
					case Binding.ARRAY_TYPE : 
						// ( ARRAY ) ARRAY
						TypeBinding castElementType = ((ArrayBinding) castType).elementsType();
						TypeBinding exprElementType = ((ArrayBinding) expressionType).elementsType();
						if (exprElementType.isBaseType() || castElementType.isBaseType()) {
							if (castElementType == exprElementType) {
								tagAsNeedCheckCast();
								return true;
							} 
							return false;
						}
						// recurse on array type elements
						return checkCastTypesCompatibility(scope, castElementType, exprElementType, expression);
						
					case Binding.TYPE_PARAMETER : 
						// ( TYPE_PARAMETER ) ARRAY
						TypeBinding match = expressionType.findSuperTypeWithSameErasure(castType);
						if (match == null) {
							checkUnsafeCast(scope, castType, expressionType, match, true);
						}
						// recurse on the type variable upper bound
						return checkCastTypesCompatibility(scope, ((TypeVariableBinding)castType).upperBound(), expressionType, expression);
						
					default:
						// ( CLASS/INTERFACE ) ARRAY
						switch (castType.id) {
							case T_JavaLangCloneable :
							case T_JavaIoSerializable :
								tagAsNeedCheckCast();
								return true;
							case T_JavaLangObject :
								tagAsUnnecessaryCast(scope, castType);
								return true;
							default :
								return false;
						}
				}
						
			case Binding.TYPE_PARAMETER :
				TypeBinding match = expressionType.findSuperTypeWithSameErasure(castType);
				if (match != null) {
					return checkUnsafeCast(scope, castType, expressionType, match, false);
				}
				// recursively on the type variable upper bound
				return checkCastTypesCompatibility(scope, castType, ((TypeVariableBinding)expressionType).upperBound(), expression);
				
			case Binding.WILDCARD_TYPE : // intersection type
				match = expressionType.findSuperTypeWithSameErasure(castType);
				if (match != null) {
					return checkUnsafeCast(scope, castType, expressionType, match, false);
				}
				// recursively on the type variable upper bound
				return checkCastTypesCompatibility(scope, castType, ((WildcardBinding)expressionType).bound, expression);

			default:
				if (expressionType.isInterface()) {
					switch (castType.kind()) {
						case Binding.ARRAY_TYPE :
							// ( ARRAY ) INTERFACE
							switch (expressionType.id) {
								case T_JavaLangCloneable :
								case T_JavaIoSerializable :
									tagAsNeedCheckCast();
									return true;
								default :									
									return false;
							}

						case Binding.TYPE_PARAMETER :
							// ( INTERFACE ) TYPE_PARAMETER
							match = expressionType.findSuperTypeWithSameErasure(castType);
							if (match == null) {
								checkUnsafeCast(scope, castType, expressionType, match, true);
							}
							// recurse on the type variable upper bound
							return checkCastTypesCompatibility(scope, ((TypeVariableBinding)castType).upperBound(), expressionType, expression);

						default :
							if (castType.isInterface()) {
								// ( INTERFACE ) INTERFACE
								ReferenceBinding interfaceType = (ReferenceBinding) expressionType;
								match = interfaceType.findSuperTypeWithSameErasure(castType);
								if (match != null) {
									return checkUnsafeCast(scope, castType, interfaceType, match, false);
								}
								tagAsNeedCheckCast();
								match = castType.findSuperTypeWithSameErasure(interfaceType);
								if (match != null) {
									return checkUnsafeCast(scope, castType, interfaceType, match, true);
								}
								if (use15specifics) {
									// ensure there is no collision between both interfaces: i.e. I1 extends List<String>, I2 extends List<Object>
									if (interfaceType.hasIncompatibleSuperType((ReferenceBinding)castType))
										return false;
								} else {
									// pre1.5 semantics - no covariance allowed (even if 1.5 compliant, but 1.4 source)
									MethodBinding[] castTypeMethods = getAllInheritedMethods((ReferenceBinding) castType);
									MethodBinding[] expressionTypeMethods = getAllInheritedMethods((ReferenceBinding) expressionType);
									int exprMethodsLength = expressionTypeMethods.length;
									for (int i = 0, castMethodsLength = castTypeMethods.length; i < castMethodsLength; i++) {
										for (int j = 0; j < exprMethodsLength; j++) {
											if ((castTypeMethods[i].returnType != expressionTypeMethods[j].returnType)
													&& (CharOperation.equals(castTypeMethods[i].selector, expressionTypeMethods[j].selector))
													&& castTypeMethods[i].areParametersEqual(expressionTypeMethods[j])) {
												return false;
					
											}
										}
									}
								}
								return true;		
							} else {
								// ( CLASS ) INTERFACE
								if (castType.id == T_JavaLangObject) { // no runtime error
									tagAsUnnecessaryCast(scope, castType);
									return true;
								}
								if (((ReferenceBinding) castType).isFinal()) {
									// no subclass for castType, thus compile-time check is valid
									match = castType.findSuperTypeWithSameErasure(expressionType);
									if (match == null) {
										return false;
									}
								}
								if (use15specifics) {
									// ensure there is no collision between both interfaces: i.e. I1 extends List<String>, I2 extends List<Object>
									if (((ReferenceBinding)castType).hasIncompatibleSuperType((ReferenceBinding) expressionType)) {
										return false;
									}
								}
							}
					}
					tagAsNeedCheckCast();
					return true;
				} else {
					switch (castType.kind()) {
						case Binding.ARRAY_TYPE :
							// ( ARRAY ) CLASS
							if (expressionType.id == T_JavaLangObject) { // potential runtime error
								checkUnsafeCast(scope, castType, expressionType, expressionType, true);
								tagAsNeedCheckCast();
								return true;
							}
							return false;
							
						case Binding.TYPE_PARAMETER :
							// ( TYPE_PARAMETER ) CLASS
							match = expressionType.findSuperTypeWithSameErasure(castType);
							if (match == null) {
								checkUnsafeCast(scope, castType, expressionType, match, true);
							}
							// recurse on the type variable upper bound
							return checkCastTypesCompatibility(scope, ((TypeVariableBinding)castType).upperBound(), expressionType, expression);
							
						default :
							if (castType.isInterface()) {
								// ( INTERFACE ) CLASS
								ReferenceBinding refExprType = (ReferenceBinding) expressionType;
								match = refExprType.findSuperTypeWithSameErasure(castType);
								if (refExprType.isFinal()) {
									// unless final a subclass may implement the interface ==> no check at compile time
									if (match == null) {
										return false;
									}
									return checkUnsafeCast(scope, castType, expressionType, match, false);
								} else {
									if (match != null) {
										return checkUnsafeCast(scope, castType, expressionType, match, false);
									}
								}
								tagAsNeedCheckCast();
								match = castType.findSuperTypeWithSameErasure(expressionType);
								if (match != null) {
									return checkUnsafeCast(scope, castType, expressionType, match, true);
								}
								if (use15specifics) {
									// ensure there is no collision between both interfaces: i.e. I1 extends List<String>, I2 extends List<Object>
									if (refExprType.hasIncompatibleSuperType((ReferenceBinding) castType))
										return false;
								}								
								return true;
							} else {
								// ( CLASS ) CLASS
								match = expressionType.findSuperTypeWithSameErasure(castType);
								if (match != null) {
									if (expression != null && castType.id == T_JavaLangString) this.constant = expression.constant; // (String) cst is still a constant
									return checkUnsafeCast(scope, castType, expressionType, match, false);
								}
								match = castType.findSuperTypeWithSameErasure(expressionType);
								if (match != null) {
									tagAsNeedCheckCast();
									return checkUnsafeCast(scope, castType, expressionType, match, true);
								}
								return false;
							}
					}
				}
		}
	}	

