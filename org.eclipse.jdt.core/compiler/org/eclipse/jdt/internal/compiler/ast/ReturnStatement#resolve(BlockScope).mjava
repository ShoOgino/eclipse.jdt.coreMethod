	public void resolve(BlockScope scope) {
		
		MethodScope methodScope = scope.methodScope();
		MethodBinding methodBinding;
		TypeBinding methodType =
			(methodScope.referenceContext instanceof AbstractMethodDeclaration)
				? ((methodBinding = ((AbstractMethodDeclaration) methodScope.referenceContext).binding) == null 
					? null 
					: methodBinding.returnType)
				: VoidBinding;
		TypeBinding expressionType;
		if (methodType == VoidBinding) {
			// the expression should be null
			if (expression == null)
				return;
			if ((expressionType = expression.resolveType(scope)) != null)
				scope.problemReporter().attemptToReturnNonVoidExpression(this, expressionType);
			return;
		}
		if (expression == null) {
			if (methodType != null) scope.problemReporter().shouldReturn(methodType, this);
			return;
		}
		expression.setExpectedType(methodType); // needed in case of generic method invocation
		if ((expressionType = expression.resolveType(scope)) == null) return;
		if (expressionType == VoidBinding) {
			scope.problemReporter().attemptToReturnVoidValue(this);
			return;
		}
		if (methodType == null) 
			return;
	
		if (methodType != expressionType) // must call before computeConversion() and typeMismatchError()
			scope.compilationUnitScope().recordTypeConversion(methodType, expressionType);
		if (expression.isConstantValueOfTypeAssignableToType(expressionType, methodType)
				|| expressionType.isCompatibleWith(methodType)) {

			expression.computeConversion(scope, methodType, expressionType);
			if (expressionType.needsUncheckedConversion(methodType)) {
			    scope.problemReporter().unsafeRawConversion(this.expression, expressionType, methodType);
			}
			return;
		} else if (scope.isBoxingCompatibleWith(expressionType, methodType)) {
			expression.computeConversion(scope, methodType, expressionType);
			return;
		}
		scope.problemReporter().typeMismatchError(expressionType, methodType, expression);
	}

