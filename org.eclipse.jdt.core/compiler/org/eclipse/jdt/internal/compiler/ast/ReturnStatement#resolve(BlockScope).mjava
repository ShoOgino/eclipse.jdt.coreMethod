	public void resolve(BlockScope scope) {
		MethodScope methodScope = scope.methodScope();
		TypeBinding methodType =
			(methodScope.referenceContext instanceof AbstractMethodDeclaration)
				? ((AbstractMethodDeclaration) methodScope.referenceContext).binding.returnType
				: VoidBinding;
		if (methodType == VoidBinding) {
			// the expression should be null
			if (expression == null)
				return;
			if ((expressionType = expression.resolveType(scope)) != null)
				scope.problemReporter().attemptToReturnNonVoidExpression(this, expressionType);
			return;
		}
		if (expression == null) {
			scope.problemReporter().shouldReturn(methodType, this);
			return;
		}
		if ((expressionType = expression.resolveType(scope)) == null)
			return;

		if (expression
			.isConstantValueOfTypeAssignableToType(expressionType, methodType)) {
			// dealing with constant
			expression.implicitWidening(methodType, expressionType);
			return;
		}
		if (expressionType == VoidBinding) {
			scope.problemReporter().attemptToReturnVoidValue(this);
			return;
		}
		if (scope.areTypesCompatible(expressionType, methodType)) {
			expression.implicitWidening(methodType, expressionType);
			return;
		}
		scope.problemReporter().typeMismatchErrorActualTypeExpectedType(
			expression,
			expressionType,
			methodType);
	}

