	/**
	 * Cast expressions will considered as useful if removing them all would actually bind to a different method
	 * (no fine grain analysis on per casted argument basis)
	 */
	public static void checkNeedForArgumentCasts(BlockScope scope, Expression receiver, ReferenceBinding receiverType, MethodBinding binding, Expression[] arguments, TypeBinding[] argumentTypes, final InvocationSite invocationSite) {
	
		if (scope.environment().options.getSeverity(CompilerOptions.UnnecessaryTypeCheck) == ProblemSeverities.Ignore) return;
		
		TypeBinding[] parameterTypes = binding.parameters;
		int length = argumentTypes.length;
		
		// first iteration, questionning widening cast
		TypeBinding[] rawArgumentTypes = argumentTypes;
		for (int i = 0; i < length; i++) {
			Expression argument = arguments[i];
			if ((argument.bits & UnnecessaryCastMask) != 0) {
				TypeBinding castedExpressionType = ((CastExpression)argument).expression.resolvedType;
				// obvious identity cast
				if (castedExpressionType == parameterTypes[i]) { 
					scope.problemReporter().unnecessaryCastForArgument((CastExpression)argument, binding.parameters[i]);
				// widening cast, will need to check later whether it would affect method lookup
				} else {
					if (rawArgumentTypes == argumentTypes) {
						System.arraycopy(rawArgumentTypes, 0, rawArgumentTypes = new TypeBinding[length], 0, length);
					}
					// only retain widened argument types, since narrowing are thought to be ok
					rawArgumentTypes[i] = castedExpressionType; 
				}
			}
		}
		// did not find any unnecessary cast candidate
		if (rawArgumentTypes != argumentTypes) {
			checkAlternateBinding(scope, receiver, receiverType, binding, arguments, argumentTypes, rawArgumentTypes, invocationSite);
		}
		
		// second attempt questionning narrowing cast
		rawArgumentTypes = argumentTypes;
		for (int i = 0; i < length; i++) {
			Expression argument = arguments[i];
			if (argument instanceof CastExpression && (argument.bits & UnnecessaryCastMask) == 0) {
				TypeBinding castedExpressionType = ((CastExpression)argument).expression.resolvedType;
				if (rawArgumentTypes == argumentTypes) {
					System.arraycopy(rawArgumentTypes, 0, rawArgumentTypes = new TypeBinding[length], 0, length);
				}
				rawArgumentTypes[i] = castedExpressionType; 
			}
		}
		if (rawArgumentTypes != argumentTypes) {
			checkAlternateBinding(scope, receiver, receiverType, binding, arguments, argumentTypes, rawArgumentTypes, invocationSite);
		}
	}

