	/**
	 * Cast expressions will considered as useful if removing them all would actually bind to a different method
	 * (no fine grain analysis on per casted argument basis)
	 */
	public static void checkNeedForArgumentCasts(BlockScope scope, Expression receiver, ReferenceBinding receiverType, MethodBinding binding, Expression[] arguments, TypeBinding[] argumentTypes, final InvocationSite invocationSite) {
	
		if (scope.environment().options.getSeverity(CompilerOptions.UnnecessaryTypeCheck) == ProblemSeverities.Ignore) return;
		
		TypeBinding[] parameterTypes = binding.parameters;
		int length = argumentTypes.length;
		TypeBinding[] rawArgumentTypes = argumentTypes;
		for (int i = 0; i < length; i++) {
			Expression argument = arguments[i];
			if ((argument.bits & UnnecessaryCastMask) != 0) {
				TypeBinding castedExpressionType = ((CastExpression)argument).expression.resolvedType;
				// obvious identity cast
				if (castedExpressionType == parameterTypes[i]) { 
					scope.problemReporter().unnecessaryCast((CastExpression)argument);
				// widening cast, will need to check later whether it would affect method lookup
				} else {
					if (rawArgumentTypes == argumentTypes) {
						System.arraycopy(rawArgumentTypes, 0, rawArgumentTypes = new TypeBinding[length], 0, length);
					}
					// only retain widened argument types, since narrowing are thought to be ok
					rawArgumentTypes[i] = castedExpressionType; 
				}
			}
		}
		if (rawArgumentTypes == argumentTypes) return; // did not find any unnecessary cast candidate
	
		InvocationSite fakeInvocationSite = new InvocationSite(){	
			public boolean isSuperAccess(){ return invocationSite.isSuperAccess(); }
			public boolean isTypeAccess() { return invocationSite.isTypeAccess(); }
			public void setActualReceiverType(ReferenceBinding actualReceiverType) {}
			public void setDepth(int depth) {}
			public void setFieldIndex(int depth){}
		};	
		MethodBinding bindingIfNoCast;
		if (binding.isConstructor()) {
			bindingIfNoCast = scope.getConstructor(receiverType, rawArgumentTypes, fakeInvocationSite);
		} else {
			bindingIfNoCast = receiver.isImplicitThis()
				? scope.getImplicitMethod(binding.selector, rawArgumentTypes, fakeInvocationSite)
				: scope.getMethod(receiverType, binding.selector, rawArgumentTypes, fakeInvocationSite); 	
		}
		if (bindingIfNoCast == binding) {
			for (int i = 0; i < length; i++) {
				if (argumentTypes[i] != rawArgumentTypes[i]) {
					scope.problemReporter().unnecessaryCast((CastExpression)arguments[i]);
				}
			}
		}
	}

