	/**
	 * After method lookup has produced 'methodBinding' but when poly expressions have been seen as arguments,
	 * inspect the arguments to trigger another round of resolving with improved target types from the methods parameters.
	 * If this resolving produces better types for any arguments, update the 'argumentTypes' array in-place as an
	 * intended side effect that will feed better type information in checkInvocationArguments() and others.
	 * @param invocation the outer invocation which is being resolved
	 * @param methodBinding the method produced by lookup (possibly involving type inference).
	 * @param argumentTypes the argument types as collected from first resolving the invocation arguments and as used for
	 * 	the method lookup.
	 */
	public static void resolvePolyExpressionArguments(Invocation invocation, MethodBinding methodBinding, TypeBinding[] argumentTypes) {
		if (!invocation.innersNeedUpdate())
			return;
		int problemReason = 0;
		MethodBinding candidateMethod;
		if (methodBinding.isValidBinding()) {
			candidateMethod = methodBinding;
		} else if (methodBinding instanceof ProblemMethodBinding) {
			problemReason = methodBinding.problemId();
			candidateMethod = ((ProblemMethodBinding) methodBinding).closestMatch;
		} else {
			candidateMethod = null;
		}
		if (candidateMethod != null) {
			boolean variableArity = candidateMethod.isVarargs();
			InferenceContext18 infCtx = null;
			if (candidateMethod instanceof ParameterizedGenericMethodBinding) {
				infCtx = invocation.getInferenceContext((ParameterizedGenericMethodBinding) candidateMethod);
				if (infCtx != null) {
					if (infCtx.stepCompleted != InferenceContext18.TYPE_INFERRED) {
						// only work in the exact state of TYPE_INFERRED
						// - below we're not yet ready
						// - above we're already done-done
						return;
					}
					variableArity &= infCtx.isVarArgs(); // TODO: if no infCtx is available, do we have to re-check if this is a varargs invocation?
				}
			} else if (invocation instanceof AllocationExpression) {
				if (((AllocationExpression)invocation).suspendedResolutionState != null)
					return; // not yet ready
			}
			
			final TypeBinding[] parameters = candidateMethod.parameters;
			Expression[] innerArguments = invocation.arguments();
			Expression [] arguments = innerArguments;
			for (int i = 0, length = arguments == null ? 0 : arguments.length; i < length; i++) {
				Expression argument = arguments[i];
				TypeBinding updatedArgumentType = null;
				TypeBinding parameterType = InferenceContext18.getParameter(parameters, i, variableArity);
				if (parameterType == null && problemReason != ProblemReasons.NoError)
					continue; // not much we can do without a target type, assume it only happens after some resolve error

				if (argument instanceof LambdaExpression && ((LambdaExpression) argument).hasErrors())
					continue; // don't update if inner poly has errors

				if (argument instanceof Invocation) {
					Invocation innerInvocation = (Invocation)argument;
					MethodBinding binding = innerInvocation.binding(parameterType);
					if (binding instanceof ParameterizedGenericMethodBinding) {
						ParameterizedGenericMethodBinding parameterizedMethod = (ParameterizedGenericMethodBinding) binding;
						InferenceContext18 innerContext = innerInvocation.getInferenceContext(parameterizedMethod);
						if (innerContext != null) {
							if (innerContext.stepCompleted < InferenceContext18.TYPE_INFERRED) {
								argument.setExpectedType(parameterType);
								MethodBinding improvedBinding = innerContext.inferInvocationType(innerInvocation, parameterizedMethod);
								innerInvocation.updateBindings(improvedBinding);
								// TODO need to report invalidMethod if !improvedBinding.isValidBinding() ?
							} else if (innerContext.stepCompleted < InferenceContext18.BINDINGS_UPDATED) {
								innerContext.rebindInnerPolies(parameterizedMethod, innerInvocation);
							}
						}
						continue; // otherwise these have been dealt with during inner method lookup
					}
				}

				if (argument.isPolyExpression()) {
					// poly expressions in an invocation context may need to be resolved now:
					if (infCtx != null && infCtx.stepCompleted == InferenceContext18.BINDINGS_UPDATED)
						updatedArgumentType = argument.resolvedType; // in this case argument was already resolved via InferenceContext18.acceptPendingPolyArguments()
					else
						updatedArgumentType = argument.checkAgainstFinalTargetType(parameterType);

					if (problemReason == ProblemReasons.NoError // preserve errors
							&& updatedArgumentType != null					// do we have a relevant update? ...
							&& !(updatedArgumentType instanceof PolyTypeBinding))
					{
						// update the argumentTypes array (supposed to be owned by the calling method)
						// in order to give better information for subsequent checks
						argumentTypes[i] = updatedArgumentType;
					}
				}
			}
		}
		invocation.innerUpdateDone();
	}

