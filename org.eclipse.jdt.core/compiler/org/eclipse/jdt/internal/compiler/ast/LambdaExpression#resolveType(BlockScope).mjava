	public TypeBinding resolveType(BlockScope blockScope) {
		super.resolveType(blockScope);
		this.scope = new MethodScope(blockScope, this, blockScope.methodScope().isStatic);

		TypeBinding expected = this.expectedType();
		if (expected == null) return TypeBinding.NULL;

		MethodBinding singleAbstractMethod = expected.getSingleAbstractMethod();
		if (this.arguments != null && singleAbstractMethod != null) {
			int parameterCount = singleAbstractMethod.parameters != null ? singleAbstractMethod.parameters.length : 0;
			int lambdaArgumentCount = this.arguments != null ? this.arguments.length : 0;

			if (parameterCount == lambdaArgumentCount) {
				for (int i = 0, length = this.arguments.length; i < length; i++) {
					Argument argument = this.arguments[i];
					if (argument.type != null) {
						argument.resolve(this.scope); // TODO: Check it!
					} else {
						argument.bind(this.scope, singleAbstractMethod.parameters[i], false);
					}
				}
			} /* TODO: else complain */
		}
		if (this.body instanceof Expression) {
			Expression expression = (Expression) this.body;
			if (singleAbstractMethod != null) {
				expression.setExpectedType(singleAbstractMethod.returnType); // chain expected type for any nested lambdas.
				/* TypeBinding expressionType = */ expression.resolveType(this.scope);
				// TODO: checkExpressionResult(singleAbstractMethod.returnType, expression, expressionType);
			}
		} else {
			this.body.resolve(this.scope);
		}
		return expected;
	}

