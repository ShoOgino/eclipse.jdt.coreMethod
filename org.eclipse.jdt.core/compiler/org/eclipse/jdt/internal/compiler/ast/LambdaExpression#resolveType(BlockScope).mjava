	/* This code is arranged so that we can continue with as much analysis as possible while avoiding 
	 * mine fields that would result in a slew of spurious messages. This method is a merger of:
	 * @see org.eclipse.jdt.internal.compiler.lookup.MethodScope.createMethod(AbstractMethodDeclaration)
	 * @see org.eclipse.jdt.internal.compiler.lookup.SourceTypeBinding.resolveTypesFor(MethodBinding)
	 * @see org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(ClassScope)
	 */
	public TypeBinding resolveType(BlockScope blockScope) {
		
		this.constant = Constant.NotAConstant;
		this.enclosingScope = blockScope;
		this.scope = new MethodScope(blockScope, this, blockScope.methodScope().isStatic);
		
		if (this.expectedType == null && this.expressionContext == INVOCATION_CONTEXT) {
			if (this.body instanceof Block) {
				// Gather shape information for potential applicability analysis.
				ASTVisitor visitor = new ASTVisitor() {
					private boolean valueReturnSeen = false;
					private boolean voidReturnSeen = false;
					private boolean throwSeen = false;
					public boolean visit(ReturnStatement returnStatement, BlockScope dontCare) {
						if (returnStatement.expression != null) {
							this.valueReturnSeen = true;
							LambdaExpression.this.voidCompatible = false;
							LambdaExpression.this.valueCompatible = !this.voidReturnSeen;
						} else {
							this.voidReturnSeen = true;
							LambdaExpression.this.valueCompatible = false;
							LambdaExpression.this.voidCompatible = !this.valueReturnSeen;
						}
						return false;
					}
					public boolean visit(ThrowStatement throwStatement, BlockScope dontCare) {
						this.throwSeen  = true;
						return false;
					}
					public void endVisit(LambdaExpression expression, BlockScope dontCare) {
						if (!this.voidReturnSeen && !this.valueReturnSeen && this.throwSeen) {  // () -> { throw new Exception(); } is value compatible.
							Block block = (Block) LambdaExpression.this.body;
							final Statement[] statements = block.statements;
							final int statementsLength = statements == null ? 0 : statements.length;
							Statement ultimateStatement = statementsLength == 0 ? null : statements[statementsLength - 1];
							LambdaExpression.this.valueCompatible = ultimateStatement instanceof ThrowStatement;
							LambdaExpression.this.shapeAnalysisComplete = LambdaExpression.this.valueCompatible;
						} else {
							LambdaExpression.this.shapeAnalysisComplete = true;
						}
					}
				};
				this.traverse(visitor, blockScope);
			} else {
				Expression expression = (Expression) this.body;
				this.voidCompatible = expression.statementExpression();
				this.valueCompatible = true;
				this.shapeAnalysisComplete = true;
			}	
			return new PolyTypeBinding(this);
		}
		super.resolveType(blockScope); // compute & capture interface function descriptor in singleAbstractMethod.
		
		final boolean argumentsTypeElided = argumentsTypeElided();
		final boolean haveDescriptor = this.descriptor != null;
		
		if (haveDescriptor && this.descriptor.typeVariables != Binding.NO_TYPE_VARIABLES) // already complained in kosher*
			return null;
		
		if (!haveDescriptor && argumentsTypeElided) 
			return null; // FUBAR, bail out...

		this.binding = new MethodBinding(ClassFileConstants.AccPublic | ExtraCompilerModifiers.AccUnresolved,
							haveDescriptor ? this.descriptor.selector : TypeConstants.ANONYMOUS_METHOD, 
							haveDescriptor ? this.descriptor.returnType : null, 
							Binding.NO_PARAMETERS, // for now. 
							haveDescriptor ? this.descriptor.thrownExceptions : Binding.NO_EXCEPTIONS, 
							blockScope.enclosingSourceType()); // declaring class, for now - this is needed for annotation holder and such.
		this.binding.typeVariables = Binding.NO_TYPE_VARIABLES;
		
		if (haveDescriptor) {
			int descriptorParameterCount = this.descriptor.parameters.length;
			int lambdaArgumentCount = this.arguments != null ? this.arguments.length : 0;
            if (descriptorParameterCount != lambdaArgumentCount) {
            	this.scope.problemReporter().lambdaSignatureMismatched(this);
            	if (argumentsTypeElided) 
            		return null; // FUBAR, bail out ...
            }
		}
		
		boolean buggyArguments = false;
		int length = this.arguments == null ? 0 : this.arguments.length;
		TypeBinding[] newParameters = new TypeBinding[length];

		AnnotationBinding [][] parameterAnnotations = null;
		for (int i = 0; i < length; i++) {
			Argument argument = this.arguments[i];
			if (argument.isVarArgs()) {
				if (i == length - 1) {
					this.binding.modifiers |= ClassFileConstants.AccVarargs;
				} else {
					this.scope.problemReporter().illegalVarargInLambda(argument);
					buggyArguments = true;
				}
			}
			
			TypeBinding parameterType;
			final TypeBinding expectedParameterType = haveDescriptor && i < this.descriptor.parameters.length ? this.descriptor.parameters[i] : null;
			parameterType = argumentsTypeElided ? expectedParameterType : argument.type.resolveType(this.scope, true /* check bounds*/);
			if (parameterType == null) {
				buggyArguments = true;
			} else if (parameterType == TypeBinding.VOID) {
				this.scope.problemReporter().argumentTypeCannotBeVoid(this, argument);
				buggyArguments = true;
			} else {
				if (!parameterType.isValidBinding()) {
					this.binding.tagBits |= TagBits.HasUnresolvedArguments;
				}
				if ((parameterType.tagBits & TagBits.HasMissingType) != 0) {
					this.binding.tagBits |= TagBits.HasMissingType;
				}
				if (haveDescriptor && expectedParameterType != null && parameterType.isValidBinding() && parameterType != expectedParameterType) {
					this.scope.problemReporter().lambdaParameterTypeMismatched(argument, argument.type, expectedParameterType);
				}

				TypeBinding leafType = parameterType.leafComponentType();
				if (leafType instanceof ReferenceBinding && (((ReferenceBinding) leafType).modifiers & ExtraCompilerModifiers.AccGenericSignature) != 0)
					this.binding.modifiers |= ExtraCompilerModifiers.AccGenericSignature;
				newParameters[i] = parameterType;
				argument.bind(this.scope, parameterType, false);
				if (argument.annotations != null) {
					this.binding.tagBits |= TagBits.HasParameterAnnotations;
					if (parameterAnnotations == null) {
						parameterAnnotations = new AnnotationBinding[length][];
						for (int j = 0; j < i; j++) {
							parameterAnnotations[j] = Binding.NO_ANNOTATIONS;
						}
					}
					parameterAnnotations[i] = argument.binding.getAnnotations();
				} else if (parameterAnnotations != null) {
					parameterAnnotations[i] = Binding.NO_ANNOTATIONS;
				}
			}
		}
		// only assign parameters if no problems are found
		if (!buggyArguments) {
			this.binding.parameters = newParameters;
			if (parameterAnnotations != null)
				this.binding.setParameterAnnotations(parameterAnnotations);
		}
	
		if (!argumentsTypeElided && this.binding.isVarargs()) {
			if (!this.binding.parameters[this.binding.parameters.length - 1].isReifiable()) {
				this.scope.problemReporter().possibleHeapPollutionFromVararg(this.arguments[this.arguments.length - 1]);
			}
		}

		ReferenceBinding [] exceptions = this.binding.thrownExceptions;
		length = exceptions.length;
		for (int i = 0; i < length; i++) {
			ReferenceBinding exception = exceptions[i];
			if ((exception.tagBits & TagBits.HasMissingType) != 0) {
				this.binding.tagBits |= TagBits.HasMissingType;
			}
			this.binding.modifiers |= (exception.modifiers & ExtraCompilerModifiers.AccGenericSignature);
		}
		
		TypeBinding returnType = this.binding.returnType;
		if (returnType != null) {
			if ((returnType.tagBits & TagBits.HasMissingType) != 0) {
				this.binding.tagBits |= TagBits.HasMissingType;
			}
			TypeBinding leafType = returnType.leafComponentType();
			if (leafType instanceof ReferenceBinding && (((ReferenceBinding) leafType).modifiers & ExtraCompilerModifiers.AccGenericSignature) != 0)
				this.binding.modifiers |= ExtraCompilerModifiers.AccGenericSignature;
		} // TODO (stephan): else? (can that happen?)

		if (haveDescriptor && blockScope.compilerOptions().isAnnotationBasedNullAnalysisEnabled) {
			if (!argumentsTypeElided) {
				AbstractMethodDeclaration.createArgumentBindings(this.arguments, this.binding, this.scope);
				validateNullAnnotations();
				// no application of null-ness default, hence also no warning regarding redundant null annotation
				mergeParameterNullAnnotations(blockScope);
			}
			this.binding.tagBits |= (this.descriptor.tagBits & TagBits.AnnotationNullMASK);
		}

		this.binding.modifiers &= ~ExtraCompilerModifiers.AccUnresolved;
		
		if (this.body instanceof Expression) {
			Expression expression = (Expression) this.body;
			new ReturnStatement(expression, expression.sourceStart, expression.sourceEnd, true).resolve(this.scope); // :-) ;-)
		} else {
			this.body.resolve(this.scope);
		}
		return this.resolvedType;
	}

