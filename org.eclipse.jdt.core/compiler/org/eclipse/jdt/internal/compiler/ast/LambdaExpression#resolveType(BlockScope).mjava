	public TypeBinding resolveType(BlockScope blockScope) {
		super.resolveType(blockScope);
		this.scope = new MethodScope(blockScope, this, blockScope.methodScope().isStatic);

		if (this.functionalInterfaceType.isValidBinding()) {
			// Resolve arguments, validate signature ...
			if (this.arguments != null && this.singleAbstractMethod != null) {
				int parameterCount = this.singleAbstractMethod.parameters != null ? this.singleAbstractMethod.parameters.length : 0;
				int lambdaArgumentCount = this.arguments != null ? this.arguments.length : 0;

				if (parameterCount == lambdaArgumentCount) {
					for (int i = 0, length = this.arguments.length; i < length; i++) {
						Argument argument = this.arguments[i];
						if (argument.type != null) {
							argument.resolve(this.scope); // TODO: Check it!
						} else {
							argument.bind(this.scope, this.singleAbstractMethod.parameters[i], false);
						}
					}
				} /* TODO: else complain */
			}
		}
		if (this.body instanceof Expression) {
			Expression expression = (Expression) this.body;
			if (this.functionalInterfaceType.isValidBinding()) {
				expression.setExpectedType(this.singleAbstractMethod.returnType); // chain expected type for any nested lambdas.
				/* TypeBinding expressionType = */ expression.resolveType(this.scope);
				// TODO: checkExpressionResult(singleAbstractMethod.returnType, expression, expressionType);
			}
		} else {
			this.body.resolve(this.scope);
		}
		return this.functionalInterfaceType;
	}

