/**
 * @see org.eclipse.jdt.internal.compiler.ast.Expression#computeConversion(org.eclipse.jdt.internal.compiler.lookup.Scope, org.eclipse.jdt.internal.compiler.lookup.TypeBinding, org.eclipse.jdt.internal.compiler.lookup.TypeBinding)
 */
public void computeConversion(Scope scope, TypeBinding runtimeTimeType, TypeBinding compileTimeType) {
	if (runtimeTimeType == null || compileTimeType == null)
		return;
	// set the generic cast after the fact, once the type expectation is fully known (no need for strict cast)
	if (this.binding != null && this.binding.isValidBinding()) {
		MethodBinding originalBinding = this.binding.original();
		if (originalBinding != this.binding) {
		    // extra cast needed if method return type has type variable
		    if ((originalBinding.returnType.tagBits & TagBits.HasTypeVariable) != 0 && runtimeTimeType.id != T_Object) {
		        this.valueCast = originalBinding.returnType.genericCast(runtimeTimeType);
		    }
		} 	else if (this.actualReceiverType.isArrayType() 
						&& runtimeTimeType.id != T_Object
						&& this.binding.parameters == NoParameters 
						&& scope.environment().options.complianceLevel >= JDK1_5 
						&& CharOperation.equals(this.binding.selector, CLONE)) {
					// from 1.5 compliant mode on, array#clone() resolves to array type, but codegen to #clone()Object - thus require extra inserted cast
			this.valueCast = runtimeTimeType;			
		}
	}
	super.computeConversion(scope, runtimeTimeType, compileTimeType);
}

