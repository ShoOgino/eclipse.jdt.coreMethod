public void manageSyntheticReadAccessIfNecessary(BlockScope currentScope, FlowInfo flowInfo) {

	if (!flowInfo.isReachable()) return;

	//If inlinable field, forget the access emulation, the code gen will directly target it
	if (constant != NotAConstant)
		return;

	if ((bits & FIELD) != 0) {
		FieldBinding fieldBinding = (FieldBinding) binding;
		if (((bits & DepthMASK) != 0)
			&& (fieldBinding.isPrivate() // private access
				|| (fieldBinding.isProtected() // implicit protected access
						&& fieldBinding.declaringClass.getPackage() 
							!= currentScope.enclosingSourceType().getPackage()))) {
			if (syntheticAccessors == null)
				syntheticAccessors = new MethodBinding[2];
			syntheticAccessors[READ] = 
				((SourceTypeBinding)currentScope.enclosingSourceType().
					enclosingTypeAt((bits & DepthMASK) >> DepthSHIFT)).
						addSyntheticMethod(fieldBinding, true);
			currentScope.problemReporter().needToEmulateFieldReadAccess(fieldBinding, this);
			return;
		}
		// if the binding declaring class is not visible, need special action
		// for runtime compatibility on 1.2 VMs : change the declaring class of the binding
		// NOTE: from target 1.2 on, field's declaring class is touched if any different from receiver type
		// and not from Object or implicit static field access.	
		if (fieldBinding.declaringClass != this.actualReceiverType
			&& !this.actualReceiverType.isArrayType()	
			&& fieldBinding.declaringClass != null
			&& fieldBinding.constant == NotAConstant
			&& ((currentScope.environment().options.targetJDK >= CompilerOptions.JDK1_2 
					&& !fieldBinding.isStatic()
					&& fieldBinding.declaringClass.id != T_Object) // no change for Object fields (if there was any)
				|| !fieldBinding.declaringClass.canBeSeenBy(currentScope))){
			this.codegenBinding = currentScope.enclosingSourceType().getUpdatedFieldBinding(fieldBinding, (ReferenceBinding)this.actualReceiverType);
		}
	}
}

