	/**
	 * Try statement code generation with or without jsr bytecode use
	 *	post 1.5 target level, cannot use jsr bytecode, must instead inline finally block
	 * returnAddress is only allocated if jsr is allowed
	 */
	public void generateCode(BlockScope currentScope, CodeStream codeStream) {
		if ((this.bits & ASTNode.IsReachable) == 0) {
			return;
		}
		// in case the labels needs to be reinitialized
		// when the code generation is restarted in wide mode
		this.anyExceptionLabel = null;
//		this.returnLocationsCount = 0;
//		this.returnLocationLabels = null;

		int pc = codeStream.position;
		final int NO_FINALLY = 0;										// no finally block
		final int FINALLY_SUBROUTINE = 1; 					// finally is generated as a subroutine (using jsr/ret bytecodes)
		final int FINALLY_DOES_NOT_COMPLETE = 2;		// non returning finally is optimized with only one instance of finally block
		final int FINALLY_INLINE = 3;								// finally block must be inlined since cannot use jsr/ret bytecodes >1.5
		final int FINALLY_EMULATE_RET = 4;					// finally ret is emulated since cannot use jsr/ret bytecodes >1.5 (NOT WORKING)
		int finallyMode;
		if (this.subRoutineStartLabel == null) {
			finallyMode = NO_FINALLY;
		} else {
			CompilerOptions options = currentScope.compilerOptions();
			if (isSubRoutineEscaping()) {
				finallyMode = FINALLY_DOES_NOT_COMPLETE;
//			} else if (options.noJSRBytecode) {
//				finallyMode = FINALLY_EMULATE_RET;
			} else if (options.inlineJsrBytecode) {
				finallyMode = FINALLY_INLINE;
			} else {
				finallyMode = FINALLY_SUBROUTINE;
			}
		}
		boolean requiresNaturalExit = false;
		// preparing exception labels
		int maxCatches = this.catchArguments == null ? 0 : this.catchArguments.length;
		ExceptionLabel[] exceptionLabels;
		if (maxCatches > 0) {
			exceptionLabels = new ExceptionLabel[maxCatches];
			for (int i = 0; i < maxCatches; i++) {
				ExceptionLabel exceptionLabel = new ExceptionLabel(codeStream, this.catchArguments[i].binding.type);
				exceptionLabel.placeStart();
				exceptionLabels[i] = exceptionLabel;
			}
		} else {
			exceptionLabels = null;
		}
		if (this.subRoutineStartLabel != null) {
			this.subRoutineStartLabel.initialize(codeStream);
			this.enterAnyExceptionHandler(codeStream);
		}
		// generate the try block
		try {
			this.enclosingExceptionLabels = exceptionLabels;
			this.tryBlock.generateCode(this.scope, codeStream);
		} finally {
			this.enclosingExceptionLabels = null;
		}
		boolean tryBlockHasSomeCode = codeStream.position != pc;
		// flag telling if some bytecodes were issued inside the try block

		// place end positions of user-defined exception labels
		if (tryBlockHasSomeCode) {
			// natural exit may require subroutine invocation (if finally != null)
			BranchLabel naturalExitLabel = new BranchLabel(codeStream);
			if ((this.bits & IsTryBlockExiting) == 0) {
				int position = codeStream.position;
				switch(finallyMode) {
					case FINALLY_SUBROUTINE :
					case FINALLY_INLINE :
					case FINALLY_EMULATE_RET :
						requiresNaturalExit = true;
						// fall through
					case NO_FINALLY :
						codeStream.goto_(naturalExitLabel);
						break;
					case FINALLY_DOES_NOT_COMPLETE :
						codeStream.goto_(this.subRoutineStartLabel);
						break;
				}
				codeStream.updateLastRecordedEndPC(this.tryBlock.scope, position);
				//goto is tagged as part of the try block
			}
			for (int i = 0; i < maxCatches; i++) {
				exceptionLabels[i].placeEnd();
			}
			/* generate sequence of handler, all starting by storing the TOS (exception
			thrown) into their own catch variables, the one specified in the source
			that must denote the handled exception.
			*/
			if (this.catchArguments != null) {
				for (int i = 0; i < maxCatches; i++) {
					// May loose some local variable initializations : affecting the local variable attributes
					if (this.preTryInitStateIndex != -1) {
						codeStream.removeNotDefinitelyAssignedVariables(currentScope, this.preTryInitStateIndex);
					}
					codeStream.pushOnStack(exceptionLabels[i].exceptionType);
					exceptionLabels[i].place();
					// optimizing the case where the exception variable is not actually used
					LocalVariableBinding catchVar;
					int varPC = codeStream.position;
					if ((catchVar = this.catchArguments[i].binding).resolvedPosition != -1) {
						codeStream.store(catchVar, false);
						catchVar.recordInitializationStartPC(codeStream.position);
						codeStream.addVisibleLocalVariable(catchVar);
					} else {
						codeStream.pop();
					}
					codeStream.recordPositionsFrom(varPC, this.catchArguments[i].sourceStart);
					// Keep track of the pcs at diverging point for computing the local attribute
					// since not passing the catchScope, the block generation will exitUserScope(catchScope)
					this.catchBlocks[i].generateCode(this.scope, codeStream);
					if (!this.catchExits[i]) {
						switch(finallyMode) {
							case FINALLY_SUBROUTINE :
							case FINALLY_INLINE :
							case FINALLY_EMULATE_RET :
								requiresNaturalExit = true;
								// fall through
							case NO_FINALLY :
								codeStream.goto_(naturalExitLabel);
								break;
							case FINALLY_DOES_NOT_COMPLETE :
								codeStream.goto_(this.subRoutineStartLabel);
								break;
						}
					}
				}
			}
			this.exitAnyExceptionHandler();
			// extra handler for trailing natural exit (will be fixed up later on when natural exit is generated below)
			ExceptionLabel naturalExitExceptionHandler = requiresNaturalExit && (finallyMode == FINALLY_SUBROUTINE || finallyMode == FINALLY_EMULATE_RET) 
						? new ExceptionLabel(codeStream, null) 
						: null;

			// addition of a special handler so as to ensure that any uncaught exception (or exception thrown
			// inside catch blocks) will run the finally block
			int finallySequenceStartPC = codeStream.position;
			if (this.subRoutineStartLabel != null) {
				codeStream.pushOnStack(this.scope.getJavaLangThrowable());
				if (this.preTryInitStateIndex != -1) {
					// reset initialization state, as for a normal catch block
					codeStream.removeNotDefinitelyAssignedVariables(currentScope, this.preTryInitStateIndex);
				}
				this.placeAllAnyExceptionHandler();
				if (naturalExitExceptionHandler != null) naturalExitExceptionHandler.place();
				
//				CaseLabel defaultReturnLocationLabel = null; // only used when emulating RET instruction
//				CaseLabel naturalExitReturnLocationLabel = null; // only used when emulating RET instruction
				switch(finallyMode) {
					case FINALLY_SUBROUTINE :
						// any exception handler
						codeStream.store(this.anyExceptionVariable, false);
						codeStream.jsr(this.subRoutineStartLabel);
						codeStream.recordPositionsFrom(finallySequenceStartPC, this.finallyBlock.sourceStart);
						int position = codeStream.position;						
						codeStream.throwAnyException(this.anyExceptionVariable);
						codeStream.recordPositionsFrom(position, this.finallyBlock.sourceEnd);
						// subroutine
						this.subRoutineStartLabel.place();
						codeStream.pushOnStack(this.scope.getJavaLangThrowable());
						position = codeStream.position;	
						codeStream.store(this.returnAddressVariable, false);
						codeStream.recordPositionsFrom(position, this.finallyBlock.sourceStart);
						this.finallyBlock.generateCode(this.scope, codeStream);
						position = codeStream.position;
						codeStream.ret(this.returnAddressVariable.resolvedPosition);
						codeStream.recordPositionsFrom(
							position,
							this.finallyBlock.sourceEnd);
						// the ret bytecode is part of the subroutine
						break;
					case FINALLY_INLINE :
						// any exception handler
						codeStream.store(this.anyExceptionVariable, false);
						codeStream.recordPositionsFrom(finallySequenceStartPC, this.finallyBlock.sourceStart);
						// subroutine
						this.finallyBlock.generateCode(currentScope, codeStream);
						position = codeStream.position;
						codeStream.throwAnyException(this.anyExceptionVariable);
						this.subRoutineStartLabel.place();
						codeStream.recordPositionsFrom(position, this.finallyBlock.sourceEnd);
						break;
					case FINALLY_DOES_NOT_COMPLETE :
						// any exception handler
						codeStream.pop();
						this.subRoutineStartLabel.place();
						codeStream.recordPositionsFrom(finallySequenceStartPC, this.finallyBlock.sourceStart);
						// subroutine
						this.finallyBlock.generateCode(this.scope, codeStream);
						break;
					case FINALLY_EMULATE_RET :
						// any exception handler
//						codeStream.store(this.anyExceptionVariable, false);
//						CaseLabel returnLocationLabel = recordReturnLocation(codeStream);
//						codeStream.generateInlinedValue(this.returnLocationsCount-1);
//						codeStream.store(this.returnAddressVariable, false);
//						codeStream.goto_(this.subRoutineStartLabel);
//						codeStream.recordPositionsFrom(finallySequenceStartPC, this.finallyBlock.sourceStart);
//						returnLocationLabel.place();
//						position = codeStream.position;						
//						codeStream.throwAnyException(this.anyExceptionVariable);
//						codeStream.recordPositionsFrom(position, this.finallyBlock.sourceEnd);
//						// subroutine
//						this.subRoutineStartLabel.place();
//						codeStream.pushOnStack(this.scope.getJavaLangThrowable());
//						position = codeStream.position;	
//						this.finallyBlock.generateCode(this.scope, codeStream);
//						position = codeStream.position;
//						// RET emulation
//						naturalExitReturnLocationLabel = recordReturnLocation(codeStream);
//						System.arraycopy(this.returnLocationLabels, 0, this.returnLocationLabels = new CaseLabel[this.returnLocationsCount], 0, this.returnLocationsCount);
//						int[] sortedIndexes = new int[this.returnLocationsCount];
//						for (int i = 0; i < this.returnLocationsCount; i++) {
//							sortedIndexes[i] = i;
//						}
//						defaultReturnLocationLabel = new CaseLabel(codeStream);
//						codeStream.load(this.returnAddressVariable);
//						codeStream.tableswitch(defaultReturnLocationLabel, 0, this.returnLocationsCount-1, sortedIndexes, sortedIndexes, this.returnLocationLabels);
//						codeStream.recordPositionsFrom(
//							position,
//							this.finallyBlock.sourceEnd);
						break;
						// the tableswitch bytecode is part of the subroutine						
				}
				// will naturally fall into subsequent code after subroutine invocation
				naturalExitLabel.place();
				if (requiresNaturalExit) {
					switch(finallyMode) {
						case FINALLY_SUBROUTINE :
							int position = codeStream.position;
							naturalExitExceptionHandler.placeStart();
							codeStream.jsr(this.subRoutineStartLabel);
							naturalExitExceptionHandler.placeEnd();
							codeStream.recordPositionsFrom(
								position,
								this.finallyBlock.sourceEnd);	
							break;
						case FINALLY_INLINE :
							// May loose some local variable initializations : affecting the local variable attributes
							// needed since any exception handler got inlined subroutine
							if (this.preTryInitStateIndex != -1) {
								codeStream.removeNotDefinitelyAssignedVariables(currentScope, this.preTryInitStateIndex);
							}
							// entire sequence for finally is associated to finally block
							this.finallyBlock.generateCode(this.scope, codeStream);
							break;
						case FINALLY_DOES_NOT_COMPLETE :
							break;
						case FINALLY_EMULATE_RET :
//							position = codeStream.position;
//							naturalExitExceptionHandler.placeStart();
//							codeStream.generateInlinedValue(this.returnLocationsCount);
//							codeStream.store(this.returnAddressVariable, false);
//							codeStream.goto_(this.subRoutineStartLabel);
//							naturalExitExceptionHandler.placeEnd();
//							naturalExitReturnLocationLabel.place();
//							codeStream.recordPositionsFrom(
//								position,
//								this.finallyBlock.sourceEnd);	
//							defaultReturnLocationLabel.place();
							break;
					}
				}
			} else {
				// no subroutine, simply position end label (natural exit == end)
				naturalExitLabel.place();
			}
		} else {
			// try block had no effect, only generate the body of the finally block if any
			if (this.subRoutineStartLabel != null) {
				this.finallyBlock.generateCode(this.scope, codeStream);
			}
		}
		// May loose some local variable initializations : affecting the local variable attributes
		if (this.mergedInitStateIndex != -1) {
			codeStream.removeNotDefinitelyAssignedVariables(currentScope, this.mergedInitStateIndex);
			codeStream.addDefinitelyAssignedVariables(currentScope, this.mergedInitStateIndex);
		}
		codeStream.recordPositionsFrom(pc, this.sourceStart);
	}

