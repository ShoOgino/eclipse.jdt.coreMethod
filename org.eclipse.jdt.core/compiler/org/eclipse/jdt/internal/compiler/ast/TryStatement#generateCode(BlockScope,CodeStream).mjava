	/**
	 * Try statement code generation
	 *
	 */
	public void generateCode(BlockScope currentScope, CodeStream codeStream) {

		if ((bits & IsReachableMASK) == 0) {
			return;
		}

		if (tryBlock.isEmptyBlock()) {
			if (subRoutineStartLabel != null) {
				// since not passing the finallyScope, the block generation will exitUserScope(finallyScope)
				finallyBlock.generateCode(scope, codeStream);
			}
			// May loose some local variable initializations : affecting the local variable attributes
			if (mergedInitStateIndex != -1) {
				codeStream.removeNotDefinitelyAssignedVariables(
					currentScope,
					mergedInitStateIndex);
			}
			// no local bytecode produced so no need for position remembering
			return;
		}
		int pc = codeStream.position;
		Label endLabel = new Label(codeStream);
		boolean requiresNaturalJsr = false;

		// preparing exception labels
		int maxCatches;
		ExceptionLabel[] exceptionLabels =
			new ExceptionLabel[maxCatches =
				catchArguments == null ? 0 : catchArguments.length];
		for (int i = 0; i < maxCatches; i++) {
			boolean preserveCurrentHandler =
				(preserveExceptionHandler[i
					/ ExceptionHandlingFlowContext.BitCacheSize]
						& (1 << (i % ExceptionHandlingFlowContext.BitCacheSize)))
					!= 0;
			if (preserveCurrentHandler) {
				exceptionLabels[i] =
					new ExceptionLabel(
						codeStream,
						(ReferenceBinding) catchArguments[i].binding.type);
			}
		}
		if (subRoutineStartLabel != null) {
			subRoutineStartLabel.codeStream = codeStream;
			this.enterAnyExceptionHandler(codeStream);
		}
		// generate the try block
		tryBlock.generateCode(scope, codeStream);
		boolean tryBlockHasSomeCode = codeStream.position != pc;
		// flag telling if some bytecodes were issued inside the try block

		// natural exit: only if necessary
		boolean nonReturningSubRoutine = subRoutineStartLabel != null && isSubRoutineEscaping; 
		if ((!tryBlockExit) && tryBlockHasSomeCode) {
			int position = codeStream.position;
			if (nonReturningSubRoutine) {
				codeStream.goto_(subRoutineStartLabel);
			} else {
				requiresNaturalJsr = true;
				codeStream.goto_(endLabel);
			}
			codeStream.updateLastRecordedEndPC(position);
			//goto is tagged as part of the try block
		}
		// place end positions of user-defined exception labels
		if (tryBlockHasSomeCode) {
			for (int i = 0; i < maxCatches; i++) {
				boolean preserveCurrentHandler =
					(preserveExceptionHandler[i / ExceptionHandlingFlowContext.BitCacheSize]
							& (1 << (i % ExceptionHandlingFlowContext.BitCacheSize))) != 0;
				if (preserveCurrentHandler) {
					exceptionLabels[i].placeEnd();
				}
			}
			/* generate sequence of handler, all starting by storing the TOS (exception
			thrown) into their own catch variables, the one specified in the source
			that must denote the handled exception.
			*/
			if (catchArguments == null) {
				this.exitAnyExceptionHandler();
			} else {
				for (int i = 0; i < maxCatches; i++) {
					boolean preserveCurrentHandler =
						(preserveExceptionHandler[i / ExceptionHandlingFlowContext.BitCacheSize]
								& (1 << (i % ExceptionHandlingFlowContext.BitCacheSize))) != 0;
					if (preserveCurrentHandler) {
						// May loose some local variable initializations : affecting the local variable attributes
						if (preTryInitStateIndex != -1) {
							codeStream.removeNotDefinitelyAssignedVariables(
								currentScope,
								preTryInitStateIndex);
						}
						exceptionLabels[i].place();
						codeStream.incrStackSize(1);
						// optimizing the case where the exception variable is not actually used
						LocalVariableBinding catchVar;
						int varPC = codeStream.position;
						if ((catchVar = catchArguments[i].binding).resolvedPosition != -1) {
							codeStream.store(catchVar, false);
							catchVar.recordInitializationStartPC(codeStream.position);
							codeStream.addVisibleLocalVariable(catchVar);
						} else {
							codeStream.pop();
						}
						codeStream.recordPositionsFrom(varPC, catchArguments[i].sourceStart);
						// Keep track of the pcs at diverging point for computing the local attribute
						// since not passing the catchScope, the block generation will exitUserScope(catchScope)
						catchBlocks[i].generateCode(scope, codeStream);
					}
					if (i == maxCatches - 1) {
						this.exitAnyExceptionHandler();
					}
					if (!catchExits[i] && preserveCurrentHandler) {
						if (nonReturningSubRoutine) {
							codeStream.goto_(subRoutineStartLabel);
						} else {
							requiresNaturalJsr = true;
							codeStream.goto_(endLabel);
						}
					}
				}
			}
			// extra handler for trailing natural exit (will be fixed up later on when natural exit is generated below)
			ExceptionLabel naturalExitExceptionHandler = null;
			if (requiresNaturalJsr) {
				naturalExitExceptionHandler = this.enterAnyExceptionHandler(codeStream);
			}
						
			// addition of a special handler so as to ensure that any uncaught exception (or exception thrown
			// inside catch blocks) will run the finally block
			int finallySequenceStartPC = codeStream.position;
			if (subRoutineStartLabel != null) {
				// the additional handler is doing: jsr finallyBlock and rethrow TOS-exception
				this.placeAllAnyExceptionHandlers();

				if (preTryInitStateIndex != -1) {
					// reset initialization state, as for a normal catch block
					codeStream.removeNotDefinitelyAssignedVariables(
						currentScope,
						preTryInitStateIndex);
				}

				codeStream.incrStackSize(1);
				if (nonReturningSubRoutine) {
					codeStream.pop();
					// "if subroutine cannot return, no need to jsr/jump to subroutine since it will be entered in sequence
				} else {
					codeStream.store(anyExceptionVariable, false);
					codeStream.jsr(subRoutineStartLabel);
					codeStream.load(anyExceptionVariable);
					codeStream.athrow();
				}
				// end of catch sequence, place label that will correspond to the finally block beginning, or end of statement	
				subRoutineStartLabel.place();
				if (!nonReturningSubRoutine) {
					codeStream.incrStackSize(1);
					codeStream.store(returnAddressVariable, false);
				}
				codeStream.recordPositionsFrom(finallySequenceStartPC, finallyBlock.sourceStart);
				// entire sequence for finally is associated to finally block
				finallyBlock.generateCode(scope, codeStream);
				if (!nonReturningSubRoutine) {
					int position = codeStream.position;
					codeStream.ret(returnAddressVariable.resolvedPosition);
					codeStream.updateLastRecordedEndPC(position);
					codeStream.recordPositionsFrom(
						position,
						finallyBlock.sourceEnd);
					// the ret bytecode is part of the subroutine
				}
				// will naturally fall into subsequent code after subroutine invocation
				endLabel.place();
				if (naturalExitExceptionHandler != null) {
					int position = codeStream.position;					
					// fix up natural exit handler
					naturalExitExceptionHandler.placeStart();
					codeStream.jsr(subRoutineStartLabel);
					naturalExitExceptionHandler.placeEnd();
					codeStream.recordPositionsFrom(
						position,
						finallyBlock.sourceStart);					
				}
			} else {
				// no subroutine, simply position end label
				endLabel.place();
			}
		} else {
			// try block had no effect, only generate the body of the finally block if any
			endLabel.place();
			if (subRoutineStartLabel != null) {
				finallyBlock.generateCode(scope, codeStream);
			}
		}
		// May loose some local variable initializations : affecting the local variable attributes
		if (mergedInitStateIndex != -1) {
			codeStream.removeNotDefinitelyAssignedVariables(
				currentScope,
				mergedInitStateIndex);
			codeStream.addDefinitelyAssignedVariables(currentScope, mergedInitStateIndex);
		}
		codeStream.recordPositionsFrom(pc, this.sourceStart);
	}

