	public ConstructorDeclaration getConstructor(Parser parser) {
		ConstructorDeclaration cd = null;
		//if a constructor has not the name of the type,
		//convert it into a method with 'null' as its return type
		boolean hasConstructor = true;
		if (this.methods != null) {
			for (int i = this.methods.length; --i >= 0;) {
				AbstractMethodDeclaration am;
				if ((am = this.methods[i]).isConstructor()) {
					if (!CharOperation.equals(am.selector, this.name)) {
						// the constructor was in fact a method with no return type
						// unless an explicit constructor call was supplied
						ConstructorDeclaration c = (ConstructorDeclaration) am;
						if (c.constructorCall == null || c.constructorCall.isImplicitSuper()) { //changed to a method
							MethodDeclaration m = parser.convertToMethodDeclaration(c, this.compilationResult);
							this.methods[i] = m;
						}
					} else {
						if (am instanceof CompactConstructorDeclaration)
							return (CompactConstructorDeclaration) am;
						// now we are looking at a "normal" constructor
						if (this.args == null) {
							if (am.arguments == null)
								return (ConstructorDeclaration) am;
							continue; // else check next one.
						} else {
							if (am.arguments == null || am.arguments.length != this.args.length)
								continue;
							for (int j = 0; j < this.args.length; j++) {
								if (!this.args[j].equals(am.arguments[j])) {
									hasConstructor = false;
									break;
								}
							}
							if (hasConstructor)
								return (ConstructorDeclaration) am;
						}
						
					}
				}
			}
		}
		return cd;
	}

