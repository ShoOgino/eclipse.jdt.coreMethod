	public void traverse(MethodBinding methodBinding, int maxLocals, byte[] bytecodes, int codeOffset, int codeLength, ArrayList frames, boolean isClinit) {
		StackMapFrameCodeStream stackMapFrameCodeStream = (StackMapFrameCodeStream) this.codeStream;
		int[] framePositions = stackMapFrameCodeStream.getFramePositions();
		int pc = codeOffset;
		int index;
		int[] constantPoolOffsets = this.constantPool.offsets;
		byte[] poolContents = this.constantPool.poolContent;

		// set initial values for frame positions
		int indexInFramePositions = 0;
		int framePositionsLength = framePositions.length;
		int currentFramePosition = framePositions[0];

		// set initial values for stack markers
		int indexInStackMarkers = 0;
		ArrayList stackMarkers = stackMapFrameCodeStream.stackMarkers;
		boolean hasStackMarkers = stackMarkers != null && stackMarkers.size() != 0;
		StackMarker[] markers = null;
		int markersLength = 0;
		StackMarker marker = null;
		if (hasStackMarkers) {
			markersLength = stackMarkers.size();
			stackMarkers.toArray(markers = new StackMarker[markersLength]);
			marker = markers[0];
		}

		// set initial values for exception markers
		int indexInExceptionMarkers = 0;
		ExceptionMarker[] exceptionMarkers= stackMapFrameCodeStream.getExceptionMarkers();
		boolean hasExceptionMarkers = exceptionMarkers != null && exceptionMarkers.length != 0;
		int exceptionsMarkersLength = 0;
		ExceptionMarker exceptionMarker = null;
		if (hasExceptionMarkers) {
			exceptionsMarkersLength = exceptionMarkers.length;
			exceptionMarker = exceptionMarkers[0];
		}

		StackMapFrame frame = new StackMapFrame(maxLocals);
		if (!isClinit) {
			initializeDefaultLocals(frame, methodBinding, maxLocals, codeLength);
		}
		frame.pc = -1;
		frames.add(frame.duplicate());
		while (true) {
			int currentPC = pc - codeOffset;
			if (hasStackMarkers && marker.pc == currentPC) {
				TypeBinding typeBinding = marker.typeBinding;
				if (typeBinding != null) {
					if (marker.delta > 0) {
						frame.addStackItem(new VerificationTypeInfo(typeBinding));
					} else {
						frame.stackItems[frame.numberOfStackItems - 1] = new VerificationTypeInfo(typeBinding);
					}
				} else {
					frame.numberOfStackItems--;
				}
				indexInStackMarkers++;
				if (indexInStackMarkers < markersLength) {
					marker = markers[indexInStackMarkers];
				} else {
					hasStackMarkers = false;
				}
			}
			if (hasExceptionMarkers && exceptionMarker.pc == currentPC) {
				frame.addStackItem(new VerificationTypeInfo(0, VerificationTypeInfo.ITEM_OBJECT, exceptionMarker.constantPoolName));
				indexInExceptionMarkers++;
				if (indexInExceptionMarkers < exceptionsMarkersLength) {
					exceptionMarker = exceptionMarkers[indexInExceptionMarkers];
				} else {
					hasExceptionMarkers = false;
				}
			}
			if (currentFramePosition < currentPC) {
				do {
					indexInFramePositions++;
					if (indexInFramePositions < framePositionsLength) {
						currentFramePosition = framePositions[indexInFramePositions];
					} else {
						// no more frame to generate
						return;
					}
				} while (currentFramePosition < currentPC);
			}
			if (currentFramePosition == currentPC) {
				// need to build a new frame and create a stack map attribute entry
				StackMapFrame currentFrame = frame.duplicate();
				currentFrame.pc = currentPC;
				// initialize locals
				initializeLocals(isClinit ? true : methodBinding.isStatic(), currentPC, currentFrame);
				// insert a new frame
				frames.add(currentFrame);
				indexInFramePositions++;
				if (indexInFramePositions < framePositionsLength) {
					currentFramePosition = framePositions[indexInFramePositions];
				} else {
					// no more frame to generate
					return;
				}
			}
			int opcode = u1At(bytecodes, 0, pc);
			switch (opcode) {
				case IOpcodeMnemonics.NOP:
					pc++;
					break;
				case IOpcodeMnemonics.ACONST_NULL:
					frame.addStackItem(TypeBinding.NULL);
					pc++;
					break;
				case IOpcodeMnemonics.ICONST_M1:
					frame.addStackItem(TypeBinding.INT);
					pc++;
					break;
				case IOpcodeMnemonics.ICONST_0:
					frame.addStackItem(TypeBinding.INT);
					pc++;
					break;
				case IOpcodeMnemonics.ICONST_1:
					frame.addStackItem(TypeBinding.INT);
					pc++;
					break;
				case IOpcodeMnemonics.ICONST_2:
					frame.addStackItem(TypeBinding.INT);
					pc++;
					break;
				case IOpcodeMnemonics.ICONST_3:
					frame.addStackItem(TypeBinding.INT);
					pc++;
					break;
				case IOpcodeMnemonics.ICONST_4:
					frame.addStackItem(TypeBinding.INT);
					pc++;
					break;
				case IOpcodeMnemonics.ICONST_5:
					frame.addStackItem(TypeBinding.INT);
					pc++;
					break;
				case IOpcodeMnemonics.LCONST_0:
					frame.addStackItem(TypeBinding.LONG);
					pc++;
					break;
				case IOpcodeMnemonics.LCONST_1:
					frame.addStackItem(TypeBinding.LONG);
					pc++;
					break;
				case IOpcodeMnemonics.FCONST_0:
					frame.addStackItem(TypeBinding.FLOAT);
					pc++;
					break;
				case IOpcodeMnemonics.FCONST_1:
					frame.addStackItem(TypeBinding.FLOAT);
					pc++;
					break;
				case IOpcodeMnemonics.FCONST_2:
					frame.addStackItem(TypeBinding.FLOAT);
					pc++;
					break;
				case IOpcodeMnemonics.DCONST_0:
					frame.addStackItem(TypeBinding.DOUBLE);
					pc++;
					break;
				case IOpcodeMnemonics.DCONST_1:
					frame.addStackItem(TypeBinding.DOUBLE);
					pc++;
					break;
				case IOpcodeMnemonics.BIPUSH:
					frame.addStackItem(TypeBinding.BYTE);
					pc += 2;
					break;
				case IOpcodeMnemonics.SIPUSH:
					frame.addStackItem(TypeBinding.SHORT);
					pc += 3;
					break;
				case IOpcodeMnemonics.LDC:
					index = u1At(bytecodes, 1, pc);
					switch (u1At(poolContents, 0, constantPoolOffsets[index])) {
						case ClassFileConstants.StringTag:
							frame
									.addStackItem(new VerificationTypeInfo(
											TypeIds.T_JavaLangString,
											ConstantPool.JavaLangStringConstantPoolName));
							break;
						case ClassFileConstants.IntegerTag:
							frame.addStackItem(TypeBinding.INT);
							break;
						case ClassFileConstants.FloatTag:
							frame.addStackItem(TypeBinding.FLOAT);
							break;
						case ClassFileConstants.ClassTag:
							int utf8index = u2At(poolContents, 1,
									constantPoolOffsets[index]);
							char[] classSignature = utf8At(poolContents,
									constantPoolOffsets[utf8index] + 3, u2At(
											poolContents, 1,
											constantPoolOffsets[utf8index]));
							frame.addStackItem(new VerificationTypeInfo(0, classSignature));
					}
					pc += 2;
					break;
				case IOpcodeMnemonics.LDC_W:
					index = u2At(bytecodes, 1, pc);
					switch (u1At(poolContents, 0, constantPoolOffsets[index])) {
						case ClassFileConstants.StringTag:
							frame
									.addStackItem(new VerificationTypeInfo(
											TypeIds.T_JavaLangString,
											ConstantPool.JavaLangStringConstantPoolName));
							break;
						case ClassFileConstants.IntegerTag:
							frame.addStackItem(TypeBinding.INT);
							break;
						case ClassFileConstants.FloatTag:
							frame.addStackItem(TypeBinding.FLOAT);
							break;
						case ClassFileConstants.ClassTag:
							int utf8index = u2At(poolContents, 1,
									constantPoolOffsets[index]);
							char[] classSignature = utf8At(poolContents,
									constantPoolOffsets[utf8index] + 3, u2At(
											poolContents, 1,
											constantPoolOffsets[utf8index]));
							frame.addStackItem(new VerificationTypeInfo(0,
									classSignature));
					}
					pc += 3;
					break;
				case IOpcodeMnemonics.LDC2_W:
					index = u2At(bytecodes, 1, pc);
					switch (u1At(poolContents, 0, constantPoolOffsets[index])) {
						case ClassFileConstants.DoubleTag:
							frame.addStackItem(TypeBinding.DOUBLE);
							break;
						case ClassFileConstants.LongTag:
							frame.addStackItem(TypeBinding.LONG);
							break;
					}
					pc += 3;
					break;
				case IOpcodeMnemonics.ILOAD:
					frame.addStackItem(TypeBinding.INT);
					pc += 2;
					break;
				case IOpcodeMnemonics.LLOAD:
					frame.addStackItem(TypeBinding.LONG);
					pc += 2;
					break;
				case IOpcodeMnemonics.FLOAD:
					frame.addStackItem(TypeBinding.FLOAT);
					pc += 2;
					break;
				case IOpcodeMnemonics.DLOAD:
					frame.addStackItem(TypeBinding.DOUBLE);
					pc += 2;
					break;
				case IOpcodeMnemonics.ALOAD:
					index = u1At(bytecodes, 1, pc);
					VerificationTypeInfo localsN = frame.locals[index];
					if (localsN == null) {
						localsN = retrieveLocal(currentPC, index);
					}
					frame.addStackItem(localsN);
					pc += 2;
					break;
				case IOpcodeMnemonics.ILOAD_0:
					frame.addStackItem(TypeBinding.INT);
					pc++;
					break;
				case IOpcodeMnemonics.ILOAD_1:
					frame.addStackItem(TypeBinding.INT);
					pc++;
					break;
				case IOpcodeMnemonics.ILOAD_2:
					frame.addStackItem(TypeBinding.INT);
					pc++;
					break;
				case IOpcodeMnemonics.ILOAD_3:
					frame.addStackItem(TypeBinding.INT);
					pc++;
					break;
				case IOpcodeMnemonics.LLOAD_0:
					frame.addStackItem(TypeBinding.LONG);
					pc++;
					break;
				case IOpcodeMnemonics.LLOAD_1:
					frame.addStackItem(TypeBinding.LONG);
					pc++;
					break;
				case IOpcodeMnemonics.LLOAD_2:
					frame.addStackItem(TypeBinding.LONG);
					pc++;
					break;
				case IOpcodeMnemonics.LLOAD_3:
					frame.addStackItem(TypeBinding.LONG);
					pc++;
					break;
				case IOpcodeMnemonics.FLOAD_0:
					frame.addStackItem(TypeBinding.FLOAT);
					pc++;
					break;
				case IOpcodeMnemonics.FLOAD_1:
					frame.addStackItem(TypeBinding.FLOAT);
					pc++;
					break;
				case IOpcodeMnemonics.FLOAD_2:
					frame.addStackItem(TypeBinding.FLOAT);
					pc++;
					break;
				case IOpcodeMnemonics.FLOAD_3:
					frame.addStackItem(TypeBinding.FLOAT);
					pc++;
					break;
				case IOpcodeMnemonics.DLOAD_0:
					frame.addStackItem(TypeBinding.DOUBLE);
					pc++;
					break;
				case IOpcodeMnemonics.DLOAD_1:
					frame.addStackItem(TypeBinding.DOUBLE);
					pc++;
					break;
				case IOpcodeMnemonics.DLOAD_2:
					frame.addStackItem(TypeBinding.DOUBLE);
					pc++;
					break;
				case IOpcodeMnemonics.DLOAD_3:
					frame.addStackItem(TypeBinding.DOUBLE);
					pc++;
					break;
				case IOpcodeMnemonics.ALOAD_0:
					VerificationTypeInfo locals0 = frame.locals[0];
					// special case to handle uninitialized object
					if (locals0 == null) {
						locals0 = retrieveLocal(currentPC, 0);
					}
					frame.addStackItem(locals0);
					pc++;
					break;
				case IOpcodeMnemonics.ALOAD_1:
					VerificationTypeInfo locals1 = retrieveLocal(currentPC, 1);
					frame.addStackItem(locals1);
					pc++;
					break;
				case IOpcodeMnemonics.ALOAD_2:
					VerificationTypeInfo locals2 = retrieveLocal(currentPC, 2);
					frame.addStackItem(locals2);
					pc++;
					break;
				case IOpcodeMnemonics.ALOAD_3:
					VerificationTypeInfo locals3 = retrieveLocal(currentPC, 3);
					frame.addStackItem(locals3);
					pc++;
					break;
				case IOpcodeMnemonics.IALOAD:
					frame.numberOfStackItems -=2;
					frame.addStackItem(TypeBinding.INT);
					pc++;
					break;
				case IOpcodeMnemonics.LALOAD:
					frame.numberOfStackItems -=2;
					frame.addStackItem(TypeBinding.LONG);
					pc++;
					break;
				case IOpcodeMnemonics.FALOAD:
					frame.numberOfStackItems -=2;
					frame.addStackItem(TypeBinding.FLOAT);
					pc++;
					break;
				case IOpcodeMnemonics.DALOAD:
					frame.numberOfStackItems -=2;
					frame.addStackItem(TypeBinding.DOUBLE);
					pc++;
					break;
				case IOpcodeMnemonics.AALOAD:
					frame.numberOfStackItems--;
					frame.replaceWithElementType();
					pc++;
					break;
				case IOpcodeMnemonics.BALOAD:
					frame.numberOfStackItems -=2;
					frame.addStackItem(TypeBinding.BYTE);
					pc++;
					break;
				case IOpcodeMnemonics.CALOAD:
					frame.numberOfStackItems -=2;
					frame.addStackItem(TypeBinding.CHAR);
					pc++;
					break;
				case IOpcodeMnemonics.SALOAD:
					frame.numberOfStackItems -=2;
					frame.addStackItem(TypeBinding.SHORT);
					pc++;
					break;
				case IOpcodeMnemonics.ISTORE:
					frame.numberOfStackItems--;
					pc += 2;
					break;
				case IOpcodeMnemonics.LSTORE:
					frame.numberOfStackItems--;
					pc += 2;
					break;
				case IOpcodeMnemonics.FSTORE:
					frame.numberOfStackItems--;
					pc += 2;
					break;
				case IOpcodeMnemonics.DSTORE:
					frame.numberOfStackItems--;
					pc += 2;
					break;
				case IOpcodeMnemonics.ASTORE:
					index = u1At(bytecodes, 1, pc);
					frame.numberOfStackItems--;
					pc += 2;
					break;
				case IOpcodeMnemonics.ISTORE_0:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.ISTORE_1:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.ISTORE_2:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.ISTORE_3:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.LSTORE_0:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.LSTORE_1:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.LSTORE_2:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.LSTORE_3:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.FSTORE_0:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.FSTORE_1:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.FSTORE_2:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.FSTORE_3:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.DSTORE_0:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.DSTORE_1:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.DSTORE_2:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.DSTORE_3:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.ASTORE_0:
					frame.locals[0] = frame.stackItems[frame.numberOfStackItems - 1];
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.ASTORE_1:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.ASTORE_2:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.ASTORE_3:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.IASTORE:
					frame.numberOfStackItems-=3;
					pc++;
					break;
				case IOpcodeMnemonics.LASTORE:
					frame.numberOfStackItems-=3;
					pc++;
					break;
				case IOpcodeMnemonics.FASTORE:
					frame.numberOfStackItems-=3;
					pc++;
					break;
				case IOpcodeMnemonics.DASTORE:
					frame.numberOfStackItems-=3;
					pc++;
					break;
				case IOpcodeMnemonics.AASTORE:
					frame.numberOfStackItems-=3;
					pc++;
					break;
				case IOpcodeMnemonics.BASTORE:
					frame.numberOfStackItems-=3;
					pc++;
					break;
				case IOpcodeMnemonics.CASTORE:
					frame.numberOfStackItems-=3;
					pc++;
					break;
				case IOpcodeMnemonics.SASTORE:
					frame.numberOfStackItems-=3;
					pc++;
					break;
				case IOpcodeMnemonics.POP:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.POP2:
					int numberOfStackItems = frame.numberOfStackItems;
					switch(frame.stackItems[numberOfStackItems - 1].id()) {
						case TypeIds.T_long :
						case TypeIds.T_double :
							frame.numberOfStackItems--;
							break;
						default:
							frame.numberOfStackItems -= 2;
					}
					pc++;
					break;
				case IOpcodeMnemonics.DUP:
					frame.addStackItem(frame.stackItems[frame.numberOfStackItems - 1]);
					pc++;
					break;
				case IOpcodeMnemonics.DUP_X1:
					VerificationTypeInfo info = frame.stackItems[frame.numberOfStackItems - 1];
					frame.numberOfStackItems--;
					VerificationTypeInfo info2 = frame.stackItems[frame.numberOfStackItems - 1];
					frame.numberOfStackItems--;
					frame.addStackItem(info);
					frame.addStackItem(info2);
					frame.addStackItem(info);
					pc++;
					break;
				case IOpcodeMnemonics.DUP_X2:
					info = frame.stackItems[frame.numberOfStackItems - 1];
					frame.numberOfStackItems--;
					info2 = frame.stackItems[frame.numberOfStackItems - 1];
					frame.numberOfStackItems--;
					switch(info2.id()) {
						case TypeIds.T_long :
						case TypeIds.T_double :
							frame.addStackItem(info);
							frame.addStackItem(info2);
							frame.addStackItem(info);
							break;
						default:
							numberOfStackItems = frame.numberOfStackItems;
							VerificationTypeInfo info3 = frame.stackItems[numberOfStackItems - 1];
							frame.numberOfStackItems--;
							frame.addStackItem(info);
							frame.addStackItem(info3);
							frame.addStackItem(info2);
							frame.addStackItem(info);
					}
					pc++;
					break;
				case IOpcodeMnemonics.DUP2:
					info = frame.stackItems[frame.numberOfStackItems - 1];
					frame.numberOfStackItems--;
					switch(info.id()) {
						case TypeIds.T_double :
						case TypeIds.T_long :
							frame.addStackItem(info);
							frame.addStackItem(info);
							break;
						default:
							info2 = frame.stackItems[frame.numberOfStackItems - 1];
							frame.numberOfStackItems--;
							frame.addStackItem(info2);
							frame.addStackItem(info);
							frame.addStackItem(info2);
							frame.addStackItem(info);
					}
					pc++;
					break;
				case IOpcodeMnemonics.DUP2_X1:
					info = frame.stackItems[frame.numberOfStackItems - 1];
					frame.numberOfStackItems--;
					info2 = frame.stackItems[frame.numberOfStackItems - 1];
					frame.numberOfStackItems--;
					switch(info.id()) {
						case TypeIds.T_double :
						case TypeIds.T_long :
							frame.addStackItem(info);
							frame.addStackItem(info2);
							frame.addStackItem(info);
							break;
						default:
							VerificationTypeInfo info3 = frame.stackItems[frame.numberOfStackItems - 1];
							frame.numberOfStackItems--;
							frame.addStackItem(info2);
							frame.addStackItem(info);
							frame.addStackItem(info3);
							frame.addStackItem(info2);
							frame.addStackItem(info);
					}
					pc++;
					break;
				case IOpcodeMnemonics.DUP2_X2:
					numberOfStackItems = frame.numberOfStackItems;
					info = frame.stackItems[numberOfStackItems - 1];
					frame.numberOfStackItems--;
					info2 = frame.stackItems[frame.numberOfStackItems - 1];
					frame.numberOfStackItems--;
					switch(info.id()) {
						case TypeIds.T_long :
						case TypeIds.T_double :
							switch(info2.id()) {
								case TypeIds.T_long :
								case TypeIds.T_double :
									// form 4
									frame.addStackItem(info);
									frame.addStackItem(info2);
									frame.addStackItem(info);
									break;
								default:
									// form 2
									numberOfStackItems = frame.numberOfStackItems;
									VerificationTypeInfo info3 = frame.stackItems[numberOfStackItems - 1];
									frame.numberOfStackItems--;
									frame.addStackItem(info);
									frame.addStackItem(info3);
									frame.addStackItem(info2);
									frame.addStackItem(info);
							}
							break;
						default:
							numberOfStackItems = frame.numberOfStackItems;
							VerificationTypeInfo info3 = frame.stackItems[numberOfStackItems - 1];
							frame.numberOfStackItems--;
							switch(info3.id()) {
								case TypeIds.T_long :
								case TypeIds.T_double :
									// form 3
									frame.addStackItem(info2);
									frame.addStackItem(info);
									frame.addStackItem(info3);
									frame.addStackItem(info2);
									frame.addStackItem(info);
									break;
								default:
									// form 1
									numberOfStackItems = frame.numberOfStackItems;
									VerificationTypeInfo info4 = frame.stackItems[numberOfStackItems - 1];
									frame.numberOfStackItems--;
									frame.addStackItem(info2);
									frame.addStackItem(info);
									frame.addStackItem(info4);
									frame.addStackItem(info3);
									frame.addStackItem(info2);
									frame.addStackItem(info);
							}
					}
					pc++;
					break;
				case IOpcodeMnemonics.SWAP:
					numberOfStackItems = frame.numberOfStackItems;
					info = frame.stackItems[numberOfStackItems - 1];
					info2 = frame.stackItems[numberOfStackItems - 2];
					frame.stackItems[numberOfStackItems - 1] = info2;
					frame.stackItems[numberOfStackItems - 2] = info;
					pc++;
					break;
				case IOpcodeMnemonics.IADD:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.LADD:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.FADD:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.DADD:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.ISUB:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.LSUB:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.FSUB:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.DSUB:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.IMUL:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.LMUL:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.FMUL:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.DMUL:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.IDIV:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.LDIV:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.FDIV:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.DDIV:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.IREM:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.LREM:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.FREM:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.DREM:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.INEG:
					pc++;
					break;
				case IOpcodeMnemonics.LNEG:
					pc++;
					break;
				case IOpcodeMnemonics.FNEG:
					pc++;
					break;
				case IOpcodeMnemonics.DNEG:
					pc++;
					break;
				case IOpcodeMnemonics.ISHL:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.LSHL:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.ISHR:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.LSHR:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.IUSHR:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.LUSHR:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.IAND:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.LAND:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.IOR:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.LOR:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.IXOR:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.LXOR:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.IINC:
					pc += 3;
					break;
				case IOpcodeMnemonics.I2L:
					frame.stackItems[frame.numberOfStackItems - 1] = new VerificationTypeInfo(TypeBinding.LONG);
					pc++;
					break;
				case IOpcodeMnemonics.I2F:
					frame.stackItems[frame.numberOfStackItems - 1] = new VerificationTypeInfo(TypeBinding.FLOAT);
					pc++;
					break;
				case IOpcodeMnemonics.I2D:
					frame.stackItems[frame.numberOfStackItems - 1] = new VerificationTypeInfo(TypeBinding.DOUBLE);
					pc++;
					break;
				case IOpcodeMnemonics.L2I:
					frame.stackItems[frame.numberOfStackItems - 1] = new VerificationTypeInfo(TypeBinding.INT);
					pc++;
					break;
				case IOpcodeMnemonics.L2F:
					frame.stackItems[frame.numberOfStackItems - 1] = new VerificationTypeInfo(TypeBinding.FLOAT);
					pc++;
					break;
				case IOpcodeMnemonics.L2D:
					frame.stackItems[frame.numberOfStackItems - 1] = new VerificationTypeInfo(TypeBinding.DOUBLE);
					pc++;
					break;
				case IOpcodeMnemonics.F2I:
					frame.stackItems[frame.numberOfStackItems - 1] = new VerificationTypeInfo(TypeBinding.INT);
					pc++;
					break;
				case IOpcodeMnemonics.F2L:
					frame.stackItems[frame.numberOfStackItems - 1] = new VerificationTypeInfo(TypeBinding.LONG);
					pc++;
					break;
				case IOpcodeMnemonics.F2D:
					frame.stackItems[frame.numberOfStackItems - 1] = new VerificationTypeInfo(TypeBinding.DOUBLE);
					pc++;
					break;
				case IOpcodeMnemonics.D2I:
					frame.stackItems[frame.numberOfStackItems - 1] = new VerificationTypeInfo(TypeBinding.INT);
					pc++;
					break;
				case IOpcodeMnemonics.D2L:
					frame.stackItems[frame.numberOfStackItems - 1] = new VerificationTypeInfo(TypeBinding.LONG);
					pc++;
					break;
				case IOpcodeMnemonics.D2F:
					frame.stackItems[frame.numberOfStackItems - 1] = new VerificationTypeInfo(TypeBinding.FLOAT);
					pc++;
					break;
				case IOpcodeMnemonics.I2B:
					frame.stackItems[frame.numberOfStackItems - 1] = new VerificationTypeInfo(TypeBinding.BYTE);
					pc++;
					break;
				case IOpcodeMnemonics.I2C:
					frame.stackItems[frame.numberOfStackItems - 1] = new VerificationTypeInfo(TypeBinding.CHAR);
					pc++;
					break;
				case IOpcodeMnemonics.I2S:
					frame.stackItems[frame.numberOfStackItems - 1] = new VerificationTypeInfo(TypeBinding.SHORT);
					pc++;
					break;
				case IOpcodeMnemonics.LCMP:
					frame.numberOfStackItems-=2;
					frame.addStackItem(TypeBinding.INT);
					pc++;
					break;
				case IOpcodeMnemonics.FCMPL:
					frame.numberOfStackItems-=2;
					frame.addStackItem(TypeBinding.INT);
					pc++;
					break;
				case IOpcodeMnemonics.FCMPG:
					frame.numberOfStackItems-=2;
					frame.addStackItem(TypeBinding.INT);
					pc++;
					break;
				case IOpcodeMnemonics.DCMPL:
					frame.numberOfStackItems-=2;
					frame.addStackItem(TypeBinding.INT);
					pc++;
					break;
				case IOpcodeMnemonics.DCMPG:
					frame.numberOfStackItems-=2;
					frame.addStackItem(TypeBinding.INT);
					pc++;
					break;
				case IOpcodeMnemonics.IFEQ:
					frame.numberOfStackItems--;
					pc += 3;
					break;
				case IOpcodeMnemonics.IFNE:
					frame.numberOfStackItems--;
					pc += 3;
					break;
				case IOpcodeMnemonics.IFLT:
					frame.numberOfStackItems--;
					pc += 3;
					break;
				case IOpcodeMnemonics.IFGE:
					frame.numberOfStackItems--;
					pc += 3;
					break;
				case IOpcodeMnemonics.IFGT:
					frame.numberOfStackItems--;
					pc += 3;
					break;
				case IOpcodeMnemonics.IFLE:
					frame.numberOfStackItems--;
					pc += 3;
					break;
				case IOpcodeMnemonics.IF_ICMPEQ:
					frame.numberOfStackItems -= 2;
					pc += 3;
					break;
				case IOpcodeMnemonics.IF_ICMPNE:
					frame.numberOfStackItems -= 2;
					pc += 3;
					break;
				case IOpcodeMnemonics.IF_ICMPLT:
					frame.numberOfStackItems -= 2;
					pc += 3;
					break;
				case IOpcodeMnemonics.IF_ICMPGE:
					frame.numberOfStackItems -= 2;
					pc += 3;
					break;
				case IOpcodeMnemonics.IF_ICMPGT:
					frame.numberOfStackItems -= 2;
					pc += 3;
					break;
				case IOpcodeMnemonics.IF_ICMPLE:
					frame.numberOfStackItems -= 2;
					pc += 3;
					break;
				case IOpcodeMnemonics.IF_ACMPEQ:
					frame.numberOfStackItems -= 2;
					pc += 3;
					break;
				case IOpcodeMnemonics.IF_ACMPNE:
					frame.numberOfStackItems -= 2;
					pc += 3;
					break;
				case IOpcodeMnemonics.GOTO:
					pc += 3;
					break;
				case IOpcodeMnemonics.TABLESWITCH:
					pc++;
					while (((pc - codeOffset) & 0x03) != 0) {
						pc++;
					}
					pc += 4; // default
					int low = i4At(bytecodes, 0, pc);
					pc += 4;
					int high = i4At(bytecodes, 0, pc);
					pc += 4;
					int length = high - low + 1;
					pc += (length * 4);
					frame.numberOfStackItems--;
					break;
				case IOpcodeMnemonics.LOOKUPSWITCH:
					pc++;
					while (((pc - codeOffset) & 0x03) != 0) {
						pc++;
					}
					pc += 4; // default
					int npairs = (int) u4At(bytecodes, 0, pc);
					pc += (4 + npairs * 8);
					frame.numberOfStackItems--;
					break;
				case IOpcodeMnemonics.IRETURN:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.LRETURN:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.FRETURN:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.DRETURN:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.ARETURN:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.RETURN:
					pc++;
					break;
				case IOpcodeMnemonics.GETSTATIC:
					index = u2At(bytecodes, 1, pc);
					int nameAndTypeIndex = u2At(poolContents, 3,
							constantPoolOffsets[index]);
					int utf8index = u2At(poolContents, 3,
							constantPoolOffsets[nameAndTypeIndex]);
					char[] descriptor = utf8At(poolContents,
							constantPoolOffsets[utf8index] + 3, u2At(
									poolContents, 1,
									constantPoolOffsets[utf8index]));
					if (descriptor.length == 1) {
						// base type
						switch(descriptor[0]) {
							case 'Z':
								frame.addStackItem(TypeBinding.BOOLEAN);
								break;
							case 'B':
								frame.addStackItem(TypeBinding.BYTE);
								break;
							case 'C':
								frame.addStackItem(TypeBinding.CHAR);
								break;
							case 'D':
								frame.addStackItem(TypeBinding.DOUBLE);
								break;
							case 'F':
								frame.addStackItem(TypeBinding.FLOAT);
								break;
							case 'I':
								frame.addStackItem(TypeBinding.INT);
								break;
							case 'J':
								frame.addStackItem(TypeBinding.LONG);
								break;
							case 'S':
								frame.addStackItem(TypeBinding.SHORT);
								break;
						}
					} else if (descriptor[0] == '[') {
						frame.addStackItem(new VerificationTypeInfo(0, descriptor));
					} else {
						frame.addStackItem(new VerificationTypeInfo(0, CharOperation.subarray(descriptor, 1, descriptor.length - 1)));
					}
					pc += 3;
					break;
				case IOpcodeMnemonics.PUTSTATIC:
					frame.numberOfStackItems--;
					pc += 3;
					break;
				case IOpcodeMnemonics.GETFIELD:
					index = u2At(bytecodes, 1, pc);
					nameAndTypeIndex = u2At(poolContents, 3,
							constantPoolOffsets[index]);
					utf8index = u2At(poolContents, 3,
							constantPoolOffsets[nameAndTypeIndex]);
					descriptor = utf8At(poolContents,
							constantPoolOffsets[utf8index] + 3, u2At(
									poolContents, 1,
									constantPoolOffsets[utf8index]));
					frame.numberOfStackItems--;
					if (descriptor.length == 1) {
						// base type
						switch(descriptor[0]) {
							case 'Z':
								frame.addStackItem(TypeBinding.BOOLEAN);
								break;
							case 'B':
								frame.addStackItem(TypeBinding.BYTE);
								break;
							case 'C':
								frame.addStackItem(TypeBinding.CHAR);
								break;
							case 'D':
								frame.addStackItem(TypeBinding.DOUBLE);
								break;
							case 'F':
								frame.addStackItem(TypeBinding.FLOAT);
								break;
							case 'I':
								frame.addStackItem(TypeBinding.INT);
								break;
							case 'J':
								frame.addStackItem(TypeBinding.LONG);
								break;
							case 'S':
								frame.addStackItem(TypeBinding.SHORT);
								break;
						}
					} else if (descriptor[0] == '[') {
						frame.addStackItem(new VerificationTypeInfo(0, descriptor));
					} else {
						frame.addStackItem(new VerificationTypeInfo(0, CharOperation.subarray(descriptor, 1, descriptor.length - 1)));
					}
					pc += 3;
					break;
				case IOpcodeMnemonics.PUTFIELD:
					frame.numberOfStackItems -= 2;
					pc += 3;
					break;
				case IOpcodeMnemonics.INVOKEVIRTUAL:
					index = u2At(bytecodes, 1, pc);
					nameAndTypeIndex = u2At(poolContents, 3,
							constantPoolOffsets[index]);
					utf8index = u2At(poolContents, 3,
							constantPoolOffsets[nameAndTypeIndex]);
					descriptor = utf8At(poolContents,
							constantPoolOffsets[utf8index] + 3, u2At(
									poolContents, 1,
									constantPoolOffsets[utf8index]));
					utf8index = u2At(poolContents, 1,
							constantPoolOffsets[nameAndTypeIndex]);
					char[] name = utf8At(poolContents,
							constantPoolOffsets[utf8index] + 3, u2At(
									poolContents, 1,
									constantPoolOffsets[utf8index]));
					frame.numberOfStackItems -= (getParametersCount(descriptor) + 1);
					char[] returnType = getReturnType(descriptor);
					if (returnType.length == 1) {
						// base type
						switch(returnType[0]) {
							case 'Z':
								frame.addStackItem(TypeBinding.BOOLEAN);
								break;
							case 'B':
								frame.addStackItem(TypeBinding.BYTE);
								break;
							case 'C':
								frame.addStackItem(TypeBinding.CHAR);
								break;
							case 'D':
								frame.addStackItem(TypeBinding.DOUBLE);
								break;
							case 'F':
								frame.addStackItem(TypeBinding.FLOAT);
								break;
							case 'I':
								frame.addStackItem(TypeBinding.INT);
								break;
							case 'J':
								frame.addStackItem(TypeBinding.LONG);
								break;
							case 'S':
								frame.addStackItem(TypeBinding.SHORT);
								break;
						}
					} else {
						if (returnType[0] == '[') {
							frame.addStackItem(new VerificationTypeInfo(0, returnType));
						} else {
							frame.addStackItem(new VerificationTypeInfo(0, CharOperation.subarray(returnType, 1, returnType.length - 1)));
						}
					}
					pc += 3;
					break;
				case IOpcodeMnemonics.INVOKESPECIAL:
					index = u2At(bytecodes, 1, pc);
					nameAndTypeIndex = u2At(poolContents, 3,
							constantPoolOffsets[index]);
					utf8index = u2At(poolContents, 3,
							constantPoolOffsets[nameAndTypeIndex]);
					descriptor = utf8At(poolContents,
							constantPoolOffsets[utf8index] + 3, u2At(
									poolContents, 1,
									constantPoolOffsets[utf8index]));
					utf8index = u2At(poolContents, 1,
							constantPoolOffsets[nameAndTypeIndex]);
					name = utf8At(poolContents,
							constantPoolOffsets[utf8index] + 3, u2At(
									poolContents, 1,
									constantPoolOffsets[utf8index]));
					frame.numberOfStackItems -= getParametersCount(descriptor);
					if (CharOperation.equals(ConstantPool.Init, name)) {
						// constructor
						frame.stackItems[frame.numberOfStackItems - 1].tag = VerificationTypeInfo.ITEM_OBJECT;
					}
					frame.numberOfStackItems--;
					returnType = getReturnType(descriptor);
					if (returnType.length == 1) {
						// base type
						switch(returnType[0]) {
							case 'Z':
								frame.addStackItem(TypeBinding.BOOLEAN);
								break;
							case 'B':
								frame.addStackItem(TypeBinding.BYTE);
								break;
							case 'C':
								frame.addStackItem(TypeBinding.CHAR);
								break;
							case 'D':
								frame.addStackItem(TypeBinding.DOUBLE);
								break;
							case 'F':
								frame.addStackItem(TypeBinding.FLOAT);
								break;
							case 'I':
								frame.addStackItem(TypeBinding.INT);
								break;
							case 'J':
								frame.addStackItem(TypeBinding.LONG);
								break;
							case 'S':
								frame.addStackItem(TypeBinding.SHORT);
								break;
						}
					} else {
						if (returnType[0] == '[') {
							frame.addStackItem(new VerificationTypeInfo(0, returnType));
						} else {
							frame.addStackItem(new VerificationTypeInfo(0, CharOperation.subarray(returnType, 1, returnType.length - 1)));
						}
					}
					pc += 3;
					break;
				case IOpcodeMnemonics.INVOKESTATIC:
					index = u2At(bytecodes, 1, pc);
					nameAndTypeIndex = u2At(poolContents, 3,
							constantPoolOffsets[index]);
					utf8index = u2At(poolContents, 3,
							constantPoolOffsets[nameAndTypeIndex]);
					descriptor = utf8At(poolContents,
							constantPoolOffsets[utf8index] + 3, u2At(
									poolContents, 1,
									constantPoolOffsets[utf8index]));
					utf8index = u2At(poolContents, 1,
							constantPoolOffsets[nameAndTypeIndex]);
					name = utf8At(poolContents,
							constantPoolOffsets[utf8index] + 3, u2At(
									poolContents, 1,
									constantPoolOffsets[utf8index]));
					frame.numberOfStackItems -= getParametersCount(descriptor);
					returnType = getReturnType(descriptor);
					if (returnType.length == 1) {
						// base type
						switch(returnType[0]) {
							case 'Z':
								frame.addStackItem(TypeBinding.BOOLEAN);
								break;
							case 'B':
								frame.addStackItem(TypeBinding.BYTE);
								break;
							case 'C':
								frame.addStackItem(TypeBinding.CHAR);
								break;
							case 'D':
								frame.addStackItem(TypeBinding.DOUBLE);
								break;
							case 'F':
								frame.addStackItem(TypeBinding.FLOAT);
								break;
							case 'I':
								frame.addStackItem(TypeBinding.INT);
								break;
							case 'J':
								frame.addStackItem(TypeBinding.LONG);
								break;
							case 'S':
								frame.addStackItem(TypeBinding.SHORT);
								break;
						}
					} else {
						if (returnType[0] == '[') {
							frame.addStackItem(new VerificationTypeInfo(0, returnType));
						} else {
							frame.addStackItem(new VerificationTypeInfo(0, CharOperation.subarray(returnType, 1, returnType.length - 1)));
						}
					}
					pc += 3;
					break;
				case IOpcodeMnemonics.INVOKEINTERFACE:
					index = u2At(bytecodes, 1, pc);
					nameAndTypeIndex = u2At(poolContents, 3,
							constantPoolOffsets[index]);
					utf8index = u2At(poolContents, 3,
							constantPoolOffsets[nameAndTypeIndex]);
					descriptor = utf8At(poolContents,
							constantPoolOffsets[utf8index] + 3, u2At(
									poolContents, 1,
									constantPoolOffsets[utf8index]));
					utf8index = u2At(poolContents, 1,
							constantPoolOffsets[nameAndTypeIndex]);
					name = utf8At(poolContents,
							constantPoolOffsets[utf8index] + 3, u2At(
									poolContents, 1,
									constantPoolOffsets[utf8index]));
					// we don't need count and args
					// u1At(bytecodes, 3, pc); // count
					// u1At(bytecodes, 4, pc); // extra args
					frame.numberOfStackItems -= (getParametersCount(descriptor) + 1);
					returnType = getReturnType(descriptor);
					if (returnType.length == 1) {
						// base type
						switch(returnType[0]) {
							case 'Z':
								frame.addStackItem(TypeBinding.BOOLEAN);
								break;
							case 'B':
								frame.addStackItem(TypeBinding.BYTE);
								break;
							case 'C':
								frame.addStackItem(TypeBinding.CHAR);
								break;
							case 'D':
								frame.addStackItem(TypeBinding.DOUBLE);
								break;
							case 'F':
								frame.addStackItem(TypeBinding.FLOAT);
								break;
							case 'I':
								frame.addStackItem(TypeBinding.INT);
								break;
							case 'J':
								frame.addStackItem(TypeBinding.LONG);
								break;
							case 'S':
								frame.addStackItem(TypeBinding.SHORT);
								break;
						}
					} else {
						if (returnType[0] == '[') {
							frame.addStackItem(new VerificationTypeInfo(0, returnType));
						} else {
							frame.addStackItem(new VerificationTypeInfo(0, CharOperation.subarray(returnType, 1, returnType.length - 1)));
						}
					}
					pc += 5;
					break;
				case IOpcodeMnemonics.NEW:
					index = u2At(bytecodes, 1, pc);
					utf8index = u2At(poolContents, 1,
							constantPoolOffsets[index]);
					char[] className = utf8At(poolContents,
							constantPoolOffsets[utf8index] + 3, u2At(
									poolContents, 1,
									constantPoolOffsets[utf8index]));
					VerificationTypeInfo verificationTypeInfo = new VerificationTypeInfo(0, VerificationTypeInfo.ITEM_UNINITIALIZED, className);
					verificationTypeInfo.offset = currentPC;
					frame.addStackItem(verificationTypeInfo);
					pc += 3;
					break;
				case IOpcodeMnemonics.NEWARRAY:
					char[] constantPoolName = null;
					switch (u1At(bytecodes, 1, pc)) {
						case ClassFileConstants.INT_ARRAY :
							constantPoolName = new char[] { '[', 'I' };
							break;
						case ClassFileConstants.BYTE_ARRAY :
							constantPoolName = new char[] { '[', 'B' };
							break;
						case ClassFileConstants.BOOLEAN_ARRAY :
							constantPoolName = new char[] { '[', 'Z' };
							break;
						case ClassFileConstants.SHORT_ARRAY :
							constantPoolName = new char[] { '[', 'S' };
							break;
						case ClassFileConstants.CHAR_ARRAY :
							constantPoolName = new char[] { '[', 'C' };
							break;
						case ClassFileConstants.LONG_ARRAY :
							constantPoolName = new char[] { '[', 'J' };
							break;
						case ClassFileConstants.FLOAT_ARRAY :
							constantPoolName = new char[] { '[', 'F' };
							break;
						case ClassFileConstants.DOUBLE_ARRAY :
							constantPoolName = new char[] { '[', 'D' };
							break;
					}
					frame.stackItems[frame.numberOfStackItems - 1] = new VerificationTypeInfo(TypeIds.T_JavaLangObject, constantPoolName);
					pc += 2;
					break;
				case IOpcodeMnemonics.ANEWARRAY:
					index = u2At(bytecodes, 1, pc);
					utf8index = u2At(poolContents, 1,
							constantPoolOffsets[index]);
					className = utf8At(poolContents,
							constantPoolOffsets[utf8index] + 3, u2At(
									poolContents, 1,
									constantPoolOffsets[utf8index]));
					int classNameLength = className.length;
					System.arraycopy(className, 0, (constantPoolName = new char[classNameLength + 3]), 2, classNameLength);
					constantPoolName[0] = '[';
					constantPoolName[1] = 'L';
					constantPoolName[classNameLength + 2] = ';';
					frame.stackItems[frame.numberOfStackItems - 1] = new VerificationTypeInfo(0, constantPoolName);
					pc += 3;
					break;
				case IOpcodeMnemonics.ARRAYLENGTH:
					frame.stackItems[frame.numberOfStackItems - 1] = new VerificationTypeInfo(TypeBinding.INT);
					pc++;
					break;
				case IOpcodeMnemonics.ATHROW:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.CHECKCAST:
					index = u2At(bytecodes, 1, pc);
					utf8index = u2At(poolContents, 1,
							constantPoolOffsets[index]);
					className = utf8At(poolContents,
							constantPoolOffsets[utf8index] + 3, u2At(
									poolContents, 1,
									constantPoolOffsets[utf8index]));
					frame.stackItems[frame.numberOfStackItems - 1] = new VerificationTypeInfo(0, className);
					pc += 3;
					break;
				case IOpcodeMnemonics.INSTANCEOF:
					// no need to know the class index = u2At(bytecodes, 1, pc);
					frame.stackItems[frame.numberOfStackItems - 1] = new VerificationTypeInfo(TypeBinding.INT);
					pc += 3;
					break;
				case IOpcodeMnemonics.MONITORENTER:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.MONITOREXIT:
					frame.numberOfStackItems--;
					pc++;
					break;
				case IOpcodeMnemonics.WIDE:
					opcode = u1At(bytecodes, 1, pc);
					if (opcode == IOpcodeMnemonics.IINC) {
						// index = u2At(bytecodes, 2, pc);
						// i2At(bytecodes, 4, pc); // const
						// we don't need the index and the const value
						pc += 6;
					} else {
						index = u2At(bytecodes, 2, pc);
						// need to handle iload, fload, aload, lload, dload, istore, fstore, astore, lstore or dstore
						switch(opcode) {
							case IOpcodeMnemonics.ILOAD :
								frame.addStackItem(TypeBinding.INT);
								break;
							case IOpcodeMnemonics.FLOAD :
								frame.addStackItem(TypeBinding.FLOAT);
								break;
							case IOpcodeMnemonics.ALOAD :
								localsN = frame.locals[index];
								if (localsN == null) {
									localsN = retrieveLocal(currentPC, index);
								}
								frame.addStackItem(localsN);
								break;
							case IOpcodeMnemonics.LLOAD :
								frame.addStackItem(TypeBinding.LONG);
								break;
							case IOpcodeMnemonics.DLOAD :
								frame.addStackItem(TypeBinding.DOUBLE);
								break;
							case IOpcodeMnemonics.ISTORE :
								frame.numberOfStackItems--;
								break;
							case IOpcodeMnemonics.FSTORE :
								frame.numberOfStackItems--;
								break;
							case IOpcodeMnemonics.ASTORE :
								frame.locals[index] = frame.stackItems[frame.numberOfStackItems - 1];
								frame.numberOfStackItems--;
								break;
							case IOpcodeMnemonics.LSTORE :
								frame.numberOfStackItems--;
								break;
							case IOpcodeMnemonics.DSTORE :
								frame.numberOfStackItems--;
								break;
						}
						pc += 4;
					}
					break;
				case IOpcodeMnemonics.MULTIANEWARRAY:
					index = u2At(bytecodes, 1, pc);
					utf8index = u2At(poolContents, 1,
							constantPoolOffsets[index]);
					className = utf8At(poolContents,
							constantPoolOffsets[utf8index] + 3, u2At(
									poolContents, 1,
									constantPoolOffsets[utf8index]));
					int dimensions = u1At(bytecodes, 3, pc); // dimensions
					frame.numberOfStackItems -= dimensions;
					classNameLength = className.length;
					constantPoolName = new char[classNameLength + dimensions];
					for (int i = 0; i < dimensions; i++) {
						constantPoolName[i] = '[';
					}
					System.arraycopy(className, 0, constantPoolName, dimensions, classNameLength);
					frame.addStackItem(new VerificationTypeInfo(0, constantPoolName));
					pc += 4;
					break;
				case IOpcodeMnemonics.IFNULL:
					frame.numberOfStackItems--;
					pc += 3;
					break;
				case IOpcodeMnemonics.IFNONNULL:
					frame.numberOfStackItems--;
					pc += 3;
					break;
				case IOpcodeMnemonics.GOTO_W:
					pc += 5;
			}
			if (pc >= (codeLength + codeOffset)) {
				break;
			}
		}
	}

