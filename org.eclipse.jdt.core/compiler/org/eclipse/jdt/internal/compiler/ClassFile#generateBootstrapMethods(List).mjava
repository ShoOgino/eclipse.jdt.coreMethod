	private int generateBootstrapMethods(List functionalExpressionList) {
		/* See JVM spec 4.7.21
		   The BootstrapMethods attribute has the following format:
		   BootstrapMethods_attribute {
		      u2 attribute_name_index;
		      u4 attribute_length;
		      u2 num_bootstrap_methods;
		      {   u2 bootstrap_method_ref;
		          u2 num_bootstrap_arguments;
		          u2 bootstrap_arguments[num_bootstrap_arguments];
		      } bootstrap_methods[num_bootstrap_methods];
		 }
		*/
		// Record inner classes for MethodHandles$Lookup
		ReferenceBinding methodHandlesLookup = this.referenceBinding.scope.getJavaLangInvokeMethodHandlesLookup();
		if (methodHandlesLookup == null) return 0; // skip bootstrap section, class path problem already reported, just avoid NPE.
		recordInnerClasses(methodHandlesLookup); // Should be done, it's what javac does also
		ReferenceBinding javaLangInvokeLambdaMetafactory = this.referenceBinding.scope.getJavaLangInvokeLambdaMetafactory(); 
		
		// Depending on the complexity of the expression it may be necessary to use the altMetafactory() rather than the metafactory()
		int indexForMetaFactory = 0;
		int indexForAltMetaFactory = 0;

		int numberOfBootstraps = functionalExpressionList.size();
		int localContentsOffset = this.contentsOffset;
		// Generate the boot strap attribute - since we are only making lambdas and
		// functional expressions, we know the size ahead of time - this less general
		// than the full invokedynamic scope, but fine for Java 8
		
		int exSize = 10 * numberOfBootstraps + 8;
		if (exSize + localContentsOffset >= this.contents.length) {
			resizeContents(exSize);
		}
		
		int attributeNameIndex =
			this.constantPool.literalIndex(AttributeNamesConstants.BootstrapMethodsName);
		this.contents[localContentsOffset++] = (byte) (attributeNameIndex >> 8);
		this.contents[localContentsOffset++] = (byte) attributeNameIndex;
		// leave space for attribute_length and remember where to insert it
		int attributeLengthPosition = localContentsOffset;
		localContentsOffset += 4;
		this.contents[localContentsOffset++] = (byte) (numberOfBootstraps >> 8);
		this.contents[localContentsOffset++] = (byte) numberOfBootstraps;
		for (int i = 0; i < numberOfBootstraps; i++) {
			FunctionalExpression functional = (FunctionalExpression) functionalExpressionList.get(i);
			MethodBinding [] bridges = functional.getRequiredBridges();
			TypeBinding[] markerInterfaces = null;
			if (functional instanceof LambdaExpression && 
				   (((markerInterfaces=((LambdaExpression)functional).getMarkerInterfaces()) != null) ||
				   	((LambdaExpression)functional).isSerializable) ||
				   	bridges != null) {
				
				LambdaExpression lambdaEx = (LambdaExpression)functional;
				// may need even more space
				int extraSpace = 2; // at least 2 more than when the normal metafactory is used, for the bitflags entry
				if (markerInterfaces != null) {
					// 2 for the marker interface list size then 2 per marker interface index
					extraSpace += (2 + 2 * markerInterfaces.length);
				}
				if (bridges != null) {
					// 2 for bridge count then 2 per bridge method type.
					extraSpace += (2 + 2 * bridges.length);
				}
				if (extraSpace + localContentsOffset >= this.contents.length) {
					resizeContents(extraSpace);
				} 
				
				if (indexForAltMetaFactory == 0) {
					indexForAltMetaFactory = 
						this.constantPool.literalIndexForMethodHandle(ClassFileConstants.MethodHandleRefKindInvokeStatic, javaLangInvokeLambdaMetafactory, 
						ConstantPool.ALTMETAFACTORY, ConstantPool.JAVA_LANG_INVOKE_LAMBDAMETAFACTORY_ALTMETAFACTORY_SIGNATURE, false);
				}
				this.contents[localContentsOffset++] = (byte) (indexForAltMetaFactory >> 8);
				this.contents[localContentsOffset++] = (byte) indexForAltMetaFactory;
				
				// u2 num_bootstrap_arguments
				this.contents[localContentsOffset++] = 0;
				this.contents[localContentsOffset++] = (byte) (4 + (markerInterfaces==null?0:1+markerInterfaces.length) + 
						                                                   (bridges == null ? 0 : 1 + bridges.length));
				
				int functionalDescriptorIndex = this.constantPool.literalIndexForMethodType(functional.descriptor.original().signature());
				this.contents[localContentsOffset++] = (byte) (functionalDescriptorIndex >> 8);
				this.contents[localContentsOffset++] = (byte) functionalDescriptorIndex;
	
				int methodHandleIndex = this.constantPool.literalIndexForMethodHandle(functional.binding.original()); // Speak of " implementation" (erased) version here, adaptations described below.
				this.contents[localContentsOffset++] = (byte) (methodHandleIndex >> 8);
				this.contents[localContentsOffset++] = (byte) methodHandleIndex;
	
				char [] instantiatedSignature = functional.descriptor.signature();
				int methodTypeIndex = this.constantPool.literalIndexForMethodType(instantiatedSignature);
				this.contents[localContentsOffset++] = (byte) (methodTypeIndex >> 8);
				this.contents[localContentsOffset++] = (byte) methodTypeIndex;

				int bitflags = 0;
				if (lambdaEx.isSerializable) {
					bitflags |= ClassFileConstants.FLAG_SERIALIZABLE;
				}
				if (markerInterfaces!=null) {
					bitflags |= ClassFileConstants.FLAG_MARKERS;
				}
				if (bridges != null) {
					bitflags |= ClassFileConstants.FLAG_BRIDGES;
				}
				int indexForBitflags = this.constantPool.literalIndex(bitflags);
				
				this.contents[localContentsOffset++] = (byte)(indexForBitflags>>8);
				this.contents[localContentsOffset++] = (byte)(indexForBitflags);
				
				if (markerInterfaces != null) {
					int markerInterfaceCountIndex =  this.constantPool.literalIndex(markerInterfaces.length);
					this.contents[localContentsOffset++] = (byte)(markerInterfaceCountIndex>>8);
					this.contents[localContentsOffset++] = (byte)(markerInterfaceCountIndex);
					for (int m = 0, maxm = markerInterfaces.length; m < maxm; m++) {
						int classTypeIndex = this.constantPool.literalIndexForType(markerInterfaces[m]);
						this.contents[localContentsOffset++] = (byte)(classTypeIndex>>8);
						this.contents[localContentsOffset++] = (byte)(classTypeIndex);
					}					
				}
				if (bridges != null) {
					int bridgeCountIndex =  this.constantPool.literalIndex(bridges.length);
					this.contents[localContentsOffset++] = (byte) (bridgeCountIndex >> 8);
					this.contents[localContentsOffset++] = (byte) (bridgeCountIndex);
					for (int m = 0, maxm = bridges.length; m < maxm; m++) {
						char [] bridgeSignature = bridges[m].signature();
						int bridgeMethodTypeIndex = this.constantPool.literalIndexForMethodType(bridgeSignature);
						this.contents[localContentsOffset++] = (byte) (bridgeMethodTypeIndex >> 8);
						this.contents[localContentsOffset++] = (byte) bridgeMethodTypeIndex;
					}					
				}
			} else {
				if (indexForMetaFactory == 0) {
					indexForMetaFactory = this.constantPool.literalIndexForMethodHandle(ClassFileConstants.MethodHandleRefKindInvokeStatic, javaLangInvokeLambdaMetafactory, 
							ConstantPool.METAFACTORY, ConstantPool.JAVA_LANG_INVOKE_LAMBDAMETAFACTORY_METAFACTORY_SIGNATURE, false);
				}
				this.contents[localContentsOffset++] = (byte) (indexForMetaFactory >> 8);
				this.contents[localContentsOffset++] = (byte) indexForMetaFactory;
				
				// u2 num_bootstrap_arguments
				this.contents[localContentsOffset++] = 0;
				this.contents[localContentsOffset++] = (byte) 3;
				
				int functionalDescriptorIndex = this.constantPool.literalIndexForMethodType(functional.descriptor.original().signature());
				this.contents[localContentsOffset++] = (byte) (functionalDescriptorIndex >> 8);
				this.contents[localContentsOffset++] = (byte) functionalDescriptorIndex;
	
				int methodHandleIndex = this.constantPool.literalIndexForMethodHandle(functional.binding.original()); // Speak of " implementation" (erased) version here, adaptations described below.
				this.contents[localContentsOffset++] = (byte) (methodHandleIndex >> 8);
				this.contents[localContentsOffset++] = (byte) methodHandleIndex;
	
				char [] instantiatedSignature = functional.descriptor.signature();
				int methodTypeIndex = this.constantPool.literalIndexForMethodType(instantiatedSignature);
				this.contents[localContentsOffset++] = (byte) (methodTypeIndex >> 8);
				this.contents[localContentsOffset++] = (byte) methodTypeIndex;				
			}
		}

		int attributeLength = localContentsOffset - attributeLengthPosition - 4;
		this.contents[attributeLengthPosition++] = (byte) (attributeLength >> 24);
		this.contents[attributeLengthPosition++] = (byte) (attributeLength >> 16);
		this.contents[attributeLengthPosition++] = (byte) (attributeLength >> 8);
		this.contents[attributeLengthPosition++] = (byte) attributeLength;
		this.contentsOffset = localContentsOffset;
		return 1;
	}

