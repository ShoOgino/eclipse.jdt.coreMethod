public void parseError(
	int startPosition, 
	int endPosition, 
	char[] currentTokenSource, 
	String errorTokenName, 
	String[] possibleTokens) {
		
	if (possibleTokens.length == 0) { //no suggestion available
		if (isKeyword(currentTokenSource)) {
			this.handle(
				IProblem.ParsingErrorOnKeywordNoSuggestion,
				new String[] {new String(currentTokenSource)},
				// this is the current -invalid- token position
				startPosition,
				endPosition);
			return;
		} else {
			this.handle(
				IProblem.ParsingErrorNoSuggestion,
				new String[] {errorTokenName},
				// this is the current -invalid- token position
				startPosition,
				endPosition);
			return;
		}
	}

	//build a list of probable right tokens
	StringBuffer list = new StringBuffer(20);
	for (int i = 0, max = possibleTokens.length; i < max; i++) {
		if (i > 0)
			list.append(", "); //$NON-NLS-1$
		list.append('"');
		list.append(possibleTokens[i]);
		list.append('"');
	}

	if (isKeyword(currentTokenSource)) {
		this.handle(
			IProblem.ParsingErrorOnKeyword,
			new String[] {new String(currentTokenSource), list.toString()},
			// this is the current -invalid- token position
			startPosition,
			endPosition);
		return;
	}
	//extract the literal when it's a literal  
	if ((errorTokenName.equals("IntegerLiteral")) || //$NON-NLS-1$
		(errorTokenName.equals("LongLiteral")) || //$NON-NLS-1$
		(errorTokenName.equals("FloatingPointLiteral")) || //$NON-NLS-1$
		(errorTokenName.equals("DoubleLiteral")) || //$NON-NLS-1$
		(errorTokenName.equals("StringLiteral")) || //$NON-NLS-1$
		(errorTokenName.equals("CharacterLiteral")) || //$NON-NLS-1$
		(errorTokenName.equals("Identifier"))) { //$NON-NLS-1$
			errorTokenName = new String(currentTokenSource);
	}

	this.handle(
		IProblem.ParsingError,
		new String[] {errorTokenName, list.toString()},
		// this is the current -invalid- token position
		startPosition,
		endPosition);
}

