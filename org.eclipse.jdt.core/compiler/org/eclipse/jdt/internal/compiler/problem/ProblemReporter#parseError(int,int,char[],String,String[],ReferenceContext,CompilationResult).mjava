public void parseError(
	int startPosition, 
	int endPosition, 
	char[] currentTokenSource, 
	String errorTokenName, 
	String[] possibleTokens,
	ReferenceContext context,
	CompilationResult compilationResult) {
		
	if (possibleTokens.length == 0) { //no suggestion available
		this.handle(
			ParsingErrorNoSuggestion,
			new String[] {errorTokenName},
			// this is the current -invalid- token position
			startPosition,
			endPosition,
			context, 
			compilationResult);
		return;
	}

	//build a list of probable right tokens
	StringBuffer list = new StringBuffer(20);
	for (int i = 0, max = possibleTokens.length; i < max; i++) {
		if (i > 0)
			list.append(", "); //$NON-NLS-1$
		list.append('"');
		list.append(possibleTokens[i]);
		list.append('"');
	}

	//extract the literal when it's a literal  
	if ((errorTokenName.equals("IntegerLiteral")) || //$NON-NLS-1$
		(errorTokenName.equals("LongLiteral")) || //$NON-NLS-1$
		(errorTokenName.equals("FloatingPointLiteral")) || //$NON-NLS-1$
		(errorTokenName.equals("DoubleLiteral")) || //$NON-NLS-1$
		(errorTokenName.equals("StringLiteral")) || //$NON-NLS-1$
		(errorTokenName.equals("CharacterLiteral")) || //$NON-NLS-1$
		(errorTokenName.equals("Identifier"))) { //$NON-NLS-1$
			errorTokenName = new String(currentTokenSource);
	}

	this.handle(
		ParsingError,
		new String[] {errorTokenName, list.toString()},
		// this is the current -invalid- token position
		startPosition,
		endPosition,
		context,
		compilationResult);
}

