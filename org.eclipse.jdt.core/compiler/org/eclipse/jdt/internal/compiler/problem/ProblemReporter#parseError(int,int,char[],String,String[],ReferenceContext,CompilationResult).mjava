public void parseError(
	int startPosition, 
	int endPosition, 
	char[] currentTokenSource, 
	String errorTokenName, 
	String[] possibleTokens,
	ReferenceContext context,
	CompilationResult compilationResult) {
		
	if (possibleTokens.length == 0) { //no suggestion available
		this.handle(
			ParsingErrorNoSuggestion,
			new String[] {errorTokenName},
			// this is the current -invalid- token position
			startPosition,
			endPosition,
			context, 
			compilationResult);
		return;
	}

	//build a list of probable right tokens
	StringBuffer list = new StringBuffer(20);
	for (int i = 0, max = possibleTokens.length; i < max; i++) {
		if (i > 0)
			list.append(", "/*nonNLS*/);
		list.append('"');
		list.append(possibleTokens[i]);
		list.append('"');
	}

	//extract the literal when it's a literal  
	if ((errorTokenName.equals("IntegerLiteral"/*nonNLS*/)) ||
		(errorTokenName.equals("LongLiteral"/*nonNLS*/)) ||
		(errorTokenName.equals("FloatingPointLiteral"/*nonNLS*/)) ||
		(errorTokenName.equals("DoubleLiteral"/*nonNLS*/)) ||
		(errorTokenName.equals("StringLiteral"/*nonNLS*/)) ||
		(errorTokenName.equals("CharacterLiteral"/*nonNLS*/)) ||
		(errorTokenName.equals("Identifier"/*nonNLS*/))) {
			errorTokenName = new String(currentTokenSource);
	}

	this.handle(
		ParsingError,
		new String[] {errorTokenName, list.toString()},
		// this is the current -invalid- token position
		startPosition,
		endPosition,
		context,
		compilationResult);
}

