public void invalidServiceImpl(int problem, TypeReference impl) {
	String[] args = new String[]{CharOperation.charToString(impl.resolvedType.readableName())};
	int problemId = ProblemReasons.NoError;
	switch(problem) {
		case ProblemReasons.ServiceImplCannotbeAbstract:
			problemId = IProblem.AbstractServiceImplementation;
			break;
		case ProblemReasons.DefaultConstructorRequiredForServiceImpl:
			problemId = IProblem.DefaultConstructorRequiredForServiceImpl;
			break;
		case ProblemReasons.ServiceImplDefaultConstructorNotPublic:
			problemId = IProblem.ServiceImplDefaultConstructorNotPublic;
			break;
		case ProblemReasons.ServiceImplCannotbeNested:
			problemId = IProblem.NestedServiceImpl;
			break;
		case ProblemReasons.ServiceImplNotDefinedByModule:
			problemId = IProblem.ServiceImplNotDefinedByModule;
	}
	if (problemId != ProblemReasons.NoError) {
		this.handle(problemId, NoArgument, args, impl.sourceStart, impl.sourceEnd);
	}
}

