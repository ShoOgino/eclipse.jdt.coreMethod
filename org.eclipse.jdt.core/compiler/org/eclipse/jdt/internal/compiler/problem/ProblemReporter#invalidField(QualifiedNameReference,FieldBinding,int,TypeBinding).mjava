public void invalidField(QualifiedNameReference nameRef, FieldBinding field, int index, TypeBinding searchedType) {
	//the resolution of the index-th field of qname failed
	//qname.otherBindings[index] is the binding that has produced the error

	//The different targetted errors should be :
	//UndefinedField
	//NotVisibleField
	//AmbiguousField

	if (searchedType.isBaseType()) {
		this.handle(
			IProblem.NoFieldOnBaseType,
			new String[] {
				new String(searchedType.readableName()),
				CharOperation.toString(CharOperation.subarray(nameRef.tokens, 0, index)),
				new String(nameRef.tokens[index])},
			nameRef.sourceStart,
			nameRef.sourceEnd);
		return;
	}

	int flag = IProblem.UndefinedField;
	switch (field.problemId()) {
		case NotFound :
			flag = IProblem.UndefinedField;
/* also need to check that the searchedType is the receiver type
			if (searchedType.isHierarchyInconsistent())
				severity = SecondaryError;
*/
			break;
		case NotVisible :
			flag = IProblem.NotVisibleField;
			break;
		case Ambiguous :
			flag = IProblem.AmbiguousField;
			break;
		case NonStaticReferenceInStaticContext :
			flag = IProblem.NonStaticFieldFromStaticInvocation;
			break;
		case NonStaticReferenceInConstructorInvocation :
			flag = IProblem.InstanceFieldDuringConstructorInvocation;
			break;
		case InheritedNameHidesEnclosingName :
			flag = IProblem.InheritedFieldHidesEnclosingName;
			break;
		case NoError : // 0
		default :
			needImplementation(); // want to fail to see why we were here...
			break;
	}
	this.handle(
		flag, 
		new String[] {CharOperation.toString(CharOperation.subarray(nameRef.tokens, 0, index + 1))},
		nameRef.sourceStart, 
		nameRef.sourceEnd); 
}

