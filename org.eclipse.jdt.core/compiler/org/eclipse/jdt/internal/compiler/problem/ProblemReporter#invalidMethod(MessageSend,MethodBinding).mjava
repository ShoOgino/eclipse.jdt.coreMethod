	public void invalidMethod(MessageSend messageSend, MethodBinding method) {
		// CODE should be UPDATED according to error coding in the different method binding errors
		// The different targetted errors should be :
		// 	UndefinedMethod
		//	NotVisibleMethod
		//	AmbiguousMethod
		//  InheritedNameHidesEnclosingName
		//	InstanceMethodDuringConstructorInvocation
		// StaticMethodRequested

		int flag = UndefinedMethod; //default...
		switch (method.problemId()) {
			case NotFound :
				flag = UndefinedMethod;
				break;
			case NotVisible :
				flag = NotVisibleMethod;
				break;
			case Ambiguous :
				flag = AmbiguousMethod;
				break;
			case InheritedNameHidesEnclosingName :
				flag = InheritedMethodHidesEnclosingName;
				break;
			case NonStaticReferenceInConstructorInvocation :
				flag = InstanceMethodDuringConstructorInvocation;
				break;
			case NonStaticReferenceInStaticContext :
				flag = StaticMethodRequested;
				break;
			case NoError : // 0
			default :
				needImplementation(); // want to fail to see why we were here...
				break;
		}

		if (flag == UndefinedMethod) {
			ProblemMethodBinding problemMethod = (ProblemMethodBinding) method;
			if (problemMethod.closestMatch != null) {
				this.handle(
					ParameterMismatch,
					new String[] {
						new String(problemMethod.closestMatch.declaringClass.readableName()),
						new String(problemMethod.closestMatch.selector),
						parametersAsString(problemMethod.closestMatch),
						parametersAsString(method)},
					(int) (messageSend.nameSourcePosition >>> 32),
					(int) messageSend.nameSourcePosition);
				return;
			}
		}

		this.handle(
			flag,
			new String[] {
				new String(method.declaringClass.readableName()),
				new String(method.selector),
				parametersAsString(method)},
			(int) (messageSend.nameSourcePosition >>> 32),
			(int) messageSend.nameSourcePosition);
	}

