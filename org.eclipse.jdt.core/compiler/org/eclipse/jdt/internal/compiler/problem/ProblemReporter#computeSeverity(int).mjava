/*
 * Given the current configuration, answers which category the problem
 * falls into:
 *		Error | Warning | Ignore
 */
public int computeSeverity(int problemId){

	// severity can have been preset on the problem
//	if ((problem.severity & Fatal) != 0){
//		return Error;
//	}

	// if not then check whether it is a configurable problem
	int errorThreshold = options.errorThreshold;
	int warningThreshold = options.warningThreshold;
	
	switch(problemId){

		case UnreachableCatch :
		case CodeCannotBeReached :
			if ((errorThreshold & CompilerOptions.UnreachableCode) != 0){
				return Error;
			}
			if ((warningThreshold & CompilerOptions.UnreachableCode) != 0){
				return Warning;
			}
			return Ignore;

		case MaskedCatch : 
			if ((errorThreshold & CompilerOptions.MaskedCatchBlock) != 0){
				return Error;
			}
			if ((warningThreshold & CompilerOptions.MaskedCatchBlock) != 0){
				return Warning;
			}
			return Ignore;
			
/*
		case Never Used  :
			if ((errorThreshold & ParsingOptionalError) != 0){
				return Error;
			}
			if ((warningThreshold & ParsingOptionalError) != 0){
				return Warning;
			}
			return Ignore;
*/
		case ImportProblemBase + NotFound :
		case ImportProblemBase + NotVisible :
		case ImportProblemBase + Ambiguous :
		case ImportProblemBase + InternalNameProvided :
		case ImportProblemBase + InheritedNameHidesEnclosingName :
		case DuplicateImport :
		case ConflictingImport :
		case CannotImportPackage :
			if ((errorThreshold & CompilerOptions.ImportProblem) != 0){
				return Error;
			}
			if ((warningThreshold & CompilerOptions.ImportProblem) != 0){
				return Warning;
			}
			return Ignore;
/*		
		case UnnecessaryEnclosingInstanceSpecification :
			if ((errorThreshold & UnnecessaryEnclosingInstance) != 0){
				return Error;
			}
			if ((warningThreshold & UnnecessaryEnclosingInstance) != 0){
				return Warning;
			}
			return Ignore;
*/		
		case MethodButWithConstructorName :
			if ((errorThreshold & CompilerOptions.MethodWithConstructorName) != 0){
				return Error;
			}
			if ((warningThreshold & CompilerOptions.MethodWithConstructorName) != 0){
				return Warning;
			}
			return Ignore;
		
		case OverridingNonVisibleMethod :
			if ((errorThreshold & CompilerOptions.OverriddenPackageDefaultMethod) != 0){
				return Error;
			}
			if ((warningThreshold & CompilerOptions.OverriddenPackageDefaultMethod) != 0){
				return Warning;
			}
			return Ignore;

		case OverridingDeprecatedMethod :				
		case UsingDeprecatedType :				
		case UsingDeprecatedMethod :
		case UsingDeprecatedConstructor :
		case UsingDeprecatedField :
			if ((errorThreshold & CompilerOptions.UsingDeprecatedAPI) != 0){
				return Error;
			}
			if ((warningThreshold & CompilerOptions.UsingDeprecatedAPI) != 0){
				return Warning;
			}
			return Ignore;
		
		case LocalVariableIsNeverUsed :
			if ((errorThreshold & CompilerOptions.UnusedLocalVariable) != 0){
				return Error;
			}
			if ((warningThreshold & CompilerOptions.UnusedLocalVariable) != 0){
				return Warning;
			}
			return Ignore;
		
		case ArgumentIsNeverUsed :
			if ((errorThreshold & CompilerOptions.UnusedArgument) != 0){
				return Error;
			}
			if ((warningThreshold & CompilerOptions.UnusedArgument) != 0){
				return Warning;
			}
			return Ignore;

		case NoImplicitStringConversionForCharArrayExpression :
			if ((errorThreshold & CompilerOptions.NoImplicitStringConversion) != 0){
				return Error;
			}
			if ((warningThreshold & CompilerOptions.NoImplicitStringConversion) != 0){
				return Warning;
			}
			return Ignore;

		case NeedToEmulateFieldReadAccess :
		case NeedToEmulateFieldWriteAccess :
		case NeedToEmulateMethodAccess :
		case NeedToEmulateConstructorAccess :			
			if ((errorThreshold & CompilerOptions.AccessEmulation) != 0){
				return Error;
			}
			if ((warningThreshold & CompilerOptions.AccessEmulation) != 0){
				return Warning;
			}
			return Ignore;
		case NonExternalizedStringLiteral :
			if ((errorThreshold & CompilerOptions.NonExternalizedString) != 0){
				return Error;
			}
			if ((warningThreshold & CompilerOptions.NonExternalizedString) != 0){
				return Warning;
			}
			return Ignore;
		case UseAssertAsAnIdentifier :
			if ((errorThreshold & CompilerOptions.AssertUsedAsAnIdentifier) != 0){
				return Error;
			}
			if ((warningThreshold & CompilerOptions.AssertUsedAsAnIdentifier) != 0){
				return Warning;
			}
			return Ignore;		
		default:
			return Error;
	}
}

