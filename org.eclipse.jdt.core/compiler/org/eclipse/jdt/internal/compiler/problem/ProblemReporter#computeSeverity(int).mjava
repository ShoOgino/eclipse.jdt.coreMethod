/*
 * Given the current configuration, answers which category the problem
 * falls into:
 *		Error | Warning | Ignore
 */
public int computeSeverity(int problemId){

// severity can have been preset on the problem
//	if ((problem.severity & Fatal) != 0){
//		return Error;
//	}

	// if not then check whether it is a configurable problem
	switch(problemId){

		case IProblem.MaskedCatch : 
			return customOptions().getSeverity(CompilerOptions.MaskedCatchBlock);

		case IProblem.UnusedImport :
			return customOptions().getSeverity(CompilerOptions.UnusedImport);
			
		case IProblem.MethodButWithConstructorName :
			return customOptions().getSeverity(CompilerOptions.MethodWithConstructorName);
		
		case IProblem.OverridingNonVisibleMethod :
			return customOptions().getSeverity(CompilerOptions.OverriddenPackageDefaultMethod);

		case IProblem.IncompatibleReturnTypeForNonInheritedInterfaceMethod :
		case IProblem.IncompatibleExceptionInThrowsClauseForNonInheritedInterfaceMethod :
			return customOptions().getSeverity(CompilerOptions.IncompatibleNonInheritedInterfaceMethod);

		case IProblem.OverridingDeprecatedMethod :				
		case IProblem.UsingDeprecatedType :				
		case IProblem.UsingDeprecatedMethod :
		case IProblem.UsingDeprecatedConstructor :
		case IProblem.UsingDeprecatedField :
			return customOptions().getSeverity(CompilerOptions.UsingDeprecatedAPI);
		
		case IProblem.LocalVariableIsNeverUsed :
			return customOptions().getSeverity(CompilerOptions.UnusedLocalVariable);
		
		case IProblem.ArgumentIsNeverUsed :
			return customOptions().getSeverity(CompilerOptions.UnusedArgument);

		case IProblem.NoImplicitStringConversionForCharArrayExpression :
			return customOptions().getSeverity(CompilerOptions.NoImplicitStringConversion);

		case IProblem.NeedToEmulateFieldReadAccess :
		case IProblem.NeedToEmulateFieldWriteAccess :
		case IProblem.NeedToEmulateMethodAccess :
		case IProblem.NeedToEmulateConstructorAccess :			
			return customOptions().getSeverity(CompilerOptions.AccessEmulation);

		case IProblem.NonExternalizedStringLiteral :
			return customOptions().getSeverity(CompilerOptions.NonExternalizedString);

		case IProblem.UseAssertAsAnIdentifier :
			return customOptions().getSeverity(CompilerOptions.AssertUsedAsAnIdentifier);
		case IProblem.UseEnumAsAnIdentifier :
			return customOptions().getSeverity(CompilerOptions.EnumUsedAsAnIdentifier);

		case IProblem.NonStaticAccessToStaticMethod :
		case IProblem.NonStaticAccessToStaticField :
			return customOptions().getSeverity(CompilerOptions.NonStaticAccessToStatic);

		case IProblem.IndirectAccessToStaticMethod :
		case IProblem.IndirectAccessToStaticField :
		case IProblem.IndirectAccessToStaticType :
			return customOptions().getSeverity(CompilerOptions.IndirectStaticAccess);

		case IProblem.AssignmentHasNoEffect:
			return customOptions().getSeverity(CompilerOptions.NoEffectAssignment);

		case IProblem.UnusedPrivateConstructor:
		case IProblem.UnusedPrivateMethod:
		case IProblem.UnusedPrivateField:
		case IProblem.UnusedPrivateType:
			return customOptions().getSeverity(CompilerOptions.UnusedPrivateMember);

		case IProblem.Task :
			return Warning;			

		case IProblem.LocalVariableHidingLocalVariable:
		case IProblem.LocalVariableHidingField:
		case IProblem.ArgumentHidingLocalVariable:
		case IProblem.ArgumentHidingField:
			return customOptions().getSeverity(CompilerOptions.LocalVariableHiding);

		case IProblem.FieldHidingLocalVariable:
		case IProblem.FieldHidingField:
			return customOptions().getSeverity(CompilerOptions.FieldHiding);

		case IProblem.TypeParameterHidingType:
			return customOptions().getSeverity(CompilerOptions.TypeParameterHiding);
			
		case IProblem.PossibleAccidentalBooleanAssignment:
			return customOptions().getSeverity(CompilerOptions.AccidentalBooleanAssign);

		case IProblem.SuperfluousSemicolon:
		case IProblem.EmptyControlFlowStatement:
			return customOptions().getSeverity(CompilerOptions.EmptyStatement);

		case IProblem.UndocumentedEmptyBlock:
			return customOptions().getSeverity(CompilerOptions.UndocumentedEmptyBlock);
			
		case IProblem.UnnecessaryCast:
		case IProblem.UnnecessaryInstanceof:
			return customOptions().getSeverity(CompilerOptions.UnnecessaryTypeCheck);
			
		case IProblem.FinallyMustCompleteNormally:
			return customOptions().getSeverity(CompilerOptions.FinallyBlockNotCompleting);
			
		case IProblem.UnusedMethodDeclaredThrownException:
		case IProblem.UnusedConstructorDeclaredThrownException:
			return customOptions().getSeverity(CompilerOptions.UnusedDeclaredThrownException);

		case IProblem.UnqualifiedFieldAccess:
			return customOptions().getSeverity(CompilerOptions.UnqualifiedFieldAccess);
		
		case IProblem.UnnecessaryElse:
			return customOptions().getSeverity(CompilerOptions.UnnecessaryElse);

		case IProblem.UnsafeRawConstructorInvocation:
		case IProblem.UnsafeRawMethodInvocation:
		case IProblem.UnsafeTypeConversion:
		case IProblem.UnsafeRawFieldAssignment:
		case IProblem.UnsafeGenericCast:
		case IProblem.UnsafeReturnTypeOverride:
		case IProblem.UnsafeRawGenericMethodInvocation:
		case IProblem.UnsafeRawGenericConstructorInvocation:
			return customOptions().getSeverity(CompilerOptions.UncheckedTypeOperation);

		case IProblem.MissingOverrideAnnotation:
			return customOptions().getSeverity(CompilerOptions.MissingOverrideAnnotation);
			
		case IProblem.FieldMissingDeprecatedAnnotation:
		case IProblem.MethodMissingDeprecatedAnnotation:
		case IProblem.TypeMissingDeprecatedAnnotation:
			return customOptions().getSeverity(CompilerOptions.MissingDeprecatedAnnotation);
			
		case IProblem.FinalBoundForTypeVariable:
		    return customOptions().getSeverity(CompilerOptions.FinalParameterBound);

		case IProblem.MissingSerialVersion:
			return customOptions().getSeverity(CompilerOptions.MissingSerialVersion);
		
		case IProblem.ForbiddenReference:
			return customOptions().getSeverity(CompilerOptions.ForbiddenReference);

		case IProblem.DiscouragedReference:
			return customOptions().getSeverity(CompilerOptions.DiscouragedReference);

		case IProblem.MethodVarargsArgumentNeedCast :
		case IProblem.ConstructorVarargsArgumentNeedCast :
			return customOptions().getSeverity(CompilerOptions.VarargsArgumentNeedCast);

		case IProblem.LocalVariableCannotBeNull :
		case IProblem.LocalVariableCanOnlyBeNull :
			return customOptions().getSeverity(CompilerOptions.NullReference);
			
		case IProblem.BoxingConversion :
		case IProblem.UnboxingConversion :
			return customOptions().getSeverity(CompilerOptions.Autoboxing);

		case IProblem.MissingEnumConstantCase :
			return customOptions().getSeverity(CompilerOptions.IncompleteEnumSwitch);
			
		case IProblem.VarargsConflict :
			return Warning;
			
		case IProblem.AnnotationTypeUsedAsSuperInterface :
			return customOptions().getSeverity(CompilerOptions.AnnotationSuperInterface);
			
		/*
		 * Javadoc syntax errors
		 */
		case IProblem.JavadocUnexpectedTag:
		case IProblem.JavadocDuplicateReturnTag:
		case IProblem.JavadocInvalidThrowsClass:
		case IProblem.JavadocInvalidSeeReference:
		case IProblem.JavadocInvalidParamTagName:
		case IProblem.JavadocInvalidParamTagTypeParameter:
		case IProblem.JavadocMalformedSeeReference:
		case IProblem.JavadocInvalidSeeHref:
		case IProblem.JavadocInvalidSeeArgs:
		case IProblem.JavadocInvalidTag:
		case IProblem.JavadocUnterminatedInlineTag:
		case IProblem.JavadocMissingHashCharacter:
		case IProblem.JavadocEmptyReturnTag:
		case IProblem.JavadocUnexpectedText:
			CompilerOptions cOptions = customOptions();
			if (cOptions.docCommentSupport) {
				return cOptions.getSeverity(CompilerOptions.InvalidJavadoc);
			} else {
				return ProblemSeverities.Ignore;
			}

		/*
		 * Javadoc tags resolved references errors
		 */
		case IProblem.JavadocInvalidParamName:
		case IProblem.JavadocDuplicateParamName:
		case IProblem.JavadocMissingParamName:
		case IProblem.JavadocInvalidThrowsClassName:
		case IProblem.JavadocDuplicateThrowsClassName:
		case IProblem.JavadocMissingThrowsClassName:
		case IProblem.JavadocMissingSeeReference:
		case IProblem.JavadocInvalidValueReference:
		case IProblem.JavadocUndefinedField:
		case IProblem.JavadocAmbiguousField:
		case IProblem.JavadocUndefinedConstructor:
		case IProblem.JavadocAmbiguousConstructor:
		case IProblem.JavadocUndefinedMethod:
		case IProblem.JavadocAmbiguousMethod:
		case IProblem.JavadocAmbiguousMethodReference:
		case IProblem.JavadocParameterMismatch:
		case IProblem.JavadocUndefinedType:
		case IProblem.JavadocAmbiguousType:
		case IProblem.JavadocInternalTypeNameProvided:
		case IProblem.JavadocNoMessageSendOnArrayType:
		case IProblem.JavadocNoMessageSendOnBaseType:
		case IProblem.JavadocInheritedMethodHidesEnclosingName:
		case IProblem.JavadocInheritedFieldHidesEnclosingName:
		case IProblem.JavadocInheritedNameHidesEnclosingTypeName:
		case IProblem.JavadocGenericMethodTypeArgumentMismatch:
		case IProblem.JavadocNonGenericMethod:
		case IProblem.JavadocIncorrectArityForParameterizedMethod:
		case IProblem.JavadocParameterizedMethodArgumentTypeMismatch:
		case IProblem.JavadocTypeArgumentsForRawGenericMethod:
		case IProblem.JavadocGenericConstructorTypeArgumentMismatch:
		case IProblem.JavadocNonGenericConstructor:
		case IProblem.JavadocIncorrectArityForParameterizedConstructor:
		case IProblem.JavadocParameterizedConstructorArgumentTypeMismatch:
		case IProblem.JavadocTypeArgumentsForRawGenericConstructor:
			cOptions = customOptions();
			if (cOptions.docCommentSupport && cOptions.reportInvalidJavadocTags) {
				return cOptions.getSeverity(CompilerOptions.InvalidJavadoc);
			}
			return ProblemSeverities.Ignore;

		/*
		 * Javadoc invalid tags due to deprecated references
		 */
		case IProblem.JavadocUsingDeprecatedField:
		case IProblem.JavadocUsingDeprecatedConstructor:
		case IProblem.JavadocUsingDeprecatedMethod:
		case IProblem.JavadocUsingDeprecatedType:
			cOptions = customOptions();
			if (cOptions.docCommentSupport && cOptions.reportInvalidJavadocTags && cOptions.reportInvalidJavadocTagsDeprecatedRef) {
				return cOptions.getSeverity(CompilerOptions.InvalidJavadoc);
			}
			return ProblemSeverities.Ignore;

		/*
		 * Javadoc invalid tags due to non-visible references
		 */
		case IProblem.JavadocNotVisibleField:
		case IProblem.JavadocNotVisibleConstructor:
		case IProblem.JavadocNotVisibleMethod:
		case IProblem.JavadocNotVisibleType:
			cOptions = customOptions();
			if (cOptions.docCommentSupport && cOptions.reportInvalidJavadocTags && cOptions.reportInvalidJavadocTagsNotVisibleRef) {
				return cOptions.getSeverity(CompilerOptions.InvalidJavadoc);
			}
			return ProblemSeverities.Ignore;

		/*
		 * Javadoc missing tags errors
		 */
		case IProblem.JavadocMissingParamTag:
		case IProblem.JavadocMissingReturnTag:
		case IProblem.JavadocMissingThrowsTag:
			cOptions = customOptions();
			if (cOptions.docCommentSupport) {
				return cOptions.getSeverity(CompilerOptions.MissingJavadocTags);
			} else {
				return ProblemSeverities.Ignore;
			}

		/*
		 * Missing Javadoc errors
		 */
		case IProblem.JavadocMissing:
			cOptions = customOptions();
			if (cOptions.docCommentSupport) {
				return cOptions.getSeverity(CompilerOptions.MissingJavadocComments);
			} else {
				return ProblemSeverities.Ignore;
			}
			
		// by default problems are errors.
		default:
			return Error;
	}
}

