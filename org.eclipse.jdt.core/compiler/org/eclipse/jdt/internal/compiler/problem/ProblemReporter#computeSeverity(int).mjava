/*
 * Given the current configuration, answers which category the problem
 * falls into:
 *		Error | Warning | Ignore
 */
public int computeSeverity(int problemId){

	// severity can have been preset on the problem
//	if ((problem.severity & Fatal) != 0){
//		return Error;
//	}

	// if not then check whether it is a configurable problem
	switch(problemId){

		case IProblem.UnreachableCatch :
		case IProblem.CodeCannotBeReached :
			return this.options.getSeverity(CompilerOptions.UnreachableCode);

		case IProblem.MaskedCatch : 
			return this.options.getSeverity(CompilerOptions.MaskedCatchBlock);

		case IProblem.ImportNotFound :
		case IProblem.ImportNotVisible :
		case IProblem.ImportAmbiguous :
		case IProblem.ImportInternalNameProvided :
		case IProblem.ImportInheritedNameHidesEnclosingName :
		case IProblem.DuplicateImport :
		case IProblem.ConflictingImport :
		case IProblem.CannotImportPackage :
			return this.options.getSeverity(CompilerOptions.ImportProblem);

		case IProblem.UnusedImport :
			// if import problem are disabled, then ignore
			if (this.options.getSeverity(CompilerOptions.ImportProblem) == Ignore) {
				return Ignore;
			}
			return this.options.getSeverity(CompilerOptions.UnusedImport);
			
		case IProblem.MethodButWithConstructorName :
			return this.options.getSeverity(CompilerOptions.MethodWithConstructorName);
		
		case IProblem.OverridingNonVisibleMethod :
			return this.options.getSeverity(CompilerOptions.OverriddenPackageDefaultMethod);

		case IProblem.IncompatibleReturnTypeForNonInheritedInterfaceMethod :
		case IProblem.IncompatibleExceptionInThrowsClauseForNonInheritedInterfaceMethod :
			return this.options.getSeverity(CompilerOptions.IncompatibleNonInheritedInterfaceMethod);

		case IProblem.OverridingDeprecatedMethod :				
		case IProblem.UsingDeprecatedType :				
		case IProblem.UsingDeprecatedMethod :
		case IProblem.UsingDeprecatedConstructor :
		case IProblem.UsingDeprecatedField :
			return this.options.getSeverity(CompilerOptions.UsingDeprecatedAPI);
		
		case IProblem.LocalVariableIsNeverUsed :
			return this.options.getSeverity(CompilerOptions.UnusedLocalVariable);
		
		case IProblem.ArgumentIsNeverUsed :
			return this.options.getSeverity(CompilerOptions.UnusedArgument);

		case IProblem.NoImplicitStringConversionForCharArrayExpression :
			return this.options.getSeverity(CompilerOptions.NoImplicitStringConversion);

		case IProblem.NeedToEmulateFieldReadAccess :
		case IProblem.NeedToEmulateFieldWriteAccess :
		case IProblem.NeedToEmulateMethodAccess :
		case IProblem.NeedToEmulateConstructorAccess :			
			return this.options.getSeverity(CompilerOptions.AccessEmulation);

		case IProblem.NonExternalizedStringLiteral :
			return this.options.getSeverity(CompilerOptions.NonExternalizedString);

		case IProblem.UseAssertAsAnIdentifier :
			return this.options.getSeverity(CompilerOptions.AssertUsedAsAnIdentifier);

		case IProblem.NonStaticAccessToStaticMethod :
		case IProblem.NonStaticAccessToStaticField :
			return this.options.getSeverity(CompilerOptions.NonStaticAccessToStatic);

		case IProblem.IndirectAccessToStaticMethod :
		case IProblem.IndirectAccessToStaticField :
		case IProblem.IndirectAccessToStaticType :
			return this.options.getSeverity(CompilerOptions.IndirectStaticAccess);

		case IProblem.AssignmentHasNoEffect:
			return this.options.getSeverity(CompilerOptions.NoEffectAssignment);

		case IProblem.UnusedPrivateConstructor:
		case IProblem.UnusedPrivateMethod:
		case IProblem.UnusedPrivateField:
		case IProblem.UnusedPrivateType:
			return this.options.getSeverity(CompilerOptions.UnusedPrivateMember);

		case IProblem.Task :
			return Warning;			

		case IProblem.LocalVariableHidingLocalVariable:
		case IProblem.LocalVariableHidingField:
		case IProblem.ArgumentHidingLocalVariable:
		case IProblem.ArgumentHidingField:
			return this.options.getSeverity(CompilerOptions.LocalVariableHiding);

		case IProblem.FieldHidingLocalVariable:
		case IProblem.FieldHidingField:
			return this.options.getSeverity(CompilerOptions.FieldHiding);

		case IProblem.PossibleAccidentalBooleanAssignment:
			return this.options.getSeverity(CompilerOptions.AccidentalBooleanAssign);

		case IProblem.SuperfluousSemicolon:
			return this.options.getSeverity(CompilerOptions.SuperfluousSemicolon);

		case IProblem.UndocumentedEmptyBlock:
			return this.options.getSeverity(CompilerOptions.UndocumentedEmptyBlock);
			
		case IProblem.UnnecessaryCast:
		case IProblem.UnnecessaryArgumentCast:
		case IProblem.UnnecessaryInstanceof:
			return this.options.getSeverity(CompilerOptions.UnnecessaryTypeCheck);
			
		case IProblem.FinallyMustCompleteNormally:
			return this.options.getSeverity(CompilerOptions.FinallyBlockNotCompleting);
			
		case IProblem.UnusedMethodDeclaredThrownException:
		case IProblem.UnusedConstructorDeclaredThrownException:
			return this.options.getSeverity(CompilerOptions.UnusedDeclaredThrownException);

		case IProblem.UnqualifiedFieldAccess:
			return this.options.getSeverity(CompilerOptions.UnqualifiedFieldAccess);

		// Annotation implicit IDs for deprecatedField(...)
		case IProblem.Annotation | IProblem.UsingDeprecatedField:
		// Annotation implicit IDs for deprecatedMethod(...)
		case IProblem.Annotation | IProblem.UsingDeprecatedConstructor:
		case IProblem.Annotation | IProblem.UsingDeprecatedMethod:
		// Annotation implicit IDs for deprecatedType(...)
		case IProblem.Annotation | IProblem.UsingDeprecatedType:
		// Annotation implicit IDs for invalidField(...)
		case IProblem.Annotation | IProblem.UndefinedField:
		case IProblem.Annotation | IProblem.NotVisibleField:
		case IProblem.Annotation | IProblem.AmbiguousField:
		// Annotation implicit IDs for invalidMethod(...)
		case IProblem.Annotation | IProblem.UndefinedMethod:
		case IProblem.Annotation | IProblem.NotVisibleMethod:
		case IProblem.Annotation | IProblem.ParameterMismatch:
		// Annotation implicit IDs for invalidType(...)
		case IProblem.Annotation | IProblem.UndefinedType:
		case IProblem.Annotation | IProblem.NotVisibleType:
		// Annotation implicit IDs for errorNoMethodFor(...)
		case IProblem.Annotation | IProblem.NoMessageSendOnArrayType:
		case IProblem.Annotation | IProblem.NoMessageSendOnBaseType:
		// Annotation explicit IDs
		case IProblem.AnnotationUnexpectedTag:
		case IProblem.AnnotationMissingParamTag:
		case IProblem.AnnotationMissingParamName:
		case IProblem.AnnotationDuplicateParamName:
		case IProblem.AnnotationInvalidParamName:
		case IProblem.AnnotationMissingReturnTag:
		case IProblem.AnnotationDuplicateReturnTag:
		case IProblem.AnnotationMissingThrowsTag:
		case IProblem.AnnotationMissingThrowsClassName:
		case IProblem.AnnotationInvalidThrowsClass:
		case IProblem.AnnotationDuplicateThrowsClassName:
		case IProblem.AnnotationInvalidThrowsClassName:
		case IProblem.AnnotationMissingSeeReference:
		case IProblem.AnnotationInvalidSeeReference:
		case IProblem.AnnotationInvalidSeeHref:
		case IProblem.AnnotationInvalidSeeArgs:
			return this.options.getSeverity(CompilerOptions.InvalidAnnotation);

		case IProblem.AnnotationMissing:
			if (!this.options.reportMissingAnnotation) return Ignore;
			return this.options.getSeverity(CompilerOptions.InvalidAnnotation);

		// by default problems are errors.
		default:
			return Error;
	}
}

