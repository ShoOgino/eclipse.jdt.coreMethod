	/*
	 * Given the current configuration, answers which category the problem
	 * falls into:
	 *		Error | Warning | Ignore
	 */
	public int computeSeverity(int problemId) {

		// severity can have been preset on the problem
		//	if ((problem.severity & Fatal) != 0){
		//		return Error;
		//	}

		// if not then check whether it is a configurable problem
		int errorThreshold = options.errorThreshold;
		int warningThreshold = options.warningThreshold;

		switch (problemId) {

			case UnreachableCatch :
			case CodeCannotBeReached :
				if ((errorThreshold & UnreachableCode) != 0) {
					return Error;
				}
				if ((warningThreshold & UnreachableCode) != 0) {
					return Warning;
				}
				return Ignore;

			case MaskedCatch :
				if ((errorThreshold & MaskedCatchBlock) != 0) {
					return Error;
				}
				if ((warningThreshold & MaskedCatchBlock) != 0) {
					return Warning;
				}
				return Ignore;

				/*
						case Never Used  :
							if ((errorThreshold & ParsingOptionalError) != 0){
								return Error;
							}
							if ((warningThreshold & ParsingOptionalError) != 0){
								return Warning;
							}
							return Ignore;
				*/
			case ImportProblemBase + NotFound :
			case ImportProblemBase + NotVisible :
			case ImportProblemBase + Ambiguous :
			case ImportProblemBase + InternalNameProvided :
			case ImportProblemBase + InheritedNameHidesEnclosingName :
			case DuplicateImport :
			case ConflictingImport :
			case CannotImportPackage :
				if ((errorThreshold & ImportProblem) != 0) {
					return Error;
				}
				if ((warningThreshold & ImportProblem) != 0) {
					return Warning;
				}
				return Ignore;
				/*		
						case UnnecessaryEnclosingInstanceSpecification :
							if ((errorThreshold & UnnecessaryEnclosingInstance) != 0){
								return Error;
							}
							if ((warningThreshold & UnnecessaryEnclosingInstance) != 0){
								return Warning;
							}
							return Ignore;
				*/
			case MethodButWithConstructorName :
				if ((errorThreshold & MethodWithConstructorName) != 0) {
					return Error;
				}
				if ((warningThreshold & MethodWithConstructorName) != 0) {
					return Warning;
				}
				return Ignore;

			case OverridingNonVisibleMethod :
				if ((errorThreshold & OverriddenPackageDefaultMethod) != 0) {
					return Error;
				}
				if ((warningThreshold & OverriddenPackageDefaultMethod) != 0) {
					return Warning;
				}
				return Ignore;

			case OverridingDeprecatedMethod :
			case UsingDeprecatedType :
			case UsingDeprecatedMethod :
			case UsingDeprecatedConstructor :
			case UsingDeprecatedField :
				if ((errorThreshold & UsingDeprecatedAPI) != 0) {
					return Error;
				}
				if ((warningThreshold & UsingDeprecatedAPI) != 0) {
					return Warning;
				}
				return Ignore;

			case LocalVariableIsNeverUsed :
				if ((errorThreshold & UnusedLocalVariable) != 0) {
					return Error;
				}
				if ((warningThreshold & UnusedLocalVariable) != 0) {
					return Warning;
				}
				return Ignore;

			case ArgumentIsNeverUsed :
				if ((errorThreshold & UnusedArgument) != 0) {
					return Error;
				}
				if ((warningThreshold & UnusedArgument) != 0) {
					return Warning;
				}
				return Ignore;

			case NoImplicitStringConversionForCharArrayExpression :
				if ((errorThreshold & TemporaryWarning) != 0) {
					return Error;
				}
				if ((warningThreshold & TemporaryWarning) != 0) {
					return Warning;
				}
				return Ignore;

			case NeedToEmulateFieldReadAccess :
			case NeedToEmulateFieldWriteAccess :
			case NeedToEmulateMethodAccess :
			case NeedToEmulateConstructorAccess :
				if ((errorThreshold & AccessEmulation) != 0) {
					return Error;
				}
				if ((warningThreshold & AccessEmulation) != 0) {
					return Warning;
				}
				return Ignore;

			default :
				return Error;
		}
	}

