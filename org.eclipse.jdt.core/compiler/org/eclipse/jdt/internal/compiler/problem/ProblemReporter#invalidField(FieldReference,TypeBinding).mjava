public void invalidField(FieldReference fieldRef, TypeBinding searchedType) {
	int severity = Error;
	int flag = IProblem.UndefinedField;
	FieldBinding field = fieldRef.binding;
	switch (field.problemId()) {
		case NotFound :
			flag = IProblem.UndefinedField;
/* also need to check that the searchedType is the receiver type
			if (searchedType.isHierarchyInconsistent())
				severity = SecondaryError;
*/
			break;
		case NotVisible :
			flag = IProblem.NotVisibleField;
			break;
		case Ambiguous :
			flag = IProblem.AmbiguousField;
			break;
		case NonStaticReferenceInStaticContext :
			flag = IProblem.NonStaticFieldFromStaticInvocation;
			break;
		case NonStaticReferenceInConstructorInvocation :
			flag = IProblem.InstanceFieldDuringConstructorInvocation;
			break;
		case InheritedNameHidesEnclosingName :
			flag = IProblem.InheritedFieldHidesEnclosingName;
			break;
		case NoError : // 0
		default :
			needImplementation(); // want to fail to see why we were here...
			break;
	}

	String[] arguments = new String[] {new String(field.readableName())};
	this.handle(
		flag,
		arguments,
		arguments,
		severity,
		fieldRef.sourceStart,
		fieldRef.sourceEnd);
}

