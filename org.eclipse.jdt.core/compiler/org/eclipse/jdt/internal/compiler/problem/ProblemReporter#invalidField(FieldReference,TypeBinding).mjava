	public void invalidField(FieldReference fieldRef, TypeBinding searchedType) {
		int severity = Error;
		int flag = UndefinedField;
		FieldBinding field = fieldRef.binding;
		switch (field.problemId()) {
			case NotFound :
				flag = UndefinedField;
				/* also need to check that the searchedType is the receiver type
							if (searchedType.isHierarchyInconsistent())
								severity = SecondaryError;
				*/
				break;
			case NotVisible :
				flag = NotVisibleField;
				break;
			case Ambiguous :
				flag = AmbiguousField;
				break;
			case NonStaticReferenceInStaticContext :
				flag = NonStaticFieldFromStaticInvocation;
				break;
			case NonStaticReferenceInConstructorInvocation :
				flag = InstanceFieldDuringConstructorInvocation;
				break;
			case InheritedNameHidesEnclosingName :
				flag = InheritedFieldHidesEnclosingName;
				break;
			case NoError : // 0
			default :
				needImplementation(); // want to fail to see why we were here...
				break;
		}

		this.handle(
			flag,
			new String[] { new String(field.readableName())},
			severity,
			fieldRef.sourceStart,
			fieldRef.sourceEnd);
	}

