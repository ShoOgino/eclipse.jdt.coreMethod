/*
 * Update the bodyStart of the corresponding parse node
 */
public void notifySourceElementRequestor(AbstractMethodDeclaration methodDeclaration) {
	if (methodDeclaration.isClinit()) {
		this.visitIfNeeded(methodDeclaration);
		return;
	}

	if (methodDeclaration.isDefaultConstructor()) {
		if (reportReferenceInfo) {
			ConstructorDeclaration constructorDeclaration = (ConstructorDeclaration) methodDeclaration;
			ExplicitConstructorCall constructorCall = constructorDeclaration.constructorCall;
			if (constructorCall != null) {
				switch(constructorCall.accessMode) {
					case ExplicitConstructorCall.This :
						requestor.acceptConstructorReference(
							typeNames[nestedTypeIndex-1],
							constructorCall.arguments == null ? 0 : constructorCall.arguments.length, 
							constructorCall.sourceStart);
						break;
					case ExplicitConstructorCall.Super :
					case ExplicitConstructorCall.ImplicitSuper :					
						requestor.acceptConstructorReference(
							superTypeNames[nestedTypeIndex-1],
							constructorCall.arguments == null ? 0 : constructorCall.arguments.length, 
							constructorCall.sourceStart);
						break;
				}
			}
		}	
		return;	
	}	
	char[][] argumentTypes = null;
	char[][] argumentNames = null;
	Argument[] arguments = methodDeclaration.arguments;
	if (arguments != null) {
		int argumentLength = arguments.length;
		argumentTypes = new char[argumentLength][];
		argumentNames = new char[argumentLength][];
		for (int i = 0; i < argumentLength; i++) {
			argumentTypes[i] = returnTypeName(arguments[i].type);
			argumentNames[i] = arguments[i].name;
		}
	}
	char[][] thrownExceptionTypes = null;
	TypeReference[] thrownExceptions = methodDeclaration.thrownExceptions;
	if (thrownExceptions != null) {
		int thrownExceptionLength = thrownExceptions.length;
		thrownExceptionTypes = new char[thrownExceptionLength][];
		for (int i = 0; i < thrownExceptionLength; i++) {
			thrownExceptionTypes[i] = 
				CharOperation.concatWith(thrownExceptions[i].getTypeName(), '.'); 
		}
	}
	// by default no selector end position
	int selectorSourceEnd = -1;
	if (methodDeclaration.isConstructor()) {
		if (methodDeclaration instanceof SourceConstructorDeclaration) {
			selectorSourceEnd = 
				((SourceConstructorDeclaration) methodDeclaration).selectorSourceEnd; 
		}
		if (scanner.initialPosition <= methodDeclaration.declarationSourceStart) {
			requestor.enterConstructor(
				methodDeclaration.declarationSourceStart, 
				methodDeclaration.modifiers, 
				methodDeclaration.selector, 
				methodDeclaration.sourceStart, 
				selectorSourceEnd, 
				argumentTypes, 
				argumentNames, 
				thrownExceptionTypes);
			if (reportReferenceInfo) {
				ConstructorDeclaration constructorDeclaration = (ConstructorDeclaration) methodDeclaration;
				ExplicitConstructorCall constructorCall = constructorDeclaration.constructorCall;
				if (constructorCall != null) {
					switch(constructorCall.accessMode) {
						case ExplicitConstructorCall.This :
							requestor.acceptConstructorReference(
								typeNames[nestedTypeIndex-1],
								constructorCall.arguments == null ? 0 : constructorCall.arguments.length, 
								constructorCall.sourceStart);
							break;
						case ExplicitConstructorCall.Super :
						case ExplicitConstructorCall.ImplicitSuper :
							requestor.acceptConstructorReference(
								superTypeNames[nestedTypeIndex-1],
								constructorCall.arguments == null ? 0 : constructorCall.arguments.length, 
								constructorCall.sourceStart);
							break;
					}
				}
			}
		}
		if (scanner.eofPosition >= methodDeclaration.declarationSourceEnd) {
			requestor.exitConstructor(methodDeclaration.declarationSourceEnd);
		}
		return;
	}
	if (methodDeclaration instanceof SourceMethodDeclaration) {
		selectorSourceEnd = 
			((SourceMethodDeclaration) methodDeclaration).selectorSourceEnd; 
	}
	requestor.enterMethod(
		methodDeclaration.declarationSourceStart, 
		methodDeclaration.modifiers, 
		returnTypeName(((MethodDeclaration) methodDeclaration).returnType), 
		methodDeclaration.selector, 
		methodDeclaration.sourceStart, 
		selectorSourceEnd, 
		argumentTypes, 
		argumentNames, 
		thrownExceptionTypes); 
		
	this.visitIfNeeded(methodDeclaration);
	
	requestor.exitMethod(methodDeclaration.declarationSourceEnd);
}

