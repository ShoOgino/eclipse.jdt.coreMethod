public void notifySourceElementRequestor(TypeDeclaration typeDeclaration, boolean notifyTypePresence) {
	FieldDeclaration[] fields = typeDeclaration.fields;
	AbstractMethodDeclaration[] methods = typeDeclaration.methods;
	MemberTypeDeclaration[] memberTypes = typeDeclaration.memberTypes;
	int fieldCount = fields == null ? 0 : fields.length;
	int methodCount = methods == null ? 0 : methods.length;
	int memberTypeCount = memberTypes == null ? 0 : memberTypes.length;
	int fieldIndex = 0;
	int methodIndex = 0;
	int memberTypeIndex = 0;
	boolean isInterface = typeDeclaration.isInterface();

	if (notifyTypePresence){
		char[][] interfaceNames = null;
		int superInterfacesLength = 0;
		TypeReference[] superInterfaces = typeDeclaration.superInterfaces;
		if (superInterfaces != null) {
			superInterfacesLength = superInterfaces.length;
			interfaceNames = new char[superInterfacesLength][];
		}
		if (superInterfaces != null) {
			for (int i = 0; i < superInterfacesLength; i++) {
				interfaceNames[i] = 
					CharOperation.concatWith(superInterfaces[i].getTypeName(), '.'); 
			}
		}
		if (isInterface) {
			requestor.enterInterface(
				typeDeclaration.declarationSourceStart, 
				typeDeclaration.modifiers, 
				typeDeclaration.name, 
				typeDeclaration.sourceStart, 
				typeDeclaration.sourceEnd, 
				interfaceNames);
			if (nestedTypeIndex == typeNames.length) {
				// need a resize
				System.arraycopy(typeNames, 0, (typeNames = new char[nestedTypeIndex * 2][]), 0, nestedTypeIndex);
				System.arraycopy(superTypeNames, 0, (superTypeNames = new char[nestedTypeIndex * 2][]), 0, nestedTypeIndex);
			}
			typeNames[nestedTypeIndex] = typeDeclaration.name;
			superTypeNames[nestedTypeIndex++] = JAVA_LANG_OBJECT;
		} else {
			TypeReference superclass = typeDeclaration.superclass;
			if (superclass == null) {
				requestor.enterClass(
					typeDeclaration.declarationSourceStart, 
					typeDeclaration.modifiers, 
					typeDeclaration.name, 
					typeDeclaration.sourceStart, 
					typeDeclaration.sourceEnd, 
					null, 
					interfaceNames); 
			} else {
				requestor.enterClass(
					typeDeclaration.declarationSourceStart, 
					typeDeclaration.modifiers, 
					typeDeclaration.name, 
					typeDeclaration.sourceStart, 
					typeDeclaration.sourceEnd, 
					CharOperation.concatWith(superclass.getTypeName(), '.'), 
					interfaceNames); 
			}
			if (nestedTypeIndex == typeNames.length) {
				// need a resize
				System.arraycopy(typeNames, 0, (typeNames = new char[nestedTypeIndex * 2][]), 0, nestedTypeIndex);
				System.arraycopy(superTypeNames, 0, (superTypeNames = new char[nestedTypeIndex * 2][]), 0, nestedTypeIndex);
			}
			typeNames[nestedTypeIndex] = typeDeclaration.name;
			superTypeNames[nestedTypeIndex++] = superclass == null ? JAVA_LANG_OBJECT : CharOperation.concatWith(superclass.getTypeName(), '.');
		}
	}
	while ((fieldIndex < fieldCount)
		|| (memberTypeIndex < memberTypeCount)
		|| (methodIndex < methodCount)) {
		FieldDeclaration nextFieldDeclaration = null;
		AbstractMethodDeclaration nextMethodDeclaration = null;
		TypeDeclaration nextMemberDeclaration = null;

		int position = Integer.MAX_VALUE;
		int nextDeclarationType = -1;
		if (fieldIndex < fieldCount) {
			nextFieldDeclaration = fields[fieldIndex];
			if (nextFieldDeclaration.declarationSourceStart < position) {
				position = nextFieldDeclaration.declarationSourceStart;
				nextDeclarationType = 0; // FIELD
			}
		}
		if (methodIndex < methodCount) {
			nextMethodDeclaration = methods[methodIndex];
			if (nextMethodDeclaration.declarationSourceStart < position) {
				position = nextMethodDeclaration.declarationSourceStart;
				nextDeclarationType = 1; // METHOD
			}
		}
		if (memberTypeIndex < memberTypeCount) {
			nextMemberDeclaration = memberTypes[memberTypeIndex];
			if (nextMemberDeclaration.declarationSourceStart < position) {
				position = nextMemberDeclaration.declarationSourceStart;
				nextDeclarationType = 2; // MEMBER
			}
		}
		switch (nextDeclarationType) {
			case 0 :
				fieldIndex++;
				notifySourceElementRequestor(nextFieldDeclaration);
				break;
			case 1 :
				methodIndex++;
				notifySourceElementRequestor(nextMethodDeclaration);
				break;
			case 2 :
				memberTypeIndex++;
				notifySourceElementRequestor(nextMemberDeclaration, true);
		}
	}
	if (notifyTypePresence){
		if (isInterface) {
			requestor.exitInterface(typeDeclaration.declarationSourceEnd);
		} else {
			requestor.exitClass(typeDeclaration.declarationSourceEnd);
		}
		nestedTypeIndex--;
	}
}

