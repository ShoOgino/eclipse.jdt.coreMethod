private final boolean atReferenceExpression() {

	/* The cursor is at a '<' that figures just past the non terminal symbol `Name' and the parser is parsing a primary expression.
	   Look ahead and answer true if we are at a method or constructor reference expression and false otherwise.

	   ReferenceExpression ::= Name OnlyTypeArgumentsForReferenceExpression Dimsopt '::' NonWildTypeArgumentsopt IdentifierOrNew
	   ReferenceExpression ::= Name OnlyTypeArgumentsForReferenceExpression '.' ClassOrInterfaceType Dimsopt '::' NonWildTypeArgumentsopt IdentifierOrNew
	   
	    Note: At this point, we don't handle annotations on dimensions, I think it is illegal, but needs to be verified.
	*/ 
	
	int savedCurrentPosition = this.currentPosition;
	int savedStartPosition = this.startPosition;
	char savedCurrentCharacter = this.currentCharacter;
	char[] savedWithoutUnicodeBuffer = null;
	int savedWithoutUnicodePtr = this.withoutUnicodePtr;
	if (savedWithoutUnicodePtr != 0) {
		int length = this.withoutUnicodeBuffer.length;
		System.arraycopy(this.withoutUnicodeBuffer, 0, savedWithoutUnicodeBuffer = new char [length], 0, length);
	}

	boolean atReferenceExpression = false;
	boolean whiteSpace;
	
	boolean justPastIdentifier = true, justPastDot = false, justPastTypeArguments = false;
	char c = '<';
	
	try {
		done:
			while (true) {
				NextToken: switch (c) {
					case '[' :
					case ']' :
						break NextToken; // good enough for now.
					case '<' :
						if (justPastIdentifier) {
							jumpOver('<' , '>', typeArgumentsBlackList);
							if (this.currentCharacter != '>')
								throw new InvalidInputException();
							justPastIdentifier = false;
							justPastTypeArguments = true;
							justPastDot = false;
							break NextToken;
						}
						throw new InvalidInputException();
					case '.' :
						if (justPastIdentifier || justPastTypeArguments) {
							justPastIdentifier = false;
							justPastTypeArguments = false;
							justPastDot = true;
							break NextToken;
						}
						throw new InvalidInputException();
					case ':' :
						if (justPastIdentifier || justPastTypeArguments) {
							if (getNextChar(':')) {
								atReferenceExpression = true;
								break done;
							}
						}
						throw new InvalidInputException();
					default:
						if (!justPastDot) {
							throw new InvalidInputException();
						}
						if (c < ScannerHelper.MAX_OBVIOUS) {
							if ((ScannerHelper.OBVIOUS_IDENT_CHAR_NATURES[c] & ScannerHelper.C_IDENT_START) != 0) {
								scanIdentifierOrKeyword();
								justPastDot = false;
								justPastIdentifier = true;
								justPastTypeArguments = false;
								break NextToken;
							}
							throw new InvalidInputException();
						}
						boolean isJavaIdStart;
						if (c >= HIGH_SURROGATE_MIN_VALUE && c <= HIGH_SURROGATE_MAX_VALUE) {
							// Unicode 4 detection
							char low = (char) getNextChar();
							if (low < LOW_SURROGATE_MIN_VALUE || low > LOW_SURROGATE_MAX_VALUE) {
								// illegal low surrogate
								throw new InvalidInputException();
							}
							isJavaIdStart = ScannerHelper.isJavaIdentifierStart(this.complianceLevel, c, low);
						} else if (c >= LOW_SURROGATE_MIN_VALUE && c <= LOW_SURROGATE_MAX_VALUE) {
							throw new InvalidInputException();
						} else {
							// optimized case already checked
							isJavaIdStart = ScannerHelper.isJavaIdentifierStart(this.complianceLevel, c);
						}
						if (isJavaIdStart) {
							scanIdentifierOrKeyword();
							justPastDot = false;
							justPastIdentifier = true;
							justPastTypeArguments = false;
							break NextToken;
						}
						throw new InvalidInputException();
				}
				do { // skip past white space
					this.startPosition = this.currentPosition;
					if (((this.currentCharacter = this.source[this.currentPosition++]) == '\\')
							&& (this.source[this.currentPosition] == 'u')) {
						whiteSpace = jumpOverUnicodeWhiteSpace();
					} else {
						whiteSpace = CharOperation.isWhitespace(this.currentCharacter);
					}
				} while (whiteSpace);
				c = this.currentCharacter;  //next non-white character, loop back to decide what to do.
			}	
	} catch (Exception e) {
		// ignore
	} finally {
		// Restore status quo ante and return suitable value.
		this.currentPosition = savedCurrentPosition;
		this.startPosition = savedStartPosition;
		this.currentCharacter = savedCurrentCharacter;
		this.withoutUnicodePtr = savedWithoutUnicodePtr;
		if (savedWithoutUnicodePtr != 0) {
			System.arraycopy(savedWithoutUnicodeBuffer, 0, this.withoutUnicodeBuffer, 0, savedWithoutUnicodeBuffer.length);
		}
	}
	return atReferenceExpression;
}

