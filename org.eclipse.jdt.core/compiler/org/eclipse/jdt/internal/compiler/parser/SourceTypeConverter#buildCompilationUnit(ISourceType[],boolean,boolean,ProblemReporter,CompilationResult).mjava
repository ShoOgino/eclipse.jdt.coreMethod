/*
 * Convert a set of source element types into a parsed compilation unit declaration
 * The argument types are then all grouped in the same unit. The argument types must 
 * at least contain one type.
 * Can optionally ignore fields & methods or member types
 */
public static CompilationUnitDeclaration buildCompilationUnit(
	ISourceType[] sourceTypes,
	boolean needFieldsAndMethods,
	boolean needMemberTypes,
	ProblemReporter problemReporter,
	CompilationResult compilationResult) {

	ISourceType sourceType = sourceTypes[0];
	if (sourceType.getName() == null) return null; // do a basic test that the sourceType is valid

	CompilationUnitDeclaration compilationUnit = 
		new CompilationUnitDeclaration(problemReporter, compilationResult, 0); // not filled at this point

	/* only positions available */
	int start = sourceType.getNameSourceStart(); 
	int end = sourceType.getNameSourceEnd();
		
	/* convert package and imports */
	if (sourceType.getPackageName() != null && sourceType.getPackageName().length > 0) // if its null then it is defined in the default package
		compilationUnit.currentPackage = createImportReference(sourceType.getPackageName(), start, end);
	char[][] importNames = sourceType.getImports();
	int importCount = importNames == null ? 0 : importNames.length;
	compilationUnit.imports = new ImportReference[importCount];
	for (int i = 0; i < importCount; i++)
		compilationUnit.imports[i] = createImportReference(importNames[i], start, end);
	/* convert type(s) */
	int typeCount = sourceTypes.length;
	compilationUnit.types = new TypeDeclaration[typeCount];
	for (int i = 0; i < typeCount; i++){
		compilationUnit.types[i] = convert(sourceTypes[i], needFieldsAndMethods, needMemberTypes); 
	}
	return compilationUnit;
}
/*
 * Convert a field source element into a parsed field declaration
 */

