	private AnnotationMessageSend parseArguments(TypeReference receiver) throws InvalidInputException {

		int modulo = 0;	// should be 2 for (Type,Type,...) and 3 for (Type arg,Type arg,...)
		int iToken = 0;
		char[] argName = null;
		int ptr = astPtr;
		int lptr = astLengthPtr;

		// Parse arguments declaration if method reference
		nextArg: while (this.index < this.scanner.eofPosition) {

			// Read argument type reference
			int argStart = this.scanner.getCurrentTokenStartPosition();
			TypeReference typeRef;
			try {
				typeRef = parseQualifiedName(false);
			} catch (InvalidInputException e) {
				break nextArg;
			}
			boolean firstArg = modulo == 0;
			if (firstArg) { // verify position
				if (iToken != 0) break nextArg;
			}
			else {
				if ((iToken % modulo) != 0) break nextArg;
			}
			if (typeRef == null) {
				if (firstArg && this.currentTokenType == TerminalTokens.TokenNameRPAREN) {
					AnnotationMessageSend msg = new AnnotationMessageSend(identifierStack[0], identifierPositionStack[0]);
					msg.receiver = receiver;
					return msg;
				} 
				break nextArg;
			}
			iToken++;

			// Read possible array declaration
			int dim = 0;
			if (readToken() == TerminalTokens.TokenNameLBRACKET) {
				while (readToken() == TerminalTokens.TokenNameLBRACKET) {
					consumeToken();
					if (readToken() != TerminalTokens.TokenNameRBRACKET) {
						break nextArg;
					}
					consumeToken();
					dim++;
				}
				long pos = ((long)typeRef.sourceStart)<<32 + typeRef.sourceEnd;
				if (typeRef instanceof AnnotationSingleTypeReference) {
					AnnotationSingleTypeReference singleRef = (AnnotationSingleTypeReference) typeRef;
					typeRef = new AnnotationArraySingleTypeReference(singleRef.token, dim, pos);
				} else {
					AnnotationQualifiedTypeReference qualifRef = (AnnotationQualifiedTypeReference) typeRef;
					typeRef = new AnnotationArrayQualifiedTypeReference(qualifRef, dim);
				}
			}

			// Read argument name
			if (readToken() == TerminalTokens.TokenNameIdentifier) {
				consumeToken();
				if (firstArg) { // verify position
					if (iToken != 1) break nextArg;
				}
				else {
					if ((iToken % modulo) != 1) break nextArg;
				}
				if (argName == null) { // verify that all arguments name are declared
					if (!firstArg)  break nextArg;
				}
				argName = this.scanner.getCurrentIdentifierSource();
				iToken++;
			}
			else {
				if (argName != null) { // verify that no argument name is declared
					break nextArg;
				}
			}

			// Verify token position
			if (firstArg) {
				modulo = iToken+1;
			}
			else {
				if ((iToken % modulo) != (modulo-1)) break nextArg;
			}

			// Read separator or end arguments declaration
			int token = readToken();
			char[] name = argName==null ? new char[0] : argName;
			if (token == TerminalTokens.TokenNameCOMMA) {
				AnnotationArgumentExpression expr = new AnnotationArgumentExpression(name, argStart, this.scanner.getCurrentTokenStartPosition()-1, typeRef);
				pushOnAstStack(expr, firstArg);
				consumeToken();
				iToken++;
			}
			else if (token == TerminalTokens.TokenNameRPAREN) {
				AnnotationArgumentExpression expr = new AnnotationArgumentExpression(name, argStart, this.scanner.getCurrentTokenStartPosition()-1, typeRef);
				pushOnAstStack(expr, (iToken==(modulo-1)));
				int size = astLengthStack[astLengthPtr--];
				AnnotationArgumentExpression[] arguments = new AnnotationArgumentExpression[size];
				for (int i=(size-1); i>=0; i--) {
					arguments[i] = (AnnotationArgumentExpression) astStack[astPtr--];
				}
				AnnotationMessageSend msg = new AnnotationMessageSend(identifierStack[0], identifierPositionStack[0], arguments);
				msg.receiver = receiver;
				return msg;
			}
			else {
				break nextArg;
			}
		}
		
		// Invalid input: reset ast stacks pointers
		consumeToken();
		if (iToken > 0) {
			this.astPtr = ptr;
			this.astLengthPtr = lptr;
		}
		throw new InvalidInputException();
	}

