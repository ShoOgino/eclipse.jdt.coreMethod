protected void reportSyntaxError(int act, int currentKind, int stateStackTop) {

	/* remember current scanner position */
	int startPos = scanner.startPosition;
	int currentPos = scanner.currentPosition;
	
	String[] expectings;
	String tokenName = name[symbol_index[currentKind]];

	//fetch all "accurate" possible terminals that could recover the error
	int start, end = start = asi(stack[stateStackTop]);
	while (asr[end] != 0)
		end++;
	int length = end - start;
	expectings = new String[length];
	if (length != 0) {
		char[] indexes = new char[length];
		System.arraycopy(asr, start, indexes, 0, length);
		for (int i = 0; i < length; i++) {
			expectings[i] = name[symbol_index[indexes[i]]];
		}
	}

	//if the pb is an EOF, try to tell the user that they are some 
	if (tokenName.equals(UNEXPECTED_EOF)) {
		if (!this.checkAndReportBracketAnomalies(problemReporter())) {
			char[] tokenSource;
			try {
				tokenSource = this.scanner.getCurrentTokenSource();
			} catch (Exception e) {
				tokenSource = new char[] {};
			}
			problemReporter().parseError(
				this.scanner.startPosition, 
				this.scanner.currentPosition - 1, 
				tokenSource, 
				tokenName, 
				expectings); 
		}
	} else { //the next test is HEAVILY grammar DEPENDENT.
		if ((length == 14)
			&& (expectings[0] == "=") //$NON-NLS-1$
			&& (expectings[1] == "*=") //$NON-NLS-1$
			&& (expressionPtr > -1)) {
				switch(currentKind) {
					case ITerminalSymbols.TokenNameSEMICOLON:
					case ITerminalSymbols.TokenNamePLUS:
					case ITerminalSymbols.TokenNameMINUS:
					case ITerminalSymbols.TokenNameDIVIDE:
					case ITerminalSymbols.TokenNameREMAINDER:
					case ITerminalSymbols.TokenNameMULTIPLY:
					case ITerminalSymbols.TokenNameLEFT_SHIFT:
					case ITerminalSymbols.TokenNameRIGHT_SHIFT:
					case ITerminalSymbols.TokenNameUNSIGNED_RIGHT_SHIFT:
					case ITerminalSymbols.TokenNameLESS:
					case ITerminalSymbols.TokenNameGREATER:
					case ITerminalSymbols.TokenNameLESS_EQUAL:
					case ITerminalSymbols.TokenNameGREATER_EQUAL:
					case ITerminalSymbols.TokenNameEQUAL_EQUAL:
					case ITerminalSymbols.TokenNameNOT_EQUAL:
					case ITerminalSymbols.TokenNameXOR:
					case ITerminalSymbols.TokenNameAND:
					case ITerminalSymbols.TokenNameOR:
					case ITerminalSymbols.TokenNameOR_OR:
					case ITerminalSymbols.TokenNameAND_AND:
						// the ; is not the expected token ==> it ends a statement when an expression is not ended
						problemReporter().invalidExpressionAsStatement(expressionStack[expressionPtr]);
						break;
					case ITerminalSymbols.TokenNameRBRACE :
						problemReporter().missingSemiColon(expressionStack[expressionPtr]);
						break;
					default:
						char[] tokenSource;
						try {
							tokenSource = this.scanner.getCurrentTokenSource();
						} catch (Exception e) {
							tokenSource = new char[] {};
						}
						problemReporter().parseError(
							this.scanner.startPosition, 
							this.scanner.currentPosition - 1, 
							tokenSource, 
							tokenName, 
							expectings); 
						this.checkAndReportBracketAnomalies(problemReporter());
				}
		} else {
			char[] tokenSource;
			try {
				tokenSource = this.scanner.getCurrentTokenSource();
			} catch (Exception e) {
				tokenSource = new char[] {};
			}
			problemReporter().parseError(
				this.scanner.startPosition, 
				this.scanner.currentPosition - 1, 
				tokenSource, 
				tokenName, 
				expectings); 
			this.checkAndReportBracketAnomalies(problemReporter());
		}
	}
	/* reset scanner where it was */
	scanner.startPosition = startPos;
	scanner.currentPosition = currentPos;
}

