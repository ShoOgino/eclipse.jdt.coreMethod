/*
 * Rebuild a flattened block from the nested structure which is in scope
 */
public Statement updateStatement(int depth, Set knownTypes){

	// if block was closed or empty, then ignore it
	if (this.blockDeclaration.sourceEnd != 0 || this.statementCount == 0) return null;
	
	/* If this block stands for the lambda body, trash the contents. Lambda expressions are recovered as part of the enclosing statement.
	   We still have left in a block here to make sure that contained elements can be trapped and tossed out.
	*/
	if (this.blockDeclaration.lambdaBody) return null; 

	Statement[] updatedStatements = new Statement[this.statementCount];
	int updatedCount = 0;

	// only collect the non-null updated statements
	for (int i = 0; i < this.statementCount; i++){
		Statement updatedStatement = this.statements[i].updatedStatement(depth, knownTypes);
		if (updatedStatement != null){
			updatedStatements[updatedCount++] = updatedStatement;
		}
	}
	if (updatedCount == 0) return null; // not interesting block

	// resize statement collection if necessary
	if (updatedCount != this.statementCount){
		this.blockDeclaration.statements = new Statement[updatedCount];
		System.arraycopy(updatedStatements, 0, this.blockDeclaration.statements, 0, updatedCount);
	} else {
		this.blockDeclaration.statements = updatedStatements;
	}

	return this.blockDeclaration;
}

