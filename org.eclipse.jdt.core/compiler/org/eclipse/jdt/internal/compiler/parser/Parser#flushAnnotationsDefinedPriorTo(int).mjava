public int flushAnnotationsDefinedPriorTo(int position) {

	int lastAnnotationIndex = scanner.commentPtr;
	if (lastAnnotationIndex < 0) return position; // no comment

	// compute the index of the first obsolete comment
	int index = lastAnnotationIndex;
	int validCount = 0;
	while (index >= 0){
		int commentEnd = scanner.commentStops[index];
		if (commentEnd < 0) commentEnd = -commentEnd; // negative end position for non-javadoc comments
		if (commentEnd <= position){
			break;
		}
		index--;
		validCount++;
	}
	// if the source at <position> is immediately followed by a line comment, then
	// flush this comment and shift <position> to the comment end.
	if (validCount > 0){
		int immediateCommentEnd = -scanner.commentStops[index+1]; //non-javadoc comment end positions are negative
		if (immediateCommentEnd > 0){ // only tolerating non-javadoc comments
			// is there any line break until the end of the immediate comment ? (thus only tolerating line comment)
			immediateCommentEnd--; // comment end in one char too far
			if (scanner.searchLineNumber(position) == scanner.searchLineNumber(immediateCommentEnd)){
				position = immediateCommentEnd;
				validCount--; // flush this comment
				index++;
			}
		}
	}
	// position can be located in the middle of a line break
	// this is a bug on Windows platform only.
	// http://dev.eclipse.org/bugs/show_bug.cgi?id=10557
	char[] source = scanner.source;
	
	if ((source[position] == '\r')
	    && ((position + 1) < source.length)
	    && (source[position + 1] == '\n')) {
		position++;
	}
	if (index < 0) return position; // no obsolete comment

	if (validCount > 0){ // move valid comment infos, overriding obsolete comment infos
		System.arraycopy(scanner.commentStarts, index + 1, scanner.commentStarts, 0, validCount);
		System.arraycopy(scanner.commentStops, index + 1, scanner.commentStops, 0, validCount);		
	}
	scanner.commentPtr = validCount - 1;
	return position;
}

