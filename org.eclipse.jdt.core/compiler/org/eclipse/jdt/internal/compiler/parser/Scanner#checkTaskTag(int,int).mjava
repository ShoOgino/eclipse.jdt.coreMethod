// chech presence of task: tags
public void checkTaskTag(int commentStart, int commentEnd) {

	// only look for newer task: tags
	if (this.taskCount > 0 && this.taskPositions[this.taskCount-1][0] >= commentStart) {
		return;
	}
	nextChar: for (int i = commentStart; i < commentEnd && i < this.eofPosition; i++) {

		int nextPos = -1;
		
		// check for tag occurrence
		nextTag: for (int itag = 0; itag < this.taskTags.length; itag++){
			char[] tag = this.taskTags[itag];
			int tagLength = tag.length;
			for (int t = 0; t < tagLength; t++){
				if (this.source[i+t] != tag[t]) continue nextTag;
			}
			nextPos = i + tagLength;
			break;
		}
		if (nextPos < 0) continue nextChar;

		// extract message
		char c = this.source[nextPos];
		int start = i; 
		int msgStart = nextPos;
		int end = -1;
		for (int j = nextPos; j < commentEnd; j++){
			if ((c = this.source[j]) == '\n' || c == '\r'){
				end = j - 1;
				i = j+1;
				break;
			}
		}
		if (end < 0){
			for (int j = commentEnd; j >= nextPos; j--){
				if ((c = this.source[j]) == '*') {
					end = j - 1;
					break;
				}
			}
			if (end < 0) end = nextPos+1;
		}
		
		// trim message
		while (source[msgStart] == ' ' && msgStart <= end) msgStart++;
		while (source[end] == ' ' && start <= end) end--;
		
		char[] message = new char[end-msgStart+1];
		System.arraycopy(source, msgStart, message, 0, end-msgStart+1);
				
		if (this.taskMessages == null){
			this.taskMessages = new char[5][];
			this.taskPositions = new int[5][];
		} else if (this.taskCount == this.taskMessages.length) {
			System.arraycopy(this.taskMessages, 0, this.taskMessages = new char[this.taskCount*2][], 0, this.taskCount);
			System.arraycopy(this.taskPositions, 0, this.taskPositions = new int[this.taskCount*2][], 0, this.taskCount);
		}
		this.taskMessages[this.taskCount] = message;
		this.taskPositions[this.taskCount] = new int[]{ start, end };
		this.taskCount++;
	}
}

