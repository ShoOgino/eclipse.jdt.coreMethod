	/*
	 * Convert a source element type into a parsed type declaration
	 *
	 * Can optionally ignore fields & methods or member types
	 */
	public static CompilationUnitDeclaration buildCompilationUnit(
		ISourceType sourceType,
		boolean needFieldsAndMethods,
		boolean needMemberTypes,
		ProblemReporter problemReporter,
		CompilationResult compilationResult) {

		if (sourceType.getName() == null)
			return null; // do a basic test that the sourceType is valid

		CompilationUnitDeclaration compilationUnit =
			new CompilationUnitDeclaration(problemReporter, compilationResult, 0);
		// not filled at this point

		/* only positions available */
		int start = sourceType.getNameSourceStart();
		int end = sourceType.getNameSourceEnd();

		/* convert package and imports */
		if (sourceType.getPackageName() != null
			&& sourceType.getPackageName().length > 0)
			// if its null then it is defined in the default package
			compilationUnit.currentPackage =
				createImportReference(sourceType.getPackageName(), start, end);
		char[][] importNames = sourceType.getImports();
		int importCount = importNames == null ? 0 : importNames.length;
		compilationUnit.imports = new ImportReference[importCount];
		for (int i = 0; i < importCount; i++)
			compilationUnit.imports[i] = createImportReference(importNames[i], start, end);
		/* convert type */
		compilationUnit.types =
			new TypeDeclaration[] {
				 convert(sourceType, needFieldsAndMethods, needMemberTypes)};

		return compilationUnit;
	}

