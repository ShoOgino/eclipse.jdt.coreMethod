public char[] getCurrentTextBlock() {
	// 1. Normalize, i.e. convert all CR CRLF to LF
	char[] all;
	if (this.withoutUnicodePtr != 0) {
		all = CharOperation.subarray(this.withoutUnicodeBuffer, this.rawStart + 1, this.withoutUnicodePtr + 1 );
	} else {
		all = CharOperation.subarray(this.source, this.startPosition + this.rawStart, this.currentPosition - 3);
		if (all == null) {
			all = new char[0];
		}
	}
	// 2. Split into lines. Consider both \n and \r as line separators
	char[][] lines = CharOperation.splitOn('\n', all);
	int size = lines.length;
	List<char[]> list = new ArrayList<>(lines.length);
	for(int i = 0; i < lines.length; i++) {
		char[] line = lines[i];
		if (i + 1 == size && line.length == 0) {
			list.add(line);
			break;
		}
		char[][] sub = CharOperation.splitOn('\r', line);
		for (char[] cs : sub) {
			if (cs.length > 0) {
				list.add(cs);
			}
		}
	}
	size = list.size();
	lines = list.toArray(new char[size][]);

	// 	3. Handle incidental white space
	//  3.1. Split into lines and identify determining lines
	int prefix = -1;
	for(int i = 0; i < size; i++) {
		char[] line = lines[i];
		boolean blank = true;
		int whitespaces = 0;
 		for (char c : line) {
			if (blank) {
				if (ScannerHelper.isWhitespace(c)) {
					whitespaces++;
				} else {
					blank = false;
				}
			}
		}
		if (!blank || (i+1 == size)) {
			if (prefix < 0 || whitespaces < prefix) {
 				prefix = whitespaces;
			}
		}
	}
	// 3.2. Remove the common white space prefix
	// 4. Handle escape sequences (already done while processing
	if (prefix == -1)
		prefix = 0;
	char[] result = new char[0];
	for(int i = 0; i < lines.length; i++) {
		char[] l  = lines[i];
		// Remove the common prefix from each line
		// And remove all trailing whitespace
		// Finally append the \n at the end of the line (except the last line)
		int length = l.length;
		int trail = length - 1;
		for(int j = trail; j>0; j--) {
			if (!ScannerHelper.isWhitespace(l[j])) {
				trail = j;
				break;
			}
		}
		int newSize = (length == 0 || prefix > trail) ? 0 : (trail - prefix + 1);
		char[] nl;
		if (i >= (size - 1)) {
			if (trail <= 0 || newSize == 0)
				continue;
			nl = new char[newSize];
			System.arraycopy(l, prefix, nl, 0, newSize); 
		} else {
			newSize += 1;
			nl = new char[newSize];
			nl[newSize - 1] = '\n';
			if (newSize > 1)
				System.arraycopy(l, prefix, nl, 0, newSize - 1);
		}
		result = CharOperation.concat(result, nl);
	}
	//	get rid of all the cached values
	this.rawStart = -1;
	return result;
}

