private void consumeTypeTestPattern() {
	TypeReference type;
	char[] identifierName = this.identifierStack[this.identifierPtr];
	long namePosition = this.identifierPositionStack[this.identifierPtr];

	LocalDeclaration local = createLocalDeclaration(identifierName, (int) (namePosition >>> 32), (int) namePosition);
	local.declarationSourceEnd = local.declarationEnd;

	this.identifierPtr--;
	this.identifierLengthPtr--;

	type = getTypeReference(this.intStack[this.intPtr--]); //getTypeReference(0); // no type dimension
	local.declarationSourceStart = type.sourceStart;
	local.type = type;
	if (!this.parsingJava14Plus) {
		problemReporter().previewFeatureNotSupported(type.sourceStart, local.declarationEnd, "Instanceof Pattern", CompilerOptions.VERSION_13); //$NON-NLS-1$
	} else if (!this.options.enablePreviewFeatures){
		problemReporter().previewFeatureNotEnabled(type.sourceStart, local.declarationEnd, "Instanceof Pattern"); //$NON-NLS-1$
	} else {
		if (this.options.isAnyEnabled(IrritantSet.PREVIEW)) {
			problemReporter().previewFeatureUsed(type.sourceStart, local.declarationEnd);
		}
	}
	local.modifiers |= ClassFileConstants.AccFinal;
	pushOnPatternStack(local);
}

