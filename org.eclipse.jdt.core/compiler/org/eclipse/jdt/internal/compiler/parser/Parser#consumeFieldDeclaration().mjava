	protected void consumeFieldDeclaration() {
		// See consumeLocalVariableDeclarationDefaultModifier() in case of change: duplicated code
		// FieldDeclaration ::= Modifiersopt Type VariableDeclarators ';'

		/*
		astStack : 
		expressionStack: Expression Expression ...... Expression
		identifierStack : type  identifier identifier ...... identifier
		intStack : typeDim      dim        dim               dim
		 ==>
		astStack : FieldDeclaration FieldDeclaration ...... FieldDeclaration
		expressionStack :
		identifierStack : 
		intStack : 
		  
		*/
		int variableDeclaratorsCounter = astLengthStack[astLengthPtr];

		for (int i = variableDeclaratorsCounter - 1; i >= 0; i--) {
			FieldDeclaration fieldDeclaration = (FieldDeclaration) astStack[astPtr - i];
			fieldDeclaration.declarationSourceEnd = endStatementPosition;
			// semi-colon included
		}
		updateSourceDeclarationParts(variableDeclaratorsCounter);
		int endPos = flushAnnotationsDefinedPriorTo(endStatementPosition);
		if (endPos != endStatementPosition) {
			for (int i = 0; i < variableDeclaratorsCounter; i++) {
				FieldDeclaration fieldDeclaration = (FieldDeclaration) astStack[astPtr - i];
				fieldDeclaration.declarationSourceEnd = endPos;
			}
		}
		// update the astStack, astPtr and astLengthStack
		int startIndex = astPtr - variablesCounter[nestedType] + 1;
		System.arraycopy(
			astStack,
			startIndex,
			astStack,
			startIndex - 1,
			variableDeclaratorsCounter);
		astPtr--; // remove the type reference
		astLengthStack[--astLengthPtr] = variableDeclaratorsCounter;

		// recovery
		if (currentElement != null) {
			lastCheckPoint = endPos + 1;
			if (currentElement.parent != null
				&& currentElement instanceof RecoveredField) {
				currentElement = currentElement.parent;
			}
			restartRecovery = true;
		}
		variablesCounter[nestedType] = 0;
	}

