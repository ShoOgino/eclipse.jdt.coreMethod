	/*
	 * Convert a source element type into a parsed type declaration
	 *
	 * Can optionally ignore fields & methods
	 */
	private TypeDeclaration convert(
		ISourceType sourceType,
		boolean needFieldsAndMethods,
		boolean needMemberTypes,
		CompilationResult compilationResult) {
		/* create type declaration - can be member type */
		TypeDeclaration type;
		if (sourceType.getEnclosingType() == null) {
			type = new TypeDeclaration(compilationResult);
		} else {
			type = new MemberTypeDeclaration(compilationResult);
		}
		type.name = sourceType.getName();
		int start, end; // only positions available
		type.sourceStart = start = sourceType.getNameSourceStart();
		type.sourceEnd = end = sourceType.getNameSourceEnd();
		type.modifiers = sourceType.getModifiers();
		type.declarationSourceStart = sourceType.getDeclarationSourceStart();
		type.declarationSourceEnd = sourceType.getDeclarationSourceEnd();
		type.bodyEnd = type.declarationSourceEnd;

		/* set superclass and superinterfaces */
		if (sourceType.getSuperclassName() != null)
			type.superclass =
				createTypeReference(sourceType.getSuperclassName(), start, end);
		char[][] interfaceNames = sourceType.getInterfaceNames();
		int interfaceCount = interfaceNames == null ? 0 : interfaceNames.length;
		type.superInterfaces = new TypeReference[interfaceCount];
		for (int i = 0; i < interfaceCount; i++) {
			type.superInterfaces[i] = createTypeReference(interfaceNames[i], start, end);
		}
		/* convert member types */
		if (needMemberTypes) {
			ISourceType[] sourceMemberTypes = sourceType.getMemberTypes();
			int sourceMemberTypeCount =
				sourceMemberTypes == null ? 0 : sourceMemberTypes.length;
			type.memberTypes = new MemberTypeDeclaration[sourceMemberTypeCount];
			for (int i = 0; i < sourceMemberTypeCount; i++) {
				type.memberTypes[i] =
					(MemberTypeDeclaration) convert(sourceMemberTypes[i],
						needFieldsAndMethods,
						true,
						compilationResult);
			}
		}
		/* convert fields and methods */
		if (needFieldsAndMethods) {
			/* convert fields */
			ISourceField[] sourceFields = sourceType.getFields();
			int sourceFieldCount = sourceFields == null ? 0 : sourceFields.length;
			type.fields = new FieldDeclaration[sourceFieldCount];
			for (int i = 0; i < sourceFieldCount; i++) {
				type.fields[i] = convert(sourceFields[i], type);
			}

			/* convert methods - need to add default constructor if necessary */
			ISourceMethod[] sourceMethods = sourceType.getMethods();
			int sourceMethodCount = sourceMethods == null ? 0 : sourceMethods.length;

			/* source type has a constructor ?           */
			/* by default, we assume that one is needed. */
			int neededCount = 0;
			if (!type.isInterface()) {
				neededCount = 1;
				for (int i = 0; i < sourceMethodCount; i++) {
					if (sourceMethods[i].isConstructor()) {
						neededCount = 0;
						// Does not need the extra constructor since one constructor already exists.
						break;
					}
				}
			}
			type.methods = new AbstractMethodDeclaration[sourceMethodCount + neededCount];
			if (neededCount != 0) { // add default constructor in first position
				type.methods[0] = type.createsInternalConstructor(false, false);
			}
			boolean isInterface = type.isInterface();
			for (int i = 0; i < sourceMethodCount; i++) {
				AbstractMethodDeclaration method =convert(sourceMethods[i], compilationResult);
				if (isInterface || method.isAbstract()) { // fix-up flag 
					method.modifiers |= AccSemicolonBody;
				}
				type.methods[neededCount + i] = method;
			}
		}
		return type;
	}

