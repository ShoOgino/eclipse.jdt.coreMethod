/*
 * Convert a method source element into a parsed method/constructor declaration 
 */
private static AbstractMethodDeclaration convert(ISourceMethod sourceMethod) {

	AbstractMethodDeclaration method;

	/* only source positions available */
	int start = sourceMethod.getNameSourceStart();
	int end = sourceMethod.getNameSourceEnd();

	if (sourceMethod.isConstructor()) {
		ConstructorDeclaration decl = new ConstructorDeclaration();
		decl.isDefaultConstructor = false;
		method = decl;
	} else {
		MethodDeclaration decl = new MethodDeclaration();
		/* convert return type */
		decl.returnType = 
			createTypeReference(sourceMethod.getReturnTypeName(), start, end); 
		method = decl;
	}
	method.selector = sourceMethod.getSelector();
	method.modifiers = sourceMethod.getModifiers();
	method.sourceStart = start;
	method.sourceEnd = end;
	method.declarationSourceStart = sourceMethod.getDeclarationSourceStart();
	method.declarationSourceEnd = sourceMethod.getDeclarationSourceEnd();

	/* convert arguments */
	char[][] argumentTypeNames = sourceMethod.getArgumentTypeNames();
	char[][] argumentNames = sourceMethod.getArgumentNames();
	int argumentCount = argumentTypeNames == null ? 0 : argumentTypeNames.length;
	long position = (long) start << 32 + end;
	method.arguments = new Argument[argumentCount];
	for (int i = 0; i < argumentCount; i++) {
		method.arguments[i] = 
			new Argument(
				argumentNames[i], 
				position, 
				createTypeReference(argumentTypeNames[i], start, end), 
				AccDefault); // do not care whether was final or not
	}

	/* convert thrown exceptions */
	char[][] exceptionTypeNames = sourceMethod.getExceptionTypeNames();
	int exceptionCount = exceptionTypeNames == null ? 0 : exceptionTypeNames.length;
	method.thrownExceptions = new TypeReference[exceptionCount];
	for (int i = 0; i < exceptionCount; i++) {
		method.thrownExceptions[i] = 
			createTypeReference(exceptionTypeNames[i], start, end); 
	}
	return method;
}

