protected void consumeEnumConstantHeader() {
   FieldDeclaration enumConstant = (FieldDeclaration) this.astStack[this.astPtr];
   boolean foundOpeningBrace = this.currentToken == TokenNameLBRACE;
   if (foundOpeningBrace){
      // qualified allocation expression
      TypeDeclaration anonymousType = new TypeDeclaration(this.compilationUnit.compilationResult);
      anonymousType.name = TypeDeclaration.ANONYMOUS_EMPTY_NAME;
      anonymousType.bits |= ASTNode.AnonymousAndLocalMask;
      final int start = this.scanner.startPosition;
      anonymousType.declarationSourceStart = start;
      anonymousType.sourceStart = start;
      anonymousType.sourceEnd = start; // closing parenthesis
      anonymousType.modifiers = 0;
      anonymousType.bodyStart = this.scanner.currentPosition;
      markEnclosingMemberWithLocalType();
      pushOnAstStack(anonymousType);
      QualifiedAllocationExpression allocationExpression = new QualifiedAllocationExpression(anonymousType);
      allocationExpression.enumConstant = enumConstant;
      
      // fill arguments if needed
      int length;
      if ((length = this.expressionLengthStack[this.expressionLengthPtr--]) != 0) {
         this.expressionPtr -= length;
         System.arraycopy(
               this.expressionStack, 
               this.expressionPtr + 1, 
               allocationExpression.arguments = new Expression[length], 
               0, 
               length); 
      }
      enumConstant.initialization = allocationExpression;
      if (this.currentElement != null) {
         this.currentElement = this.currentElement.add(anonymousType, 0);
       	this.lastCheckPoint = anonymousType.bodyStart;
        this.lastIgnoredToken = -1;
         this.currentToken = 0; // opening brace already taken into account
         return;
      }
   } else {
      AllocationExpression allocationExpression = new AllocationExpression();
      allocationExpression.enumConstant = enumConstant;
      // fill arguments if needed
      int length;
      if ((length = this.expressionLengthStack[this.expressionLengthPtr--]) != 0) {
         this.expressionPtr -= length;
         System.arraycopy(
               this.expressionStack, 
               this.expressionPtr + 1, 
               allocationExpression.arguments = new Expression[length], 
               0, 
               length); 
      }
      enumConstant.initialization = allocationExpression;
   }
   
   // recovery
   if (this.currentElement != null) {
	  if(this.currentToken == TokenNameSEMICOLON) {
	  	this.isInsideEnumConstantPart = false;
	  }
      if (!(this.currentElement instanceof RecoveredType)
            && (this.currentToken == TokenNameDOT)){
         this.lastCheckPoint = enumConstant.sourceStart;
         this.restartRecovery = true;
         return;
      }
	  this.lastCheckPoint = this.scanner.startPosition; // force to restart at this exact position
      this.lastIgnoredToken = -1;
      this.restartRecovery = true;
   }
}

