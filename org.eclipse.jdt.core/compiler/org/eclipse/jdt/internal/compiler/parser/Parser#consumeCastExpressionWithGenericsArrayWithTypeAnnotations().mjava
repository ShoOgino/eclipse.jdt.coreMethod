protected void consumeCastExpressionWithGenericsArrayWithTypeAnnotations() {
	// CastExpression ::= PushLPAREN Modifiers Name OnlyTypeArgumentsForCastExpression Dimsopt PushRPARENForAnnotatedTypeCast InsideCastExpression UnaryExpressionNotPlusMinus
	int end = this.intStack[this.intPtr--];
	int dim = this.intStack[this.intPtr--];

	pushOnGenericsIdentifiersLengthStack(this.identifierLengthStack[this.identifierLengthPtr]);
	TypeReference typeReference = getTypeReference(dim);
	
	// pop expression
	Expression expression = this.expressionStack[this.expressionPtr--];
	this.expressionLengthPtr--;

	int length;
	if ((length = this.expressionLengthStack[this.expressionLengthPtr--]) != 0) {
		System.arraycopy(
				this.expressionStack,
				(this.expressionPtr -= length) + 1,
				typeReference.annotations = new Annotation[length],
				0,
				length);
		int typeReferenceSourceStart = typeReference.annotations[0].sourceStart;
		if (this.modifiersSourceStart < typeReferenceSourceStart) {
			typeReferenceSourceStart = this.modifiersSourceStart;
		}
		typeReference.bits |= ASTNode.HasTypeAnnotations;
		typeReference.sourceStart = typeReferenceSourceStart;
	}
	Expression cast;
	pushOnExpressionStack(cast = new CastExpression(expression, typeReference));
	this.intPtr--;
	typeReference.sourceEnd = end - 1;
	typeReference.sourceStart = (cast.sourceStart = this.intStack[this.intPtr--]) + 1;
	cast.sourceEnd = expression.sourceEnd;
	if (this.modifiers != ClassFileConstants.AccDefault) {
		problemReporter().invalidLocationForModifiers(typeReference);
	}
	resetModifiers();
}

