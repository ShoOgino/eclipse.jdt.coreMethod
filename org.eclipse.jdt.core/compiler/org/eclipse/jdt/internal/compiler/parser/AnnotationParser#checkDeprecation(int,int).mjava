	/* (non-Javadoc)
	 * Returns true if tag @deprecated is present in annotation.
	 * 
	 * If annotation checking is enabled, will also construct an Annotation node, which will be stored into Parser.annotation
	 * slot for being consumed later on.
	 */
	public boolean checkDeprecation(int annotationStart, int annotationEnd) {

		boolean foundDeprecated = false;
		try {
			this.source = this.sourceParser.scanner.source;
			if (this.checkAnnotation) {
				this.annotation = new Annotation(annotationStart, annotationEnd);
				this.astLengthPtr = -1;
				this.astPtr = -1;
				this.currentTokenType = -1;
			} else {
				this.annotation = null;
			}

			int firstLineNumber = this.sourceParser.scanner.getLineNumber(annotationStart);
			int lastLineNumber = this.sourceParser.scanner.getLineNumber(annotationEnd);

			// scan line per line, since tags must be at beginning of lines only
			nextLine : for (int line = firstLineNumber; line <= lastLineNumber; line++) {
				int lineStart = line == firstLineNumber
						? annotationStart + 3 // skip leading /**
						: this.sourceParser.scanner.getLineStart(line);
				this.index = lineStart;
				this.lineEnd = line == lastLineNumber
						? annotationEnd - 2 // remove trailing */
						: this.sourceParser.scanner.getLineEnd(line);
				while (this.index < this.lineEnd) {
					char nextCharacter = readChar(); // consider unicodes
					switch (nextCharacter) {
						case '@' :
							if (!this.checkAnnotation) {
								if ((readChar() == 'd') &&
									(readChar() == 'e') &&
									(readChar() == 'p') &&
									(readChar() == 'r') &&
									(readChar() == 'e') &&
									(readChar() == 'c') &&
									(readChar() == 'a') &&
									(readChar() == 't') &&
									(readChar() == 'e') &&
									(readChar() == 'd')) {
									// ensure the tag is properly ended: either followed by a space, a tab, line end or asterisk.
									nextCharacter = readChar();
									if (Character.isWhitespace(nextCharacter) || nextCharacter == '*') {
										foundDeprecated = true;
										break nextLine; // done
									}
								}
								continue nextLine;
							}
							this.scanner.resetTo(this.index, this.lineEnd);
							this.currentTokenType = -1; // flush token cache at line begin
							try {
								int tk = readTokenAndConsume();
								this.tagSourceStart = this.scanner.getCurrentTokenStartPosition();
								this.tagSourceEnd = this.scanner.getCurrentTokenEndPosition();
								switch (tk) {
									case TerminalTokens.TokenNameIdentifier :
										char[] tag = this.scanner.getCurrentIdentifierSource();
									if (CharOperation.equals(tag, TAG_DEPRECATED)) {
										foundDeprecated = true;
									} else if (CharOperation.equals(tag, TAG_PARAM)) {
										parseParam();
									} else if (CharOperation.equals(tag, TAG_EXCEPTION)) {
										parseThrows();
									} else if (CharOperation.equals(tag, TAG_SEE)) {
										parseSee();
									}
										break;
									case TerminalTokens.TokenNamereturn :
										parseReturn();
										break;
									case TerminalTokens.TokenNamethrows :
										parseThrows();
										break;
								}
							} catch (InvalidInputException e) {
								consumeToken();
							}
							continue nextLine;
						case '*' :
							break;
						default :
							if (!CharOperation.isWhitespace(nextCharacter)) {
								continue nextLine;
							}
					}
				}
			}
		} finally {
			updateAnnotation();
			this.source = null; // release source as soon as finished
		}
		return foundDeprecated;
	}

