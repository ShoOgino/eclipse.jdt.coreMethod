	/**
	 * Returns true if tag @deprecated is present in annotation
	 */
	public boolean checkDeprecation(int annotationStart, int annotationEnd) {
	
		char[] source = this.scanner.source;
		boolean foundDeprecated = false;
		if (this.sourceParser.checkAnnotation) {
			this.annotation = new Annotation(annotationStart, annotationEnd);
		} else {
			this.annotation = null;
		} 
	
		int firstLineNumber = this.scanner.getLineNumber(annotationStart);
		int lastLineNumber = this.scanner.getLineNumber(annotationEnd);
		int[] index = new int[]{ 0 };
				
		// scan line per line, since tags are supposed to be at beginning of lines only
		nextLine: for (int line = firstLineNumber; line <= lastLineNumber; line++) {
			int lineStart = this.scanner.getLineStart(line);
			if (line == firstLineNumber) lineStart = annotationStart + 3; // skip leading /**
			int lineEnd = this.scanner.getLineEnd(line);
			if (line == lastLineNumber) lineEnd = annotationEnd - 2; // remove trailing */
			index[0] = lineStart;
			boolean foundStar = false;
			while (index[0] < lineEnd) {
				char nextCharacter = getNextCharacter(source, index); // consider unicodes
				switch(nextCharacter) {
					case '@' :
						if (this.annotation == null) {
							if ((getNextCharacter(source, index) == 'd')
								&& (getNextCharacter(source, index) == 'e')
								&& (getNextCharacter(source, index) == 'p')
								&& (getNextCharacter(source, index) == 'r')
								&& (getNextCharacter(source, index) == 'e')
								&& (getNextCharacter(source, index) == 'c')
								&& (getNextCharacter(source, index) == 'a')
								&& (getNextCharacter(source, index) == 't')
								&& (getNextCharacter(source, index) == 'e')
								&& (getNextCharacter(source, index) == 'd')) {
								// ensure the tag is properly ended: either followed by a space, a tab, line end or asterisk.
								nextCharacter = getNextCharacter(source, index);
								if (Character.isWhitespace(nextCharacter) || nextCharacter == '*') {
									foundDeprecated = true;
									break nextLine; // done
								}
							}
							continue nextLine;
						} 
/*
 						// parse annotation
						int tagStart = index[0], tagEnd = 0;
						try {
							saveScannerState();
							this.scanner.startPosition = index[0];
							this.scanner.currentPosition = index[0];
							this.scanner.currentCharacter = -1;
							// read tag
							parseTag();
						} finally {
							loadScannerState();
						}						
						do {
							nextCharacter = getNextCharacter(source, index);
							// ensure the tag is properly ended: either followed by a space, a tab, line end or asterisk
							if (Character.isWhitespace(nextCharacter) || nextCharacter == '*') break; 
							this.annotationBuffer[bufferLength++] = nextCharacter;
							tagEnd = index[0];
						} while (index[0] < lineEnd);
						if (bufferLength == 0) continue nextLine;
						char[] tag = null;
						switch(this.annotationBuffer[0]) {
							case 'd' :
								if (CharOperation.equals(Annotation.TAG_DEPRECATED, this.annotationBuffer, 0, bufferLength)) {
									tag = Annotation.TAG_DEPRECATED;
									foundDeprecated = true;
								}
								break;
							case 'e' :
								if (CharOperation.equals(Annotation.TAG_EXCEPTION, this.annotationBuffer, 0, bufferLength)) {
									tag = Annotation.TAG_EXCEPTION;
								}
								break;
							case 't' :
								if (CharOperation.equals(Annotation.TAG_THROWS, this.annotationBuffer, 0, bufferLength)) {
									tag = Annotation.TAG_THROWS;
								}
								break;					
							case 's' :
								if (CharOperation.equals(Annotation.TAG_SEE, this.annotationBuffer, 0, bufferLength)) {
									tag = Annotation.TAG_SEE;
								} else if (CharOperation.equals(Annotation.TAG_SINCE, this.annotationBuffer, 0, bufferLength)) {
									tag = Annotation.TAG_SINCE;
								}
								break;					
							case 'p' :
								if (CharOperation.equals(Annotation.TAG_PARAM, this.annotationBuffer, 0, bufferLength)) {
									tag = Annotation.TAG_PARAM;
								}
								break;					
							case 'r' :
								if (CharOperation.equals(Annotation.TAG_RETURN, this.annotationBuffer, 0, bufferLength)) {
									tag = Annotation.TAG_RETURN;
								}
								break;					
						}
						if (tag == null) {
							tag = new char[bufferLength];
							System.arraycopy(this.annotationBuffer, 0, tag, 0, bufferLength);
						}
						// read argument
						int argumentStart = index[0];
						while (argumentStart < lineEnd && Character.isWhitespace(source[argumentStart])) argumentStart++; // trim argument leading spaces
						int argumentEnd = lineEnd-1;
						while (argumentEnd > argumentStart && Character.isWhitespace(source[argumentEnd])) argumentEnd--; // trim argument trailing spaces
						bufferLength = 0;
						for (index[0] = argumentStart; index[0] <= argumentEnd;) {
							this.annotationBuffer[bufferLength++] = getNextCharacter(source, index);
						}					
						char[] argument = new char[bufferLength];
						System.arraycopy(this.annotationBuffer, 0, argument, 0, bufferLength);
						annotation.record(tag, argument, tagStart, argumentEnd);
*/						
						continue nextLine;
					case '*' :
						if (foundStar) continue nextLine;
						foundStar = true;
						break;
					default :
						if (!CharOperation.isWhitespace(nextCharacter)) continue nextLine;
				}
			}
		}
		
		return foundDeprecated;
	}

