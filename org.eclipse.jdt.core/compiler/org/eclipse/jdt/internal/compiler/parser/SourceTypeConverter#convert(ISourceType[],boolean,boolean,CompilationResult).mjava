	/*
	 * Convert a set of source element types into a parsed compilation unit declaration
	 * The argument types are then all grouped in the same unit. The argument types must 
	 * at least contain one type.
	 */
	private CompilationUnitDeclaration convert(
		ISourceType[] sourceTypes,
		boolean needFieldsAndMethods,
		boolean needMemberTypes,
		CompilationResult compilationResult) {
		ISourceType sourceType = sourceTypes[0];
		if (sourceType.getName() == null)
			return null; // do a basic test that the sourceType is valid

		this.unit = new CompilationUnitDeclaration(problemReporter, compilationResult, 0);
		// not filled at this point

		/* only positions available */
		int start = sourceType.getNameSourceStart();
		int end = sourceType.getNameSourceEnd();

		/* convert package and imports */
		if (sourceType.getPackageName() != null
			&& sourceType.getPackageName().length > 0)
			// if its null then it is defined in the default package
			this.unit.currentPackage =
				createImportReference(sourceType.getPackageName(), start, end);
		char[][] importNames = sourceType.getImports();
		int importCount = importNames == null ? 0 : importNames.length;
		this.unit.imports = new ImportReference[importCount];
		for (int i = 0; i < importCount; i++)
			this.unit.imports[i] = createImportReference(importNames[i], start, end);
		/* convert type(s) */
		int typeCount = sourceTypes.length;
		this.unit.types = new TypeDeclaration[typeCount];
		for (int i = 0; i < typeCount; i++) {
			this.unit.types[i] =
				convert(sourceTypes[i], needFieldsAndMethods, needMemberTypes, compilationResult);
		}
		return this.unit;
	}

