	/*
	 * Parse argument in @see tag method reference
	 */
	private Expression parseArguments(TypeReference receiver) throws InvalidInputException {

		// Init
		int modulo = 0; // should be 2 for (Type,Type,...) or 3 for (Type arg,Type arg,...)
		int iToken = 0;
		char[] argName = null;
		int ptr = astPtr;
		int lptr = astLengthPtr;
		
		// Decide whether we have a constructor or not
		char[][] receiverTokens = receiver.getTypeName();
		char[] memberName = identifierStack[0];
		boolean isConstructor = CharOperation.equals(memberName, receiverTokens[receiverTokens.length-1]);

		// Parse arguments declaration if method reference
		nextArg : while (this.index < this.scanner.eofPosition) {

			// Read argument type reference
			TypeReference typeRef;
			try {
				typeRef = parseQualifiedName(false);
			} catch (InvalidInputException e) {
				break nextArg;
			}
			boolean firstArg = modulo == 0;
			if (firstArg) { // verify position
				if (iToken != 0)
					break nextArg;
			} else if ((iToken % modulo) != 0) {
					break nextArg;
			}
			if (typeRef == null) {
				if (firstArg && this.currentTokenType == TerminalTokens.TokenNameRPAREN) {
					if (isConstructor) {
						JavadocAllocationExpression expr = new JavadocAllocationExpression(identifierPositionStack[0]);
						expr.type = receiver;
						return expr;
					} else {
						JavadocMessageSend msg = new JavadocMessageSend(identifierStack[0], identifierPositionStack[0]);
						msg.receiver = receiver;
						return msg;
					}
				}
				break nextArg;
			}
			int argStart = typeRef.sourceStart;
			int argEnd = typeRef.sourceEnd;
			iToken++;

			// Read possible array declaration
			int dim = 0;
			if (readToken() == TerminalTokens.TokenNameLBRACKET) {
				while (readToken() == TerminalTokens.TokenNameLBRACKET) {
					consumeToken();
					if (readToken() != TerminalTokens.TokenNameRBRACKET) {
						break nextArg;
					}
					consumeToken();
					dim++;
				}
				long pos = ((long) typeRef.sourceStart) << 32 + typeRef.sourceEnd;
				if (typeRef instanceof JavadocSingleTypeReference) {
					JavadocSingleTypeReference singleRef = (JavadocSingleTypeReference) typeRef;
					typeRef = new JavadocArraySingleTypeReference(singleRef.token, dim, pos);
				} else {
					JavadocQualifiedTypeReference qualifRef = (JavadocQualifiedTypeReference) typeRef;
					typeRef = new JavadocArrayQualifiedTypeReference(qualifRef, dim);
				}
			}

			// Read argument name
			if (readToken() == TerminalTokens.TokenNameIdentifier) {
				consumeToken();
				if (firstArg) { // verify position
					if (iToken != 1)
						break nextArg;
				} else if ((iToken % modulo) != 1) {
						break nextArg;
				}
				if (argName == null) { // verify that all arguments name are declared
					if (!firstArg) {
						break nextArg;
					}
				}
				argName = this.scanner.getCurrentIdentifierSource();
				argEnd = this.scanner.getCurrentTokenEndPosition();
				iToken++;
			} else if (argName != null) { // verify that no argument name is declared
				break nextArg;
			}
			
			// Verify token position
			if (firstArg) {
				modulo = iToken + 1;
			} else {
				if ((iToken % modulo) != (modulo - 1)) {
					break nextArg;
				}
			}

			// Read separator or end arguments declaration
			int token = readToken();
			char[] name = argName == null ? new char[0] : argName;
			if (token == TerminalTokens.TokenNameCOMMA) {
				// Create new argument
				JavadocArgumentExpression expr = new JavadocArgumentExpression(name, argStart, argEnd, typeRef);
				pushOnAstStack(expr, firstArg);
				consumeToken();
				iToken++;
			} else if (token == TerminalTokens.TokenNameRPAREN) {
				// Create new argument
				JavadocArgumentExpression expr = new JavadocArgumentExpression(name, argStart, argEnd, typeRef);
				pushOnAstStack(expr, firstArg);
				int size = astLengthStack[astLengthPtr--];
				// Build arguments array
				JavadocArgumentExpression[] arguments = new JavadocArgumentExpression[size];
				for (int i = (size - 1); i >= 0; i--) {
					arguments[i] = (JavadocArgumentExpression) astStack[astPtr--];
				}
				// Create message send
				if (isConstructor) {
					JavadocAllocationExpression alloc = new JavadocAllocationExpression(identifierPositionStack[0]);
					alloc.arguments = arguments;
					alloc.type = receiver;
					return alloc;
				} else {
					JavadocMessageSend msg = new JavadocMessageSend(identifierStack[0], identifierPositionStack[0], arguments);
					msg.receiver = receiver;
					return msg;
				}
			} else {
				break nextArg;
			}
		}

		// Invalid input: reset ast stacks pointers
		consumeToken();
		if (iToken > 0) {
			this.astPtr = ptr;
			this.astLengthPtr = lptr;
		}
		throw new InvalidInputException();
	}

