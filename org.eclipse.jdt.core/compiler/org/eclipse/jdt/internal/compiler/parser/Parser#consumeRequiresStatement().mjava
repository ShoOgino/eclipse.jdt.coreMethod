protected void consumeRequiresStatement() {
	ModuleReference impt = (ModuleReference) this.astStack[this.astPtr];
	
	RequiresStatement req = new RequiresStatement(impt);
	if (this.currentToken == TokenNameSEMICOLON){
		req.declarationSourceEnd = this.scanner.currentPosition - 1;
	} else {
		req.declarationSourceEnd = impt.sourceEnd;
	}
	req.sourceStart = req.declarationSourceStart;
	req.declarationEnd = req.declarationSourceEnd;
	req.modifiersSourceStart = this.intStack[this.intPtr--];
	req.modifiers |= this.intStack[this.intPtr--];
	req.declarationSourceStart = this.intStack[this.intPtr--];
	if (req.modifiersSourceStart >= 0) {
		req.declarationSourceStart = req.modifiersSourceStart;
	}
	req.sourceEnd = impt.sourceEnd;
	this.astStack[this.astPtr] = req;
	// recovery
	if (this.currentElement instanceof RecoveredModule) {
		this.lastCheckPoint = req.declarationSourceEnd + 1;
		this.currentElement = this.currentElement.add(req, 0);
		this.lastIgnoredToken = -1;
		this.restartRecovery = true; // used to avoid branching back into the regular automaton
	}
}

