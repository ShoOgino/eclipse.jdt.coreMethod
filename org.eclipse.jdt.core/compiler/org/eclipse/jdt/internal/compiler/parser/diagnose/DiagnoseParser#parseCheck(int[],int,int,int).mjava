//
//	   Try to parse until first_token and all tokens in BUFFER have
//	   been consumed, or an error is encountered. Return the number
//	   of tokens that were expended before the parse blocked.
//
	private int parseCheck(int stck[], int stack_top, int first_token, int buffer_position) {
		int max_pos;
		int indx;
		int ct;
		int act;

		//
		// Initialize pointer for temp_stack and initialize maximum
		// position of state stack that is still useful.
		//
		act = stck[stack_top];
		if (first_token > NT_OFFSET) {
			tempStackTop = stack_top;
			max_pos = stack_top;
			indx = buffer_position;
			ct = lexStream.kind(buffer[indx]);
			lexStream.reset(lexStream.next(buffer[indx]));
			int lhs_symbol = first_token - NT_OFFSET;
			act = Parser.ntAction(act, lhs_symbol);
			if (act <= NUM_RULES) {
				do {
					tempStackTop -= (Parser.rhs[act]-1);
					lhs_symbol = Parser.lhs[act];
					act = (tempStackTop > max_pos
										  ? tempStack[tempStackTop]
										  : stck[tempStackTop]);
					act = Parser.ntAction(act, lhs_symbol);
				} while(act <= NUM_RULES);
	
				max_pos = max_pos < tempStackTop ? max_pos : tempStackTop;
			}
		} else {
			tempStackTop = stack_top - 1;
			max_pos = tempStackTop;
			indx = buffer_position - 1;
			ct = first_token;
			lexStream.reset(buffer[buffer_position]);
		}

		process_terminal: for (;;) {
			if (++tempStackTop >= stackLength)  // Stack overflow!!!
				return indx;
			tempStack[tempStackTop] = act;

			act = Parser.tAction(act, ct);

			if (act <= NUM_RULES) {               // reduce action
				tempStackTop--;
			} else if (act < ACCEPT_ACTION ||     // shift action
					 act > ERROR_ACTION) {        // shift-reduce action
				if (indx == MAX_DISTANCE)
					return indx;
				indx++;
				ct = lexStream.kind(buffer[indx]);
				lexStream.reset(lexStream.next(buffer[indx]));
				if (act > ERROR_ACTION) {
					 act -= ERROR_ACTION;
				} else {
					continue process_terminal;
				}
			} else if (act == ACCEPT_ACTION) {           // accept action
				 return MAX_DISTANCE;
			} else {
				return indx;                         // error action
			}

			process_non_terminal:
			do {
				tempStackTop -= (Parser.rhs[act]-1);
				int lhs_symbol = Parser.lhs[act];
				act = (tempStackTop > max_pos
									  ? tempStack[tempStackTop]
									  : stck[tempStackTop]);
				act = Parser.ntAction(act, lhs_symbol);
			} while(act <= NUM_RULES);

			max_pos = max_pos < tempStackTop ? max_pos : tempStackTop;
		} // process_terminal;
	}

