public final void getNextUnicodeChar()
	throws IndexOutOfBoundsException, InvalidInputException {
	//VOID
	//handle the case of unicode.
	//when a unicode appears then we must use a buffer that holds char internal values
	//At the end of this method currentCharacter holds the new visited char
	//and currentPosition points right next after it

	//ALL getNextChar.... ARE OPTIMIZED COPIES 

	int c1 = 0, c2 = 0, c3 = 0, c4 = 0, unicodeSize = 6;
	currentPosition++;
	while (source[currentPosition] == 'u') {
		currentPosition++;
		unicodeSize++;
	}

	if ((c1 = Character.getNumericValue(source[currentPosition++])) > 15
		|| c1 < 0
		|| (c2 = Character.getNumericValue(source[currentPosition++])) > 15
		|| c2 < 0
		|| (c3 = Character.getNumericValue(source[currentPosition++])) > 15
		|| c3 < 0
		|| (c4 = Character.getNumericValue(source[currentPosition++])) > 15
		|| c4 < 0){
		throw new InvalidInputException(INVALID_UNICODE_ESCAPE);
	} else {
		currentCharacter = (char) (((c1 * 16 + c2) * 16 + c3) * 16 + c4);
		//need the unicode buffer
		if (withoutUnicodePtr == 0) {
			//buffer all the entries that have been left aside....
			withoutUnicodePtr = currentPosition - unicodeSize - startPosition;
			System.arraycopy(
				source, 
				startPosition, 
				withoutUnicodeBuffer, 
				1, 
				withoutUnicodePtr); 
		}
		//fill the buffer with the char
		withoutUnicodeBuffer[++withoutUnicodePtr] = currentCharacter;
	}
	unicodeAsBackSlash = currentCharacter == '\\';
}

