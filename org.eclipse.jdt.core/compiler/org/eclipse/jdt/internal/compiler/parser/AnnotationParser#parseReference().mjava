	private Expression parseReference() throws InvalidInputException {
		TypeReference typeRef = null;
		nextToken : while (this.index < this.scanner.eofPosition) {
			int token = readToken();
			switch (token) {
				case TerminalTokens.TokenNameStringLiteral :
					// @see "string"
					int start = this.scanner.getCurrentTokenStartPosition();
					if (typeRef == null) {
						consumeToken();
						try {
							if (readToken() == TerminalTokens.TokenNameEOF) {
								return null;
							}
						} catch (InvalidInputException e) {// Do nothing as we want to underline from the beginning of the string
						}
					}
					this.sourceParser.problemReporter().annotationInvalidSeeReference(start, this.lineEnd - 1);
					return null;
				case TerminalTokens.TokenNameLESS :
					// @see "<a href="URL#Value">label</a>
					consumeToken();
					start = this.scanner.getCurrentTokenStartPosition();
					if (parseHref()) {
						if (typeRef == null) {
							consumeToken();
							try {
								if (readToken() == TerminalTokens.TokenNameEOF) {
									return null;
								}
							} catch (InvalidInputException e) {// Do nothing as we want to underline from the beginning of the href
							}
						}
						this.sourceParser.problemReporter().annotationInvalidSeeReference(start, this.lineEnd - 1);
					}
					return null;
				case TerminalTokens.TokenNameERROR :
					consumeToken();
					if (this.scanner.currentCharacter == '#') { // @see ...#member
						return parseMember(typeRef);
					}
					break nextToken;
				case TerminalTokens.TokenNameIdentifier :
					if (typeRef == null) {
						typeRef = parseQualifiedName(true);
						break;
					}
				default :
					break nextToken;
			}
		}
		if (typeRef == null) {
			this.sourceParser.problemReporter().annotationMissingSeeReference(this.tagSourceStart, this.tagSourceEnd);
		}
		return typeRef;
	}

