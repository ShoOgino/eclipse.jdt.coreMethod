/*
 * Reconsider the entire source looking for inconsistencies in {} () []
 */
public boolean checkAndReportBracketAnomalies(ProblemReporter problemReporter) {

	boolean anomaliesDetected = false;	
	try {
		char[] source = scanner.source;
		int[] leftCount = {0, 0, 0};
		int[] rightCount = {0, 0, 0};
		int[] depths = {0, 0, 0};
		int[][] leftPositions = new int[][] {new int[10], new int[10], new int[10]};
		int[][] leftDepths = new int[][] {new int[10], new int[10], new int[10]};
		int[][] rightPositions = new int[][] {new int[10], new int[10], new int[10]};
		int[][] rightDepths = new int[][] {new int[10], new int[10], new int[10]};
		scanner.currentPosition = scanner.initialPosition; //starting point (first-zero-based char)
		while (scanner.currentPosition < scanner.eofPosition) { //loop for jumping over comments
			try {
				// ---------Consume white space and handles startPosition---------
				boolean isWhiteSpace;
				do {
					scanner.startPosition = scanner.currentPosition;
					if (((scanner.currentCharacter = source[scanner.currentPosition++]) == '\\') && (source[scanner.currentPosition] == 'u')) {
						isWhiteSpace = scanner.jumpOverUnicodeWhiteSpace();
					} else {
						if (scanner.recordLineSeparator && ((scanner.currentCharacter == '\r') || (scanner.currentCharacter == '\n'))) {
							if (scanner.lineEnds[scanner.linePtr] < scanner.startPosition) {
								// only record line positions we have not recorded yet
								scanner.pushLineSeparator();
							}
						}
						isWhiteSpace = Character.isWhitespace(scanner.currentCharacter);
					}
				} while (isWhiteSpace && (scanner.currentPosition < scanner.eofPosition));

				// -------consume token until } is found---------

				switch (scanner.currentCharacter) {
					case '{' :
						{
							int index = leftCount[CurlyBracket] ++;
							if (index == leftPositions[CurlyBracket].length) {
								System.arraycopy(leftPositions[CurlyBracket], 0, (leftPositions[CurlyBracket] = new int[index * 2]), 0, index);
								System.arraycopy(leftDepths[CurlyBracket], 0, (leftDepths[CurlyBracket] = new int[index * 2]), 0, index);
							}
							leftPositions[CurlyBracket][index] = scanner.startPosition;
							leftDepths[CurlyBracket][index] = depths[CurlyBracket] ++;
						}
						break;
					case '}' :
						{
							int index = rightCount[CurlyBracket] ++;
							if (index == rightPositions[CurlyBracket].length) {
								System.arraycopy(rightPositions[CurlyBracket], 0, (rightPositions[CurlyBracket] = new int[index * 2]), 0, index);
								System.arraycopy(rightDepths[CurlyBracket], 0, (rightDepths[CurlyBracket] = new int[index * 2]), 0, index);
							}
							rightPositions[CurlyBracket][index] = scanner.startPosition;
							rightDepths[CurlyBracket][index] = --depths[CurlyBracket];
						}
						break;
					case '(' :
						{
							int index = leftCount[RoundBracket] ++;
							if (index == leftPositions[RoundBracket].length) {
								System.arraycopy(leftPositions[RoundBracket], 0, (leftPositions[RoundBracket] = new int[index * 2]), 0, index);
								System.arraycopy(leftDepths[RoundBracket], 0, (leftDepths[RoundBracket] = new int[index * 2]), 0, index);
							}
							leftPositions[RoundBracket][index] = scanner.startPosition;
							leftDepths[RoundBracket][index] = depths[RoundBracket] ++;
						}
						break;
					case ')' :
						{
							int index = rightCount[RoundBracket] ++;
							if (index == rightPositions[RoundBracket].length) {
								System.arraycopy(rightPositions[RoundBracket], 0, (rightPositions[RoundBracket] = new int[index * 2]), 0, index);
								System.arraycopy(rightDepths[RoundBracket], 0, (rightDepths[RoundBracket] = new int[index * 2]), 0, index);
							}
							rightPositions[RoundBracket][index] = scanner.startPosition;
							rightDepths[RoundBracket][index] = --depths[RoundBracket];
						}
						break;
					case '[' :
						{
							int index = leftCount[SquareBracket] ++;
							if (index == leftPositions[SquareBracket].length) {
								System.arraycopy(leftPositions[SquareBracket], 0, (leftPositions[SquareBracket] = new int[index * 2]), 0, index);
								System.arraycopy(leftDepths[SquareBracket], 0, (leftDepths[SquareBracket] = new int[index * 2]), 0, index);
							}
							leftPositions[SquareBracket][index] = scanner.startPosition;
							leftDepths[SquareBracket][index] = depths[SquareBracket] ++;
						}
						break;
					case ']' :
						{
							int index = rightCount[SquareBracket] ++;
							if (index == rightPositions[SquareBracket].length) {
								System.arraycopy(rightPositions[SquareBracket], 0, (rightPositions[SquareBracket] = new int[index * 2]), 0, index);
								System.arraycopy(rightDepths[SquareBracket], 0, (rightDepths[SquareBracket] = new int[index * 2]), 0, index);
							}
							rightPositions[SquareBracket][index] = scanner.startPosition;
							rightDepths[SquareBracket][index] = --depths[SquareBracket];
						}
						break;
					case '\'' :
						{
							boolean test;
							if (test = scanner.getNextChar('\\')) {
								scanner.scanEscapeCharacter();
							} else { // consume next character
								scanner.unicodeAsBackSlash = false;
								if (((scanner.currentCharacter = source[scanner.currentPosition++]) == '\\') && (source[scanner.currentPosition] == 'u')) {
									scanner.getNextUnicodeChar();
								} else {
									if (scanner.withoutUnicodePtr != 0) {
										scanner.withoutUnicodeBuffer[++scanner.withoutUnicodePtr] = scanner.currentCharacter;
									}
								}
							}
							scanner.getNextChar('\'');
							break;
						}
					case '"' : // consume next character
						scanner.unicodeAsBackSlash = false;
						if (((scanner.currentCharacter = source[scanner.currentPosition++]) == '\\') && (source[scanner.currentPosition] == 'u')) {
							scanner.getNextUnicodeChar();
						} else {
							if (scanner.withoutUnicodePtr != 0) {
								scanner.withoutUnicodeBuffer[++scanner.withoutUnicodePtr] = scanner.currentCharacter;
							}
						}
						while (scanner.currentCharacter != '"') {
							if (scanner.currentCharacter == '\r') {
								if (source[scanner.currentPosition] == '\n')
									scanner.currentPosition++;
								break; // the string cannot go further that the line
							}
							if (scanner.currentCharacter == '\n') {
								break; // the string cannot go further that the line
							}
							if (scanner.currentCharacter == '\\') {
								scanner.scanEscapeCharacter();
							}
							// consume next character
							scanner.unicodeAsBackSlash = false;
							if (((scanner.currentCharacter = source[scanner.currentPosition++]) == '\\') && (source[scanner.currentPosition] == 'u')) {
								scanner.getNextUnicodeChar();
							} else {
								if (scanner.withoutUnicodePtr != 0) {
									scanner.withoutUnicodeBuffer[++scanner.withoutUnicodePtr] = scanner.currentCharacter;
								}
							}
						}
						break;
					case '/' :
						{
							int test;
							if ((test = scanner.getNextChar('/', '*')) == 0) { //line comment 
								//get the next char 
								if (((scanner.currentCharacter = source[scanner.currentPosition++]) == '\\') && (source[scanner.currentPosition] == 'u')) {
									//-------------unicode traitement ------------
									int c1 = 0, c2 = 0, c3 = 0, c4 = 0;
									scanner.currentPosition++;
									while (source[scanner.currentPosition] == 'u') {
										scanner.currentPosition++;
									}
									if ((c1 = Character.getNumericValue(source[scanner.currentPosition++])) > 15 || c1 < 0 || (c2 = Character.getNumericValue(source[scanner.currentPosition++])) > 15 || c2 < 0 || (c3 = Character.getNumericValue(source[scanner.currentPosition++])) > 15 || c3 < 0 || (c4 = Character.getNumericValue(source[scanner.currentPosition++])) > 15 || c4 < 0) { //error don't care of the value
										scanner.currentCharacter = 'A';
									} //something different from \n and \r
									else {
										scanner.currentCharacter = (char) (((c1 * 16 + c2) * 16 + c3) * 16 + c4);
									}
								}
								while (scanner.currentCharacter != '\r' && scanner.currentCharacter != '\n') {
									//get the next char
									scanner.startPosition = scanner.currentPosition;
									if (((scanner.currentCharacter = source[scanner.currentPosition++]) == '\\') && (source[scanner.currentPosition] == 'u')) {
										//-------------unicode traitement ------------
										int c1 = 0, c2 = 0, c3 = 0, c4 = 0;
										scanner.currentPosition++;
										while (source[scanner.currentPosition] == 'u') {
											scanner.currentPosition++;
										}
										if ((c1 = Character.getNumericValue(source[scanner.currentPosition++])) > 15 || c1 < 0 || (c2 = Character.getNumericValue(source[scanner.currentPosition++])) > 15 || c2 < 0 || (c3 = Character.getNumericValue(source[scanner.currentPosition++])) > 15 || c3 < 0 || (c4 = Character.getNumericValue(source[scanner.currentPosition++])) > 15 || c4 < 0) { //error don't care of the value
											scanner.currentCharacter = 'A';
										} //something different from \n and \r
										else {
											scanner.currentCharacter = (char) (((c1 * 16 + c2) * 16 + c3) * 16 + c4);
										}
									}
								}
								if (scanner.recordLineSeparator && ((scanner.currentCharacter == '\r') || (scanner.currentCharacter == '\n'))) {
									if (scanner.lineEnds[scanner.linePtr] < scanner.startPosition) {
										// only record line positions we have not recorded yet
										scanner.pushLineSeparator();
									}
								}
								break;
							}
							if (test > 0) { //traditional and annotation comment
								boolean star = false;
								// consume next character
								scanner.unicodeAsBackSlash = false;
								if (((scanner.currentCharacter = source[scanner.currentPosition++]) == '\\') && (source[scanner.currentPosition] == 'u')) {
									scanner.getNextUnicodeChar();
								} else {
									if (scanner.withoutUnicodePtr != 0) {
										scanner.withoutUnicodeBuffer[++scanner.withoutUnicodePtr] = scanner.currentCharacter;
									}
								}
								if (scanner.currentCharacter == '*') {
									star = true;
								}
								//get the next char 
								if (((scanner.currentCharacter = source[scanner.currentPosition++]) == '\\') && (source[scanner.currentPosition] == 'u')) {
									//-------------unicode traitement ------------
									int c1 = 0, c2 = 0, c3 = 0, c4 = 0;
									scanner.currentPosition++;
									while (source[scanner.currentPosition] == 'u') {
										scanner.currentPosition++;
									}
									if ((c1 = Character.getNumericValue(source[scanner.currentPosition++])) > 15 || c1 < 0 || (c2 = Character.getNumericValue(source[scanner.currentPosition++])) > 15 || c2 < 0 || (c3 = Character.getNumericValue(source[scanner.currentPosition++])) > 15 || c3 < 0 || (c4 = Character.getNumericValue(source[scanner.currentPosition++])) > 15 || c4 < 0) { //error don't care of the value
										scanner.currentCharacter = 'A';
									} //something different from * and /
									else {
										scanner.currentCharacter = (char) (((c1 * 16 + c2) * 16 + c3) * 16 + c4);
									}
								}
								//loop until end of comment */ 
								while ((scanner.currentCharacter != '/') || (!star)) {
									star = scanner.currentCharacter == '*';
									//get next char
									if (((scanner.currentCharacter = source[scanner.currentPosition++]) == '\\') && (source[scanner.currentPosition] == 'u')) {
										//-------------unicode traitement ------------
										int c1 = 0, c2 = 0, c3 = 0, c4 = 0;
										scanner.currentPosition++;
										while (source[scanner.currentPosition] == 'u') {
											scanner.currentPosition++;
										}
										if ((c1 = Character.getNumericValue(source[scanner.currentPosition++])) > 15 || c1 < 0 || (c2 = Character.getNumericValue(source[scanner.currentPosition++])) > 15 || c2 < 0 || (c3 = Character.getNumericValue(source[scanner.currentPosition++])) > 15 || c3 < 0 || (c4 = Character.getNumericValue(source[scanner.currentPosition++])) > 15 || c4 < 0) { //error don't care of the value
											scanner.currentCharacter = 'A';
										} //something different from * and /
										else {
											scanner.currentCharacter = (char) (((c1 * 16 + c2) * 16 + c3) * 16 + c4);
										}
									}
								}
								break;
							}
							break;
						}
					default :
						if (Character.isJavaIdentifierStart(scanner.currentCharacter)) {
							scanner.scanIdentifierOrKeyword();
							break;
						}
						if (Character.isDigit(scanner.currentCharacter)) {
							scanner.scanNumber(false);
							break;
						}
				}
				//-----------------end switch while try--------------------
			} catch (IndexOutOfBoundsException e) {
					break; // read until EOF
			} catch (InvalidInputException e) {
				return false; // no clue
			}
		}
		if (scanner.recordLineSeparator) {
			compilationUnit.compilationResult.lineSeparatorPositions = scanner.lineEnds();
		}

		// check placement anomalies against other kinds of brackets
		for (int kind = 0; kind < BracketKinds; kind++) {
			for (int leftIndex = leftCount[kind] - 1; leftIndex >= 0; leftIndex--) {
				int start = leftPositions[kind][leftIndex]; // deepest first
				// find matching closing bracket
				int depth = leftDepths[kind][leftIndex];
				int end = -1;
				for (int i = 0; i < rightCount[kind]; i++) {
					int pos = rightPositions[kind][i];
					// want matching bracket further in source with same depth
					if ((pos > start) && (depth == rightDepths[kind][i])) {
						end = pos;
						break;
					}
				}
				if (end < 0) { // did not find a good closing match
					problemReporter.unmatchedBracket(start, referenceContext, compilationUnit.compilationResult);
					return true;
				}
				// check if even number of opening/closing other brackets in between this pair of brackets
				int balance = 0;
				for (int otherKind = 0;(balance == 0) && (otherKind < BracketKinds); otherKind++) {
					for (int i = 0; i < leftCount[otherKind]; i++) {
						int pos = leftPositions[otherKind][i];
						if ((pos > start) && (pos < end))
							balance++;
					}
					for (int i = 0; i < rightCount[otherKind]; i++) {
						int pos = rightPositions[otherKind][i];
						if ((pos > start) && (pos < end))
							balance--;
					}
					if (balance != 0) {
						problemReporter.unmatchedBracket(start, referenceContext, compilationUnit.compilationResult); //bracket anomaly
						return true;
					}
				}
			}
			// too many opening brackets ?
			for (int i = rightCount[kind]; i < leftCount[kind]; i++) {
				anomaliesDetected = true;
				problemReporter.unmatchedBracket(leftPositions[kind][leftCount[kind] - i - 1], referenceContext, compilationUnit.compilationResult);
			}
			// too many closing brackets ?
			for (int i = leftCount[kind]; i < rightCount[kind]; i++) {
				anomaliesDetected = true;
				problemReporter.unmatchedBracket(rightPositions[kind][i], referenceContext, compilationUnit.compilationResult);
			}
			if (anomaliesDetected) return true;
		}
		
		return anomaliesDetected;
	} catch (ArrayStoreException e) { // jdk1.2.2 jit bug
		return anomaliesDetected;
	} catch (NullPointerException e) { // jdk1.2.2 jit bug
		return anomaliesDetected;
	}
}

