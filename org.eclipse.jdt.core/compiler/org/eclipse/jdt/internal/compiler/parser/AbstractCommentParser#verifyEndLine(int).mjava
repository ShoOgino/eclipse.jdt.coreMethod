	/*
	 * Verify that end of the line only contains space characters or end of comment.
	 * Note that end of comment may be preceding by several contiguous '*' chars.
	 */
	protected boolean verifyEndLine(int textPosition) {
		boolean isDomParser = (this.kind & DOM_PARSER) != 0;
		boolean isFormatterParser = (this.kind & FORMATTER_COMMENT_PARSER) != 0;
		// Special case for inline tag
		if (this.inlineTagStarted) {
			// expecting closing brace
			if (peekChar() == '}') {
				if (isDomParser || isFormatterParser) {
					createTag();
					pushText(textPosition, this.starPosition);
				}
				return true;
			}
			return false;
		}
		
		int startPosition = this.index;
		int previousPosition = this.index;
		int spacePos = this.index;
		this.starPosition = -1;
		char ch = readChar();
		char previousChar = ch;
		nextChar: while (true) {
			switch (ch) {
				case '\r':
				case '\n':
					if (isDomParser || isFormatterParser) {
						createTag();
						int textEndPosition = previousPosition;
						if (isFormatterParser && ScannerHelper.isWhitespace(previousChar)) {
							textEndPosition = spacePos;
						}
						pushText(textPosition, textEndPosition);
					}
					this.index = previousPosition;
					return true;
				case '\u000c' :	/* FORM FEED               */
				case ' ' :			/* SPACE                   */
				case '\t' :			/* HORIZONTAL TABULATION   */
					if (isFormatterParser && previousChar != ch && !ScannerHelper.isWhitespace(previousChar)) {
						this.spacePosition = previousPosition;
					}
					if (this.starPosition >= 0) break nextChar;
					break;
				case '*':
					this.starPosition = previousPosition;
					break;
				case '/':
					if (this.starPosition >= textPosition) {
						if (isDomParser || isFormatterParser) {
							createTag();
							int textEndPosition = this.starPosition;
							if (isFormatterParser && ScannerHelper.isWhitespace(previousChar)) {
								textEndPosition = this.spacePosition;
							}
							pushText(textPosition, textEndPosition);
						}
						return true;
					}
				default :
					// leave loop
					break nextChar;
				
			}
			previousPosition = this.index;
			previousChar = ch;
			ch = readChar();
		}
		this.index = startPosition;
		return false;
	}

