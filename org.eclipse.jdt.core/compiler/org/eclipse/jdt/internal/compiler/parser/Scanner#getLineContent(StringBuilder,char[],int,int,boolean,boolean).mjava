// This method is for handling the left over escaped characters during the first
// scanning (scanForStringLiteral). Admittedly this goes over the text block
// content again char by char, but this is required in order to correctly
// treat all the white space and line endings
private boolean getLineContent(StringBuilder result, char[] line, int start, int end, boolean merge, boolean lastLine) {
	int lastPointer = 0;
	for(int i = start; i < end; i++) {
		char c = line[i];
		if (c == '\\') {
			if (i < end) {
				if (lastPointer + 1 == i) {
					lastPointer = i+1;
				} else {
					result.append(CharOperation.subarray(line, lastPointer == 0 ? start : lastPointer+1, i));
				}
				switch (line[++i]) {
					case '\\' :
						result.append('\\');
						if (i == end)
							merge = false;
						//i = lastPointer;
						lastPointer = i;
						break;
					case 's' :
						result.append(' ');
						lastPointer = i;
						break;
					case 'n' :
						result.append('\n');
						lastPointer = i;
						break;
					case 'r' :
						result.append('\r');
						lastPointer = i;
						break;
					case 'f' :
						result.append('\f');
						lastPointer = i;
						break;
					default :
						// Direct copy from scanEscapeCharacter
						int pos = i;
						char ch = line[pos];
						int number = ScannerHelper.getHexadecimalValue(ch);
						if (number >= 0 && number <= 7) {
							boolean zeroToThreeNot = number > 3;
							try {
								if (ScannerHelper.isDigit(ch = line[++pos])) {
									int digit = ScannerHelper.getHexadecimalValue(ch);
									if (digit >= 0 && digit <= 7) {
										number = (number * 8) + digit;
										if (ScannerHelper.isDigit(ch = line[++pos])) {
											if (zeroToThreeNot) {
												// has read \NotZeroToThree OctalDigit Digit --> ignore last character
											} else {
												digit = ScannerHelper.getHexadecimalValue(ch);
												if (digit >= 0 && digit <= 7){ // has read \ZeroToThree OctalDigit OctalDigit
													number = (number * 8) + digit;
												} else {
													// has read \ZeroToThree OctalDigit NonOctalDigit --> ignore last character
												}
											}
										} else {
											// has read \OctalDigit NonDigit--> ignore last character
										}
									} else {
										// has read \OctalDigit NonOctalDigit--> ignore last character
									}
								} else {
									// has read \OctalDigit --> ignore last character
								}
							} catch (InvalidInputException e) {
								// Unlikely as this has already been processed in scanForStringLiteral()
							}
							if (number < 255) {
								ch = (char) number;
								//replaceEscapedChar(result, line, start, end, i, lastPointer, ch);
							}
							result.append(ch);
							lastPointer = i = pos -1;
						} else {
							// Dealing with just '\'
							result.append(c);
							lastPointer = --i;
						}
				}
			}
		}
	}
	end = merge ? end : end >= line.length ? end : end + 1;
	char[] chars = lastPointer == 0 ?
			CharOperation.subarray(line, start, end) :
				CharOperation.subarray(line, lastPointer + 1, end);
	// The below check is because CharOperation.subarray tend to return null when the
	// boundaries produce a zero sized char[]
	if (chars != null)
		result.append(chars);
	return (!merge && !lastLine);
}

