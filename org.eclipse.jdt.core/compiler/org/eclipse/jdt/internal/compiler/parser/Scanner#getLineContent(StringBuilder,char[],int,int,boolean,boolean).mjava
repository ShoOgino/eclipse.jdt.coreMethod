// This method is for handling the left over escaped characters during the first
// scanning (scanForStringLiteral). Admittedly this goes over the text block 
// content again char by char, but this is required in order to correctly
// treat all the white space and line endings
private boolean getLineContent(StringBuilder result, char[] line, int start, int end, boolean merge, boolean lastLine) {
	int lastPointer = 0;
	for(int i = start; i < end; i++) {
		char c = line[i];
		if (c == '\\') {
			if ( i < end) {
				switch (line[i+1]) {
					case '\\' :
						lastPointer = replaceEscapedChar(result, line, start, end, i, lastPointer, '\\');
						if (i+1 == end)
							merge = false;
						i = lastPointer;
						break;
					case 's' :
						lastPointer = i = replaceEscapedChar(result, line, start, end, i, lastPointer, ' ');
						break;
					case 'n' :
						lastPointer = i = replaceEscapedChar(result, line, start, end, i, lastPointer, '\n');
						break;
					case 'r' :
						lastPointer = i = replaceEscapedChar(result, line, start, end, i, lastPointer, '\r');
						break;
					case 'f' :
						lastPointer = i = replaceEscapedChar(result, line, start, end, i, lastPointer, '\f');
						break;
				}
			}
		} 
	}
	end = merge ? end : end >= line.length ? end : end + 1;
	char[] chars = lastPointer == 0 ? 
			CharOperation.subarray(line, start, end) :
				CharOperation.subarray(line, lastPointer + 1, end);
	// The below check is because CharOperation.subarray tend to return null when the
	// boundaries produce a zero sized char[]
	if (chars != null)
		result.append(chars);
	return (!merge && !lastLine);
}

