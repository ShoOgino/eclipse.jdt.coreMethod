// This method is for handling the left over escaped characters during the first
// scanning (scanForStringLiteral). Admittedly this goes over the text block 
// content again char by char, but this is required in order to correctly
// treat all the white space and line endings
private boolean getLineContent(StringBuilder result, char[] line, int start, int end, boolean merge, boolean lastLine) {
	int lastPointer = 0;
	for(int i = start; i < line.length; i++) {
		char c = line[i];
		if (c == '\\') {
			if ( i < end) {
				switch (line[i+1]) {
					case '\\' :
						if (lastPointer == 0) {
							result.append(CharOperation.subarray(line, start, i));
						} else {
							result.append(CharOperation.subarray(line, lastPointer + 1, i));
						}
						result.append('\\');
						if (i+1 == end)
							merge = false;
						lastPointer = ++i;
						break;
					case 's' :
						if (lastPointer == 0) {
							result.append(CharOperation.subarray(line, start, i));
						} else {
							result.append(CharOperation.subarray(line, lastPointer + 1, i));
						}
						result.append(' ');
						lastPointer = ++i;
				}
			}
		} 
	}
	end = merge ? end : end + 1;
	char[] chars = lastPointer == 0 ? 
			CharOperation.subarray(line, start, end) :
				CharOperation.subarray(line, lastPointer + 1, end);
	// The below check is because CharOperation.subarray tend to return null when the
	// boundaries produce a zero sized char[]
	if (chars != null)
		result.append(chars);
	return (!merge && !lastLine);
}

