public TypeDeclaration updatedTypeDeclaration(){

	/* update member types */
	if (memberTypeCount > 0){
		int existingCount = typeDeclaration.memberTypes == null ? 0 : typeDeclaration.memberTypes.length;
		MemberTypeDeclaration[] memberTypeDeclarations = new MemberTypeDeclaration[existingCount + memberTypeCount];
		if (existingCount > 0){
			System.arraycopy(typeDeclaration.memberTypes, 0, memberTypeDeclarations, 0, existingCount);
		}
		// may need to update the declarationSourceEnd of the last type
		if (memberTypes[memberTypeCount - 1].typeDeclaration.declarationSourceEnd == 0){
			int bodyEnd = bodyEnd();
			memberTypes[memberTypeCount - 1].typeDeclaration.declarationSourceEnd = bodyEnd;
			memberTypes[memberTypeCount - 1].typeDeclaration.bodyEnd =  bodyEnd;
		}
		for (int i = 0; i < memberTypeCount; i++){
			memberTypeDeclarations[existingCount + i] = (MemberTypeDeclaration)memberTypes[i].updatedTypeDeclaration();
		}
		typeDeclaration.memberTypes = memberTypeDeclarations;
	}
	/* update fields */
	if (fieldCount > 0){
		int existingCount = typeDeclaration.fields == null ? 0 : typeDeclaration.fields.length;
		FieldDeclaration[] fieldDeclarations = new FieldDeclaration[existingCount + fieldCount];
		if (existingCount > 0){
			System.arraycopy(typeDeclaration.fields, 0, fieldDeclarations, 0, existingCount);
		}
		// may need to update the declarationSourceEnd of the last field
		if (fields[fieldCount - 1].fieldDeclaration.declarationSourceEnd == 0){
			fields[fieldCount - 1].fieldDeclaration.declarationSourceEnd = bodyEnd();
		}
		for (int i = 0; i < fieldCount; i++){
			fieldDeclarations[existingCount + i] = fields[i].updatedFieldDeclaration();
		}
		typeDeclaration.fields = fieldDeclarations;
	}
	/* update methods */
	int existingCount = typeDeclaration.methods == null ? 0 : typeDeclaration.methods.length;
	boolean hasConstructor = false, hasRecoveredConstructor = false;
	int defaultConstructorIndex = -1;
	if (methodCount > 0){
		AbstractMethodDeclaration[] methodDeclarations = new AbstractMethodDeclaration[existingCount + methodCount];
		for (int i = 0; i < existingCount; i++){
			AbstractMethodDeclaration m = typeDeclaration.methods[i];
			if (m.isDefaultConstructor()) defaultConstructorIndex = i;
			methodDeclarations[i] = m;
		}
		// may need to update the declarationSourceEnd of the last method
		if (methods[methodCount - 1].methodDeclaration.declarationSourceEnd == 0){
			int bodyEnd = bodyEnd();
			methods[methodCount - 1].methodDeclaration.declarationSourceEnd = bodyEnd;
			methods[methodCount - 1].methodDeclaration.bodyEnd = bodyEnd;
		}
		for (int i = 0; i < methodCount; i++){
			AbstractMethodDeclaration updatedMethod = methods[i].updatedMethodDeclaration();			
			if (updatedMethod.isConstructor()) hasRecoveredConstructor = true;
			methodDeclarations[existingCount + i] = updatedMethod;			
		}
		typeDeclaration.methods = methodDeclarations;
		hasConstructor = typeDeclaration.checkConstructors(this.parser());
	} else {
		for (int i = 0; i < existingCount; i++){
			if (typeDeclaration.methods[i].isConstructor()) hasConstructor = true;
		}		
	}
	/* add clinit ? */
	if (typeDeclaration.needClassInitMethod()){
		boolean alreadyHasClinit = false;
		for (int i = 0; i < existingCount; i++){
			if (typeDeclaration.methods[i].isClinit()){
				alreadyHasClinit = true;
				break;
			}
		}
		if (!alreadyHasClinit) typeDeclaration.addClinit();
	}
	/* add default constructor ? */
	if (defaultConstructorIndex >= 0 && hasRecoveredConstructor){
		/* should discard previous default construtor */
		AbstractMethodDeclaration[] methodDeclarations = new AbstractMethodDeclaration[typeDeclaration.methods.length - 1];
		if (defaultConstructorIndex != 0){
			System.arraycopy(typeDeclaration.methods, 0, methodDeclarations, 0, defaultConstructorIndex);
		}
		if (defaultConstructorIndex != typeDeclaration.methods.length-1){
			System.arraycopy(
				typeDeclaration.methods, 
				defaultConstructorIndex+1, 
				methodDeclarations, 
				defaultConstructorIndex, 
				typeDeclaration.methods.length - defaultConstructorIndex - 1);
		}
		typeDeclaration.methods = methodDeclarations;
	} else {
		if (!hasConstructor) {// if was already reduced, then constructor
			boolean insideFieldInitializer = false;
			RecoveredElement parent = this.parent; 
			while (parent != null){
				if (parent instanceof RecoveredField){
						insideFieldInitializer = true;
						break; 
				}
				parent = parent.parent;
			}
			typeDeclaration.createsInternalConstructor(!parser().diet || insideFieldInitializer, true);
		} 
	}
	/* might need to cast itself into a MemberTypeDeclaration or a LocalTypeDeclaration */
	TypeDeclaration newTypeDeclaration = null;
	if ((typeDeclaration instanceof TypeDeclaration) && (parent instanceof RecoveredType)){
		newTypeDeclaration = new MemberTypeDeclaration(typeDeclaration.compilationResult);
	} else {
		if ((typeDeclaration instanceof TypeDeclaration) && (parent instanceof RecoveredMethod)){
			newTypeDeclaration = new LocalTypeDeclaration(typeDeclaration.compilationResult);
		}
	}
	/* copy slots into new type */
	if (newTypeDeclaration != null){
		newTypeDeclaration.modifiers = typeDeclaration.modifiers;
		newTypeDeclaration.modifiersSourceStart = typeDeclaration.modifiersSourceStart;
		newTypeDeclaration.name = typeDeclaration.name;
		newTypeDeclaration.superclass = typeDeclaration.superclass;
		newTypeDeclaration.superInterfaces = typeDeclaration.superInterfaces;
		newTypeDeclaration.fields = typeDeclaration.fields;
		newTypeDeclaration.methods = typeDeclaration.methods;
		newTypeDeclaration.memberTypes = typeDeclaration.memberTypes;
		newTypeDeclaration.ignoreFurtherInvestigation = typeDeclaration.ignoreFurtherInvestigation;
		newTypeDeclaration.maxFieldCount = typeDeclaration.maxFieldCount;
		newTypeDeclaration.declarationSourceStart = typeDeclaration.declarationSourceStart;
		newTypeDeclaration.declarationSourceEnd = typeDeclaration.declarationSourceEnd;
		newTypeDeclaration.bodyEnd = typeDeclaration.bodyEnd;
		newTypeDeclaration.bodyStart = typeDeclaration.bodyStart;
		typeDeclaration = newTypeDeclaration;
	}
	return typeDeclaration;
}

