private void convertToFields(TypeDeclaration typeDecl, Argument[] args) {
	int length = args.length;
	FieldDeclaration[] fields = new FieldDeclaration[length];
	int nFields = 0;
	Set<String> argsSet = new HashSet<>();
	for (int i = 0, max = args.length; i < max; i++) {
		Argument arg = args[i];
		arg.bits |= ASTNode.IsRecordComponent;
		String argName = new String(arg.name);
		if (TypeDeclaration.disallowedComponentNames.contains(argName)) {
			problemReporter().recordIllegalComponentNameInRecord(arg, typeDecl);
			continue;
		}
		if (argsSet.contains(argName)) {
			// flag the error at the place where duplicate params of methods would have been flagged.
			continue;
		}
		if (arg.type.getLastToken() == TypeConstants.VOID) {
			problemReporter().recordComponentCannotBeVoid(typeDecl, arg);
			continue;
		}
		if (arg.isVarArgs() && i < max - 1)
			problemReporter().recordIllegalVararg(arg, typeDecl);

		argsSet.add(argName);
		FieldDeclaration f = fields[nFields++] = createFieldDeclaration(arg.name, arg.sourceStart, arg.sourceEnd);
		f.bits = arg.bits;
		f.declarationSourceStart = arg.declarationSourceStart;
		f.declarationEnd = arg.declarationEnd;
		f.declarationSourceEnd = arg.declarationSourceEnd;
		f.endPart1Position = arg.sourceEnd; //TODO BETA_JAVA14 - recheck
		f.endPart2Position = arg.declarationSourceEnd;
		f.modifiers = ClassFileConstants.AccPrivate | ClassFileConstants.AccFinal;
		// Note: JVMS 14 S 4.7.8 The Synthetic Attribute mandates do not mark Synthetic for Record compoents.
		// hence marking this "explicitly" as implicit.
		f.isARecordComponent = true;
		/*
		 * JLS 14 Sec 8.10.1 Record Header
		 * The record header declares a number of record components. The record components
		 * declare the fields of the record class. Each record component in the RecordHeader
		 * declares one private final field in the record class whose name is same as the
		 * Identifier in the record component.
		 *
		 * JLS 14 Sec 8.10.3 Record Components
		 * For each record component appearing in the record component list:
		 * An implicitly declared private final field with the same name as the record
		 * component and the type as the declared type of the record component.
		 */
		f.modifiers |= ClassFileConstants.AccPrivate | ClassFileConstants.AccFinal;
		f.modifiersSourceStart = arg.modifiersSourceStart;
		f.sourceStart = arg.sourceStart;
		f.sourceEnd = arg.sourceEnd;
		f.type = arg.type;
		/*
		 * JLS 14 SEC 8.10.3 Item 1 says the following:
		 *  "This field is annotated with the annotation that appears on the corresponding
		 *  record component, if this annotation type is applicable to a field declaration
		 *  or type context."
		 *
		 *  However, at this point there is no sufficient information to conclude the ElementType
		 *  targeted by the annotation. Hence, do a blanket assignment for now and later (read binding
		 *  time) weed out the irrelevant ones.
		 */
		f.annotations = arg.annotations;
		arg.annotations = null;
		if ((args[i].bits & ASTNode.HasTypeAnnotations) != 0) {
			f.bits |= ASTNode.HasTypeAnnotations;
		}
	}
	if (nFields < fields.length) {
		// Note: This happens only if there are errors in the code.
		FieldDeclaration[] tmp = new FieldDeclaration[nFields];
		System.arraycopy(fields	, 0, tmp, 0, nFields);
		fields = tmp;
	}
	typeDecl.fields = fields;
	typeDecl.nRecordComponents = fields.length;
}

