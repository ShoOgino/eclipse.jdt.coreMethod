	/*main loop of the automat
	When a rule is reduced, the method consumeRule(int) is called with the number
	of the consumed rule. When a terminal is consumed, the method consumeToken(int) is 
	called in order to remember (when needed) the consumed token */
	// (int)asr[asi(act)]
	// name[symbol_index[currentKind]]
	protected void parse() {

		hasReportedError = false;
		int act = START_STATE;
		stateStackTop = -1;
		currentToken = getFirstToken();
		ProcessTerminals : for (;;) {
			try {
				stack[++stateStackTop] = act;
			} catch (IndexOutOfBoundsException e) {
				int oldStackLength = stack.length;
				int oldStack[] = stack;
				stack = new int[oldStackLength + StackIncrement];
				System.arraycopy(oldStack, 0, stack, 0, oldStackLength);
				stack[stateStackTop] = act;
			};

			act = tAction(act, currentToken);

			if (act == ERROR_ACTION || restartRecovery) {
				int errorPos = scanner.currentPosition;
				if (!hasReportedError) {
					this.reportSyntaxError(ERROR_ACTION, currentToken, stateStackTop);
					hasReportedError = true;
				}
				if (resumeOnSyntaxError()) {
					if (act == ERROR_ACTION)
						lastErrorEndPosition = errorPos;
					act = START_STATE;
					stateStackTop = -1;
					currentToken = getFirstToken();
					continue ProcessTerminals;
				} else {
					act = ERROR_ACTION;
				}
				break ProcessTerminals;
			}
			if (act <= NUM_RULES)
				stateStackTop--;
			else
				if (act > ERROR_ACTION) { /* shift-reduce */
					consumeToken(currentToken);
					if (currentElement != null)
						this.recoveryTokenCheck();
					try {
						currentToken = scanner.getNextToken();
					} catch (InvalidInputException e) {
						if (!hasReportedError) {
							this.problemReporter().scannerError(this, e.getMessage());
							hasReportedError = true;
						}
						lastCheckPoint = scanner.currentPosition;
						restartRecovery = true;
					}
					act -= ERROR_ACTION;
				} else
					if (act < ACCEPT_ACTION) { /* shift */
						consumeToken(currentToken);
						if (currentElement != null)
							this.recoveryTokenCheck();
						try {
							currentToken = scanner.getNextToken();
						} catch (InvalidInputException e) {
							if (!hasReportedError) {
								this.problemReporter().scannerError(this, e.getMessage());
								hasReportedError = true;
							}
							lastCheckPoint = scanner.currentPosition;
							restartRecovery = true;
						}
						continue ProcessTerminals;
					} else
						break ProcessTerminals;

			ProcessNonTerminals : do { /* reduce */
				consumeRule(act);
				stateStackTop -= (rhs[act] - 1);
				act = ntAction(stack[stateStackTop], lhs[act]);
			} while (act <= NUM_RULES);
		}
		endParse(act);
	}

