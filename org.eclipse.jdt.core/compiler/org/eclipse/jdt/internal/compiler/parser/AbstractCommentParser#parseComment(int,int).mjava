	/* (non-Javadoc)
	 * Returns true if tag @deprecated is present in javadoc comment.
	 * 
	 * If javadoc checking is enabled, will also construct an Javadoc node, which will be stored into Parser.javadoc
	 * slot for being consumed later on.
	 */
	protected boolean parseComment(int javadocStart, int javadocEnd) {

		boolean validComment = true;
		try {
			// Init scanner position
			this.scanner.resetTo(javadocStart, javadocEnd);
			this.endComment = javadocEnd;
			this.index = javadocStart;
			readChar(); // starting '/'
			int previousPosition = this.index;
			readChar(); // first '*'
			char nextCharacter= readChar(); // second '*'
			
			// Init local variables
			this.astLengthPtr = -1;
			this.astPtr = -1;
			this.currentTokenType = -1;
			this.inlineTagStarted = false;
			this.inlineTagStart = -1;
			this.lineStarted = false;
			this.returnStatement = null;
			this.inherited = false;
			this.deprecated = false;
			this.linePtr = getLineNumber(javadocStart);
			this.lastLinePtr = getLineNumber(javadocEnd);
			this.lineEnd = (this.linePtr == this.lastLinePtr) ? this.endComment : javadocStart;
			this.textStart = -1;
			char previousChar = 0;
			
			// Loop on each comment character
			while (this.index < this.endComment) {
				previousPosition = this.index;
				previousChar = nextCharacter;
				
				// Calculate line end (cannot use this.scanner.linePtr as scanner does not parse line ends again)
				if (this.index > (this.lineEnd+1)) {
					updateLineEnd();
					this.lineStarted = false;
				}
				
				// Read next char only if token was consumed
				if (this.currentTokenType < 0) {
					nextCharacter = readChar(); // consider unicodes
				} else {
					previousPosition = this.scanner.getCurrentTokenStartPosition();
					switch (this.currentTokenType) {
						case TerminalTokens.TokenNameRBRACE:
							nextCharacter = '}';
							break;
						case TerminalTokens.TokenNameMULTIPLY:
							nextCharacter = '*';
							break;
					default:
							nextCharacter = this.scanner.currentCharacter;
					}
					consumeToken();
				}
			
				if (this.index >= this.endComment) {
					break;
				}
				
				switch (nextCharacter) {
					case '@' :
						boolean valid = false;
						// Start tag parsing only if we are on line beginning or at inline tag beginning
						if (!this.lineStarted || previousChar == '{') {
							this.lineStarted = true;
							if (this.inlineTagStarted) {
								this.inlineTagStarted = false;
								if (this.sourceParser != null) this.sourceParser.problemReporter().javadocUnexpectedTag(this.inlineTagStart, this.inlineTagStart);
								validComment = false;
							} else {
								if (previousChar == '{') {
									if (this.textStart != -1 && this.textStart < this.inlineTagStart) {
										pushText(this.textStart, this.inlineTagStart);
									}
									this.inlineTagStarted = true;
								}
								this.scanner.resetTo(this.index, this.endComment);
								this.currentTokenType = -1; // flush token cache at line begin
								try {
									int tk = readTokenAndConsume();
									this.tagSourceStart = this.kind == COMPIL_PARSER ? this.scanner.getCurrentTokenStartPosition() : previousPosition;
									this.tagSourceEnd = this.scanner.getCurrentTokenEndPosition();
									switch (tk) {
										case TerminalTokens.TokenNameIdentifier :
											char[] tag = this.scanner.getCurrentIdentifierSource();
											if (CharOperation.equals(tag, TAG_DEPRECATED)) {
												this.deprecated = true;
												if (this.kind == DOM_PARSER) {
													valid = parseTag();
												} else {
													valid = true;
												}
											} else if (CharOperation.equals(tag, TAG_INHERITDOC)) {
												this.inherited = true;
												if (this.kind == DOM_PARSER) {
													valid = parseTag();
												} else {
													valid = true;
												}
											} else if (CharOperation.equals(tag, TAG_PARAM)) {
												valid = parseParam();
											} else if (CharOperation.equals(tag, TAG_EXCEPTION)) {
												valid = parseThrows(false);
											} else if (CharOperation.equals(tag, TAG_SEE)) {
												valid = parseSee(false);
											} else if (CharOperation.equals(tag, TAG_LINK)) {
												if (this.inlineTagStarted) {
													valid = parseSee(false);
												} else {
													valid = parseTag();
												}
											} else if (CharOperation.equals(tag, TAG_LINKPLAIN)) {
												if (this.inlineTagStarted) {
													valid = parseSee(true);
												} else {
													valid = parseTag();
												}
											} else {
												valid = parseTag();
											}
											break;
										case TerminalTokens.TokenNamereturn :
											valid = parseReturn();
											break;
										case TerminalTokens.TokenNamethrows :
											valid = parseThrows(true);
											break;
										default:
											if (this.kind == DOM_PARSER) {
												switch (tk) {
													case TerminalTokens.TokenNameabstract:
													case TerminalTokens.TokenNameassert:
													case TerminalTokens.TokenNameboolean:
													case TerminalTokens.TokenNamebreak:
													case TerminalTokens.TokenNamebyte:
													case TerminalTokens.TokenNamecase:
													case TerminalTokens.TokenNamecatch:
													case TerminalTokens.TokenNamechar:
													case TerminalTokens.TokenNameclass:
													case TerminalTokens.TokenNamecontinue:
													case TerminalTokens.TokenNamedefault:
													case TerminalTokens.TokenNamedo:
													case TerminalTokens.TokenNamedouble:
													case TerminalTokens.TokenNameelse:
													case TerminalTokens.TokenNameextends:
													case TerminalTokens.TokenNamefalse:
													case TerminalTokens.TokenNamefinal:
													case TerminalTokens.TokenNamefinally:
													case TerminalTokens.TokenNamefloat:
													case TerminalTokens.TokenNamefor:
													case TerminalTokens.TokenNameif:
													case TerminalTokens.TokenNameimplements:
													case TerminalTokens.TokenNameimport:
													case TerminalTokens.TokenNameinstanceof:
													case TerminalTokens.TokenNameint:
													case TerminalTokens.TokenNameinterface:
													case TerminalTokens.TokenNamelong:
													case TerminalTokens.TokenNamenative:
													case TerminalTokens.TokenNamenew:
													case TerminalTokens.TokenNamenull:
													case TerminalTokens.TokenNamepackage:
													case TerminalTokens.TokenNameprivate:
													case TerminalTokens.TokenNameprotected:
													case TerminalTokens.TokenNamepublic:
													case TerminalTokens.TokenNameshort:
													case TerminalTokens.TokenNamestatic:
													case TerminalTokens.TokenNamestrictfp:
													case TerminalTokens.TokenNamesuper:
													case TerminalTokens.TokenNameswitch:
													case TerminalTokens.TokenNamesynchronized:
													case TerminalTokens.TokenNamethis:
													case TerminalTokens.TokenNamethrow:
													case TerminalTokens.TokenNametransient:
													case TerminalTokens.TokenNametrue:
													case TerminalTokens.TokenNametry:
													case TerminalTokens.TokenNamevoid:
													case TerminalTokens.TokenNamevolatile:
													case TerminalTokens.TokenNamewhile:
														valid = parseTag();
														break;
												}
											}
									}
									if (!valid) {
										this.inlineTagStarted = false;
										validComment = false;
									}
									this.textStart = this.index;
								} catch (InvalidInputException e) {
									consumeToken();
								}
							}
						}
						break;
					case '\r':
					case '\n':
						if (this.lineStarted && this.textStart < previousPosition) {
							pushText(this.textStart, previousPosition);
						}
						this.lineStarted = false;
						this.inlineTagStarted = false;
						// Fix bug 51650
						this.textStart = -1;
						break;
					case '}' :
						if (this.inlineTagStarted) {
							if (this.lineStarted && this.textStart != -1 && this.textStart < previousPosition) {
								pushText(this.textStart, previousPosition);
							}
							if (this.kind == DOM_PARSER) refreshInlineTagPosition(previousPosition);
							this.textStart = this.index;
							this.inlineTagStarted = false;
						} else {
							if (!this.lineStarted) {
								this.textStart = previousPosition;
							}
							this.lineStarted = true;
						}
						break;
					case '{' :
						if (this.inlineTagStarted) {
							this.inlineTagStarted = false;
							if (this.sourceParser != null) this.sourceParser.problemReporter().javadocInvalidTag(this.inlineTagStart, this.index);
						} else {
							if (!this.lineStarted) {
								this.textStart = previousPosition;
							}
							this.lineStarted = true;
							this.inlineTagStart = previousPosition;
						}
						break;
					case '*' :
						// do nothing for '*' character
						break;
					default :
						if (!CharOperation.isWhitespace(nextCharacter)) {
							if (!this.lineStarted) {
								this.textStart = previousPosition;
							}
							this.lineStarted = true;
						}
				}
			}
			if (this.lineStarted && this.textStart < previousPosition) {
				pushText(this.textStart, previousPosition);
			}
			updateDocComment();
		} catch (Exception ex) {
			validComment = false;
		}
		return validComment;
	}

