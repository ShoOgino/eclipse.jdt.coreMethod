	/* (non-Javadoc)
	 * Returns true if tag @deprecated is present in javadoc comment.
	 * 
	 * If javadoc checking is enabled, will also construct an Javadoc node, which will be stored into Parser.javadoc
	 * slot for being consumed later on.
	 */
	protected boolean parseComment(int javadocStart, int javadocEnd) {

		boolean validComment = true;
		try {
			// Init scanner position
			this.scanner.resetTo(javadocStart, javadocEnd);
			this.endComment = javadocEnd;
			this.index = javadocStart;
			readChar(); // starting '/'
			int previousPosition = this.index;
			readChar(); // first '*'
			char nextCharacter= readChar(); // second '*'
			
			// Init local variables
			this.astLengthPtr = -1;
			this.astPtr = -1;
			this.currentTokenType = -1;
			this.inlineTagStarted = false;
			this.inlineTagStart = -1;
			this.lineStarted = false;
			this.returnStatement = null;
			this.inherited = false;
			this.deprecated = false;
			this.linePtr = getLineNumber(javadocStart);
			this.lastLinePtr = getLineNumber(javadocEnd);
			this.lineEnd = (this.linePtr == this.lastLinePtr) ? this.endComment : this.scanner.getLineEnd(this.linePtr);
			this.textStart = -1;
			char previousChar = 0;
			int invalidTagLineEnd = -1;
			int invalidInlineTagLineEnd = -1;
			
			// Loop on each comment character
			while (this.index < this.endComment) {
				previousPosition = this.index;
				previousChar = nextCharacter;
				
				// Calculate line end (cannot use this.scanner.linePtr as scanner does not parse line ends again)
				if (this.index > (this.lineEnd+1)) {
					updateLineEnd();
				}
				
				// Read next char only if token was consumed
				if (this.currentTokenType < 0) {
					nextCharacter = readChar(); // consider unicodes
				} else {
					previousPosition = this.scanner.getCurrentTokenStartPosition();
					switch (this.currentTokenType) {
						case TerminalTokens.TokenNameRBRACE:
							nextCharacter = '}';
							break;
						case TerminalTokens.TokenNameMULTIPLY:
							nextCharacter = '*';
							break;
					default:
							nextCharacter = this.scanner.currentCharacter;
					}
					consumeToken();
				}
			
				if (this.index >= this.endComment) {
					break;
				}
				
				switch (nextCharacter) {
					case '@' :
						boolean valid = false;
						// Start tag parsing only if we have a java identifier start character and if we are on line beginning or at inline tag beginning
						if ((!this.lineStarted || previousChar == '{')) {
							this.lineStarted = true;
							if (this.inlineTagStarted) {
								this.inlineTagStarted = false;
								// bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=53279
								// Cannot have @ inside inline comment
								if (this.sourceParser != null) {
									int end = previousPosition<invalidInlineTagLineEnd ? previousPosition : invalidInlineTagLineEnd;
									this.sourceParser.problemReporter().javadocUnterminatedInlineTag(this.inlineTagStart, end);
								}
								validComment = false;
								if (this.lineStarted && this.textStart != -1 && this.textStart < previousPosition) {
									pushText(this.textStart, previousPosition);
								}
								if (this.kind == DOM_PARSER) refreshInlineTagPosition(previousPosition);
							}
							if (previousChar == '{') {
								if (this.textStart != -1 && this.textStart < this.inlineTagStart) {
									pushText(this.textStart, this.inlineTagStart);
								}
								this.inlineTagStarted = true;
								invalidInlineTagLineEnd = this.lineEnd;
							} else if (this.textStart != -1 && this.textStart < invalidTagLineEnd) {
								pushText(this.textStart, invalidTagLineEnd);
							}
							this.scanner.resetTo(this.index, this.endComment);
							this.currentTokenType = -1; // flush token cache at line begin
							try {
								int token = readTokenAndConsume();
								this.tagSourceStart = this.scanner.getCurrentTokenStartPosition();
								this.tagSourceEnd = this.scanner.getCurrentTokenEndPosition();
								char[] tag = this.scanner.getCurrentIdentifierSource(); // first token is either an identifier or a keyword
								if (this.kind == DOM_PARSER) {
									// For DOM parser, try to get tag name other than java identifier
									// (see bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=51660)
									int tk = token;
									int le = this.lineEnd;
									char pc = peekChar();
									tagNameToken: while (tk != TerminalTokens.TokenNameEOF) {
										this.tagSourceEnd = this.scanner.getCurrentTokenEndPosition();
										token = tk;
										// !, ", #, %, &, ', -, :, <, >, * chars and spaces are not allowed in tag names
										switch (pc) {
											case '}':
											case '!':
											case '#':
											case '%':
											case '&':
											case '\'':
											case ':':
											// case '-': allowed in tag names as this character is often used in doclets (bug 68087)
											case '<':
											case '>':
											case '*': // break for '*' as this is perhaps the end of comment (bug 65288)
												break tagNameToken;
											default:
												if (pc == ' ' || Character.isWhitespace(pc)) break tagNameToken;
										}
										tk = readTokenAndConsume();
										pc = peekChar();
									}
									int length = this.tagSourceEnd-this.tagSourceStart+1;
									tag = new char[length];
									System.arraycopy(this.source, this.tagSourceStart, tag, 0, length);
									this.index = this.tagSourceEnd+1;
									this.scanner.currentPosition = this.tagSourceEnd+1;
									this.tagSourceStart = previousPosition;
									this.lineEnd = le;
								}
								switch (token) {
									case TerminalTokens.TokenNameIdentifier :
										if (CharOperation.equals(tag, TAG_DEPRECATED)) {
											this.deprecated = true;
											if (this.kind == DOM_PARSER) {
												valid = parseTag();
											} else {
												valid = true;
											}
										} else if (CharOperation.equals(tag, TAG_INHERITDOC)) {
											// inhibits inherited flag when tags have been already stored
											// see bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=51606
											// Note that for DOM_PARSER, nodes stack may be not empty even no '@' tag
											// was encountered in comment. But it cannot be the case for COMPILER_PARSER
											// and so is enough as it is only this parser which signals the missing tag warnings...
											this.inherited = this.astPtr==-1;
											if (this.kind == DOM_PARSER) {
												valid = parseTag();
											} else {
												valid = true;
											}
										} else if (CharOperation.equals(tag, TAG_PARAM)) {
											valid = parseParam();
										} else if (CharOperation.equals(tag, TAG_EXCEPTION)) {
											valid = parseThrows(false);
										} else if (CharOperation.equals(tag, TAG_SEE)) {
											if (this.inlineTagStarted) {
												// bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=53290
												// Cannot have @see inside inline comment
												valid = false;
												if (this.sourceParser != null)
													this.sourceParser.problemReporter().javadocUnexpectedTag(this.tagSourceStart, this.tagSourceEnd);
											} else {
												valid = parseSee(false);
											}
										} else if (CharOperation.equals(tag, TAG_LINK)) {
											if (this.inlineTagStarted) {
												valid = parseSee(false);
											} else {
												// bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=53290
												// Cannot have @link outside inline comment
												valid = false;
												if (this.sourceParser != null)
													this.sourceParser.problemReporter().javadocUnexpectedTag(this.tagSourceStart, this.tagSourceEnd);
											}
										} else if (CharOperation.equals(tag, TAG_LINKPLAIN)) {
											if (this.inlineTagStarted) {
												valid = parseSee(true);
											} else {
												valid = parseTag();
											}
										} else {
											valid = parseTag();
										}
										break;
									case TerminalTokens.TokenNamereturn :
										valid = parseReturn();
										// verify characters after return tag (we're expecting text description)
										if(!verifyCharsAfterReturnTag(this.index)) {
											if (this.sourceParser != null) {
												int end = this.starPosition == -1 || this.lineEnd<this.starPosition ? this.lineEnd : this.starPosition;
												this.sourceParser.problemReporter().javadocEmptyReturnTag(this.tagSourceStart, end);
											}
										}
										break;
									case TerminalTokens.TokenNamethrows :
										valid = parseThrows(true);
										break;
									default:
										if (this.kind == DOM_PARSER) {
											switch (token) {
												case TerminalTokens.TokenNameabstract:
												case TerminalTokens.TokenNameassert:
												case TerminalTokens.TokenNameboolean:
												case TerminalTokens.TokenNamebreak:
												case TerminalTokens.TokenNamebyte:
												case TerminalTokens.TokenNamecase:
												case TerminalTokens.TokenNamecatch:
												case TerminalTokens.TokenNamechar:
												case TerminalTokens.TokenNameclass:
												case TerminalTokens.TokenNamecontinue:
												case TerminalTokens.TokenNamedefault:
												case TerminalTokens.TokenNamedo:
												case TerminalTokens.TokenNamedouble:
												case TerminalTokens.TokenNameelse:
												case TerminalTokens.TokenNameextends:
												case TerminalTokens.TokenNamefalse:
												case TerminalTokens.TokenNamefinal:
												case TerminalTokens.TokenNamefinally:
												case TerminalTokens.TokenNamefloat:
												case TerminalTokens.TokenNamefor:
												case TerminalTokens.TokenNameif:
												case TerminalTokens.TokenNameimplements:
												case TerminalTokens.TokenNameimport:
												case TerminalTokens.TokenNameinstanceof:
												case TerminalTokens.TokenNameint:
												case TerminalTokens.TokenNameinterface:
												case TerminalTokens.TokenNamelong:
												case TerminalTokens.TokenNamenative:
												case TerminalTokens.TokenNamenew:
												case TerminalTokens.TokenNamenull:
												case TerminalTokens.TokenNamepackage:
												case TerminalTokens.TokenNameprivate:
												case TerminalTokens.TokenNameprotected:
												case TerminalTokens.TokenNamepublic:
												case TerminalTokens.TokenNameshort:
												case TerminalTokens.TokenNamestatic:
												case TerminalTokens.TokenNamestrictfp:
												case TerminalTokens.TokenNamesuper:
												case TerminalTokens.TokenNameswitch:
												case TerminalTokens.TokenNamesynchronized:
												case TerminalTokens.TokenNamethis:
												case TerminalTokens.TokenNamethrow:
												case TerminalTokens.TokenNametransient:
												case TerminalTokens.TokenNametrue:
												case TerminalTokens.TokenNametry:
												case TerminalTokens.TokenNamevoid:
												case TerminalTokens.TokenNamevolatile:
												case TerminalTokens.TokenNamewhile:
													valid = parseTag();
													break;
											}
										}
								}
								this.textStart = this.index;
								if (!valid) {
									// bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=51600
									// do not stop the inline tag when error is encountered to get text after
									validComment = false;
									// bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=51600
									// for DOM AST node, store tag as text in case of invalid syntax
									if (this.kind == DOM_PARSER) {
										parseTag();
										this.textStart = this.tagSourceEnd+1;
										invalidTagLineEnd  = this.lineEnd;
									}
								}
							} catch (InvalidInputException e) {
								consumeToken();
							}
						}
						break;
					case '\r':
					case '\n':
						if (this.lineStarted && this.textStart < previousPosition) {
							pushText(this.textStart, previousPosition);
						}
						this.lineStarted = false;
						// Fix bug 51650
						this.textStart = -1;
						break;
					case '}' :
						if (this.inlineTagStarted) {
							if (this.lineStarted && this.textStart != -1 && this.textStart < previousPosition) {
								pushText(this.textStart, previousPosition);
							}
							if (this.kind == DOM_PARSER) refreshInlineTagPosition(previousPosition);
							this.textStart = this.index;
							this.inlineTagStarted = false;
						} else {
							if (!this.lineStarted) {
								this.textStart = previousPosition;
							}
						}
						this.lineStarted = true;
						break;
					case '{' :
						if (this.inlineTagStarted) {
							this.inlineTagStarted = false;
							// bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=53279
							// Cannot have opening brace in inline comment
							if (this.sourceParser != null) {
								int end = previousPosition<invalidInlineTagLineEnd ? previousPosition : invalidInlineTagLineEnd;
								this.sourceParser.problemReporter().javadocUnterminatedInlineTag(this.inlineTagStart, end);
							}
							if (this.lineStarted && this.textStart != -1 && this.textStart < previousPosition) {
								pushText(this.textStart, previousPosition);
							}
							if (this.kind == DOM_PARSER) refreshInlineTagPosition(previousPosition);
						}
						if (!this.lineStarted) {
							this.textStart = previousPosition;
						}
						this.lineStarted = true;
						this.inlineTagStart = previousPosition;
						break;
					case '*' :
					case '\u000c' :	/* FORM FEED               */
					case ' ' :			/* SPACE                   */
					case '\t' :			/* HORIZONTAL TABULATION   */
						// do nothing for space or '*' characters
						break;
					default :
						if (!this.lineStarted) {
							this.textStart = previousPosition;
						}
						this.lineStarted = true;
						break;
				}
			}
			// bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=53279
			// Cannot leave comment inside inline comment
			if (this.inlineTagStarted) {
				this.inlineTagStarted = false;
				if (this.sourceParser != null) {
					int end = previousPosition<invalidInlineTagLineEnd ? previousPosition : invalidInlineTagLineEnd;
					if (this.index >= this.endComment) end = invalidInlineTagLineEnd;
					this.sourceParser.problemReporter().javadocUnterminatedInlineTag(this.inlineTagStart, end);
				}
				if (this.lineStarted && this.textStart != -1 && this.textStart < previousPosition) {
					pushText(this.textStart, previousPosition);
				}
				if (this.kind == DOM_PARSER) {
					refreshInlineTagPosition(previousPosition);
				}
			} else if (this.lineStarted && this.textStart < previousPosition) {
				pushText(this.textStart, previousPosition);
			}
			updateDocComment();
		} catch (Exception ex) {
			validComment = false;
		}
		return validComment;
	}

