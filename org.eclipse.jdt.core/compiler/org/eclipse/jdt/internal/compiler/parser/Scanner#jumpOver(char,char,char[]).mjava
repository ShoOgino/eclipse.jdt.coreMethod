private void jumpOver(char open, char close, char [] blackList) throws InvalidInputException {
	// Lifted from jumpOverMethodBody() and simplified and minimized side effects. Caller should still save and restore cursor.
	int found = 1;
	boolean whiteSpace;
	int blackListLength = blackList == null ? 0 : blackList.length;
	while (true) {
		do {
			this.startPosition = this.currentPosition;
			if (((this.currentCharacter = this.source[this.currentPosition++]) == '\\')
					&& (this.source[this.currentPosition] == 'u')) {
				whiteSpace = jumpOverUnicodeWhiteSpace();
			} else {
				whiteSpace = CharOperation.isWhitespace(this.currentCharacter);
			}
		} while (whiteSpace);

		char c = this.currentCharacter;
		for (int i = 0; i < blackListLength; i++) {
			if (blackList[i] == c)
				return;
		}
		
		// -------consume token until close is found
		NextToken: switch (c) {
			case '(' :
				if (open == '(') {
					found++;
				}
				break NextToken;
			case ')' :
				if (close == ')') {
					found--;
					if (found == 0) {
						return;
					}
				}
				break NextToken;
			case '<' :
				if (open == '<') {
					found++;
				}
				break NextToken;
			case '>' :
				if (close == '>') {
					found--;
					if (found == 0) {
						return;
					}
				}
				break NextToken;
			case '\'' :   // can show up in annotations ...
				int test;
				if ((test = getNextChar('\n', '\r')) >= 0 || getNextChar('\'')) {
					throw new InvalidInputException(INVALID_CHARACTER_CONSTANT);
				}
				if (getNextChar('\\')) {
					if (this.unicodeAsBackSlash) {
						this.unicodeAsBackSlash = false;
						if (((this.currentCharacter = this.source[this.currentPosition++]) == '\\') && (this.source[this.currentPosition] == 'u')) {
							getNextUnicodeChar();
						}
					} else {
						this.currentCharacter = this.source[this.currentPosition++];
					}
					scanEscapeCharacter();
				} else { // consume next character
					this.unicodeAsBackSlash = false;
					if ((this.currentCharacter = this.source[this.currentPosition++]) == '\\' && this.source[this.currentPosition] == 'u') {
						getNextUnicodeChar();	
					}
				}
				if (getNextChar('\''))
					break NextToken;
				throw new InvalidInputException(INVALID_CHARACTER_CONSTANT);
			case '"' : // can show up in annotations ...
					this.unicodeAsBackSlash = false;
					if (((this.currentCharacter = this.source[this.currentPosition++]) == '\\')
						&& (this.source[this.currentPosition] == 'u')) {
						getNextUnicodeChar();
					} 
					while (this.currentCharacter != '"') {
						if (this.currentCharacter == '\n' || this.currentCharacter == '\r') {
							throw new InvalidInputException(INVALID_CHAR_IN_STRING);
						}
						if (this.currentCharacter == '\\') {
							if (this.unicodeAsBackSlash) {
								this.unicodeAsBackSlash = false;
								if (((this.currentCharacter = this.source[this.currentPosition++]) == '\\') && (this.source[this.currentPosition] == 'u')) {
									getNextUnicodeChar();
								}
							} else {
								this.currentCharacter = this.source[this.currentPosition++];
							}
							scanEscapeCharacter();
						}
						this.unicodeAsBackSlash = false;
						if (((this.currentCharacter = this.source[this.currentPosition++]) == '\\')
							&& (this.source[this.currentPosition] == 'u')) {
							getNextUnicodeChar();
						}
					}
				break NextToken;
			case '/' :
			{
				if ((test = getNextChar('/', '*')) == 0) { // line comment
					do {
						if (((this.currentCharacter = this.source[this.currentPosition++]) == '\\')
								&& (this.source[this.currentPosition] == 'u')) {
							getNextUnicodeChar();
						}
						// handle the \\u case manually into comment
						if (this.currentCharacter == '\\') {
							if (this.source[this.currentPosition] == '\\')
								this.currentPosition++;
						}
					} while (this.currentCharacter != '\r' && this.currentCharacter != '\n');
					// completely consume the line break
					if (this.currentCharacter == '\r') {
						if (this.source[this.currentPosition] == '\n') {
							this.currentPosition++;
							this.currentCharacter = '\n';
						} else if ((this.source[this.currentPosition] == '\\')
								&& (this.source[this.currentPosition + 1] == 'u')) {
							getNextUnicodeChar();
						}
					}
					break NextToken;
				}
				if (test > 0) { // /**/ && /***/
					if (((this.currentCharacter = this.source[this.currentPosition++]) == '\\')
							&& (this.source[this.currentPosition] == 'u')) {
						getNextUnicodeChar();
					} 
					boolean star;
					do {
						star = this.currentCharacter == '*';
						if (((this.currentCharacter = this.source[this.currentPosition++]) == '\\')
								&& (this.source[this.currentPosition] == 'u')) {
							getNextUnicodeChar();
						}
						// handle the \\u case manually into comment
						if (this.currentCharacter == '\\') {
							if (this.source[this.currentPosition] == '\\')
								this.currentPosition++;
						}
					} while ((this.currentCharacter != '/') || (!star));
				}
				break NextToken;
			}
			default :
				if (c < ScannerHelper.MAX_OBVIOUS) {
					if ((ScannerHelper.OBVIOUS_IDENT_CHAR_NATURES[c] & ScannerHelper.C_IDENT_START) != 0) {
						scanIdentifierOrKeyword();
						break NextToken;
					} else if ((ScannerHelper.OBVIOUS_IDENT_CHAR_NATURES[c] & ScannerHelper.C_DIGIT) != 0) {
						scanNumber(false); // can occur in annotations.
						break NextToken;
					} else {
						break NextToken;
					}
				}
				boolean isJavaIdStart;
				if (c >= HIGH_SURROGATE_MIN_VALUE && c <= HIGH_SURROGATE_MAX_VALUE) {
					// Unicode 4 detection
					char low = (char) getNextChar();
					if (low < LOW_SURROGATE_MIN_VALUE || low > LOW_SURROGATE_MAX_VALUE) {
						// illegal low surrogate
						break NextToken;
					}
					isJavaIdStart = ScannerHelper.isJavaIdentifierStart(this.complianceLevel, c, low);
				} else if (c >= LOW_SURROGATE_MIN_VALUE && c <= LOW_SURROGATE_MAX_VALUE) {
					break NextToken;
				} else {
					// optimized case already checked
					isJavaIdStart = ScannerHelper.isJavaIdentifierStart(this.complianceLevel, c);
				}
				if (isJavaIdStart) {
					scanIdentifierOrKeyword();
				}
				break NextToken;
		}
	}
}

