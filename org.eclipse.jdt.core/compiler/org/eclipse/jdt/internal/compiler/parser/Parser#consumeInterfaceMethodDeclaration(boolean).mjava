protected void consumeInterfaceMethodDeclaration(boolean hasSemicolonBody) {
	// InterfaceMemberDeclaration ::= DefaultMethodHeader MethodBody
	// InterfaceMemberDeclaration ::= MethodHeader MethodBody
	// -- the next rule is illegal but allows to give a more canonical error message from inside consumeInterfaceMethodDeclaration(): 
	// InterfaceMemberDeclaration ::= DefaultMethodHeader ';'


	/*
	this.astStack : modifiers arguments throws statements
	this.identifierStack : type name
	this.intStack : dim dim dim
	 ==>
	this.astStack : MethodDeclaration
	this.identifierStack :
	this.intStack :
	*/

	if (!hasSemicolonBody) {
		// pop the position of the {  (body of the method) pushed in block decl
		this.intPtr--;
		// retrieve end position of method declarator

		//statements
		this.realBlockPtr--;
		int length;
		if ((length = this.astLengthStack[this.astLengthPtr--]) != 0) {
			this.astPtr -= length;
		}
	}

	//watch for } that could be given as a unicode ! ( u007D is '}' )
	MethodDeclaration md = (MethodDeclaration) this.astStack[this.astPtr];
	md.bodyEnd = this.endPosition;
	md.declarationSourceEnd = flushCommentsDefinedPriorTo(this.endStatementPosition);
	
	boolean isDefault = (md.modifiers & ExtraCompilerModifiers.AccDefaultMethod) != 0;
	if (isDefault) {
		if (!this.parsingJava8Plus) {
			problemReporter().defaultMethodsNotBelow18(md);
		} else if (hasSemicolonBody) {
			md.modifiers |= ExtraCompilerModifiers.AccSemicolonBody; // avoid complaints regarding undocumented empty body
			problemReporter().methodNeedBody(md);	// grammar intentially allows illegal input to enable this error message
		}
	} else {
		// report the problem and continue the parsing - narrowing the problem onto the method
		if(!this.statementRecoveryActivated && !hasSemicolonBody) problemReporter().abstractMethodNeedingNoBody(md);
	}
}

