private void reportHierarchy() {
	// ensure each binary type knows its supertypes before reporting the hierarchy
	int problemLength = typeIndex+1;
	boolean[] typesWithProblem = new boolean[problemLength];
	for (int current = 0; current <= typeIndex; current++) { // typeIndex may continue to grow
		ReferenceBinding typeBinding = typeBindings[current];
		if (typeBinding.isBinaryBinding()) {
			// fault in its hierarchy...
			try {
				typeBinding.superclass();
				typeBinding.superInterfaces();
			} catch (AbortCompilation e) {
				if (current >= problemLength) {
					System.arraycopy(typesWithProblem, 0, typesWithProblem = new boolean[current+1], 0, problemLength);
					problemLength = current+1;
				}
				typesWithProblem[current] = true;
			}
		}
	}

	for (int current = typeIndex; current >= 0; current--) {
		if (current < problemLength && typesWithProblem[current]) continue;

		IGenericType suppliedType = typeModels[current];
		ReferenceBinding typeBinding = typeBindings[current];
		IGenericType superclass;
		if (typeBinding.isInterface()){ // do not connect interfaces to Object
			superclass = null;
		} else {
			superclass = this.findSuperClass(suppliedType, typeBinding);
		}
		IGenericType[] superinterfaces = this.findSuperInterfaces(suppliedType, typeBinding);
		
		requestor.connect(suppliedType, superclass, superinterfaces);
	}
}

