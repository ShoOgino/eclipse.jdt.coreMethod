private void reportHierarchy() {
	// ensure each binary type knows its supertypes before reporting the hierarchy
	int problemLength = typeIndex+1;
	boolean[] typesWithProblem = new boolean[problemLength];
	for (int current = 0; current <= typeIndex; current++) { // typeIndex may continue to grow
		ReferenceBinding typeBinding = typeBindings[current];
		if (typeBinding.isBinaryBinding()) {
			// fault in its hierarchy...
			try {
				typeBinding.superclass();
				typeBinding.superInterfaces();
			} catch (AbortCompilation e) {
				if (current >= problemLength) {
					System.arraycopy(typesWithProblem, 0, typesWithProblem = new boolean[current+1], 0, problemLength);
					problemLength = current+1;
				}
				typesWithProblem[current] = true;
			}
		}
	}

	for (int current = typeIndex; current >= 0; current--) {
		IGenericType suppliedType = typeModels[current];
		ReferenceBinding typeBinding = typeBindings[current];
		if (current < problemLength && typesWithProblem[current]) continue;

		ReferenceBinding superBinding = typeBinding.superclass();
		IGenericType superclass = null;
		if (superBinding != null) {
			for (int t = typeIndex; t >= 0; t--) {
				if (typeBindings[t] == superBinding) {
					superclass = typeModels[t];
					break;
				}
			}
		}

		ReferenceBinding[] interfaceBindings = typeBinding.superInterfaces();
		int length = interfaceBindings.length;
		IGenericType[] superinterfaces = new IGenericType[length];
		next : for (int i = 0; i < length; i++) {
			ReferenceBinding interfaceBinding = interfaceBindings[i];
			for (int t = typeIndex; t >= 0; t--) {
				if (typeBindings[t] == interfaceBinding) {
					superinterfaces[i] = typeModels[t];
					continue next;
				}
			}
		}
		if (typeBinding.isInterface()){ // do not connect interfaces to Object
			superclass = null;
		}
		requestor.connect(suppliedType, superclass, superinterfaces);
	}
}

