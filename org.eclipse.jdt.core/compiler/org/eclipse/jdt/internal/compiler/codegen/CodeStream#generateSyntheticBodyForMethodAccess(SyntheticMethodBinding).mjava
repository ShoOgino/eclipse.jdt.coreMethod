public void generateSyntheticBodyForMethodAccess(SyntheticMethodBinding accessMethod) {

	initializeMaxLocals(accessMethod);
	MethodBinding targetMethod = accessMethod.targetMethod;
	TypeBinding[] parameters = targetMethod.parameters;
	int length = parameters.length;
	TypeBinding[] arguments = accessMethod.purpose == SyntheticMethodBinding.BridgeMethod 
													? accessMethod.parameters
													: null;
	int resolvedPosition;
	if (targetMethod.isStatic())
		resolvedPosition = 0;
	else {
		this.aload_0();
		resolvedPosition = 1;
	}
	for (int i = 0; i < length; i++) {
	    TypeBinding parameter = parameters[i];
	    if (arguments != null) { // for bridge methods
		    TypeBinding argument = arguments[i];
			load(argument, resolvedPosition);
			if (argument != parameter) 
			    checkcast(parameter);
	    } else {
			load(parameter, resolvedPosition);
		}
		if ((parameter == TypeBinding.DOUBLE) || (parameter == TypeBinding.LONG))
			resolvedPosition += 2;
		else
			resolvedPosition++;
	}
	if (targetMethod.isStatic())
		this.invokestatic(targetMethod);
	else {
		if (targetMethod.isConstructor()
			|| targetMethod.isPrivate()
			// qualified super "X.super.foo()" targets methods from superclass
			|| accessMethod.purpose == SyntheticMethodBinding.SuperMethodAccess){
			this.invokespecial(targetMethod);
		} else {
			if (targetMethod.declaringClass.isInterface()) { // interface or annotation type
				this.invokeinterface(targetMethod);
			} else {
				this.invokevirtual(targetMethod);
			}
		}
	}
	switch (targetMethod.returnType.id) {
		case TypeIds.T_void :
			this.return_();
			break;
		case TypeIds.T_boolean :
		case TypeIds.T_byte :
		case TypeIds.T_char :
		case TypeIds.T_short :
		case TypeIds.T_int :
			this.ireturn();
			break;
		case TypeIds.T_long :
			this.lreturn();
			break;
		case TypeIds.T_float :
			this.freturn();
			break;
		case TypeIds.T_double :
			this.dreturn();
			break;
		default :
			TypeBinding accessErasure = accessMethod.returnType.erasure();
			TypeBinding match = targetMethod.returnType.findSuperTypeOriginatingFrom(accessErasure);
			if (match == null) {
				this.checkcast(accessErasure); // for bridge methods
			}
			this.areturn();
	}
}

