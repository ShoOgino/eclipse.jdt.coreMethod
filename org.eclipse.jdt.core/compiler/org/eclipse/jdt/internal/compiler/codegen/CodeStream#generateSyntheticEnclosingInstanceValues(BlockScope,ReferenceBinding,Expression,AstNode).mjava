/**
 * Code responsible to generate the suitable code to supply values for the synthetic enclosing
 * instance arguments of a constructor invocation of a nested type.
 */
public void generateSyntheticEnclosingInstanceValues(BlockScope currentScope, ReferenceBinding targetType, Expression enclosingInstance, AstNode invocationSite) {

	// perform some emulation work in case there is some and we are inside a local type only
	boolean hasExtraEnclosingInstance = enclosingInstance != null;
	ReferenceBinding[] syntheticArgumentTypes;

	if ((syntheticArgumentTypes = targetType.syntheticEnclosingInstanceTypes()) != null) {

		ReferenceBinding targetEnclosingType = targetType.isAnonymousType() ? 
				targetType.superclass().enclosingType() // supplying enclosing instance for the anonymous type's superclass
				: targetType.enclosingType();

		boolean needEnclosingInstanceNullCheck = currentScope.environment().options.complianceLevel >= CompilerOptions.JDK1_4;
						
		for (int i = 0, max = syntheticArgumentTypes.length; i < max; i++) {
			ReferenceBinding syntheticArgType = syntheticArgumentTypes[i];
			if (hasExtraEnclosingInstance && syntheticArgType == targetEnclosingType) {
				hasExtraEnclosingInstance = false;
				enclosingInstance.generateCode(currentScope, this, true);
				if (needEnclosingInstanceNullCheck){
					dup();
					invokeObjectGetClass(); // will perform null check
					pop();
				}
				
			} else {
				Object[] emulationPath = currentScope.getEmulationPath(
					syntheticArgType, 
					false /*not only exact match (i.e. allow compatible)*/,
					targetType.isAnonymousType());
				this.generateOuterAccess(emulationPath, invocationSite, syntheticArgType, currentScope);
			}
		}
		if (hasExtraEnclosingInstance){
			currentScope.problemReporter().unnecessaryEnclosingInstanceSpecification(enclosingInstance, targetType);
		}
	} else { // we may still have an enclosing instance to consider
		if (hasExtraEnclosingInstance) {
			currentScope.problemReporter().unnecessaryEnclosingInstanceSpecification(enclosingInstance, targetType);
		}
	}
}

