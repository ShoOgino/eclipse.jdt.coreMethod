/*
 * Some placed labels might be branching to a goto bytecode which we can optimize better.
 */
public void inlineForwardReferencesFromLabelsTargeting(BranchLabel label, int gotoLocation) {
	
/*
 Code required to optimized unreachable gotos.
	public boolean isBranchTarget(int location) {
		Label[] labels = codeStream.labels;
		for (int i = codeStream.countLabels - 1; i >= 0; i--){
			Label label = labels[i];
			if ((label.position == location) && label.isStandardLabel()){
				return true;
			}
		}
		return false;
	}
 */
	boolean hasStandardLabel = false;
	boolean removeFrame = true;
	for (int i = this.countLabels - 1; i >= 0; i--) {
		BranchLabel currentLabel = labels[i];
		if (currentLabel.position == gotoLocation) {
			if (currentLabel.isStandardLabel()) {
				hasStandardLabel = true;
				if (currentLabel.forwardReferenceCount == 0 && ((currentLabel.tagBits & BranchLabel.USED) != 0)) {
					removeFrame = false;
				}
			} else if (currentLabel.isCaseLabel()) {
				removeFrame = false;
			}
		} else {
			break; // same target labels should be contiguous
		}
	}
	if (hasStandardLabel) {
		for (int i = this.countLabels - 1; i >= 0; i--) {
			BranchLabel currentLabel = labels[i];
			if ((currentLabel.position == gotoLocation) && currentLabel.isStandardLabel()){
				label.appendForwardReferencesFrom(currentLabel);
				// we should remove the frame corresponding to otherLabel position in order to prevent unused stack frame
				if (removeFrame) {
					currentLabel.tagBits &= ~BranchLabel.USED;
					this.removeStackFrameFor(gotoLocation);
				}
				/*
				 Code required to optimized unreachable gotos.
					label.position = POS_NOT_SET;
				*/
			} else {
				break; // same target labels should be contiguous
			}
		}
	}
}

