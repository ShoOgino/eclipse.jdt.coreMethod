public boolean inlineForwardReferencesFromLabelsTargeting(BranchLabel targetLabel, int gotoLocation) {
	if (targetLabel.delegate != null) return false; // already inlined
	int chaining = L_UNKNOWN;

	boolean removeFrame = true;
	for (int i = this.countLabels - 1; i >= 0; i--) {
		BranchLabel currentLabel = labels[i];
		if (currentLabel.position != gotoLocation) break;
		if (currentLabel == targetLabel) {
			chaining |= L_CANNOT_OPTIMIZE;
			continue;
		}
		if (currentLabel.isStandardLabel()) {
			if (currentLabel.delegate != null) continue;			
			chaining |= L_OPTIMIZABLE;
			if (currentLabel.forwardReferenceCount() == 0 && ((currentLabel.tagBits & BranchLabel.USED) != 0)) {
				removeFrame = false;
			}
			continue;
		}
		// case label
		removeFrame = false;
		chaining |= L_CANNOT_OPTIMIZE;
	}
	if ((chaining & L_OPTIMIZABLE) != 0) {
		for (int i = this.countLabels - 1; i >= 0; i--) {
			BranchLabel currentLabel = labels[i];
			if (currentLabel.position != gotoLocation) break;
			if (currentLabel == targetLabel) continue;
			if (currentLabel.isStandardLabel()) {
				if (currentLabel.delegate != null) continue;
				targetLabel.becomeDelegateFor(currentLabel);
				// we should remove the frame corresponding to otherLabel position in order to prevent unused stack frame
				if (removeFrame) {
					currentLabel.tagBits &= ~BranchLabel.USED;
					this.removeStackFrameFor(gotoLocation);
				}
			}
		}
	}
	return (chaining & (L_OPTIMIZABLE|L_CANNOT_OPTIMIZE)) == L_OPTIMIZABLE; // check was some standards, and no case/recursive	
}

