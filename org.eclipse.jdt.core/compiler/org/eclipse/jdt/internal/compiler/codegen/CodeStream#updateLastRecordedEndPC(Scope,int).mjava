/**
 * Note: it will walk the locals table and extend the end range for all matching ones, no matter if
 * visible or not.
 * {  int i = 0;
 *    {  int j = 1; }
 * }   <== would process both 'i' and 'j'
 * Processing non-visible ones is mandated in some cases (include goto instruction after if-then block)
 */
public void updateLastRecordedEndPC(Scope scope, int pos) {

	/* Tune positions in the table, this is due to some 
	 * extra bytecodes being
	 * added to some user code (jumps). */
	/** OLD CODE
		if (!generateLineNumberAttributes)
			return;
		pcToSourceMap[pcToSourceMapSize - 1][1] = position;
		// need to update the initialization endPC in case of generation of local variable attributes.
		updateLocalVariablesAttribute(pos);	
	*/	

	if ((this.generateAttributes & ClassFileConstants.ATTR_LINES) != 0) {
		this.lastEntryPC = pos;
	}
	// need to update the initialization endPC in case of generation of local variable attributes.
	if (((this.generateAttributes & ClassFileConstants.ATTR_VARS) != 0)
			|| ((this.generateAttributes & ClassFileConstants.ATTR_STACK_MAP) != 0)) {
		for (int i = 0, max = this.locals.length; i < max; i++) {
			LocalVariableBinding local = this.locals[i];
			if (local != null && local.declaringScope == scope && local.initializationCount > 0) {
				if (local.initializationPCs[((local.initializationCount - 1) << 1) + 1] == pos) {
					local.initializationPCs[((local.initializationCount - 1) << 1) + 1] = this.position;
				}
			}
		}
	}
}

