/**
 * This method returns the index into the constantPool corresponding to the 
 * method descriptor. It can be either an interface method reference constant
 * or a method reference constant.
 * Note: uses the method binding #constantPoolDeclaringClass which could be an array type
 * for the array clone method (see UpdatedMethodDeclaration).
 * @param aMethodBinding MethodBinding
 * @return <CODE>int</CODE>
 */
public int literalIndex(MethodBinding aMethodBinding) {
	int index;
	final TypeBinding constantPoolDeclaringClass = aMethodBinding.constantPoolDeclaringClass();
	final char[] declaringClassConstantPoolName = constantPoolDeclaringClass.constantPoolName();
	final char[] selector = aMethodBinding.selector;
	final char[] signature = aMethodBinding.signature();
	if ((index = getFromCache(declaringClassConstantPoolName, selector, signature)) < 0) {
		int classIndex = literalIndexForType(constantPoolDeclaringClass.constantPoolName());
		int nameAndTypeIndex = literalIndexForMethods(literalIndex(selector), literalIndex(signature), selector, signature);
		index = putInCache(declaringClassConstantPoolName, selector, signature, currentIndex++);
		if (index > 0xFFFF){
			this.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceInConstantPool(this.classFile.referenceBinding.scope.referenceType());
		}
		// Write the interface method ref constant into the constant pool
		// First add the tag
		writeU1(constantPoolDeclaringClass.isInterface() || constantPoolDeclaringClass.isAnnotationType() ? InterfaceMethodRefTag : MethodRefTag);
		// Then write the class index
		writeU2(classIndex);
		// The write the nameAndType index
		writeU2(nameAndTypeIndex);
	}
	return index;
}

