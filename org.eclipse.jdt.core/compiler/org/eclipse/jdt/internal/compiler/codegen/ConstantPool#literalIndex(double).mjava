	/**
	 * This method returns the index into the constantPool corresponding to the double
	 * value. If the double is not already present into the pool, it is added. The 
	 * double cache is updated and it returns the right index.
	 *
	 * @param <CODE>double</CODE> key
	 * @return <CODE>int</CODE>
	 */
	public int literalIndex(double key) {
		//Retrieve the index from the cache
		// The double constant takes two indexes into the constant pool, but we only store
		// the first index into the long table
		int index;
		// lazy initialization for base type caches
		// If it is null, initialize it, otherwise use it
		if (doubleCache == null) {
			doubleCache = new DoubleCache(DOUBLE_INITIAL_SIZE);
		}
		if ((index = doubleCache.get(key)) < 0) {
			index = doubleCache.put(key, currentIndex++);
			currentIndex++; // a double needs an extra place into the constant pool
			// Write the double into the constant pool
			// First add the tag
			writeU1(DoubleTag);
			// Then add the 8 bytes representing the double
			long temp = java.lang.Double.doubleToLongBits(key);
			for (int i = 0; i < 8; i++) {
				try {
					poolContent[currentOffset++] = (byte) (temp >>> (56 - (i << 3)));
				} catch (IndexOutOfBoundsException e) { //currentOffset has been ++ already (see the -1)
					int length = poolContent.length;
					System.arraycopy(
						poolContent,
						0,
						(poolContent = new byte[(length << 1) + CONSTANTPOOL_INITIAL_SIZE]),
						0,
						length);
					poolContent[currentOffset - 1] = (byte) (temp >>> (56 - (i << 3)));
				}
			}
		};
		return index;
	}

