/**
 * This method returns the index into the constantPool corresponding to the double
 * value. If the double is not already present into the pool, it is added. The 
 * double cache is updated and it returns the right index.
 *
 * @param key <CODE>double</CODE>
 * @return <CODE>int</CODE>
 */
public int literalIndex(double key) {
	//Retrieve the index from the cache
	// The double constant takes two indexes into the constant pool, but we only store
	// the first index into the long table
	int index;
	// lazy initialization for base type caches
	// If it is null, initialize it, otherwise use it
	if (doubleCache == null) {
			doubleCache = new DoubleCache(DOUBLE_INITIAL_SIZE);
	}
	if ((index = doubleCache.putIfAbsent(key, this.currentIndex)) < 0) {
		if ((index = -index)> 0xFFFF){
			this.classFile.referenceBinding.scope.problemReporter().noMoreAvailableSpaceInConstantPool(this.classFile.referenceBinding.scope.referenceType());
		}
		this.currentIndex += 2; // a double needs an extra place into the constant pool
		// Write the double into the constant pool
		// First add the tag
		writeU1(DoubleTag);
		// Then add the 8 bytes representing the double
		long temp = java.lang.Double.doubleToLongBits(key);
		int length = poolContent.length;
		if (currentOffset + 8 >= length) {
			resizePoolContents(8);
		}
		poolContent[currentOffset++] = (byte) (temp >>> 56);
		poolContent[currentOffset++] = (byte) (temp >>> 48);
		poolContent[currentOffset++] = (byte) (temp >>> 40);
		poolContent[currentOffset++] = (byte) (temp >>> 32);
		poolContent[currentOffset++] = (byte) (temp >>> 24);
		poolContent[currentOffset++] = (byte) (temp >>> 16);
		poolContent[currentOffset++] = (byte) (temp >>> 8);
		poolContent[currentOffset++] = (byte) temp;
	}
	return index;
}

