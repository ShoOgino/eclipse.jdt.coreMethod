	/*
	 * INTERNAL USE-ONLY
	 * Innerclasses get their name computed as they are generated, since some may not
	 * be actually outputed if sitting inside unreachable code.
	 *
	 * @param localType org.eclipse.jdt.internal.compiler.lookup.LocalTypeBinding
	 */
	public char[] computeConstantPoolName(LocalTypeBinding localType) {
		if (localType.constantPoolName() != null) {
			return localType.constantPoolName();
		}

		// delegates to the outermost enclosing classfile, since it is the only one with a global vision of its innertypes.
		if (enclosingClassFile != null) {
			return this.outerMostEnclosingClassFile().computeConstantPoolName(localType);
		}

		if (nameUsage == null) {
			nameUsage = new CharArrayCache();
		}
		if (localType.isMemberType()) { // catches member types of local types
			return CharOperation.concat(
				localType.enclosingType().constantPoolName(),
				localType.sourceName,
				'$');
		} else {
			char[][] compoundName = (char[][]) referenceBinding.compoundName.clone();
			int last = compoundName.length - 1;
			StringBuffer nameBuffer = new StringBuffer().append(compoundName[last]);
			// retrieve the number of use of the combination
			char[] simpleName = localType.sourceName;
			//if (simpleName == null) simpleName = new char[]{}; // for anonymous
			int nameCount = nameUsage.get(simpleName); // -1 if not found
			nameCount = nameCount == -1 ? 1 : nameCount + 1;
			nameBuffer.append('$').append(nameCount);
			nameUsage.put(simpleName, nameCount);
			if (!localType.isAnonymousType()) { // named local type
				nameBuffer.append('$').append(simpleName);
			}
			compoundName[last] = nameBuffer.toString().toCharArray();
			return CharOperation.concatWith(compoundName, '/');
		}
	}

