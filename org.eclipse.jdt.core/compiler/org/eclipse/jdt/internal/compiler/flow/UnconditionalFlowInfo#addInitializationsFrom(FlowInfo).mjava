public FlowInfo addInitializationsFrom(FlowInfo inits) {
	if (this == DEAD_END)
		return this;
	if (inits == DEAD_END)
		return this;
	UnconditionalFlowInfo otherInits = inits.unconditionalInits();		

	// union of definitely assigned variables, 
	this.definiteInits |= otherInits.definiteInits;
	// union of potentially set ones
	this.potentialInits |= otherInits.potentialInits;
	// combine null information
	// note: we may have both forms of protection (null and non null) 
	// coming with otherInits, because of loops
	boolean considerNulls = (otherInits.tagBits & NULL_FLAG_MASK) != 0;
	long a1, na1, a2, na2, a3, a4, na4, b1, b2, nb2, b3, nb3, b4, nb4;
	// REVIEW does an inner declaration save stack space? does duplicate declaration waste time?
	if (considerNulls) {
		if ((this.tagBits & NULL_FLAG_MASK) == 0) {
			this.nullAssignmentStatusBit1 = otherInits.nullAssignmentStatusBit1;
			this.nullAssignmentStatusBit2 = otherInits.nullAssignmentStatusBit2;
			this.nullAssignmentValueBit1 = otherInits.nullAssignmentValueBit1;
			this.nullAssignmentValueBit2 = otherInits.nullAssignmentValueBit2;
			if (coverageTestFlag && coverageTestId == 1) {
				this.nullAssignmentValueBit2 = ~0;
			}
		}
		else {
		// TODO (maxime) indent as follows: 
			/*
			 *   a 
			 *   	| (b
			 *   		& c)
			 *   
			 */
			// REVIEW indentation example
			this.nullAssignmentStatusBit1 =
				(b1 = otherInits.nullAssignmentStatusBit1) 
					| ((a1 = this.nullAssignmentStatusBit1) 
						& (((nb2 = ~(b2 = otherInits.nullAssignmentStatusBit2)) 
								& (nb3 = ~(b3 = otherInits.nullAssignmentValueBit1)) 
								& ((nb4 = ~(b4 = otherInits.nullAssignmentValueBit2)) 
									| ((a2 = this.nullAssignmentStatusBit2) 
										^ (a4 = this.nullAssignmentValueBit2)))) 
							| nb4 &	(na2 = ~a2)	& (na4 = ~a4)));
			this.nullAssignmentStatusBit2 =
				(b1 & b2) 
					| (~b1 
						& ((((na1 = ~a1) | a4) & b2) 
							| (a2 
								& (b2 
									| (a1 & (na4 = ~a4) & nb2 & nb3) 
									| ((~(a3 = this.nullAssignmentValueBit1) & nb3) 
											| (na1 & na4)) 
										& nb4))));
			this.nullAssignmentValueBit1 = 
				nb2 & b3 |
				~b1 & ((a1 & na2 & na4 | na1 & a3) & (nb2 | nb4) |
						a1 & na2 & a3 & nb2 |
						(a1 | a2 | na4) & b3);
			this.nullAssignmentValueBit2 =
				b4 |
				a4 & (nb2 & nb3 | ~(b1 ^ b2));
			if (coverageTestFlag && coverageTestId == 2) {
				this.nullAssignmentValueBit2 = ~0;
			}
		}
		this.tagBits |= NULL_FLAG_MASK; // in all cases - avoid forgetting extras
	}
	// treating extra storage
	if (this.extra != null || otherInits.extra != null) {
		int mergeLimit = 0, copyLimit = 0;
		if (this.extra != null) {
			if (otherInits.extra != null) {
				// both sides have extra storage
				int length, otherLength;
				if ((length = this.extra[0].length) < 
						(otherLength = otherInits.extra[0].length)) {
					if (coverageTestFlag && coverageTestId == 3) {
						throw new AssertionFailedException("COVERAGE 3"); //$NON-NLS-1$
					}
					// current storage is shorter -> grow current
					for (int j = 0; j < extraLength; j++) {
						System.arraycopy(this.extra[j], 0, 
							(this.extra[j] = new long[otherLength]), 0, length);
					}
					mergeLimit = length;
					copyLimit = otherLength;
				} else {
					if (coverageTestFlag && coverageTestId == 4) {
						throw new AssertionFailedException("COVERAGE 4"); //$NON-NLS-1$
					}
					// current storage is longer
					mergeLimit = otherLength;
				}
			} 
		} 
		else if (otherInits.extra != null) {
			// no storage here, but other has extra storage.
			// shortcut regular copy because array copy is better
			int otherLength;
			this.extra = new long[extraLength][];
			System.arraycopy(otherInits.extra[0], 0, 
				(this.extra[0] = new long[otherLength = 
					otherInits.extra[0].length]), 0, otherLength);			
			System.arraycopy(otherInits.extra[1], 0, 
				(this.extra[1] = new long[otherLength]), 0, otherLength);
			if (considerNulls) {
				for (int j = 2; j < extraLength; j++) {
					System.arraycopy(otherInits.extra[j], 0, 
						(this.extra[j] = new long[otherLength]), 0, otherLength);
				}
				if (coverageTestFlag && coverageTestId == 5) {
					this.extra[5][otherLength - 1] = ~0;
				}
			}
			else {
				for (int j = 2; j < extraLength; j++) {
					this.extra[j] = new long[otherLength];			
				}
				if (coverageTestFlag && coverageTestId == 6) {
					this.extra[5][otherLength - 1] = ~0;
				}
			}
		}
		int i = 0;
		for (; i < mergeLimit; i++) {
			this.extra[0][i] |= otherInits.extra[0][i];
			this.extra[1][i] |= otherInits.extra[1][i];
			if (considerNulls) { // could consider pushing the test outside the loop
				if (this.extra[2][i] == 0 &&
						this.extra[3][i] == 0 &&
						this.extra[4][i] == 0 &&
						this.extra[5][i] == 0) {
					for (int j = 2; j < extraLength; j++) {
						this.extra[j][i] = otherInits.extra[j][i];
					}
					if (coverageTestFlag && coverageTestId == 7) {
						this.extra[5][i] = ~0;
					}
				}
				else {
					this.extra[2][i] =
						(b1 = otherInits.extra[2][i]) |
						(a1	 = this.extra[2][i]) & 
							((nb2 = ~(b2 = otherInits.extra[3][i])) &
								(nb3 = ~(b3 = otherInits.extra[4][i])) &
								((nb4 = ~(b4 = otherInits.extra[5][i])) |
									((a2 = this.extra[3][i]) ^ 
										(a4 = this.extra[5][i]))) | 
							nb4 & (na2 = ~a2) & (na4 = ~a4));
					this.extra[3][i] =
						b1 & b2 |
						~b1 & (((na1 = ~a1) | a4) & b2 |
								a2 & (b2 |
									a1 & (na4 = ~a4) & nb2 & nb3 |
									(~(a3 = this.extra[4][i]) & nb3 | na1 & na4) & nb4));
					this.extra[4][i] = 
						nb2 & b3 |
						~b1 & ((a1 & na2 & na4 | na1 & a3) & (nb2 | nb4) |
								a1 & na2 & a3 & nb2 |
								(a1 | a2 | na4) & b3);
					this.extra[5][i] =
						b4 |
						a4 & (nb2 & nb3 | ~(b1 ^ b2));
						if (coverageTestFlag && coverageTestId == 8) {
							this.extra[5][i] = ~0;
						}
				}
			}
		}
		for (; i < copyLimit; i++) {
			this.extra[0][i] = otherInits.extra[0][i];
			this.extra[1][i] = otherInits.extra[1][i];
			if (considerNulls) {
				for (int j = 2; j < extraLength; j++) {
					this.extra[j][i] = otherInits.extra[j][i];
				}
				if (coverageTestFlag && coverageTestId == 9) {
					this.extra[5][i] = ~0;
				}
			}
		}
	}
	return this;
}

