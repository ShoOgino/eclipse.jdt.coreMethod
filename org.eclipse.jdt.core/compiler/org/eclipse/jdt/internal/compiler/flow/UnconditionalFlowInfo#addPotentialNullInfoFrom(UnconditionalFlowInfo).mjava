/**
 * Compose other inits over this flow info, then return this. The operation
 * semantics are to wave into this flow info the consequences upon null 
 * information of a possible path into the operations that resulted into 
 * otherInits. The fact that this path may be left unexecuted under peculiar 
 * conditions results into less specific results than 
 * {@link #addInitializationsFrom(FlowInfo) addInitializationsFrom}; moreover,
 * only the null information is affected.
 * @param otherInits other null inits to compose over this
 * @return this, modified according to otherInits information
 */
public UnconditionalFlowInfo addPotentialNullInfoFrom(
		UnconditionalFlowInfo otherInits) {
	if ((this.tagBits & UNREACHABLE) != 0 ||
			(otherInits.tagBits & UNREACHABLE) != 0 ||
			(otherInits.tagBits & NULL_FLAG_MASK) == 0) {
		return this;
	}
	// if we get here, otherInits has some null info
	boolean thisHasNulls = (this.tagBits & NULL_FLAG_MASK) != 0;
	if (thisHasNulls) {
		long a1, a2, na2, a3, na3, a4, na4, b1, nb1, b2, nb2, b3, nb3, b4, nb4;
		this.nullAssignmentStatusBit1 =
			((a1 = this.nullAssignmentStatusBit1) &
					(na4 = ~(a4 = this.nullAssignmentValueBit2)) &	
					((na3 = ~(a3 = this.nullAssignmentValueBit1)) | 
							(a2 = this.nullAssignmentStatusBit2)) | 
							a2 & na3 &	a4) & 
					(nb3 = ~(b3 = otherInits.nullAssignmentValueBit1)) &
					((b2 = otherInits.nullAssignmentStatusBit2) | 
					(nb4 = ~(b4 = otherInits.nullAssignmentValueBit2))) |
			a1 & (na2 = ~a2) & 
				(a4 & ((nb1 = ~(b1 = otherInits.nullAssignmentStatusBit1)) & 
						nb3 | b1 &
						(b4 | b2)) |
				na4 & (nb1 & (((nb2 = ~b2) & nb4 | b2) & nb3 | b3 & nb4) | 
						b1 & nb4 & (nb2 | nb3)));
		this.nullAssignmentStatusBit2 =
			a2 & (~a1 & na4 & nb4 |
					a1 & na3 & nb3 & (nb1 & (nb2 & nb4 | b2) |
										b1 & (nb4 |b2 & b4)));
		this.nullAssignmentValueBit1 =
			a3 |
			b1 & nb2 & nb4 |
			nb1 & b3 |
			a1 & na2 & (b1 & b3 | nb1 & b4);
//			b1 & (~b2 & ~b4 | a1 & ~a2 & b3) |
//			~b1 & (b3 | a1 & ~a2 & b4); -- same op nb
		this.nullAssignmentValueBit2 =
			a4 & (na2 | a2 & na3) |
			b4 & (nb2 | b2 & nb3);
		if (coverageTestFlag && coverageTestId == 15) {
			this.nullAssignmentValueBit2 = ~0;
		}
		// extra storage management
		if (otherInits.extra != null) {
			int mergeLimit = 0, copyLimit = 0;
			int otherLength = otherInits.extra[0].length;
			if (this.extra == null) {
				this.extra = new long[extraLength][];
				for (int j = 0; j < extraLength; j++) {
					this.extra[j] = new long[otherLength];
				}
				copyLimit = otherLength;
				if (coverageTestFlag && coverageTestId == 16) {
					this.extra[2][0] = ~0; thisHasNulls = true;
				}
			}
			else {
				mergeLimit = otherLength;
				if (mergeLimit > this.extra[0].length) {
					copyLimit = mergeLimit;
					mergeLimit = this.extra[0].length;
					for (int j = 0; j < extraLength; j++) {
						System.arraycopy(this.extra[j], 0,
								this.extra[j] = new long[otherLength], 0,
								mergeLimit);
					}
				}
				int i;
				for (i = 0; i < mergeLimit; i++) {
					this.extra[2][i] =
						((a1 = this.extra[2][i]) &
								(na4 = ~(a4 = this.extra[5][i])) &	
								((na3 = ~(a3 = this.extra[4][i])) | 
										(a2 = this.extra[3][i])) | 
										a2 & na3 &	a4) & 
								(nb3 = ~(b3 = otherInits.extra[4][i])) &
								((b2 = otherInits.extra[3][i]) | 
								(nb4 = ~(b4 = otherInits.extra[5][i]))) |
						a1 & (na2 = ~a2) & 
							(a4 & ((nb1 = ~(b1 = otherInits.extra[2][i])) & 
									nb3 | b1 &
									(b4 | b2)) |
							na4 & (nb1 & (((nb2 = ~b2) & nb4 | b2) & nb3 | b3 & nb4) | 
									b1 & nb4 & (nb2 | nb3)));
					this.extra[3][i] =
						a2 & (~a1 & na4 & nb4 |
								a1 & na3 & nb3 & (nb1 & (nb2 & nb4 | b2) |
													b1 & (nb4 |b2 & b4)));
					this.extra[4][i] =
						a3 |
						b1 & nb2 & nb4 |
						nb1 & b3 |
						a1 & na2 & (b1 & b3 | nb1 & b4);
					this.extra[5][i] =
						a4 & (na2 | a2 & na3) |
						b4 & (nb2 | b2 & nb3);
					if (coverageTestFlag && coverageTestId == 17) {
						this.nullAssignmentValueBit2 = ~0;
					}
				}
				for (; i < copyLimit; i++) {
					if (otherInits.extra[4][i] != 0 ||
						otherInits.extra[5][i] != 0) {
						this.tagBits |= NULL_FLAG_MASK; 
						this.extra[4][i] = 
							otherInits.extra[4][i] &
							~(otherInits.extra[2][i] &
							  ~otherInits.extra[3][i] &
							  otherInits.extra[5][i]);
						this.extra[5][i] = 
							otherInits.extra[5][i];
						if (coverageTestFlag && coverageTestId == 18) {
							this.extra[5][i] = ~0;
						}
					}
				}
			}
		}
	}
	else {
		if (otherInits.nullAssignmentValueBit1 != 0 ||
			otherInits.nullAssignmentValueBit2 != 0) {
			// add potential values
			this.nullAssignmentValueBit1 = 
				otherInits.nullAssignmentValueBit1 & 
					~(otherInits.nullAssignmentStatusBit1 &
					  ~otherInits.nullAssignmentStatusBit2 &
					  otherInits.nullAssignmentValueBit2); // exclude assigned unknown
			this.nullAssignmentValueBit2 = 
				otherInits.nullAssignmentValueBit2;
			thisHasNulls = 
				this.nullAssignmentValueBit1 != 0 ||
				this.nullAssignmentValueBit2 != 0;
			if (coverageTestFlag && coverageTestId == 10) {
				this.nullAssignmentValueBit2 = ~0;
			}
		}
		// extra storage management
		if (otherInits.extra != null) {
			int mergeLimit = 0, copyLimit = 0;
			int otherLength = otherInits.extra[0].length;
			if (this.extra == null) {
				copyLimit = otherLength; 
					// cannot happen when called from addPotentialInitializationsFrom
				this.extra = new long[extraLength][];
				for (int j = 0; j < extraLength; j++) {
					this.extra[j] = new long[otherLength];
				}
				if (coverageTestFlag && coverageTestId == 11) {
					this.extra[5][0] = ~0; this.tagBits |= NULL_FLAG_MASK;
				}
			}
			else {
				mergeLimit = otherLength;
				if (mergeLimit > this.extra[0].length) {
					copyLimit = mergeLimit;
					mergeLimit = this.extra[0].length;
					System.arraycopy(this.extra[0], 0,
							this.extra[0] = new long[otherLength], 0,
							mergeLimit);
					System.arraycopy(this.extra[1], 0,
							this.extra[1] = new long[otherLength], 0,
							mergeLimit);
					for (int j = 2; j < extraLength; j++) {
						this.extra[j] = new long[otherLength];
					}
					if (coverageTestFlag && coverageTestId == 12) {
						throw new AssertionFailedException("COVERAGE 12"); //$NON-NLS-1$
					}
				}
			}
			int i;
			for (i = 0; i < mergeLimit; i++) {
				if (otherInits.extra[4][i] != 0 ||
					otherInits.extra[5][i] != 0) {
					this.extra[4][i] |= 
						otherInits.extra[4][i] &
						~(otherInits.extra[2][i] &
						  ~otherInits.extra[3][i] &
						  otherInits.extra[5][i]);
					this.extra[5][i] |= 
						otherInits.extra[5][i];
					thisHasNulls = thisHasNulls ||
						this.extra[4][i] != 0 ||
						this.extra[5][i] != 0;
					if (coverageTestFlag && coverageTestId == 13) {
						this.extra[5][i] = ~0;
					}
				}
			}
			for (; i < copyLimit; i++) {
				if (otherInits.extra[4][i] != 0 ||
					otherInits.extra[5][i] != 0) {
					this.extra[4][i] = 
						otherInits.extra[4][i] &
						~(otherInits.extra[2][i] &
						  ~otherInits.extra[3][i] &
						  otherInits.extra[5][i]);
					this.extra[5][i] = 
						otherInits.extra[5][i];
					thisHasNulls = thisHasNulls ||
						this.extra[4][i] != 0 ||
						this.extra[5][i] != 0;
					if (coverageTestFlag && coverageTestId == 14) {
						this.extra[5][i] = ~0;
					}
				}
			}
		}
	}
	if (thisHasNulls) {
		this.tagBits |= NULL_FLAG_MASK; 
	}
	else {
		this.tagBits &= NULL_FLAG_MASK; 
	}
	return this;
}

