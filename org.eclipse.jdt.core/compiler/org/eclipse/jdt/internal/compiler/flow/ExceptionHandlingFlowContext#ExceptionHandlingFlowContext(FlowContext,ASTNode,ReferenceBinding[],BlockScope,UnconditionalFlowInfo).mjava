public ExceptionHandlingFlowContext(
		FlowContext parent,
		ASTNode associatedNode,
		ReferenceBinding[] handledExceptions,
		BlockScope scope,
		UnconditionalFlowInfo flowInfo) {

	super(parent, associatedNode);
	this.isMethodContext = scope == scope.methodScope();
	this.handledExceptions = handledExceptions;
	int count = handledExceptions.length, cacheSize = (count / ExceptionHandlingFlowContext.BitCacheSize) + 1;
	this.isReached = new int[cacheSize]; // none is reached by default
	this.isNeeded = new int[cacheSize]; // none is needed by default
	this.initsOnExceptions = new UnconditionalFlowInfo[count];
	boolean reachUnchecked = !scope.compilerOptions().
		reportUnusedDeclaredThrownExceptionIncludeUncheckedExceptions;
	for (int i = 0; i < count; i++) {
		this.indexes.put(handledExceptions[i], i); // key type  -> value index
		int cacheIndex = i / ExceptionHandlingFlowContext.BitCacheSize, bitMask = 1 << (i % ExceptionHandlingFlowContext.BitCacheSize);
		if (handledExceptions[i].isUncheckedException(true)) {
			if (reachUnchecked) {
				this.isReached[cacheIndex] |= bitMask;
			}
			this.initsOnExceptions[i] = flowInfo.unconditionalCopy();
		} else {
			this.initsOnExceptions[i] = FlowInfo.DEAD_END;
		}
	}
	System.arraycopy(this.isReached, 0, this.isNeeded, 0, cacheSize);
	this.initsOnReturn = FlowInfo.DEAD_END;	
}

