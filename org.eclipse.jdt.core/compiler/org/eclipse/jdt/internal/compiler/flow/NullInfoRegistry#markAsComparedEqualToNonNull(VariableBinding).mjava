public void markAsComparedEqualToNonNull(VariableBinding local) {
	// protected from non-object locals in calling methods
	if (this != DEAD_END) {
    	this.tagBits |= NULL_FLAG_MASK;
    	int position;
    	if (local instanceof FieldBinding && ((local.modifiers & AccConstant) == AccConstant)) {
	    	// non-final fields may be modified in separate threads and we cannot be sure about their
	    	// definite nullness. Hence, marking as definitely unknown to avoid deferring null check for these fields.
	    	this.markAsDefinitelyUnknown(local);
	    	return;
    	} else {
    		position = local.getAnalysisId(this.maxFieldCount);
    	}
    	// position is zero-based
    	if (position < BitCacheSize) { // use bits
    		// set protected non null
    		this.nullBit1 |= (1L << position);
    		if (COVERAGE_TEST_FLAG) {
    			if (CoverageTestId == 290) {
	    		  	this.nullBit1 = 0;
    			}
    		}
    	}
    	else {
    		// use extra vector
			int vectorIndex = (position / BitCacheSize) - 1;
			if (this.extra == null) {
				int length = vectorIndex + 1;
				this.extra = new long[extraLength][];
				for (int j = 2; j < extraLength; j++) {
					this.extra[j] = new long[length];
				}
			}
			else {
				int oldLength; // might need to grow the arrays
				if (vectorIndex >= (oldLength = this.extra[2].length)) {
					for (int j = 2; j < extraLength; j++) {
						System.arraycopy(this.extra[j], 0,
							(this.extra[j] = new long[vectorIndex + 1]), 0,
							oldLength);
					}
				}
			}
    		this.extra[2][vectorIndex] |= (1L << (position % BitCacheSize));
    		if (COVERAGE_TEST_FLAG) {
    			if (CoverageTestId == 300) {
		   		  	this.extra[5][vectorIndex] = ~0;
    			}
    		}
    	}
	}
}

