/**
 * Perform deferred checks relative to the null status of local variables.
 * @param scope the scope to which this context is associated
 * @param flowInfo the flow info against which checks must be performed
 */
public void complainOnDeferredNullChecks(BlockScope scope, FlowInfo flowInfo) {
	for (int i = 0 ; i < this.innerFlowContextsNb ; i++) {
		this.upstreamNullFlowInfo.
			addPotentialNullInfoFrom(
				this.innerFlowContexts[i].upstreamNullFlowInfo).
			addPotentialNullInfoFrom(this.innerFlowInfos[i]);
	}
	this.innerFlowContextsNb = 0;
	flowInfo = this.upstreamNullFlowInfo.
		addPotentialNullInfoFrom(
			flowInfo.unconditionalInitsWithoutSideEffect());
	if (this.deferNullDiagnostic) {
		// check only immutable null checks on innermost looping context
		for (int i = 0; i < this.nullCount; i++) {
			LocalVariableBinding local = this.nullLocals[i];
			Expression expression = this.nullReferences[i];
			// final local variable
			switch (this.nullCheckTypes[i]) {
				case CAN_ONLY_NON_NULL :
					if (flowInfo.isDefinitelyNonNull(local)) {
						this.nullReferences[i] = null;
						scope.problemReporter().localVariableCannotBeNull(local, expression);
						continue;
					}
					break;
				case CAN_ONLY_NULL_NON_NULL :
					if (flowInfo.isDefinitelyNonNull(local)) {
						this.nullReferences[i] = null;
						scope.problemReporter().localVariableCannotBeNull(local, expression);
						continue;
					}
					if (flowInfo.isDefinitelyNull(local)) {
						this.nullReferences[i] = null;
						scope.problemReporter().localVariableCanOnlyBeNull(local, expression);
						continue;
					}
					break;
				case CAN_ONLY_NULL :
					if (flowInfo.isDefinitelyNull(local)) {
						this.nullReferences[i] = null;
						scope.problemReporter().localVariableCanOnlyBeNull(local, expression);
						continue;
					}
					break;
				case MAY_NULL:
					if (flowInfo.isDefinitelyNull(local)) {
						this.nullReferences[i] = null;
						scope.problemReporter().localVariableCanOnlyBeNull(local, expression);
						continue;
					}
					break;
				default:
					// never happens	
			}
			this.parent.recordUsingNullReference(scope, local, expression, 
					this.nullCheckTypes[i], flowInfo);
		}
	}
	else {
		// check inconsistent null checks on outermost looping context
		for (int i = 0; i < this.nullCount; i++) {
			Expression expression = this.nullReferences[i];
			// final local variable
			LocalVariableBinding local = this.nullLocals[i];
			switch (this.nullCheckTypes[i]) {
				case CAN_ONLY_NULL_NON_NULL :
					if (flowInfo.isDefinitelyNonNull(local)) {
						this.nullReferences[i] = null;
						scope.problemReporter().localVariableCannotBeNull(local, expression);
						continue;
					}
				case CAN_ONLY_NULL :
					if (flowInfo.isDefinitelyNull(local)) {
						this.nullReferences[i] = null;
						scope.problemReporter().localVariableCanOnlyBeNull(local, expression);
						continue;
					}
					break;
				case MAY_NULL:
					if (flowInfo.isDefinitelyNull(local)) {
						this.nullReferences[i] = null;
						scope.problemReporter().localVariableCanOnlyBeNull(local, expression);
						continue;
					}
					if (flowInfo.isPotentiallyNull(local)) {
						this.nullReferences[i] = null;
						scope.problemReporter().localVariableMayBeNull(local, expression);
						continue;
					}
					break;
				default:
					// never happens	
			}
		}
	}
}

