	/* 
	"	- SMARTER VERSION -
	| unhandledExceptionTypes nameEnv traversedContext |
	
	someExceptionTypes isEmpty ifTrue: [^self].
	
	unhandledExceptionTypes := someExceptionTypes asOrderedCollection.
	nameEnv := scope enclosingMethod nameEnvironment.
	
	traversedContext := self.
	[traversedContext isNil] whileFalse: [| caughtExceptions sub |
	
	((sub := traversedContext subRoutine) notNil and: [sub cannotReturn])
	ifTrue: [
	" "Traversing a non-returning subroutine means that all unhandled exceptions will actually
	never get sent..." "
	^self].
	" "Filter exceptions that are locally caught from the most enclosing try statement to the outer ones." "
	(caughtExceptions := traversedContext handledExceptions) isNil
	ifFalse: [
	caughtExceptions do: [:handledExceptionAssoc | | handledException |
	handledException := handledExceptionAssoc key.
	unhandledExceptionTypes copy do: [:raisedException | | safe |
	" "Any exception recognized as being caught is removed from the exceptions list" "
	((safe := raisedException isCompatibleWith: handledException in: nameEnv)
	or: [handledException isCompatibleWith: raisedException in: nameEnv])
	ifTrue: [
	traversedContext
	recordInitializationInfo: initInfo
	onException: handledException.
	handledExceptionAssoc value: true.
	safe ifTrue: [unhandledExceptionTypes remove: raisedException]]]]].
	unhandledExceptionTypes isEmpty ifTrue: [^self].
	traversedContext := traversedContext parent].
	
	scope enclosingMethod errorInterface
	unexpectedExceptionsError: unhandledExceptionTypes
	from: invocationSite
	
	*/
	public void checkExceptionHandlers(
		TypeBinding raisedException,
		AstNode location,
		FlowInfo flowInfo,
		BlockScope scope) {

		// LIGHT-VERSION OF THE EQUIVALENT WITH AN ARRAY OF EXCEPTIONS

		// check that all the argument exception types are handled
		// JDK Compatible implementation - when an exception type is thrown, 
		// all related catch blocks are marked as reachable... instead of those only
		// until the point where it is safely handled (Smarter - see comment at the end)

		FlowContext traversedContext = this;
		while (traversedContext != null) {
			AstNode sub;
			if (((sub = traversedContext.subRoutine()) != null) && sub.cannotReturn()) {
				// traversing a non-returning subroutine means that all unhandled 
				// exceptions will actually never get sent...
				return;
			}

			// filter exceptions that are locally caught from the most enclosing 
			// try statement to the outer ones.
			if (traversedContext instanceof ExceptionHandlingFlowContext) {
				ExceptionHandlingFlowContext exceptionContext =
					(ExceptionHandlingFlowContext) traversedContext;
				ReferenceBinding[] caughtExceptions;
				if ((caughtExceptions = exceptionContext.handledExceptions) != NoExceptions) {
					boolean definitelyCaught = false;
					for (int caughtIndex = 0, caughtCount = caughtExceptions.length;
						caughtIndex < caughtCount;
						caughtIndex++) {
						ReferenceBinding caughtException = caughtExceptions[caughtIndex];
						switch (scope.compareTypes(raisedException, caughtException)) {
							case EqualOrMoreSpecific :
								exceptionContext.recordHandlingException(
									caughtException,
									flowInfo.unconditionalInits(),
									raisedException,
									location,
									definitelyCaught);
								// was it already definitely caught ?
								definitelyCaught = true;
								break;
							case MoreGeneric :
								exceptionContext.recordHandlingException(
									caughtException,
									flowInfo.unconditionalInits(),
									raisedException,
									location,
									false);
								// was not caught already per construction
						}
					}
					if (definitelyCaught)
						return;
				}
				// method treatment for unchecked exceptions
				if (exceptionContext.isMethodContext) {
					if (scope
						.areTypesCompatible(raisedException, scope.getJavaLangRuntimeException())
						|| scope.areTypesCompatible(raisedException, scope.getJavaLangError()))
						return;
					break; // not handled anywhere, thus jump to error handling
				}
			}
			traversedContext = traversedContext.parent;
		}

		// if reaches this point, then there are some remaining unhandled exception types.
		scope.problemReporter().unhandledException(raisedException, location, scope);
	}

