/**
 * Given some contextual initialization info (derived from a try block or a catch block), this 
 * code will check that the subroutine context does not also initialize a final variable potentially set
 * redundantly.
 */
public void complainOnDeferredChecks(FlowInfo flowInfo, BlockScope scope) {
	
	// check redundant final assignments
	for (int i = 0; i < this.assignCount; i++) {
		VariableBinding variable = this.finalVariables[i];
		if (variable == null) continue;
		
		boolean complained = false; // remember if have complained on this final assignment
		if (variable instanceof FieldBinding) {
			// final field
			if (flowInfo.isPotentiallyAssigned((FieldBinding)variable)) {
				complained = true;
				scope.problemReporter().duplicateInitializationOfBlankFinalField((FieldBinding)variable, finalAssignments[i]);
			}
		} else {
			// final local variable
			if (flowInfo.isPotentiallyAssigned((LocalVariableBinding) variable)) {
				complained = true;
				scope.problemReporter().duplicateInitializationOfFinalLocal(
					(LocalVariableBinding) variable,
					this.finalAssignments[i]);
			}
		}
		// any reference reported at this level is removed from the parent context 
		// where it could also be reported again
		if (complained) {
			FlowContext currentContext = this.parent;
			while (currentContext != null) {
				//if (currentContext.isSubRoutine()) {
				currentContext.removeFinalAssignmentIfAny(this.finalAssignments[i]);
				//}
				currentContext = currentContext.parent;
			}
		}
	}
	
	// check inconsistent null checks
	if (this.deferNullDiagnostic) { // within an enclosing loop, be conservative
		for (int i = 0; i < this.nullCount; i++) {
			Expression expression = this.nullReferences[i];
			LocalVariableBinding local = this.nullLocals[i];
			switch (this.nullCheckTypes[i]) {
				case CAN_ONLY_NULL_NON_NULL :
				case CAN_ONLY_NULL:
					if (flowInfo.isProtectedNonNull(local)) {
						if (nullCheckTypes[i] == CAN_ONLY_NULL_NON_NULL) {
							scope.problemReporter().localVariableCannotBeNull(local, expression);
						}
						return; // WORK wrong, test second variable!
					}
					if (flowInfo.isProtectedNull(local)) {
						scope.problemReporter().localVariableCanOnlyBeNull(local, expression);
						return;
					}
					break;
				case MAY_NULL :
					if (flowInfo.isProtectedNonNull(local)) {
						return;
					}
					if (flowInfo.isProtectedNull(local)) {
						scope.problemReporter().localVariableCanOnlyBeNull(local, expression);
						return;
					}
					break;
				default:
					// never happens
			}
			this.parent.recordUsingNullReference(scope, local, expression, 
					this.nullCheckTypes[i], flowInfo);
		}
	}
	else { // no enclosing loop, be as precise as possible right now
		for (int i = 0; i < this.nullCount; i++) {
			Expression expression = this.nullReferences[i];
			// final local variable
			LocalVariableBinding local = this.nullLocals[i];
			switch (this.nullCheckTypes[i]) {
				case CAN_ONLY_NULL_NON_NULL :
					if (flowInfo.isDefinitelyNonNull(local)) {
						scope.problemReporter().localVariableCannotBeNull(local, expression);				
						return;
					}
				case CAN_ONLY_NULL:
					if (flowInfo.isDefinitelyNull(local)) {
						scope.problemReporter().localVariableCanOnlyBeNull(local, expression);
						return;
					}
					break;
				case MAY_NULL :
					if (flowInfo.isDefinitelyNull(local)) {
						scope.problemReporter().localVariableCanOnlyBeNull(local, expression);
						return;
					}
					if (flowInfo.isPotentiallyNull(local)) {
						scope.problemReporter().localVariableMayBeNull(local, expression);
						return;
					}
					break;
				default:
					// should not happen
			}
		}
	}
}

