public UnconditionalFlowInfo mergedWith(UnconditionalFlowInfo otherInits) {
	if ((otherInits.tagBits & UNREACHABLE_OR_DEAD) != 0 && this != DEAD_END) {
		if (COVERAGE_TEST_FLAG) {
			if(CoverageTestId == 28) {
				throw new AssertionFailedException("COVERAGE 28"); //$NON-NLS-1$
			}
		}
		return this;
	}
	if ((this.tagBits & UNREACHABLE_OR_DEAD) != 0) {
		if (COVERAGE_TEST_FLAG) {
			if(CoverageTestId == 29) {
				throw new AssertionFailedException("COVERAGE 29"); //$NON-NLS-1$
			}
		}
		return (UnconditionalFlowInfo) otherInits.copy(); // make sure otherInits won't be affected
	}

	// intersection of definitely assigned variables,
	this.definiteInits &= otherInits.definiteInits;
	// union of potentially set ones
	this.potentialInits |= otherInits.potentialInits;

	// null combinations
	boolean
		thisHasNulls = (this.tagBits & NULL_FLAG_MASK) != 0,
		otherHasNulls = (otherInits.tagBits & NULL_FLAG_MASK) != 0,
		thisHadNulls = thisHasNulls;
	long
		a1, a2, a3, a4,
		na1, na2, na3, na4,
		nb1, nb2, nb3, nb4,
		b1, b2, b3, b4;
	if ((otherInits.tagBits & FlowInfo.UNREACHABLE_BY_NULLANALYSIS) != 0) {
		otherHasNulls = false; // skip merging, otherInits is unreachable by null analysis
	} else if ((this.tagBits & FlowInfo.UNREACHABLE_BY_NULLANALYSIS) != 0) { // directly copy if this is unreachable by null analysis
		this.nullBit1 = otherInits.nullBit1;
		this.nullBit2 = otherInits.nullBit2;
		this.nullBit3 = otherInits.nullBit3;
		this.nullBit4 = otherInits.nullBit4;
		thisHadNulls = false;
		thisHasNulls = otherHasNulls;
		this.tagBits = otherInits.tagBits;
	} else if (thisHadNulls) {
    	if (otherHasNulls) {
    		this.nullBit1 = (a2 = this.nullBit2) & (a3 = this.nullBit3)
    							& (a4 = this.nullBit4) & (b1 = otherInits.nullBit1)
    							& (nb2 = ~(b2 = otherInits.nullBit2))
                  			| (a1 = this.nullBit1) & (b1 & (a3 & a4 & (b3 = otherInits.nullBit3)
                  													& (b4 = otherInits.nullBit4)
                  												| (na2 = ~a2) & nb2
                  													& ((nb4 = ~b4) | (na4 = ~a4)
                  															| (na3 = ~a3) & (nb3 = ~b3))
                  												| a2 & b2 & ((na4 | na3) & (nb4	| nb3)))
                  											| na2 & b2 & b3 & b4);
    		this.nullBit2 = b2 & (nb3 | (nb1 = ~b1) | a3 & (a4 | (na1 = ~a1)) & nb4)
        			| a2 & (b2 | na4 & b3 & (b4 | nb1) | na3 | na1);
    		this.nullBit3 = b3 & (nb2 & b4 | nb1 | a3 & (na4 & nb4 | a4 & b4))
        			| a3 & (na2 & a4 | na1)
        			| (a2 | na1) & b1 & nb2 & nb4
        			| a1 & na2 & na4 & (b2 | nb1);
    		this.nullBit4 = na3 & (nb1 & nb3 & b4
              			| b1 & (nb2 & nb3 | a4 & b2 & nb4)
              			| na1 & a4 & (nb3 | b1 & b2))
        			| a3 & a4 & (b3 & b4 | b1 & nb2)
        			| na2 & (nb1 & b4 | b1 & nb3 | na1 & a4) & nb2
        			| a1 & (na3 & (nb3 & b4
                        			| b1 & b2 & b3 & nb4
                        			| na2 & (nb3 | nb2))
                			| na2 & b3 & b4
                			| a2 & (nb1 & b4 | a3 & na4 & b1) & nb3);
    		// the above formulae do not handle the state 0111, do it now explicitly:
    		long ax = ~a1 & a2 & a3 & a4;
    		long bx = ~b1 & b2 & b3 & b4;
    		long x = ax|bx;
    		if (x != 0) {
    			// restore state 0111 for all variable ids in x:
    			this.nullBit1 &= ~x;
    			this.nullBit2 |= x;
    			this.nullBit3 |= x;
    			this.nullBit4 |= x;
    		}
    		// workaround for Bug 386181 - [compiler][null] wrong transition in UnconditionalFlowInfo.mergedWith()
    		ax = a1 & ~a2 & a3 & ~a4;
    		bx = b1 & ~b2 & ~b3 & b4;
    		x = ax&bx;
    		ax = a1 & ~a2 & ~a3 & a4;
    		bx = b1 & ~b2 & b3 & ~b4;
    		x |= (ax&bx);
    		if (x != 0) {
    			// establish state 0011 for all variable ids in x:
    			this.nullBit1 &= ~x;
    			this.nullBit2 &= ~x;
    			this.nullBit3 |= x;
    			this.nullBit4 |= x;
    		}

    		if (COVERAGE_TEST_FLAG) {
    			if(CoverageTestId == 30) {
	    		  	this.nullBit4 = ~0;
    			}
    		}
    	} else { // other has no null info
    		a1 = this.nullBit1;
      		this.nullBit1 = 0;
      		this.nullBit2 = (a2 = this.nullBit2) & (na3 = ~(a3 = this.nullBit3) | (na1 = ~a1));
      		this.nullBit3 = a3 & ((na2 = ~a2) & (a4 = this.nullBit4) | na1) | a1 & na2 & ~a4;
      		this.nullBit4 = (na3 | na2) & na1 & a4	| a1 & na3 & na2;
    		if (COVERAGE_TEST_FLAG) {
    			if(CoverageTestId == 31) {
	    		  	this.nullBit4 = ~0;
    			}
    		}
    	}
	} else if (otherHasNulls) { // only other had nulls
  		this.nullBit1 = 0;
  		this.nullBit2 = (b2 = otherInits.nullBit2) & (nb3 = ~(b3 = otherInits.nullBit3) | (nb1 = ~(b1 = otherInits.nullBit1)));
  		this.nullBit3 = b3 & ((nb2 = ~b2) & (b4 = otherInits.nullBit4) | nb1) | b1 & nb2 & ~b4;
  		this.nullBit4 = (nb3 | nb2) & nb1 & b4	| b1 & nb3 & nb2;
  		if (COVERAGE_TEST_FLAG) {
  			if(CoverageTestId == 32) {
	  		  	this.nullBit4 = ~0;
  			}
  		}
    	thisHasNulls =
    		// redundant with the three following ones
    		this.nullBit2 != 0 ||
    		this.nullBit3 != 0 ||
    		this.nullBit4 != 0;
	}

	// treating extra storage
	if (this.extra != null || otherInits.extra != null) {
		int mergeLimit = 0, copyLimit = 0, resetLimit = 0;
		int i;
		if (this.extra != null) {
			if (otherInits.extra != null) {
				// both sides have extra storage
				int length, otherLength;
				if ((length = this.extra[0].length) <
						(otherLength = otherInits.extra[0].length)) {
					// current storage is shorter -> grow current
					for (int j = 0; j < extraLength; j++) {
						System.arraycopy(this.extra[j], 0,
							(this.extra[j] = new long[otherLength]), 0, length);
					}
					mergeLimit = length;
					copyLimit = otherLength;
					if (COVERAGE_TEST_FLAG) {
						if(CoverageTestId == 33) {
							throw new AssertionFailedException("COVERAGE 33"); //$NON-NLS-1$
						}
					}
				}
				else {
					// current storage is longer
					mergeLimit = otherLength;
					resetLimit = length;
					if (COVERAGE_TEST_FLAG) {
						if(CoverageTestId == 34) {
							throw new AssertionFailedException("COVERAGE 34"); //$NON-NLS-1$
						}
					}
				}
			}
			else {
				resetLimit = this.extra[0].length;
				if (COVERAGE_TEST_FLAG) {
					if(CoverageTestId == 35) {
						throw new AssertionFailedException("COVERAGE 35"); //$NON-NLS-1$
					}
				}
			}
		}
		else if (otherInits.extra != null) {
			// no storage here, but other has extra storage.
			int otherLength = otherInits.extra[0].length;
			this.extra = new long[extraLength][];
			for (int j = 0; j < extraLength; j++) {
				this.extra[j] = new long[otherLength];
			}
			System.arraycopy(otherInits.extra[1], 0,
				this.extra[1], 0, otherLength);
			copyLimit = otherLength;
			if (COVERAGE_TEST_FLAG) {
				if(CoverageTestId == 36) {
					throw new AssertionFailedException("COVERAGE 36"); //$NON-NLS-1$
				}
			}
		}
        // MACRO :'b,'es/nullBit\(.\)/extra[\1 + 1][i]/g
		// manage definite assignment
		for (i = 0; i < mergeLimit; i++) {
	  		this.extra[0][i] &= otherInits.extra[0][i];
	  		this.extra[1][i] |= otherInits.extra[1][i];
		}
		for (; i < copyLimit; i++) {
		  	this.extra[1][i] = otherInits.extra[1][i];
		}
		for (; i < resetLimit; i++) {
		  	this.extra[0][i] = 0;
		}
		// refine null bits requirements
		if (!otherHasNulls) {
		  if (resetLimit < mergeLimit) {
			resetLimit = mergeLimit;
		  }
		  copyLimit = 0; // no need to carry inexisting nulls
		  mergeLimit = 0;
		}
		if (!thisHadNulls) {
		  resetLimit = 0; // no need to reset anything
		}
		// compose nulls
		for (i = 0; i < mergeLimit; i++) {
    		this.extra[1 + 1][i] = (a2 = this.extra[2 + 1][i]) & (a3 = this.extra[3 + 1][i])
    							& (a4 = this.extra[4 + 1][i]) & (b1 = otherInits.extra[1 + 1][i])
    							& (nb2 = ~(b2 = otherInits.extra[2 + 1][i]))
                  			| (a1 = this.extra[1 + 1][i]) & (b1 & (a3 & a4 & (b3 = otherInits.extra[3 + 1][i])
                  													& (b4 = otherInits.extra[4 + 1][i])
                  												| (na2 = ~a2) & nb2
                  													& ((nb4 = ~b4) | (na4 = ~a4)
                  															| (na3 = ~a3) & (nb3 = ~b3))
                  												| a2 & b2 & ((na4 | na3) & (nb4	| nb3)))
                  											| na2 & b2 & b3 & b4);
    		this.extra[2 + 1][i] = b2 & (nb3 | (nb1 = ~b1) | a3 & (a4 | (na1 = ~a1)) & nb4)
        			| a2 & (b2 | na4 & b3 & (b4 | nb1) | na3 | na1);
    		this.extra[3 + 1][i] = b3 & (nb2 & b4 | nb1 | a3 & (na4 & nb4 | a4 & b4))
        			| a3 & (na2 & a4 | na1)
        			| (a2 | na1) & b1 & nb2 & nb4
        			| a1 & na2 & na4 & (b2 | nb1);
    		this.extra[4 + 1][i] = na3 & (nb1 & nb3 & b4
              			| b1 & (nb2 & nb3 | a4 & b2 & nb4)
              			| na1 & a4 & (nb3 | b1 & b2))
        			| a3 & a4 & (b3 & b4 | b1 & nb2)
        			| na2 & (nb1 & b4 | b1 & nb3 | na1 & a4) & nb2
        			| a1 & (na3 & (nb3 & b4
                        			| b1 & b2 & b3 & nb4
                        			| na2 & (nb3 | nb2))
                			| na2 & b3 & b4
                			| a2 & (nb1 & b4 | a3 & na4 & b1) & nb3);
    		// the above formulae do not handle the state 0111, do it now explicitly:
    		long ax = ~a1 & a2 & a3 & a4;
    		long bx = ~b1 & b2 & b3 & b4;
    		long x = ax|bx;
    		if (x != 0) {
    			// restore state 0111 for all variable ids in x:
    			this.extra[2][i] &= ~x;
    			this.extra[3][i] |= x;
    			this.extra[4][i] |= x;
    			this.extra[5][i] |= x;
    		}
    		// workaround for Bug 386181 - [compiler][null] wrong transition in UnconditionalFlowInfo.mergedWith()
    		ax = a1 & ~a2 & a3 & ~a4;
    		bx = b1 & ~b2 & ~b3 & b4;
    		x = ax&bx;
    		ax = a1 & ~a2 & ~a3 & a4;
    		bx = b1 & ~b2 & b3 & ~b4;
    		x |= (ax&bx);
    		if (x != 0) {
    			// establish state 0011 for all variable ids in x:
    			this.extra[2][i] &= ~x;
    			this.extra[3][i] &= ~x;
    			this.extra[4][i] |= x;
    			this.extra[5][i] |= x;
    		}
			thisHasNulls = thisHasNulls ||
				this.extra[3][i] != 0 ||
				this.extra[4][i] != 0 ||
				this.extra[5][i] != 0 ;
			if (COVERAGE_TEST_FLAG) {
				if(CoverageTestId == 37) {
					this.extra[5][i] = ~0;
				}
			}
		}
		for (; i < copyLimit; i++) {
    		this.extra[1 + 1][i] = 0;
    		this.extra[2 + 1][i] = (b2 = otherInits.extra[2 + 1][i]) & (nb3 = ~(b3 = otherInits.extra[3 + 1][i]) | (nb1 = ~(b1 = otherInits.extra[1 + 1][i])));
    		this.extra[3 + 1][i] = b3 & ((nb2 = ~b2) & (b4 = otherInits.extra[4 + 1][i]) | nb1) | b1 & nb2 & ~b4;
    		this.extra[4 + 1][i] = (nb3 | nb2) & nb1 & b4	| b1 & nb3 & nb2;
			thisHasNulls = thisHasNulls ||
				this.extra[3][i] != 0 ||
				this.extra[4][i] != 0 ||
				this.extra[5][i] != 0;
			if (COVERAGE_TEST_FLAG) {
				if(CoverageTestId == 38) {
					this.extra[5][i] = ~0;
				}
			}
		}
		for (; i < resetLimit; i++) {
    		a1 = this.extra[1 + 1][i];
      		this.extra[1 + 1][i] = 0;
      		this.extra[2 + 1][i] = (a2 = this.extra[2 + 1][i]) & (na3 = ~(a3 = this.extra[3 + 1][i]) | (na1 = ~a1));
      		this.extra[3 + 1][i] = a3 & ((na2 = ~a2) & (a4 = this.extra[4 + 1][i]) | na1) | a1 & na2 & ~a4;
      		this.extra[4 + 1][i] = (na3 | na2) & na1 & a4	| a1 & na3 & na2;
			thisHasNulls = thisHasNulls ||
				this.extra[3][i] != 0 ||
				this.extra[4][i] != 0 ||
				this.extra[5][i] != 0;
			if (COVERAGE_TEST_FLAG) {
				if(CoverageTestId == 39) {
					this.extra[5][i] = ~0;
				}
			}
		}
	}
	if (thisHasNulls) {
		this.tagBits |= NULL_FLAG_MASK;
	}
	else {
		this.tagBits &= ~NULL_FLAG_MASK;
	}
	return this;
}

