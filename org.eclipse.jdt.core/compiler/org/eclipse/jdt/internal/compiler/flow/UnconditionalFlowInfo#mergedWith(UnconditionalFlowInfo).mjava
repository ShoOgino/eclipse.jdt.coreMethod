public UnconditionalFlowInfo mergedWith(UnconditionalFlowInfo otherInits) {
	if ((otherInits.tagBits & UNREACHABLE) != 0 && this != DEAD_END) {
		if (coverageTestFlag && coverageTestId == 35) {
			throw new AssertionFailedException("COVERAGE 35"); //$NON-NLS-1$
		}
		// DEAD_END + unreachable other -> other
		return this;
	}
	if ((this.tagBits & UNREACHABLE) != 0) {
		if (coverageTestFlag && coverageTestId == 36) {
			throw new AssertionFailedException("COVERAGE 36"); //$NON-NLS-1$
		}
		return (UnconditionalFlowInfo) otherInits.copy(); // make sure otherInits won't be affected
	} 
	
	// intersection of definitely assigned variables, 
	this.definiteInits &= otherInits.definiteInits;
	// union of potentially set ones
	this.potentialInits |= otherInits.potentialInits;

	// null combinations
	boolean otherHasNulls = (otherInits.tagBits & NULL_FLAG_MASK) != 0,
		thisHasNulls = false;
	long a1, a2, na2, a3, na3, a4, na4, b1, nb1, b2, nb2, b3, nb3, b4, nb4;
	if (otherHasNulls) {
		this.nullAssignmentStatusBit1 =
			(a1 = this.nullAssignmentStatusBit1) & 
			(b1 = otherInits.nullAssignmentStatusBit1) & (
				(nb4 = ~(b4 = otherInits.nullAssignmentValueBit2)) & 
				((b2 = otherInits.nullAssignmentStatusBit2) & 
						(nb3 = ~(b3 = otherInits.nullAssignmentValueBit1)) & 
						(na3 = ~(a3 = this.nullAssignmentValueBit1)) & 
						((a2 = this.nullAssignmentStatusBit2) & 
							(na4 = ~(a4 = this.nullAssignmentValueBit2)) | a4) |
						(na2 = ~a2) & a3 & na4 & (nb2 = ~b2) & b3 ) |
				b4 & (na3 & nb3 & (na4 & a2 | a4) |
						na2 & a4 & nb2));
		this.nullAssignmentStatusBit2 =
			a2 & b2 & ~(a1 ^ b1) & (na3 & nb3 | na4 & nb4) |
			a1 & b1 & (a2 ^ b2) & na3 & nb3 |
			(a1 & na2 & (nb1 = ~b1) & b2 | ~a1 & a2 & b1 & nb2) & na4 & nb4;
		this.nullAssignmentValueBit1 =
			b1 & nb2 & nb4 |
			~a1 & (a3 |
					a2 & na3 & (b1 | nb2)) |
			(a1 | na2) & nb1 & b2 & nb3 |
			nb1 & b3 |
			a1 & na2 & (na4 |
						b1 & nb2 & (a3 | b3));
		this.nullAssignmentValueBit2 =
			a4 | b4;
		
		// WORK recode if tests succeed
		this.nullAssignmentValueBit1 &= 
			~(a1 & na2 & na3 & a4 & nb1 & b2 & nb3 & nb4
					| ~a1 & a2 & na3 & na4 & b1 & nb2 & nb3 & b4);
		
		if (coverageTestFlag && coverageTestId == 37) {
			this.nullAssignmentValueBit2 = ~0;
		}
	}
	else {
		// tune potentials
		this.nullAssignmentValueBit1 =
			~(~this.nullAssignmentStatusBit1 &
					~this.nullAssignmentStatusBit2 &
					~this.nullAssignmentValueBit1) &
			~(this.nullAssignmentStatusBit1 & 
					(this.nullAssignmentStatusBit2 | this.nullAssignmentValueBit2));
		// reset assignment and protected
		this.nullAssignmentStatusBit1 = 
		this.nullAssignmentStatusBit2 = 0;
		if (coverageTestFlag && coverageTestId == 38) {
			this.nullAssignmentValueBit2 = ~0;
		}
	}
	thisHasNulls = this.nullAssignmentStatusBit1 != 0 || 
		this.nullAssignmentStatusBit2 != 0 ||
		this.nullAssignmentValueBit1 != 0 ||
		this.nullAssignmentValueBit2 != 0;

	// treating extra storage
	if (this.extra != null || otherInits.extra != null) {
		int mergeLimit = 0, copyLimit = 0, resetLimit = 0;
		if (this.extra != null) {
			if (otherInits.extra != null) {
				// both sides have extra storage
				int length, otherLength;
				if ((length = this.extra[0].length) < 
						(otherLength = otherInits.extra[0].length)) {
					// current storage is shorter -> grow current 
					for (int j = 0; j < extraLength; j++) {
						System.arraycopy(this.extra[j], 0, 
							(this.extra[j] = new long[otherLength]), 0, length);
					}
					mergeLimit = length;
					copyLimit = otherLength;
					if (coverageTestFlag && coverageTestId == 39) {
						throw new AssertionFailedException("COVERAGE 39"); //$NON-NLS-1$
					}
				} 
				else {
					// current storage is longer
					mergeLimit = otherLength;
					resetLimit = length;
					if (coverageTestFlag && coverageTestId == 40) {
						throw new AssertionFailedException("COVERAGE 40"); //$NON-NLS-1$
					}
				}
			} 
			else {
				resetLimit = this.extra[0].length;
				if (coverageTestFlag && coverageTestId == 41) {
					throw new AssertionFailedException("COVERAGE 41"); //$NON-NLS-1$
				}
			}
		} 
		else if (otherInits.extra != null) {
			// no storage here, but other has extra storage.
			int otherLength = otherInits.extra[0].length;
			this.extra = new long[extraLength][];
			for (int j = 0; j < extraLength; j++) {
				this.extra[j] = new long[otherLength];
			}
			System.arraycopy(otherInits.extra[1], 0, 
				this.extra[1], 0, otherLength);
			copyLimit = otherLength;
			if (coverageTestFlag && coverageTestId == 42) {
				throw new AssertionFailedException("COVERAGE 42"); //$NON-NLS-1$
			}
		}
		int i;
		if (otherHasNulls) {
			for (i = 0; i < mergeLimit; i++) {
				this.extra[2][i] =
					(a1 = this.extra[2][i]) & 
					(b1 = otherInits.extra[2][i]) & (
						(nb4 = ~(b4 = otherInits.extra[5][i])) & 
						((b2 = otherInits.extra[3][i]) & 
								(nb3 = ~(b3 = otherInits.extra[4][i])) & 
								(na3 = ~(a3 = this.extra[4][i])) & 
								((a2 = this.extra[3][i]) & 
									(na4 = ~(a4 = this.extra[5][i])) | a4) |
								(na2 = ~a2) & a3 & na4 & (nb2 = ~b2) & b3 ) |
						b4 & (na3 & nb3 & (na4 & a2 | a4) |
								na2 & a4 & nb2));
				this.extra[3][i] =
					a2 & b2 & ~(a1 ^ b1) & (na3 & nb3 | na4 & nb4) |
					a1 & b1 & (a2 ^ b2) & na3 & nb3 |
					(a1 & na2 & (nb1 = ~b1) & b2 | ~a1 & a2 & b1 & nb2) & na4 & nb4;
				this.extra[4][i] =
					b1 & nb2 & nb4 |
					~a1 & (a3 |
							a2 & na3 & (b1 | nb2)) |
					(a1 | na2) & nb1 & b2 & nb3 |
					nb1 & b3 |
					a1 & na2 & (na4 |
								b1 & nb2 & (a3 | b3));
				this.extra[5][i] =
					a4 | b4;

				// WORK recode if tests succeed
				this.extra[4][i] &= 
					~(a1 & na2 & na3 & a4 & nb1 & b2 & nb3 & nb4
							| ~a1 & a2 & na3 & na4 & b1 & nb2 & nb3 & b4);
		
				thisHasNulls = thisHasNulls ||
					this.extra[5][i] != 0 ||
					this.extra[2][i] != 0 ||
					this.extra[3][i] != 0 ||
					this.extra[4][i] != 0;
				if (coverageTestFlag && coverageTestId == 43) {
					this.extra[5][i] = ~0;
				}
			}
		}
		else {
			for (i = 0; i < mergeLimit; i++) {
				this.extra[0][i] &= 
					otherInits.extra[0][i];
				this.extra[1][i] |= 
					otherInits.extra[1][i];
				this.extra[4][i] =
					~(~this.extra[2][i] &
							~this.extra[3][i] &
							~this.extra[4][i]) &
					~(this.extra[2][i] & 
							(this.extra[3][i] | 
							this.extra[5][i]));
				this.extra[2][i] = 
				this.extra[3][i] = 0;
				thisHasNulls = thisHasNulls ||
					this.extra[4][i] != 0 ||
					this.extra[5][i] != 0;
				if (coverageTestFlag && coverageTestId == 44) {
					this.extra[5][i] = ~0;
				}
			}
		}
		for (; i < copyLimit; i++) {
			this.extra[1][i] = otherInits.extra[1][i];
			this.extra[4][i] =
				~(~otherInits.extra[2][i] &
					~otherInits.extra[3][i] &
					~otherInits.extra[4][i]) &
				~(otherInits.extra[2][i] & 
					(otherInits.extra[3][i] |
					otherInits.extra[5][i]));
			this.extra[5][i] = otherInits.extra[5][i];
			thisHasNulls = thisHasNulls ||
				this.extra[4][i] != 0 ||
				this.extra[5][i] != 0;
			if (coverageTestFlag && coverageTestId == 45) {
				this.extra[5][i] = ~0;
			}
		}
		for (; i < resetLimit; i++) {
			this.extra[4][i] =
				~(~this.extra[2][i] &
						~this.extra[3][i] &
						~this.extra[4][i]) &
				~(this.extra[2][i] & 
						(this.extra[3][i] | 
						this.extra[5][i]));
			this.extra[0][i] = 
			this.extra[2][i] = 
			this.extra[3][i] = 0;
			thisHasNulls = thisHasNulls ||
				this.extra[4][i] != 0 ||
				this.extra[5][i] != 0;
			if (coverageTestFlag && coverageTestId == 46) {
				this.extra[5][i] = ~0;
			}
		}
	}
	if (thisHasNulls) {
		this.tagBits |= NULL_FLAG_MASK;
	}
	else {
		this.tagBits &= ~NULL_FLAG_MASK;
	}
	return this;
}

