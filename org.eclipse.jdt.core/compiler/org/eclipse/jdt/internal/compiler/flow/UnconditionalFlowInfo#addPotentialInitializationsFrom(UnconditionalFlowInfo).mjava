public UnconditionalFlowInfo addPotentialInitializationsFrom(UnconditionalFlowInfo otherInits) {

	// unions of both sets of initialization - used for try/finally
	if (this == DeadEnd){
		return this;
	}
	if (otherInits == DeadEnd){
		return this;
	}
	// union of potentially set ones
	potentialInits |= otherInits.potentialInits;

	// treating extra storage
	if (extraDefiniteInits != null) {
		if (otherInits.extraDefiniteInits != null) {
			// both sides have extra storage
			int i = 0, length, otherLength;
			if ((length = extraDefiniteInits.length) < (otherLength = otherInits.extraDefiniteInits.length)) {
				// current storage is shorter -> grow current (could maybe reuse otherInits extra storage?)
				System.arraycopy(extraDefiniteInits, 0, (extraDefiniteInits = new long[otherLength]), 0, length);
				System.arraycopy(extraPotentialInits, 0, (extraPotentialInits = new long[otherLength]), 0, length);
				while (i < length) {
					extraPotentialInits[i] |= otherInits.extraPotentialInits[i++];
				}
				while (i < otherLength) {
					extraPotentialInits[i] = otherInits.extraPotentialInits[i++];
				}
			} else {
				// current storage is longer
				while (i < otherLength) {
					extraPotentialInits[i] |= otherInits.extraPotentialInits[i++];
				}
			}
		}
	} else
		if (otherInits.extraDefiniteInits != null) {
			// no storage here, but other has extra storage.
			int otherLength;
			extraDefiniteInits = new long[otherLength = otherInits.extraDefiniteInits.length];			
			System.arraycopy(otherInits.extraPotentialInits, 0, (extraPotentialInits = new long[otherLength]), 0, otherLength);
		}
	return this;
}

