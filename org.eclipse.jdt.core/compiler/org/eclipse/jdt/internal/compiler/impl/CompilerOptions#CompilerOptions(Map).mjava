	/** 
	 * Initializing the compiler options with external settings
	 */
	public CompilerOptions(Map settings){

		if (settings == null) return;
		
		// filter options which are related to the compiler component
		Iterator entries = settings.entrySet().iterator();
		while (entries.hasNext()) {
			Map.Entry entry = (Map.Entry)entries.next();
			if (!(entry.getKey() instanceof String)) continue;
			if (!(entry.getValue() instanceof String)) continue;
			String optionID = (String) entry.getKey();
			String optionValue = (String) entry.getValue();
			
			// Local variable attribute
			if(optionID.equals(OPTION_LocalVariableAttribute)){
				if (optionValue.equals(GENERATE)) {
					this.produceDebugAttributes |= Vars;
				} else if (optionValue.equals(DO_NOT_GENERATE)){
					this.produceDebugAttributes &= ~Vars;
				}
				continue;
			}  
			// Line number attribute	
			if(optionID.equals(OPTION_LineNumberAttribute)) {
				if (optionValue.equals(GENERATE)) {
					this.produceDebugAttributes |= Lines;
				} else if (optionValue.equals(DO_NOT_GENERATE)) {
					this.produceDebugAttributes &= ~Lines;
				}
				continue;
			} 
			// Source file attribute	
			if(optionID.equals(OPTION_SourceFileAttribute)) {
				if (optionValue.equals(GENERATE)) {
					this.produceDebugAttributes |= Source;
				} else if (optionValue.equals(DO_NOT_GENERATE)) {
					this.produceDebugAttributes &= ~Source;
				}
				continue;
			} 
			// Preserve unused local	
			if(optionID.equals(OPTION_PreserveUnusedLocal)){
				if (optionValue.equals(PRESERVE)) {
					this.preserveAllLocalVariables = true;
				} else if (optionValue.equals(OPTIMIZE_OUT)) {
					this.preserveAllLocalVariables = false;
				}
				continue;
			} 
			// Report unreachable code				
			if(optionID.equals(OPTION_ReportUnreachableCode)){
				updateSeverity(UnreachableCode, optionValue);
				continue;
			} 
			// Report invalid import	
			if(optionID.equals(OPTION_ReportInvalidImport)){
				updateSeverity(ImportProblem, optionValue);
				continue;
			} 
			// Define the target JDK tag for .classfiles
			if(optionID.equals(OPTION_TargetPlatform)){
				long level = versionToJdkLevel(optionValue);
				if (level != 0) this.targetJDK = level;
				continue;
			} 
			// Define the JDK compliance level
			if(optionID.equals(OPTION_Compliance)){
				long level = versionToJdkLevel(optionValue);
				if (level != 0) this.complianceLevel = level;
				continue;
			} 
			// Private constructor access emulation (extra arg vs. visibility change)
			if(optionID.equals(OPTION_PrivateConstructorAccess)){
				long level = versionToJdkLevel(optionValue);
				if (level >= JDK1_3) this.isPrivateConstructorAccessChangingVisibility = true;
				continue;
			} 
			// Report method with constructor name
			if(optionID.equals(OPTION_ReportMethodWithConstructorName)){
				updateSeverity(MethodWithConstructorName, optionValue);
				continue;
			} 
			// Report overriding package default method
			if(optionID.equals(OPTION_ReportOverridingPackageDefaultMethod)){
				updateSeverity(OverriddenPackageDefaultMethod, optionValue);
				continue;
			} 
			// Report deprecation
			if(optionID.equals(OPTION_ReportDeprecation)){
				updateSeverity(UsingDeprecatedAPI, optionValue);
				continue;
			} 
			// Report deprecation inside deprecated code 
			if(optionID.equals(OPTION_ReportDeprecationInDeprecatedCode)){
				if (optionValue.equals(ENABLED)) {
					this.reportDeprecationInsideDeprecatedCode = true;
				} else if (optionValue.equals(DISABLED)) {
					this.reportDeprecationInsideDeprecatedCode = false;
				}
				continue;
			} 
			// Report hidden catch block
			if(optionID.equals(OPTION_ReportHiddenCatchBlock)){
				updateSeverity(MaskedCatchBlock, optionValue);
				continue;
			} 
			// Report unused local variable
			if(optionID.equals(OPTION_ReportUnusedLocal)){
				updateSeverity(UnusedLocalVariable, optionValue);
				continue;
			}
			// Report no implicit String conversion
			if (optionID.equals(OPTION_ReportNoImplicitStringConversion)) {
				updateSeverity(NoImplicitStringConversion, optionValue);
				continue;
			}
			// Report unused parameter
			if(optionID.equals(OPTION_ReportUnusedParameter)){
				updateSeverity(UnusedArgument, optionValue);
				continue;
			} 
			// Report unused parameter when implementing abstract method 
			if(optionID.equals(OPTION_ReportUnusedParameterWhenImplementingAbstract)){
				if (optionValue.equals(ENABLED)) {
					this.reportUnusedParameterWhenImplementingAbstract = true;
				} else if (optionValue.equals(DISABLED)) {
					this.reportUnusedParameterWhenImplementingAbstract = false;
				}
				continue;
			} 
			// Report unused parameter when implementing abstract method 
			if(optionID.equals(OPTION_ReportUnusedParameterWhenOverridingConcrete)){
				if (optionValue.equals(ENABLED)) {
					this.reportUnusedParameterWhenOverridingConcrete = true;
				} else if (optionValue.equals(DISABLED)) {
					this.reportUnusedParameterWhenOverridingConcrete = false;
				}
				continue;
			} 
			// Report unused import
			if(optionID.equals(OPTION_ReportUnusedImport)){
				updateSeverity(UnusedImport, optionValue);
				continue;
			} 
			// Report synthetic access emulation
			if(optionID.equals(OPTION_ReportSyntheticAccessEmulation)){
				updateSeverity(AccessEmulation, optionValue);
				continue;
			}
			// Report local var hiding another variable
			if(optionID.equals(OPTION_ReportLocalVariableHiding)){
				updateSeverity(LocalVariableHiding, optionValue);
				continue;
			}
			// Report field hiding another variable
			if(optionID.equals(OPTION_ReportFieldHiding)){
				updateSeverity(FieldHiding, optionValue);
				continue;
			}
			// Report constructor/setter parameter hiding another field
			if(optionID.equals(OPTION_ReportSpecialParameterHidingField)){
				if (optionValue.equals(ENABLED)) {
					this.reportSpecialParameterHidingField = true;
				} else if (optionValue.equals(DISABLED)) {
					this.reportSpecialParameterHidingField = false;
				}
				continue;
			}			
			// Report possible accidental boolean assignment
			if(optionID.equals(OPTION_ReportPossibleAccidentalBooleanAssignment)){
				updateSeverity(AccidentalBooleanAssign, optionValue);
				continue;
			}
			// Report possible accidental boolean assignment
			if(optionID.equals(OPTION_ReportSuperfluousSemicolon)){
				updateSeverity(SuperfluousSemicolon, optionValue);
				continue;
			}
			// Report non-externalized string literals
			if(optionID.equals(OPTION_ReportNonExternalizedStringLiteral)){
				updateSeverity(NonExternalizedString, optionValue);
				continue;
			}
			// Report usage of 'assert' as an identifier
			if(optionID.equals(OPTION_ReportAssertIdentifier)){
				updateSeverity(AssertUsedAsAnIdentifier, optionValue);
				continue;
			}
			// Set the source compatibility mode (assertions)
			if(optionID.equals(OPTION_Source)){
				long level = versionToJdkLevel(optionValue);
				if (level != 0) this.sourceLevel = level;
				continue;
			}
			// Set the default encoding format
			if(optionID.equals(OPTION_Encoding)){
				if (optionValue.length() == 0){
					this.defaultEncoding = null;
				} else {
					try { // ignore unsupported encoding
						new InputStreamReader(new ByteArrayInputStream(new byte[0]), optionValue);
						this.defaultEncoding = optionValue;
					} catch(UnsupportedEncodingException e){
					}
				}
				continue;
			}
			// Set the threshold for problems per unit
			if(optionID.equals(OPTION_MaxProblemPerUnit)){
				try {
					int val = Integer.parseInt(optionValue);
					if (val >= 0) this.maxProblemsPerUnit = val;
				} catch(NumberFormatException e){
				}				
				continue;
			}
			// Report unnecessary receiver for static access
			if(optionID.equals(OPTION_ReportNonStaticAccessToStatic)){
				updateSeverity(NonStaticAccessToStatic, optionValue);
				continue;
			} 
			// Report indirect static access
			if(optionID.equals(OPTION_ReportIndirectStaticAccess)){
				updateSeverity(IndirectStaticAccess, optionValue);
				continue;
			} 
			// Report interface method incompatible with non-inherited Object method
			if(optionID.equals(OPTION_ReportIncompatibleNonInheritedInterfaceMethod)){
				updateSeverity(IncompatibleNonInheritedInterfaceMethod, optionValue);
				continue;
			} 
			// Report unused private members
			if(optionID.equals(OPTION_ReportUnusedPrivateMember)){
				updateSeverity(UnusedPrivateMember, optionValue);
				continue;
			} 
			// Report boolean method throwing exception
			if(optionID.equals(OPTION_ReportBooleanMethodThrowingException)){
				updateSeverity(BooleanMethodThrowingException, optionValue);
				continue;
			} 
			// Report unnecessary cast
			if(optionID.equals(OPTION_ReportUnnecessaryTypeCheck)){
				updateSeverity(UnnecessaryTypeCheck, optionValue);
				continue;
			} 
			// Report task
			if(optionID.equals(OPTION_TaskTags)){
				if (optionValue.length() == 0) {
					this.taskTags = null;
				} else {
					this.taskTags = CharOperation.splitAndTrimOn(',', optionValue.toCharArray());
				}
				continue;
			} 
			// Report no-op assignments
			if(optionID.equals(OPTION_ReportNoEffectAssignment)){
				updateSeverity(NoEffectAssignment, optionValue);
				continue;
			}
			if(optionID.equals(OPTION_TaskPriorities)){
				if (optionValue.length() == 0) {
					this.taskPriorites = null;
				} else {
					this.taskPriorites = CharOperation.splitAndTrimOn(',', optionValue.toCharArray());
				}
				continue;
			} 
		}
	}

