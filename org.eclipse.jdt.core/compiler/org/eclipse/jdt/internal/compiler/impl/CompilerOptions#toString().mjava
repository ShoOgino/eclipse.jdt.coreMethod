public String toString() {

	StringBuffer buf = new StringBuffer("CompilerOptions:"/*nonNLS*/);
	if ((produceDebugAttributes & Vars) != 0){
		buf.append("\n-local variables debug attributes: ON"/*nonNLS*/);
	} else {
		buf.append("\n-local variables debug attributes: OFF"/*nonNLS*/);
	}
	if ((produceDebugAttributes & Lines) != 0){
		buf.append("\n-line number debug attributes: ON"/*nonNLS*/);
	} else {
		buf.append("\n-line number debug attributes: OFF"/*nonNLS*/);
	}
	if ((produceDebugAttributes & Source) != 0){
		buf.append("\n-source debug attributes: ON"/*nonNLS*/);
	} else {
		buf.append("\n-source debug attributes: OFF"/*nonNLS*/);
	}
	if (preserveAllLocalVariables){
		buf.append("\n-preserve all local variables: ON"/*nonNLS*/);
	} else {
		buf.append("\n-preserve all local variables: OFF"/*nonNLS*/);
	}
	if ((errorThreshold & UnreachableCode) != 0){
		buf.append("\n-unreachable code: ERROR"/*nonNLS*/);
	} else {
		if ((warningThreshold & UnreachableCode) != 0){
			buf.append("\n-unreachable code: WARNING"/*nonNLS*/);
		} else {
			buf.append("\n-unreachable code: IGNORE"/*nonNLS*/);
		}
	}
	if ((errorThreshold & ImportProblem) != 0){
		buf.append("\n-import problem: ERROR"/*nonNLS*/);
	} else {
		if ((warningThreshold & ImportProblem) != 0){
			buf.append("\n-import problem: WARNING"/*nonNLS*/);
		} else {
			buf.append("\n-import problem: IGNORE"/*nonNLS*/);
		}
	}
	if ((errorThreshold & MethodWithConstructorName) != 0){
		buf.append("\n-method with constructor name: ERROR"/*nonNLS*/);		
	} else {
		if ((warningThreshold & MethodWithConstructorName) != 0){
			buf.append("\n-method with constructor name: WARNING"/*nonNLS*/);
		} else {
			buf.append("\n-method with constructor name: IGNORE"/*nonNLS*/);
		}
	}
	if ((errorThreshold & OverriddenPackageDefaultMethod) != 0){
		buf.append("\n-overridden package default method: ERROR"/*nonNLS*/);
	} else {
		if ((warningThreshold & OverriddenPackageDefaultMethod) != 0){
			buf.append("\n-overridden package default method: WARNING"/*nonNLS*/);
		} else {
			buf.append("\n-overridden package default method: IGNORE"/*nonNLS*/);
		}
	}
	if ((errorThreshold & UsingDeprecatedAPI) != 0){
		buf.append("\n-deprecation: ERROR"/*nonNLS*/);
	} else {
		if ((warningThreshold & UsingDeprecatedAPI) != 0){
			buf.append("\n-deprecation: WARNING"/*nonNLS*/);
		} else {
			buf.append("\n-deprecation: IGNORE"/*nonNLS*/);
		}
	}
	if ((errorThreshold & MaskedCatchBlock) != 0){
		buf.append("\n-masked catch block: ERROR"/*nonNLS*/);
	} else {
		if ((warningThreshold & MaskedCatchBlock) != 0){
			buf.append("\n-masked catch block: WARNING"/*nonNLS*/);
		} else {
			buf.append("\n-masked catch block: IGNORE"/*nonNLS*/);
		}
	}
	if ((errorThreshold & UnusedLocalVariable) != 0){
		buf.append("\n-unused local variable: ERROR"/*nonNLS*/);
	} else {
		if ((warningThreshold & UnusedLocalVariable) != 0){
			buf.append("\n-unused local variable: WARNING"/*nonNLS*/);
		} else {
			buf.append("\n-unused local variable: IGNORE"/*nonNLS*/);
		}
	}
	if ((errorThreshold & UnusedArgument) != 0){
		buf.append("\n-unused parameter: ERROR"/*nonNLS*/);
	} else {
		if ((warningThreshold & UnusedArgument) != 0){
			buf.append("\n-unused parameter: WARNING"/*nonNLS*/);
		} else {
			buf.append("\n-unused parameter: IGNORE"/*nonNLS*/);
		}
	}
	if ((errorThreshold & AccessEmulation) != 0){
		buf.append("\n-synthetic access emulation: ERROR"/*nonNLS*/);
	} else {
		if ((warningThreshold & AccessEmulation) != 0){
			buf.append("\n-synthetic access emulation: WARNING"/*nonNLS*/);
		} else {
			buf.append("\n-synthetic access emulation: IGNORE"/*nonNLS*/);
		}
	}
	if ((errorThreshold & NonExternalizedString) != 0){
		buf.append("\n-non externalized string: ERROR"/*nonNLS*/);
	} else {
		if ((warningThreshold & NonExternalizedString) != 0){
			buf.append("\n-non externalized string: WARNING"/*nonNLS*/);
		} else {
			buf.append("\n-non externalized string: IGNORE"/*nonNLS*/);
		}
	}
	switch(targetJDK){
		case JDK1_1 :
			buf.append("\n-target JDK: 1.1"/*nonNLS*/);
			break;
		case JDK1_2 :
			buf.append("\n-target JDK: 1.2"/*nonNLS*/);
	}
	buf.append("\n-verbose : "/*nonNLS*/ + (verbose ? "ON"/*nonNLS*/ : "OFF"/*nonNLS*/));
	buf.append("\n-produce reference info : "/*nonNLS*/ + (produceReferenceInfo ? "ON"/*nonNLS*/ : "OFF"/*nonNLS*/));
	buf.append("\n-parse literal expressions as constants : "/*nonNLS*/ + (parseLiteralExpressionsAsConstants ? "ON"/*nonNLS*/ : "OFF"/*nonNLS*/));
	buf.append("\n-runtime exception name for compile error : "/*nonNLS*/ + runtimeExceptionNameForCompileError);
	return buf.toString();
}

