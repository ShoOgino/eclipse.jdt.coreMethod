public String toString() {

	StringBuffer buf = new StringBuffer("CompilerOptions:");
	if ((produceDebugAttributes & Vars) != 0){
		buf.append("\n-local variables debug attributes: ON");
	} else {
		buf.append("\n-local variables debug attributes: OFF");
	}
	if ((produceDebugAttributes & Lines) != 0){
		buf.append("\n-line number debug attributes: ON");
	} else {
		buf.append("\n-line number debug attributes: OFF");
	}
	if ((produceDebugAttributes & Source) != 0){
		buf.append("\n-source debug attributes: ON");
	} else {
		buf.append("\n-source debug attributes: OFF");
	}
	if (preserveAllLocalVariables){
		buf.append("\n-preserve all local variables: ON");
	} else {
		buf.append("\n-preserve all local variables: OFF");
	}
	if ((errorThreshold & UnreachableCode) != 0){
		buf.append("\n-unreachable code: ERROR");
	} else {
		if ((warningThreshold & UnreachableCode) != 0){
			buf.append("\n-unreachable code: WARNING");
		} else {
			buf.append("\n-unreachable code: IGNORE");
		}
	}
	if ((errorThreshold & ImportProblem) != 0){
		buf.append("\n-import problem: ERROR");
	} else {
		if ((warningThreshold & ImportProblem) != 0){
			buf.append("\n-import problem: WARNING");
		} else {
			buf.append("\n-import problem: IGNORE");
		}
	}
	if ((errorThreshold & MethodWithConstructorName) != 0){
		buf.append("\n-method with constructor name: ERROR");		
	} else {
		if ((warningThreshold & MethodWithConstructorName) != 0){
			buf.append("\n-method with constructor name: WARNING");
		} else {
			buf.append("\n-method with constructor name: IGNORE");
		}
	}
	if ((errorThreshold & OverriddenPackageDefaultMethod) != 0){
		buf.append("\n-overridden package default method: ERROR");
	} else {
		if ((warningThreshold & OverriddenPackageDefaultMethod) != 0){
			buf.append("\n-overridden package default method: WARNING");
		} else {
			buf.append("\n-overridden package default method: IGNORE");
		}
	}
	if ((errorThreshold & UsingDeprecatedAPI) != 0){
		buf.append("\n-deprecation: ERROR");
	} else {
		if ((warningThreshold & UsingDeprecatedAPI) != 0){
			buf.append("\n-deprecation: WARNING");
		} else {
			buf.append("\n-deprecation: IGNORE");
		}
	}
	if ((errorThreshold & MaskedCatchBlock) != 0){
		buf.append("\n-masked catch block: ERROR");
	} else {
		if ((warningThreshold & MaskedCatchBlock) != 0){
			buf.append("\n-masked catch block: WARNING");
		} else {
			buf.append("\n-masked catch block: IGNORE");
		}
	}
	if ((errorThreshold & UnusedLocalVariable) != 0){
		buf.append("\n-unused local variable: ERROR");
	} else {
		if ((warningThreshold & UnusedLocalVariable) != 0){
			buf.append("\n-unused local variable: WARNING");
		} else {
			buf.append("\n-unused local variable: IGNORE");
		}
	}
	if ((errorThreshold & UnusedArgument) != 0){
		buf.append("\n-unused parameter: ERROR");
	} else {
		if ((warningThreshold & UnusedArgument) != 0){
			buf.append("\n-unused parameter: WARNING");
		} else {
			buf.append("\n-unused parameter: IGNORE");
		}
	}
	if ((errorThreshold & AccessEmulation) != 0){
		buf.append("\n-synthetic access emulation: ERROR");
	} else {
		if ((warningThreshold & AccessEmulation) != 0){
			buf.append("\n-synthetic access emulation: WARNING");
		} else {
			buf.append("\n-synthetic access emulation: IGNORE");
		}
	}
	if ((errorThreshold & NonExternalizedString) != 0){
		buf.append("\n-non externalized string: ERROR");
	} else {
		if ((warningThreshold & NonExternalizedString) != 0){
			buf.append("\n-non externalized string: WARNING");
		} else {
			buf.append("\n-non externalized string: IGNORE");
		}
	}
	switch(targetJDK){
		case JDK1_1 :
			buf.append("\n-target JDK: 1.1");
			break;
		case JDK1_2 :
			buf.append("\n-target JDK: 1.2");
	}
	buf.append("\n-verbose : " + (verbose ? "ON" : "OFF"));
	buf.append("\n-produce reference info : " + (produceReferenceInfo ? "ON" : "OFF"));
	buf.append("\n-parse literal expressions as constants : " + (parseLiteralExpressionsAsConstants ? "ON" : "OFF"));
	buf.append("\n-runtime exception name for compile error : " + runtimeExceptionNameForCompileError);
	return buf.toString();
}

