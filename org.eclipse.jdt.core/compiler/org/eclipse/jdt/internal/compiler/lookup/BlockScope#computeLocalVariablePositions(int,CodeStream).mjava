	/* Compute variable positions in scopes given an initial position offset
	 * ignoring unused local variables.
	 * 
	 * Special treatment to have Try secret return address variables located at non
	 * colliding positions. Return addresses are not allocated initially, but gathered
	 * and allocated behind all other variables.
	 */
	public void computeLocalVariablePositions(
		int initOffset,
		CodeStream codeStream) {

		this.offset = initOffset;
		this.maxOffset = initOffset;

		// local variable init
		int ilocal = 0, maxLocals = 0, localsLength = locals.length;
		while ((maxLocals < localsLength) && (locals[maxLocals] != null))
			maxLocals++;
		boolean hasMoreVariables = maxLocals > 0;

		// scope init
		int iscope = 0, maxScopes = 0, subscopesLength = subscopes.length;
		while ((maxScopes < subscopesLength) && (subscopes[maxScopes] != null))
			maxScopes++;
		boolean hasMoreScopes = maxScopes > 0;

		// iterate scopes and variables in parallel
		while (hasMoreVariables || hasMoreScopes) {
			if (hasMoreScopes
				&& (!hasMoreVariables || (subscopes[iscope].startIndex() <= ilocal))) {
				// consider subscope first
				if (subscopes[iscope] instanceof BlockScope) {
					BlockScope subscope = (BlockScope) subscopes[iscope];
					int subOffset =
						subscope.shiftScope == null ? this.offset : subscope.shiftScope.offset;
					subscope.computeLocalVariablePositions(subOffset, codeStream);
					if (subscope.maxOffset > this.maxOffset)
						this.maxOffset = subscope.maxOffset;
				}
				hasMoreScopes = ++iscope < maxScopes;
			} else {
				// consider variable first
				LocalVariableBinding local = locals[ilocal];

				// check if variable is actually used, and may force it to be preserved
				boolean generatesLocal =
					(local.used && (local.constant == Constant.NotAConstant)) || local.isArgument;
				if (!local.used
					&& (local.declaration != null) // unused (and non secret) local
					&& ((local.declaration.bits & AstNode.IsReachableMASK) != 0)) { // declaration is reachable
					if (local.isArgument) // method argument
						this.problemReporter().unusedArgument(local.declaration);
					else if (!(local.declaration instanceof Argument)) // catch variable
						this.problemReporter().unusedLocalVariable(local.declaration);
				}
				if (!generatesLocal) {
					if (local.declaration != null
						&& environment().options.preserveAllLocalVariables) {
						generatesLocal = true; // force it to be preserved in the generated code
						local.used = true;
					}
				}
				if (generatesLocal) {

					// Return addresses are managed separately afterwards.
					if (local.name != TryStatement.SecretReturnName) {

						if (local.declaration != null) {
							codeStream.record(local);
							// record user local variables for attribute generation
						}
						// allocate variable position
						local.resolvedPosition = this.offset;

						// check for too many arguments/local variables
						if (local.isArgument) {
							if (this.offset > 0xFF) { // no more than 255 words of arguments
								this.problemReporter().noMoreAvailableSpaceForArgument(local, local.declaration);
							}
						} else {
							if (this.offset > 0xFFFF) { // no more than 65535 words of locals
								this.problemReporter().noMoreAvailableSpaceForLocal(
									local, local.declaration == null ? (AstNode)this.methodScope().referenceContext : local.declaration);
							}
						}

						// increment offset
						if ((local.type == LongBinding) || (local.type == DoubleBinding)) {
							this.offset += 2;
						} else {
							this.offset++;
						}
					}
				} else {
					local.resolvedPosition = -1; // not generated
				}
				hasMoreVariables = ++ilocal < maxLocals;
			}
		}
		if (this.offset > this.maxOffset)
			this.maxOffset = this.offset;
	}

