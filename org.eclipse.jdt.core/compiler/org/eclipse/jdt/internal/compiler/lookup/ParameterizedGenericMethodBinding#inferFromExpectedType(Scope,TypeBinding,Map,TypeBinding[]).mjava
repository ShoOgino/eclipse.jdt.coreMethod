	/**
	 * Given some type expectation, and type variable bounds, perform some inference.
	 * Returns true if still had unresolved type variable at the end of the operation
	 */
	private ParameterizedGenericMethodBinding inferFromExpectedType(Scope scope, TypeBinding expectedType, Map collectedSubstitutes, TypeBinding[] substitutes) {
	    TypeVariableBinding[] originalVariables = this.originalMethod.typeVariables; // immediate parent (could be a parameterized method)
		int varLength = originalVariables.length;
		
		computeSubstitutes: {
		    // infer from expected return type
			if (expectedType != null) {
			    this.returnType.collectSubstitutes(scope, expectedType, collectedSubstitutes, CONSTRAINT_SUPER);
				if (collectedSubstitutes.get(VoidBinding) != null) return null; // impossible substitution
			}
		    // infer from bounds of type parameters
			for (int i = 0; i < varLength; i++) {
				TypeVariableBinding originalVariable = originalVariables[i];
				TypeBinding argument = this.typeArguments[i];
				boolean argAlreadyInferred = argument != originalVariable;
				if (originalVariable.firstBound == originalVariable.superclass) {
					TypeBinding substitutedBound = Scope.substitute(this, originalVariable.superclass);
					argument.collectSubstitutes(scope, substitutedBound, collectedSubstitutes, CONSTRAINT_SUPER);
					if (collectedSubstitutes.get(VoidBinding) != null) return null; // impossible substitution
					// JLS 15.12.2.8 claims reverse inference shouldn't occur, however it improves inference
					// e.g. given: <E extends Object, S extends Collection<E>> S test1(S param)
					//                   invocation: test1(new Vector<String>())    will infer: S=Vector<String>  and with code below: E=String
					if (argAlreadyInferred)
						substitutedBound.collectSubstitutes(scope, argument, collectedSubstitutes, CONSTRAINT_EXTENDS);
						if (collectedSubstitutes.get(VoidBinding) != null) return null; // impossible substitution
				}
				for (int j = 0, max = originalVariable.superInterfaces.length; j < max; j++) {
					TypeBinding substitutedBound = Scope.substitute(this, originalVariable.superInterfaces[j]);
					argument.collectSubstitutes(scope, substitutedBound, collectedSubstitutes, CONSTRAINT_SUPER);
					if (collectedSubstitutes.get(VoidBinding) != null) return null; // impossible substitution
					// JLS 15.12.2.8 claims reverse inference shouldn't occur, however it improves inference
					if (argAlreadyInferred)
						substitutedBound.collectSubstitutes(scope, argument, collectedSubstitutes, CONSTRAINT_EXTENDS);
						if (collectedSubstitutes.get(VoidBinding) != null) return null; // impossible substitution
				}
			}
			substitutes = resolveSubstituteConstraints(scope, originalVariables, substitutes, true/*consider Ti<:Uk*/, collectedSubstitutes);
			if (substitutes == null) 
				return null; // incompatible
			if (substitutes.length == 0) {
		    	// raw generic method inferred
		    	this.isRaw = true;
				this.isUnchecked = false;
		    	for (int i = 0; i < varLength; i++) {
		    		this.typeArguments[i] = originalVariables[i].upperBound();
		    	}
		    	break computeSubstitutes;
			}
			// this.typeArguments = substitutes; - no op since side effects got performed during #resolveSubstituteConstraints
	    	for (int i = 0; i < varLength; i++) {
	    		TypeBinding substitute = substitutes[i];
	    		if (substitute != null) {
	    			this.typeArguments[i] = substitutes[i];
	    		} else {
	    			// remaining unresolved variable are considered to be Object (or their bound actually)
		    		this.typeArguments[i] = originalVariables[i].upperBound();
		    	}
	    	}
		}		
		// adjust method types to reflect latest inference
		TypeBinding oldReturnType = this.returnType;
		this.returnType = Scope.substitute(this, this.returnType);
		this.inferredReturnType = this.returnType != oldReturnType;
	    this.parameters = Scope.substitute(this, this.parameters);
	    this.thrownExceptions = Scope.substitute(this, this.thrownExceptions);
	    return this;
	}

