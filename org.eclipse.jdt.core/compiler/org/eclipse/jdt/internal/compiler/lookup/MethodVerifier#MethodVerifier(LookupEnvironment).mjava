/*
Binding creation is responsible for reporting all problems with types:
	- all modifier problems (duplicates & multiple visibility modifiers + incompatible combinations - abstract/final)
		- plus invalid modifiers given the context (the verifier did not do this before)
	- qualified name collisions between a type and a package (types in default packages are excluded)
	- all type hierarchy problems:
		- cycles in the superclass or superinterface hierarchy
		- an ambiguous, invisible or missing superclass or superinterface
		- extending a final class
		- extending an interface instead of a class
		- implementing a class instead of an interface
		- implementing the same interface more than once (ie. duplicate interfaces)
	- with nested types:
		- shadowing an enclosing type's source name
		- defining a static class or interface inside a non-static nested class
		- defining an interface as a local type (local types can only be classes)

verifyTypeStructure

	| hasHierarchyProblem superclass current names interfaces interfacesByIndentity duplicateExists invalidType |

	(type basicModifiers anyMask: AccModifierProblem | AccAlternateModifierProblem) ifTrue: [
		self reportModifierProblemsOnType: type].

	type controller isJavaDefaultPackage ifFalse: [
		(nameEnvironment class doesPackageExistNamed: type javaQualifiedName) ifTrue: [
			problemSummary
				reportVerificationProblem: #CollidesWithPackage
				args: (Array with: type javaQualifiedName)
				severity: nil
				forType: type]].

	hasHierarchyProblem := false.

	type isJavaClass
		ifTrue: [
			(superclass := self superclassFor: type) ~~ nil ifTrue: [
				superclass isBuilderClass ifTrue: [
					superclass := superclass newClass].
				superclass isJavaMissing
					ifTrue: [
						hasHierarchyProblem := true.
						type javaSuperclassIsMissing ifTrue: [
							problemSummary
								reportVerificationProblem: #MissingSuperclass
								args: (Array with: superclass javaQualifiedName with: superclass unmatchedDescriptor)
								severity: nil
								forType: type].
						type javaSuperclassCreatesCycle ifTrue: [
							problemSummary
								reportVerificationProblem: #CyclicSuperclass
								args: (Array with: superclass javaQualifiedName)
								severity: nil
								forType: type].
						type javaSuperclassIsInterface ifTrue: [
							problemSummary
								reportVerificationProblem: #ClassCannotExtendAnInterface
								args: (Array with: superclass javaQualifiedName)
								severity: nil
								forType: type]]
					ifFalse: [
						"NOTE:  If type is a Java class and its superclass is
						a valid descriptor then it should NEVER be an interface."

						superclass isJavaFinal ifTrue: [
							problemSummary
								reportVerificationProblem: #ClassCannotExtendFinalClass
								args: nil
								severity: nil
								forType: type]]]]
		ifFalse: [
			type isJavaLocalType ifTrue: [
				problemSummary
					reportVerificationProblem: #CannotDefineLocalInterface
					args: nil
					severity: nil
					forType: type]].

	type isJavaNestedType ifTrue: [
		(current := type) sourceName notEmpty ifTrue: [
			names := Set new.
			[(current := current enclosingType) ~~ nil] whileTrue: [
				names add: current sourceName].

			(names includes: type sourceName) ifTrue: [
				problemSummary
					reportVerificationProblem: #NestedTypeCannotShadowTypeName
					args: nil
					severity: nil
					forType: type]].

		(type enclosingType isJavaNestedType and: [type enclosingType isJavaClass]) ifTrue: [
			type enclosingType isJavaStatic ifFalse: [
				type isJavaClass
					ifTrue: [
						type isJavaStatic ifTrue: [
							problemSummary
								reportVerificationProblem: #StaticClassCannotExistInNestedClass
								args: nil
								severity: nil
								forType: type]]
					ifFalse: [
						problemSummary
							reportVerificationProblem: #InterfaceCannotExistInNestedClass
							args: nil
							severity: nil
							forType: type]]]].

	(interfaces := newClass superinterfaces) notEmpty ifTrue: [
		interfacesByIndentity := interfaces asSet.
		duplicateExists := interfaces size ~~ interfacesByIndentity size.

		interfacesByIndentity do: [:interface |
			duplicateExists ifTrue: [
				(interfaces occurrencesOf: interface) > 1 ifTrue: [
					problemSummary
						reportVerificationProblem: #InterfaceIsSpecifiedMoreThanOnce
						args: (Array with: interface javaQualifiedName)
						severity: nil
						forType: type]].

			interface isJavaMissing ifTrue: [
				hasHierarchyProblem := true.
				interface basicClass == JavaInterfaceIsClass basicClass
					ifTrue: [
						problemSummary
							reportVerificationProblem: #UsingClassWhereInterfaceIsRequired
							args: (Array with: interface javaQualifiedName)
							severity: nil
							forType: type]
					ifFalse: [
						interface basicClass == JavaMissingInterface basicClass
							ifTrue: [
								problemSummary
									reportVerificationProblem: #MissingInterface
									args: (Array with: interface javaQualifiedName with: interface unmatchedDescriptor)
									severity: nil
									forType: type]
							ifFalse: [
								problemSummary
									reportVerificationProblem: #CyclicSuperinterface
									args: (Array with: interface javaQualifiedName)
									severity: nil
									forType: type]]]]].

	hasHierarchyProblem ifFalse: [
		"Search up the type's hierarchy for
			1. missing superclass,
			2. superclass cycle, or
			3. superclass is interface."
		(invalidType := newClass findFirstInvalidSupertypeSkipping: EsIdentitySet new) ~~ nil ifTrue: [
			problemSummary
				reportVerificationProblem: #HasHierarchyProblem
				args: (Array with: invalidType javaReadableName)
				severity: nil
				forType: type]]

reportModifierProblemsOnType: aType

	(type basicModifiers anyMask: AccAlternateModifierProblem) ifTrue: [
		(type basicModifiers anyMask: AccModifierProblem)
			ifTrue: [
				^problemSummary
					reportVerificationProblem: #OnlyOneVisibilityModifierAllowed
					args: nil
					severity: nil
					forType: aType]
			ifFalse: [
				^problemSummary
					reportVerificationProblem: #DuplicateModifier
					args: nil
					severity: nil
					forType: aType]].

	type isJavaInterface ifTrue: [
		^problemSummary
			reportVerificationProblem: #IllegalModifierForInterface
			args: nil
			severity: nil
			forType: aType].

	(type basicModifiers allMask: AccAbstract | AccFinal) ifTrue: [
		^problemSummary
			reportVerificationProblem: #IllegalModifierCombinationAbstractFinal
			args: nil
			severity: nil
			forType: aType].

	^problemSummary
		reportVerificationProblem: #IllegalModifierForClass
		args: nil
		severity: nil
		forType: aType

void reportModifierProblems() {
	if (this.type.isAbstract() && this.type.isFinal())
		this.problemReporter.illegalModifierCombinationAbstractFinal(this.type);

	// Should be able to detect all 3 problems NOT just 1
	if ((type.modifiers() & Modifiers.AccAlternateModifierProblem) == 0) {
		if (this.type.isInterface())
			this.problemReporter.illegalModifierForInterface(this.type);
		else
			this.problemReporter.illegalModifier(this.type);
	} else {
		if ((type.modifiers() & Modifiers.AccModifierProblem) != 0)
			this.problemReporter.onlyOneVisibilityModifierAllowed(this.type);
		else
			this.problemReporter.duplicateModifier(this.type);
	}
}
*/
public MethodVerifier(LookupEnvironment environment) {
	this.type = null;		// Initialized with the public method verify(SourceTypeBinding)
	this.inheritedMethods = null;
	this.currentMethods = null;
	this.runtimeException = null;
	this.errorException = null;
	this.environment = environment;
}

