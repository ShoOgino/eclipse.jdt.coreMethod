/*
Binding creation is responsible for reporting all problems with fields:
	- all modifier problems (duplicates & multiple visibility modifiers + incompatible combinations - final/volatile)
		- plus invalid modifiers given the context (the verifier did not do this before)
		- include initializers in the modifier checks even though bindings are not created
	- collisions... 2 fields with same name
	- interfaces cannot define initializers
	- nested types cannot define static fields
	- with the type of the field:
		- void is not a valid type (or for an array)
		- an ambiguous, invisible or missing type

verifyFields

	| toSearch |
	(toSearch := newClass fields) notEmpty ifTrue: [
		newClass fromJavaClassFile
			ifTrue: [
				toSearch do: [:field |
					field isJavaInitializer ifFalse: [
						self verifyFieldType: field]]]
			ifFalse: [
				toSearch do: [:field |
					field isJavaInitializer
						ifTrue: [self verifyFieldInitializer: field]
						ifFalse: [self verifyField: field]]]]

verifyFieldInitializer: field

	type isJavaInterface
		ifTrue: [
			problemSummary
				reportVerificationProblem: #InterfacesCannotHaveInitializers
				args: #()
				severity: nil
				forField: field]
		ifFalse: [
			field isJavaStatic
				ifTrue: [
					field modifiers == AccStatic ifFalse: [
						problemSummary
							reportVerificationProblem: #IllegalModifierForStaticInitializer
							args: #()
							severity: nil
							forField: field]]
				ifFalse: [
					field modifiers == 0 ifFalse: [
						problemSummary
							reportVerificationProblem: #IllegalModifierForInitializer
							args: #()
							severity: nil
							forField: field]]]

verifyField: field

	(field basicModifiers anyMask: AccAlternateModifierProblem | AccModifierProblem) ifTrue: [
		self reportModifierProblemsOnField: field].

	field isJavaStatic ifTrue: [
		type isJavaStatic ifFalse: [
			(type isJavaNestedType and: [type isJavaClass]) ifTrue: [
				problemSummary
					reportVerificationProblem: #NestedClassCannotHaveStaticField
					args: #()
					severity: nil
					forField: field]]].

	self verifyFieldType: field

verifyFieldType: field

	| descriptor fieldType |
	"8.3 (Class) 9.3 (Interface)"
	"Optimize the base type case"
	field typeIsBaseType
		ifTrue: [
			field typeName = 'V' ifTrue: [  "$NON-NLS$"
				problemSummary
					reportVerificationProblem: #IllegalTypeForField
					args: (Array with: JavaVoid)
					severity: nil
					forField: field]]
		ifFalse: [
			descriptor := field asDescriptorIn: nameEnvironment.
			(fieldType := descriptor type) isValidDescriptor
				ifTrue: [
					(fieldType isArrayType and: [fieldType leafComponentType isVoidType]) ifTrue: [
						problemSummary
							reportVerificationProblem: #InvalidArrayType
							args: (Array with: fieldType javaReadableName)
							severity: nil
							forField: field]]
				ifFalse: [
					problemSummary
						reportVerificationProblem: #UnboundTypeForField
						args: (Array with: fieldType javaReadableName with: fieldType leafComponentType)
						severity: nil
						forField: field]].

reportModifierProblemsOnField: field

	(field basicModifiers anyMask: AccAlternateModifierProblem) ifTrue: [
		(field basicModifiers anyMask: AccModifierProblem)
			ifTrue: [
				^problemSummary
					reportVerificationProblem: #OnlyOneVisibilityModifierAllowed
					args: #()
					severity: ErrorInfo::ConflictingModifier
					forField: field]
			ifFalse: [
				^problemSummary
					reportVerificationProblem: #DuplicateModifier
					args: #()
					severity: ErrorInfo::ConflictingModifier
					forField: field]].

	type isJavaInterface ifTrue: [
		^problemSummary
			reportVerificationProblem: #IllegalModifierForInterfaceField
			args: #()
			severity: nil
			forField: field].

	(field basicModifiers allMask: AccFinal |  AccVolatile) ifTrue: [
		^problemSummary
			reportVerificationProblem: #IllegalModifierCombinationFinalVolatile
			args: #()
			severity: nil
			forField: field].

	^problemSummary
		reportVerificationProblem: #IllegalModifierForField
		args: #()
		severity: nil
		forField: field

void reportModifierProblems(FieldBinding field) {
	if (field.isFinal() && field.isVolatile())
		this.problemReporter.illegalModifierCombinationFinalVolatile(field);

	// Should be able to detect all 3 problems NOT just 1
	if ((type.modifiers() & Modifiers.AccAlternateModifierProblem) == 0) {
		if (this.type.isInterface())
			this.problemReporter.illegalModifierForInterfaceField(field);
		else
			this.problemReporter.illegalModifier(field);
	} else {
		if ((field.modifiers & Modifiers.AccModifierProblem) != 0)
			this.problemReporter.onlyOneVisibilityModifierAllowed(field);
		else
			this.problemReporter.duplicateModifier(field);
	}
}
*/
private void zzImportProblems() {
}

