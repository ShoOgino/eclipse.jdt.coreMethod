void scanTypeForNullDefaultAnnotation(IBinaryType binaryType) {
	char[][] nonNullByDefaultAnnotationName = this.environment.getNonNullByDefaultAnnotationName();
	if (nonNullByDefaultAnnotationName == null)
		return; // not well-configured to use null annotations

	IBinaryAnnotation[] annotations = binaryType.getAnnotations();
	if (annotations != null) {
		long annotationBit = 0L;
		int nullness = NO_NULL_DEFAULT;
		int length = annotations.length;
		for (int i = 0; i < length; i++) {
			char[] annotationTypeName = annotations[i].getTypeName();
			if (annotationTypeName[0] != Util.C_RESOLVED)
				continue;
			char[][] typeName = CharOperation.splitOn('/', annotationTypeName, 1, annotationTypeName.length-1); // cut of leading 'L' and trailing ';'
			if (CharOperation.equals(typeName, nonNullByDefaultAnnotationName)) {
				IBinaryElementValuePair[] elementValuePairs = annotations[i].getElementValuePairs();
				if (elementValuePairs != null && elementValuePairs.length == 1) {
					Object value = elementValuePairs[0].getValue();
					if (value instanceof BooleanConstant
						&& !((BooleanConstant)value).booleanValue())
					{
						// parameter is 'false': this means we cancel defaults from outer scopes:
						annotationBit = TagBits.AnnotationNullUnspecifiedByDefault;
						nullness = NULL_UNSPECIFIED_BY_DEFAULT;
						break;
					}
				}
				annotationBit = TagBits.AnnotationNonNullByDefault;
				nullness = NONNULL_BY_DEFAULT;
				break;
			}
		}
		if (annotationBit != 0L) {
			this.tagBits |= annotationBit;
			if (CharOperation.equals(this.sourceName(), TypeConstants.PACKAGE_INFO_NAME))
				this.getPackage().defaultNullness = nullness;
		} else {
			switch (this.getPackage().defaultNullness) {
				case NONNULL_BY_DEFAULT : 
					this.tagBits |= TagBits.AnnotationNonNullByDefault;
					break;
				case NULL_UNSPECIFIED_BY_DEFAULT :
					this.tagBits |= TagBits.AnnotationNullUnspecifiedByDefault;
					break;
			}
		}
	}
}

