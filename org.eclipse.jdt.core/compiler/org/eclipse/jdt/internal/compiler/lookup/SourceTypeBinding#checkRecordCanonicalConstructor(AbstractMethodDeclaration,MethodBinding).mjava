private void checkRecordCanonicalConstructor(AbstractMethodDeclaration methodDecl,
		MethodBinding explicitCanonicalConstructor) {
	if (!explicitCanonicalConstructor.isPublic())
		this.scope.problemReporter().recordCanonicalConstructorNotPublic(methodDecl);
	TypeParameter[] typeParameters = methodDecl.typeParameters();
	if (typeParameters != null && typeParameters.length > 0)
		this.scope.problemReporter().recordCanonicalConstructorShouldNotBeGeneric(methodDecl);
	if (explicitCanonicalConstructor.thrownExceptions != null && explicitCanonicalConstructor.thrownExceptions.length > 0)
		this.scope.problemReporter().recordCanonicalConstructorHasThrowsClause(methodDecl);
	explicitCanonicalConstructor.tagBits |= TagBits.IsCanonicalConstructor;
	ASTVisitor visitor = new ASTVisitor() {
		@Override
		public boolean visit(ExplicitConstructorCall explicitConstructorCall, BlockScope skope) {
			if (explicitConstructorCall.accessMode != ExplicitConstructorCall.ImplicitSuper)
				skope.problemReporter().recordCanonicalConstructorHasExplicitConstructorCall(explicitConstructorCall);
			return false;
		}
		@Override
		public boolean visit(MethodDeclaration methodDeclaration, ClassScope skope) {
			return false;
		}
		@Override
		public boolean visit(LambdaExpression lambda, BlockScope skope) {
			return false;
		}
		@Override
		public boolean visit(ReturnStatement returnStatement, BlockScope skope) {
			skope.problemReporter().recordCompactConstructorHasReturnStatement(returnStatement);
			return false;
		}
	};
	methodDecl.traverse(visitor, this.scope);
}

