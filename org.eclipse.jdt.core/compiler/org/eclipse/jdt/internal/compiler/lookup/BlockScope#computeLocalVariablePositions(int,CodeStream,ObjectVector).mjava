public final void computeLocalVariablePositions(int initOffset, CodeStream codeStream, ObjectVector returnAddresses) {

	this.offset = initOffset;
	this.maxOffset = initOffset;
	
	// local variable init
	int ilocal = 0, maxLocals = 0, localsLength = locals.length;
	while ((maxLocals < localsLength) && (locals[maxLocals] != null))
		maxLocals++;
	boolean hasMoreVariables = maxLocals > 0;
	
	// scope init
	int iscope = 0, maxScopes = 0, subscopesLength = subscopes.length;
	while ((maxScopes < subscopesLength) && (subscopes[maxScopes] != null))
		maxScopes++;
	boolean hasMoreScopes = maxScopes > 0;

	// iterate scopes and variables in parallel
	while (hasMoreVariables || hasMoreScopes) {
		if (hasMoreScopes && (!hasMoreVariables || (subscopes[iscope].startIndex() <= ilocal))) {
			// consider subscope first
			if (subscopes[iscope] instanceof BlockScope) {
				BlockScope subscope = (BlockScope) subscopes[iscope];
				int subOffset = subscope.shiftScope == null ? this.offset : subscope.shiftScope.offset;
				subscope.computeLocalVariablePositions(subOffset, codeStream, returnAddresses);
				if (subscope.maxOffset > this.maxOffset) this.maxOffset = subscope.maxOffset;
			}
			hasMoreScopes = ++iscope < maxScopes;
		} else {	
			// consider variable first
			LocalVariableBinding local = locals[ilocal];

			// check if variable is actually used, and may force it to be preserved
			boolean generatesLocal = (local.used && (local.constant == Constant.NotAConstant)) || local.isArgument;
			if (!local.used && (local.declaration != null)) { // unused (and non secret) local
				if (local.isArgument) // method argument
					this.problemReporter().unusedArgument(local.declaration);
				else if (!(local.declaration instanceof Argument)) // catch variable
					this.problemReporter().unusedLocalVariable(local.declaration);
			} 
			if (!generatesLocal) {
				if (local.declaration != null && referenceCompilationUnit().problemReporter.options.preserveAllLocalVariables) {
					generatesLocal = true; // force it to be preserved in the generated code
					local.used = true;
				}
			}
			if (generatesLocal) {
				
				// Return addresses are managed separately afterwards.
				if (local.name == TryStatement.SecretReturnName){
					returnAddresses.add(local);
				} else {

					if (local.declaration != null){
						codeStream.record(local); // record user local variables for attribute generation
					}

					// allocate variable position
					local.resolvedPosition = this.offset;
							
					// check for too many arguments/local variables
					if(local.isArgument){
						if (offset > 0xFF){ // no more than 255 words of arguments
							this.problemReporter().noMoreAvailableSpaceForArgument(local.declaration);
						}
					} else {
						if(offset > 0xFFFF){ // no more than 65535 words of locals
							this.problemReporter().noMoreAvailableSpaceForLocal(local.declaration);
						}
					}
					
					// increment offset
					if ((local.type == LongBinding) || (local.type == DoubleBinding)){
						this.offset += 2;
					} else {
						this.offset++;
					}
				}
			} else {
				local.resolvedPosition = -1; // not generated
			}
			hasMoreVariables = ++ilocal < maxLocals;
		}
	}
	if (this.offset > this.maxOffset) this.maxOffset = this.offset;
}

