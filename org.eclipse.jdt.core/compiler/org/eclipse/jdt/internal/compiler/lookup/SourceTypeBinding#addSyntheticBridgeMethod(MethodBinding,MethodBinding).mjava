/* 
 * Record the fact that bridge methods need to be generated to override certain inherited methods
 */
public SyntheticMethodBinding addSyntheticBridgeMethod(MethodBinding inheritedMethodToBridge, MethodBinding localTargetMethod) {
	if (!isClass()) return null; // only classes get bridge methods
	if (inheritedMethodToBridge.returnType.erasure() == localTargetMethod.returnType.erasure())
		if (inheritedMethodToBridge.areParameterErasuresEqual(localTargetMethod))
			return null; // do not need bridge method

	if (synthetics == null) {
		synthetics = new HashMap[4];
	}
	if (synthetics[METHOD_EMUL] == null) {
		synthetics[METHOD_EMUL] = new HashMap(5);
	} else {
		// TODO (philippe) MethodBindings do not implement equals() so how do we prevent adding 2 'equal' inherited methods?
		// check to see if there is another equivalent inheritedMethod already added
		Iterator synthMethods = synthetics[METHOD_EMUL].keySet().iterator();
		while (synthMethods.hasNext()) {
			Object method = synthMethods.next();
			if (method instanceof MethodBinding)
				if (inheritedMethodToBridge.returnType.erasure() == ((MethodBinding) method).returnType.erasure())
					if (inheritedMethodToBridge.areParameterErasuresEqual((MethodBinding) method))
						return null;
		}
	}

	SyntheticMethodBinding accessMethod = null;
	SyntheticMethodBinding[] accessors = (SyntheticMethodBinding[]) synthetics[METHOD_EMUL].get(inheritedMethodToBridge);
	if (accessors == null) {
		accessMethod = new SyntheticMethodBinding(inheritedMethodToBridge, localTargetMethod);
		synthetics[METHOD_EMUL].put(inheritedMethodToBridge, accessors = new SyntheticMethodBinding[2]);
		accessors[1] = accessMethod;		
	} else {
		if ((accessMethod = accessors[1]) == null) {
			accessMethod = new SyntheticMethodBinding(inheritedMethodToBridge, localTargetMethod);
			accessors[1] = accessMethod;
		}
	}
	return accessMethod;
}

