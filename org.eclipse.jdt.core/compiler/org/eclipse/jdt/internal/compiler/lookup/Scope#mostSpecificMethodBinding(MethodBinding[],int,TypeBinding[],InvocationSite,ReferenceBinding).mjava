	// caveat: this is not a direct implementation of JLS
	protected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite, ReferenceBinding receiverType) {
		int[] compatibilityLevels = new int[visibleSize];
		for (int i = 0; i < visibleSize; i++)
			compatibilityLevels[i] = parameterCompatibilityLevel(visible[i], argumentTypes);

		boolean useTiebreakMethod = invocationSite.genericTypeArguments() == null;
		MethodBinding[] moreSpecific = new MethodBinding[visibleSize];
		int count = 0;
		for (int level = 0, max = VARARGS_COMPATIBLE; level <= max; level++) {
			nextVisible : for (int i = 0; i < visibleSize; i++) {
				if (compatibilityLevels[i] != level) continue nextVisible;
				max = level; // do not examine further categories, will either return mostSpecific or report ambiguous case
				MethodBinding current = visible[i];
				MethodBinding original = current.original();
				MethodBinding tiebreakMethod = useTiebreakMethod ? current.tiebreakMethod() : current;
				for (int j = 0; j < visibleSize; j++) {
					if (i == j || compatibilityLevels[j] != level) continue;
					MethodBinding next = visible[j];
					if (original == next.original()) {
						// parameterized superclasses & interfaces may be walked twice from different paths so skip next from now on
						compatibilityLevels[j] = -1; 
						continue;
					}

					MethodBinding methodToTest = next;
					if (next instanceof ParameterizedGenericMethodBinding) {
						ParameterizedGenericMethodBinding pNext = (ParameterizedGenericMethodBinding) next;
						if (pNext.isRaw && !pNext.isStatic()) {
							// hold onto the raw substituted method
						} else {
							methodToTest = pNext.originalMethod;
						}
					}
					MethodBinding acceptable = computeCompatibleMethod(methodToTest, tiebreakMethod.parameters, invocationSite);
					/* There are 4 choices to consider with current & next :
					 foo(B) & foo(A) where B extends A
					 1. the 2 methods are equal (both accept each others parameters) -> want to continue
					 2. current has more specific parameters than next (so acceptable is a valid method) -> want to continue
					 3. current has less specific parameters than next (so acceptable is null) -> go on to next
					 4. current and next are not compatible with each other (so acceptable is null) -> go on to next
					 */
					if (acceptable == null || !acceptable.isValidBinding())
						continue nextVisible;
					if (!isAcceptableMethod(tiebreakMethod, acceptable))
						continue nextVisible;
					// pick a concrete method over a bridge method when parameters are equal since the return type of the concrete method is more specific
					if (current.isBridge() && !next.isBridge())
						if (tiebreakMethod.areParametersEqual(acceptable))
							continue nextVisible; // skip current so acceptable wins over this bridge method
				}
				moreSpecific[i] = current;
				count++;
			}
		}
		if (count == 1) {
			for (int i = 0; i < visibleSize; i++) {
				if (moreSpecific[i] != null) {
					compilationUnitScope().recordTypeReferences(visible[i].thrownExceptions);
					return visible[i];
				}
			}
		} else if (count == 0) {
			return new ProblemMethodBinding(visible[0], visible[0].selector, visible[0].parameters, ProblemReasons.Ambiguous);
		}

		// found several methods that are mutually acceptable -> must be equal
		// so now with the first acceptable method, find the 'correct' inherited method for each other acceptable method AND
		// see if they are equal after substitution of type variables (do the type variables have to be equal to be considered an override???)
		if (receiverType != null)
			receiverType = receiverType instanceof CaptureBinding ? receiverType : (ReferenceBinding) receiverType.erasure();
		nextSpecific : for (int i = 0; i < visibleSize; i++) {
			MethodBinding current = moreSpecific[i];
			if (current != null) {
				ReferenceBinding[] mostSpecificExceptions = null;
				SimpleSet possibleMethods = null;
				MethodBinding original = current.original();
				for (int j = 0; j < visibleSize; j++) {
					MethodBinding next = moreSpecific[j];
					if (next == null || i == j) continue;
					MethodBinding original2 = next.original();
					if (original.declaringClass == original2.declaringClass)
						break nextSpecific; // duplicates thru substitution

					if (!original.isAbstract()) {
						if (original2.isAbstract())
							continue; // only compare current against other concrete methods
						TypeBinding superType = original.declaringClass.findSuperTypeOriginatingFrom(original2.declaringClass.erasure());
						if (superType == null)
							continue nextSpecific; // current's declaringClass is not a subtype of next's declaringClass
						if (current.hasSubstitutedParameters() || original.typeVariables != Binding.NO_TYPE_VARIABLES) {
							if (original2.declaringClass != superType) {
								// must find inherited method with the same substituted variables
								MethodBinding[] superMethods = ((ReferenceBinding) superType).getMethods(original2.selector);
								for (int m = 0, l = superMethods.length; m < l; m++) {
									if (superMethods[m].original() == original2) {
										original2 = superMethods[m];
										break;
									}
								}
							}
							if (!environment().methodVerifier().isParameterSubsignature(original, original2))
								continue nextSpecific; // current does not override next
						}
					} else if (receiverType != null) { // should not be null if original isAbstract, but be safe
						TypeBinding superType = receiverType.findSuperTypeOriginatingFrom(original.declaringClass.erasure());
						if (original.declaringClass == superType || !(superType instanceof ReferenceBinding)) {
							// keep original
						} else {
							// must find inherited method with the same substituted variables
							MethodBinding[] superMethods = ((ReferenceBinding) superType).getMethods(original.selector);
							for (int m = 0, l = superMethods.length; m < l; m++) {
								if (superMethods[m].original() == original) {
									original = superMethods[m];
									break;
								}
							}
						}
						superType = receiverType.findSuperTypeOriginatingFrom(original2.declaringClass.erasure());
						if (original2.declaringClass == superType || !(superType instanceof ReferenceBinding)) {
							// keep original2
						} else {
							// must find inherited method with the same substituted variables
							MethodBinding[] superMethods = ((ReferenceBinding) superType).getMethods(original2.selector);
							for (int m = 0, l = superMethods.length; m < l; m++) {
								if (superMethods[m].original() == original2) {
									original2 = superMethods[m];
									break;
								}
							}
						}
						if (original.typeVariables != Binding.NO_TYPE_VARIABLES)
							original2 = original.computeSubstitutedMethod(original2, environment());
						if (original2 == null || !original.areParameterErasuresEqual(original2))
							continue nextSpecific; // current does not override next
						if (!original.returnType.isCompatibleWith(original2.returnType) &&
								!original.returnType.erasure().isCompatibleWith(original2.returnType.erasure())) {
							// 15.12.2
							continue nextSpecific; // choose original2 instead
						}
						if (original.thrownExceptions != original2.thrownExceptions) {
							if (mostSpecificExceptions == null)
								mostSpecificExceptions = original.thrownExceptions;
							if (possibleMethods == null)
								possibleMethods = new SimpleSet(3);
							int mostSpecificLength = mostSpecificExceptions.length;
							int original2Length = original2.thrownExceptions.length;
							SimpleSet temp = new SimpleSet(mostSpecificLength);
							nextException : for (int t = 0; t < mostSpecificLength; t++) {
								ReferenceBinding exception = mostSpecificExceptions[t];
								for (int s = 0; s < original2Length; s++) {
									if (exception.isCompatibleWith(original2.thrownExceptions[s])) {
										possibleMethods.add(current);
										temp.add(exception);
										continue nextException;
									} else if (original2.thrownExceptions[s].isCompatibleWith(exception)) {
										possibleMethods.add(next);
										temp.add(original2.thrownExceptions[s]);
										continue nextException;
									}
								}
							}
							mostSpecificExceptions = temp.elementSize == 0 ? Binding.NO_EXCEPTIONS : new ReferenceBinding[temp.elementSize];
							temp.asArray(mostSpecificExceptions);
						}
					}
				}
				if (mostSpecificExceptions != null) {
					Object[] values = possibleMethods.values;
					int exceptionLength = mostSpecificExceptions.length;
					nextMethod : for (int p = 0, vLength = values.length; p < vLength; p++) {
						MethodBinding possible = (MethodBinding) values[p];
						if (possible == null) continue nextMethod;
						ReferenceBinding[] itsExceptions = possible.thrownExceptions;
						if (itsExceptions.length == exceptionLength) {
							nextException : for (int e = 0; e < exceptionLength; e++) {
								ReferenceBinding exception = itsExceptions[e];
								for (int f = 0; f < exceptionLength; f++)
									if (exception == mostSpecificExceptions[f]) continue nextException;
								continue nextMethod;
							}
							return possible;
						}
					}
					return new MethodBinding(
						current.modifiers | ClassFileConstants.AccSynthetic,
						current.selector,
						current.returnType,
						current.parameters,
						mostSpecificExceptions,
						current.declaringClass
					);
				}
				return current;
			}
		}

		// if all moreSpecific methods are equal then see if duplicates exist because of substitution
		return new ProblemMethodBinding(visible[0], visible[0].selector, visible[0].parameters, ProblemReasons.Ambiguous);
	}

