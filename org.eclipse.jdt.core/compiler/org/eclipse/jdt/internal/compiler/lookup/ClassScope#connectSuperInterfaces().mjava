	/*
		Our current belief based on available JCK 1.3 tests is:
			inherited member types are visible as a potential superclass.
			inherited interfaces are visible when defining a superinterface.
	
		Error recovery story:
			ensure the superinterfaces contain only valid visible interfaces.
	
		Answer false if an error was reported against the sourceType.
	*/
	private boolean connectSuperInterfaces() {
		SourceTypeBinding sourceType = referenceContext.binding;
		sourceType.superInterfaces = NoSuperInterfaces;
		if (referenceContext.superInterfaces == null) {
			if (sourceType.isAnnotationType() && compilerOptions().sourceLevel >= JDK1_5) { // do not connect if source < 1.5 as annotation already got flagged as syntax error) {
				ReferenceBinding annotationType = getJavaLangAnnotationAnnotation();
				boolean foundCycle = detectHierarchyCycle(sourceType, annotationType, null);
				sourceType.superInterfaces = new ReferenceBinding[] { annotationType };
				return !foundCycle;
			}
			return true;
		}
		if (sourceType.id == T_JavaLangObject) // already handled the case of redefining java.lang.Object
			return true;

		boolean noProblems = true;
		int length = referenceContext.superInterfaces.length;
		ReferenceBinding[] interfaceBindings = new ReferenceBinding[length];
		int count = 0;
		nextInterface : for (int i = 0; i < length; i++) {
		    TypeReference superInterfaceRef = referenceContext.superInterfaces[i];
			ReferenceBinding superInterface = findSupertype(superInterfaceRef);
			if (superInterface == null) { // detected cycle
				sourceType.tagBits |= HierarchyHasProblems;
				noProblems = false;
				continue nextInterface;
			}
			superInterfaceRef.resolvedType = superInterface; // hold onto the problem type
			// check for simple interface collisions 
			// Check for a duplicate interface once the name is resolved, otherwise we may be confused (ie : a.b.I and c.d.I)
			for (int j = 0; j < i; j++) {
				if (interfaceBindings[j] == superInterface) {
					problemReporter().duplicateSuperinterface(sourceType, superInterfaceRef, superInterface);
					continue nextInterface;
				}
			}
			if (!superInterface.isInterface()) {
				problemReporter().superinterfaceMustBeAnInterface(sourceType, superInterfaceRef, superInterface);
				sourceType.tagBits |= HierarchyHasProblems;
				noProblems = false;
				continue nextInterface;
			} else if (superInterface.isAnnotationType()){
				problemReporter().annotationTypeUsedAsSuperinterface(sourceType, superInterfaceRef, superInterface);
			}
			if ((superInterface.tagBits & TagBits.HasDirectWildcard) != 0) {
				problemReporter().superTypeCannotUseWildcard(sourceType, superInterfaceRef, superInterface);
				sourceType.tagBits |= HierarchyHasProblems;
				noProblems = false;
				continue nextInterface;
			}
			// only want to reach here when no errors are reported
			interfaceBindings[count++] = superInterface;
		}
		// check for parameterized interface collisions (when different parameterizations occur)
		if (compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5) {
			TypeBinding[] types = new TypeBinding[2];
			Map invocations = new HashMap(2);
			nextInterface: for (int i = 0; i < count; i++) {
				ReferenceBinding superInterface =  interfaceBindings[i];
				// check against superclass
				if (!sourceType.isInterface()) {
					types[0] = sourceType.superclass;
					types[1] = superInterface;
					TypeBinding[] mecs = minimalErasedCandidates(types, invocations);
					if (mecs != null) {
						nextCandidate: for (int k = 0, max = mecs.length; k < max; k++) {
							TypeBinding mec = mecs[k];
							if (mec == null) continue nextCandidate;
							Set invalidInvocations = (Set)invocations.get(mec);
							int invalidSize = invalidInvocations.size();
							if (invalidSize > 1) {
								TypeBinding[] collisions;
								invalidInvocations.toArray(collisions = new TypeBinding[invalidSize]);
								problemReporter().superinterfacesCollide(collisions[0].erasure(), referenceContext, collisions[0], collisions[1]);
								sourceType.tagBits |= HierarchyHasProblems;
								noProblems = false;
								continue nextInterface;
							}
						}					
					}					
				}
				// check against other super-interfaces
				types[0] = superInterface;
				nextOtherInterface: for (int j = 0; j < i; j++) {
					ReferenceBinding otherInterface = interfaceBindings[j];
					if (otherInterface == null) continue nextOtherInterface;
					types[1] = otherInterface;
					invocations.clear();
					TypeBinding[] mecs = minimalErasedCandidates(types, invocations);
					if (mecs != null) {
						nextCandidate: for (int k = 0, max = mecs.length; k < max; k++) {
							TypeBinding mec = mecs[k];
							if (mec == null) continue nextCandidate;
							Set invalidInvocations = (Set)invocations.get(mec);
							int invalidSize = invalidInvocations.size();
							if (invalidSize > 1) {
								TypeBinding[] collisions;
								invalidInvocations.toArray(collisions = new TypeBinding[invalidSize]);
								problemReporter().superinterfacesCollide(collisions[0].erasure(), referenceContext, collisions[0], collisions[1]);
								sourceType.tagBits |= HierarchyHasProblems;
								noProblems = false;
								continue nextInterface;
							}
						}					
					}
				}
			}
		}
		// hold onto all correctly resolved superinterfaces
		if (count > 0) {
			if (count != length)
				System.arraycopy(interfaceBindings, 0, interfaceBindings = new ReferenceBinding[count], 0, count);
			sourceType.superInterfaces = interfaceBindings;
		}
		return noProblems;
	}

