void checkInheritedMethods(MethodBinding[] methods, int length) {
	int count = length;
	int[] skip = new int[count];
	nextMethod : for (int i = 0, l = length - 1; i < l; i++) {
		if (skip[i] == -1) continue nextMethod;
		MethodBinding method = methods[i];
		MethodBinding[] duplicates = null;
		for (int j = i + 1; j <= l; j++) {
			MethodBinding method2 = methods[j];
			if (method.declaringClass == method2.declaringClass && areMethodsEqual(method, method2)) {
				skip[j] = -1;
				if (duplicates == null)
					duplicates = new MethodBinding[length];
				duplicates[j] = method2;
			}
		}
		if (duplicates != null) {
			// found an inherited ParameterizedType that defines duplicate methods
			// if all methods are abstract or more than 1 concrete method exists, then consider them to be duplicates
			// if a single concrete method 'implements' the abstract methods, then do not report a duplicate error
			int concreteCount = method.isAbstract() ? 0 : 1;
			MethodBinding methodToKeep = method; // if a concrete method exists, keep it, otherwise keep the first method
			for (int m = 0, s = duplicates.length; m < s; m++) {
				if (duplicates[m] != null) {
					if (!duplicates[m].isAbstract()) {
						methodToKeep = duplicates[m];
						concreteCount++;
					}
				}
			}
			if (concreteCount != 1) {
				for (int m = 0, s = duplicates.length; m < s; m++) {
					if (duplicates[m] != null) {
						problemReporter().duplicateInheritedMethods(this.type, method, duplicates[m]);
						count--;
						if (methodToKeep == duplicates[m])
							methods[i] = null;
						else
							methods[m] = null;
					}
				}
			}
		}
	}
	if (count < length) {
		if (count == 1) return; // no need to continue since only 1 inherited method is left
		MethodBinding[] newMethods = new MethodBinding[count];
		for (int i = length; --i >= 0;)
			if (methods[i] != null)
				newMethods[--count] = methods[i];
		methods = newMethods;
		length = newMethods.length;
	}

	super.checkInheritedMethods(methods, length);
}

