void checkNullSpecInheritance(MethodBinding currentMethod, MethodBinding inheritedMethod) {
	// precondition: caller has checked whether annotation-based null analysis is enabled.
	long inheritedBits = inheritedMethod.tagBits;
	long currentBits = currentMethod.tagBits;
	AbstractMethodDeclaration srcMethod = null;
	if (this.type.equals(currentMethod.declaringClass)) // is currentMethod from the current type?
		srcMethod = currentMethod.sourceMethod();

	// return type:
	if ((inheritedBits & TagBits.AnnotationNonNull) != 0) {
		long currentNullBits = currentBits & (TagBits.AnnotationNonNull|TagBits.AnnotationNullable);
		if (currentNullBits != TagBits.AnnotationNonNull) {
			if (srcMethod != null) {
				this.type.scope.problemReporter().illegalReturnRedefinition(srcMethod, inheritedMethod,
															this.environment.getNonNullAnnotationName());
			} else {
				this.type.scope.problemReporter().cannotImplementIncompatibleNullness(currentMethod, inheritedMethod);
				return;
			}
		}
	}

	// parameters:
	Argument[] currentArguments = srcMethod == null ? null : srcMethod.arguments;
	if (inheritedMethod.parameterNonNullness != null) {
		// inherited method has null-annotations, check compatibility:

		int length = inheritedMethod.parameterNonNullness.length;
		for (int i = 0; i < length; i++) {
			Argument currentArgument = currentArguments == null ? null : currentArguments[i];

			Boolean inheritedNonNullNess = inheritedMethod.parameterNonNullness[i];
			Boolean currentNonNullNess = (currentMethod.parameterNonNullness == null)
										? null : currentMethod.parameterNonNullness[i];
			if (inheritedNonNullNess != null) {				// super has a null annotation
				if (currentNonNullNess == null) {			// current parameter lacks null annotation
					boolean needNonNull = false;
					char[][] annotationName;
					if (inheritedNonNullNess == Boolean.TRUE) {
						needNonNull = true;
						annotationName = this.environment.getNonNullAnnotationName();
					} else {
						annotationName = this.environment.getNullableAnnotationName();
					}
					if (currentArgument != null) {
						this.type.scope.problemReporter().parameterLackingNullAnnotation(
								currentArgument,
								inheritedMethod.declaringClass,
								needNonNull,
								annotationName);
						continue;
					} else {
						this.type.scope.problemReporter().cannotImplementIncompatibleNullness(currentMethod, inheritedMethod);
						break;
					}
				}
			}
			if (inheritedNonNullNess != Boolean.TRUE) {		// super parameter is not restricted to @NonNull
				if (currentNonNullNess == Boolean.TRUE) { 	// current parameter is restricted to @NonNull
					if (currentArgument != null)
						this.type.scope.problemReporter().illegalRedefinitionToNonNullParameter(
														currentArgument,
														inheritedMethod.declaringClass,
														inheritedNonNullNess == null
														? null
														: this.environment.getNullableAnnotationName());
					else
						this.type.scope.problemReporter().cannotImplementIncompatibleNullness(currentMethod, inheritedMethod);
				}
			}
		}
	} else if (currentMethod.parameterNonNullness != null) {
		// super method has no annotations but current has
		for (int i = 0; i < currentMethod.parameterNonNullness.length; i++) {
			if (currentMethod.parameterNonNullness[i] == Boolean.TRUE) { // tightening from unconstrained to @NonNull
				if (currentArguments != null) {
					this.type.scope.problemReporter().illegalRedefinitionToNonNullParameter(
																	currentArguments[i],
																	inheritedMethod.declaringClass,
																	null);
				} else {
					this.type.scope.problemReporter().cannotImplementIncompatibleNullness(currentMethod, inheritedMethod);
					break;
				}
			}
		}
	}
}

