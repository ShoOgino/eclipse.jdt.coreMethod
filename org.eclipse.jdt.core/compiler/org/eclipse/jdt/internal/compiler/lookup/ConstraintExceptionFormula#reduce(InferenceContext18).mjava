	public Object reduce(InferenceContext18 inferenceContext) {
		// JLS 18.2.5
		Scope scope = inferenceContext.scope;
		if (!this.right.isFunctionalInterface(scope))
			return FALSE;
		MethodBinding sam = this.right.getSingleAbstractMethod(scope, true);
		if (sam == null)
			return FALSE;
		if (this.left instanceof LambdaExpression) {
			if (((LambdaExpression)this.left).argumentsTypeElided()) {
				int nParam = sam.parameters.length;
				for (int i = 0; i < nParam; i++)
					if (!sam.parameters[i].isProperType(true))
						return FALSE;
			}
			if (sam.returnType != TypeBinding.VOID && !sam.returnType.isProperType(true))
				return FALSE;
		} else { // reference expression
			if (!((ReferenceExpression)this.left).isExactMethodReference()) {					
				int nParam = sam.parameters.length;
				for (int i = 0; i < nParam; i++)
					if (!sam.parameters[i].isProperType(true))
						return FALSE;
				if (sam.returnType != TypeBinding.VOID && !sam.returnType.isProperType(true))
					return FALSE;
			}
		}
		TypeBinding[] thrown = sam.thrownExceptions;
		InferenceVariable[] e = new InferenceVariable[thrown.length];
		int n = 0;
		for (int i = 0; i < thrown.length; i++)
			if (!thrown[i].isProperType(true))
				e[n++] = (InferenceVariable) thrown[i]; // thrown[i] is not a proper type, since it's an exception it must be an inferenceVariable, right?
		TypeBinding[] ePrime = null;
		if (this.left instanceof LambdaExpression) {
			LambdaExpression lambda = ((LambdaExpression) this.left).getResolvedCopyForInferenceTargeting(this.right);
			Set<TypeBinding> ePrimeSet = lambda.getThrownExceptions();
			ePrime = ePrimeSet.toArray(new TypeBinding[ePrimeSet.size()]);
		} else {
			ReferenceExpression referenceExpression = (ReferenceExpression)this.left;
			MethodBinding method = referenceExpression.findCompileTimeMethodTargeting(this.right, scope);
			if (method != null)
				ePrime = method.thrownExceptions;
		}
		if (ePrime == null)
			return TRUE; // TODO is it a bug if we actually get here?
		int m = ePrime.length;
		if (n == 0) {
			actual: for (int i = 0; i < m; i++) {
				for (int j = 0; j < thrown.length; j++)
					if (ePrime[i].isCompatibleWith(thrown[j]))
						continue actual;
				return FALSE;
			}
			return TRUE;
		} else {
			List<ConstraintFormula> result = new ArrayList<ConstraintFormula>();
			actual: for (int i = 0; i < m; i++) {
				for (int j = 0; j < thrown.length; j++)
					if (thrown[j].isProperType(true) && ePrime[i].isCompatibleWith(thrown[j]))
						continue actual;
				for (int j = 0; j < n; j++)
					result.add(ConstraintTypeFormula.create(ePrime[i], e[j], SUBTYPE));
			}				
			for (int j = 0; j < n; j++)
				inferenceContext.currentBounds.inThrows.add(e[j]);
			return result.toArray(new ConstraintFormula[result.size()]);
		}
	}

