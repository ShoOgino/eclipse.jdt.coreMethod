void checkAgainstInheritedMethods(MethodBinding currentMethod, MethodBinding[] methods, int length, MethodBinding[] otherInheritedMethods) {
	boolean isAnnotationMember = this.type.isAnnotationType();
	nextMethod : for (int i = length; --i >= 0;) {
		MethodBinding inheritedMethod = methods[i];
		if (currentMethod.isStatic() != inheritedMethod.isStatic()) {  // Cannot override a static method or hide an instance method
			problemReporter(currentMethod).staticAndInstanceConflict(currentMethod, inheritedMethod);
			continue nextMethod;
		}

		if (inheritedMethod.isAbstract()) {
			if (inheritedMethod.declaringClass.isInterface()) {
				currentMethod.modifiers |= CompilerModifiers.AccImplementing;
			} else {
				currentMethod.modifiers |= CompilerModifiers.AccImplementing | CompilerModifiers.AccOverriding;
			}
// with the above change an abstract method is tagged as implementing the inherited abstract method
//		if (!currentMethod.isAbstract() && inheritedMethod.isAbstract()) {
//			if ((currentMethod.modifiers & CompilerModifiers.AccOverriding) == 0)
//				currentMethod.modifiers |= CompilerModifiers.AccImplementing;
		} else {
			currentMethod.modifiers |= CompilerModifiers.AccOverriding;
		}

		if (isAnnotationMember) {
			// annotation cannot override any method
			problemReporter().annotationCannotOverrideMethod(currentMethod, inheritedMethod);
			return; // do not repoort against subsequent inherited methods
		}		
		if (!areReturnTypesEqual(currentMethod, inheritedMethod)) {
			problemReporter(currentMethod).incompatibleReturnType(currentMethod, inheritedMethod);
		} else {
			if (currentMethod.thrownExceptions != NoExceptions)
				checkExceptions(currentMethod, inheritedMethod);
			if (inheritedMethod.isFinal())
				problemReporter(currentMethod).finalMethodCannotBeOverridden(currentMethod, inheritedMethod);
			if (!isAsVisible(currentMethod, inheritedMethod))
				problemReporter(currentMethod).visibilityConflict(currentMethod, inheritedMethod);
			if (environment.options.reportDeprecationWhenOverridingDeprecatedMethod && inheritedMethod.isViewedAsDeprecated()) {
				if (!currentMethod.isViewedAsDeprecated() || environment.options.reportDeprecationInsideDeprecatedCode) {
					// check against the other inherited methods to see if they hide this inheritedMethod
					ReferenceBinding declaringClass = inheritedMethod.declaringClass;
					if (declaringClass.isInterface())
						for (int j = length; --j >= 0;)
							if (i != j && methods[j].declaringClass.implementsInterface(declaringClass, false))
								continue nextMethod;

					problemReporter(currentMethod).overridesDeprecatedMethod(currentMethod, inheritedMethod);
				}
			}
			checkForBridgeMethod(currentMethod, inheritedMethod, otherInheritedMethods);
		}
	}
}

