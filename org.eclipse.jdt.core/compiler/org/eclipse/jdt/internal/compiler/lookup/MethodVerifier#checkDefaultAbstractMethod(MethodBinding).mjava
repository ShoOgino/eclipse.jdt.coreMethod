private void checkDefaultAbstractMethod(MethodBinding abstractMethod) {
	ReferenceBinding superType = this.type.superclass();
	char[] selector = abstractMethod.selector;
	while (superType != abstractMethod.declaringClass && superType.isValidBinding()) {
		MethodBinding[] methods = superType.getMethods(selector);
		nextMethod : for (int m = methods.length; --m >= 0;) {
			MethodBinding method = methods[m];
			if (method.returnType != abstractMethod.returnType || !method.areParametersEqual(abstractMethod))
				continue nextMethod;
			if (method.isPrivate() || method.isConstructor() || method.isDefaultAbstract() || method.isAbstract())
				continue nextMethod;

			if (superType.fPackage == abstractMethod.declaringClass.fPackage) return; // found concrete implementation of abstract method in same package
			if (!superType.isAbstract()) return; // will report error against this type

			// non visible abstract methods cannot be overridden so the type must be defined abstract
			this.problemReporter().abstractMethodCannotBeOverridden(this.type, abstractMethod);
			return;
		}
		superType = superType.superclass();
	}
}
/*
"8.4.4"
Verify that newExceptions are all included in inheritedExceptions.
Assumes all exceptions are valid and throwable.
Unchecked exceptions (compatible with runtime & error) are ignored (see the spec on pg. 203).
*/

