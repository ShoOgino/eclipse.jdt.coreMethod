	/* API
	 *	
	 *	Answer the method binding that corresponds to selector, argumentTypes.
	 *	Start the lookup at the enclosing type of the receiver.
	 *	InvocationSite implements 
	 *		isSuperAccess(); this is used to determine if the discovered method is visible.
	 *		setDepth(int); this is used to record the depth of the discovered method
	 *			relative to the enclosing type of the receiver. (If the method is defined
	 *			in the enclosing type of the receiver, the depth is 0; in the next enclosing
	 *			type, the depth is 1; and so on
	 * 
	 *	If no visible method is discovered, an error binding is answered.
	 */
	public MethodBinding getImplicitMethod(char[] selector, TypeBinding[] argumentTypes, InvocationSite invocationSite) {

		boolean insideStaticContext = false;
		boolean insideConstructorCall = false;
		boolean insideTypeAnnotation = false;
		MethodBinding foundMethod = null;
		MethodBinding foundFuzzyProblem = null;
		// the weird method lookup case (matches method name in scope, then arg types, then visibility)
		MethodBinding foundInsideProblem = null;
		// inside Constructor call or inside static context
		Scope scope = this;
		int depth = 0;
		done : while (true) { // done when a COMPILATION_UNIT_SCOPE is found
			switch (scope.kind) {
				case METHOD_SCOPE :
					MethodScope methodScope = (MethodScope) scope;
					insideStaticContext |= methodScope.isStatic;
					insideConstructorCall |= methodScope.isConstructorCall;
					insideTypeAnnotation = methodScope.insideTypeAnnotation;
					break;
				case CLASS_SCOPE :
					ClassScope classScope = (ClassScope) scope;
					ReferenceBinding receiverType = classScope.enclosingReceiverType();
					if (!insideTypeAnnotation) {
						// retrieve an exact visible match (if possible)
						// compilationUnitScope().recordTypeReference(receiverType);   not needed since receiver is the source type
						MethodBinding methodBinding =
							(foundMethod == null)
								? classScope.findExactMethod(receiverType, selector, argumentTypes, invocationSite)
								: classScope.findExactMethod(receiverType, foundMethod.selector, foundMethod.parameters, invocationSite);
						if (methodBinding == null)
							methodBinding = classScope.findMethod(receiverType, selector, argumentTypes, invocationSite);
						if (methodBinding != null) { // skip it if we did not find anything
							if (methodBinding.problemId() == ProblemReasons.Ambiguous) {
								if (foundMethod == null || foundMethod.problemId() == ProblemReasons.NotVisible) {
									// supercedes any potential InheritedNameHidesEnclosingName problem
									return methodBinding;
								}
								// make the user qualify the method, likely wants the first inherited method (javac generates an ambiguous error instead)
								return new ProblemMethodBinding(
									methodBinding, // closest match
									selector,
									argumentTypes,
									ProblemReasons.InheritedNameHidesEnclosingName);
							}
							MethodBinding fuzzyProblem = null;
							MethodBinding insideProblem = null;
							if (methodBinding.isValidBinding()) {
								if (!methodBinding.isStatic()) {
									if (insideConstructorCall) {
										insideProblem =
											new ProblemMethodBinding(
												methodBinding, // closest match
												methodBinding.selector,
												methodBinding.parameters,
												ProblemReasons.NonStaticReferenceInConstructorInvocation);
									} else if (insideStaticContext) {
										insideProblem =
											new ProblemMethodBinding(
												methodBinding, // closest match
												methodBinding.selector,
												methodBinding.parameters,
												ProblemReasons.NonStaticReferenceInStaticContext);
									}
								}

								if (foundMethod == null) {
									if (receiverType == methodBinding.declaringClass
										|| (receiverType.getMethods(selector)) != Binding.NO_METHODS
										|| ((foundFuzzyProblem == null || foundFuzzyProblem.problemId() != ProblemReasons.NotVisible) && compilerOptions().complianceLevel >= ClassFileConstants.JDK1_4)) {
											// found a valid method in the 'immediate' scope (ie. not inherited)
											// OR the receiverType implemented a method with the correct name
											// OR in 1.4 mode (inherited visible shadows enclosing)
											if (depth > 0) {
												invocationSite.setDepth(depth);
												invocationSite.setActualReceiverType(receiverType);
											}
											// return the methodBinding if it is not declared in a superclass of the scope's binding (that is, inherited)
											if (foundFuzzyProblem != null && foundFuzzyProblem.problemId() != ProblemReasons.NotVisible)
												return foundFuzzyProblem;
											if (insideProblem != null)
												return insideProblem;
											return methodBinding;
										}
									}
							} else {
								fuzzyProblem = methodBinding;
							}

							if (foundMethod != null && foundMethod.declaringClass != methodBinding.declaringClass)
								if (receiverType == methodBinding.declaringClass || (receiverType.getMethods(selector)) != Binding.NO_METHODS)
									// if a method was found, complain when another is found in an 'immediate' enclosing type (that is, not inherited)
									// NOTE: Unlike fields, a non visible method hides a visible method
									return new ProblemMethodBinding(
										methodBinding, // closest match
										methodBinding.selector,
										methodBinding.parameters,
										ProblemReasons.InheritedNameHidesEnclosingName);

							if (foundMethod == null || (foundMethod.problemId() == ProblemReasons.NotVisible && methodBinding.problemId() != ProblemReasons.NotVisible)) {
								// only remember the methodBinding if its the first one found or the previous one was not visible & methodBinding is...
								// remember that private methods are visible if defined directly by an enclosing class
								if (depth > 0) {
									invocationSite.setDepth(depth);
									invocationSite.setActualReceiverType(receiverType);
								}
								foundFuzzyProblem = fuzzyProblem;
								foundInsideProblem = insideProblem;
								if (fuzzyProblem == null)
									foundMethod = methodBinding; // only keep it if no error was found
							}
						}
					}
					insideTypeAnnotation = false;
					depth++;
					insideStaticContext |= receiverType.isStatic();
					// 1EX5I8Z - accessing outer fields within a constructor call is permitted
					// in order to do so, we change the flag as we exit from the type, not the method
					// itself, because the class scope is used to retrieve the fields.
					MethodScope enclosingMethodScope = scope.methodScope();
					insideConstructorCall =
						enclosingMethodScope == null ? false : enclosingMethodScope.isConstructorCall;
					break;
				case COMPILATION_UNIT_SCOPE :
					break done;
			}
			scope = scope.parent;
		}

		if (foundFuzzyProblem != null)
			if (foundFuzzyProblem.problemId() != ProblemReasons.NotVisible && foundFuzzyProblem.problemId() != ProblemReasons.NotFound)
				return foundFuzzyProblem;
		if (foundInsideProblem != null)
			return foundInsideProblem;

		if (insideStaticContext && compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5) {
			if (foundFuzzyProblem != null && foundFuzzyProblem.declaringClass != null && foundFuzzyProblem.declaringClass.id == TypeIds.T_JavaLangObject)
				return foundFuzzyProblem; // static imports lose to methods from Object

			// at this point the scope is a compilation unit scope & need to check for imported static methods
			CompilationUnitScope unitScope = (CompilationUnitScope) scope;
			ImportBinding[] imports = unitScope.imports;
			if (imports != null) {
				ObjectVector visible = null;
				boolean skipOnDemand = false; // set to true when matched static import of method name so stop looking for on demand methods
				for (int i = 0, length = imports.length; i < length; i++) {
					ImportBinding importBinding = imports[i];
					if (importBinding.isStatic()) {
						Binding resolvedImport = importBinding.resolvedImport;
						MethodBinding possible = null;
						if (importBinding.onDemand) {
							if (!skipOnDemand && resolvedImport instanceof ReferenceBinding)
								// answers closest approximation, may not check argumentTypes or visibility
								possible = findMethod((ReferenceBinding) resolvedImport, selector, argumentTypes, invocationSite);
						} else {
							if (resolvedImport instanceof MethodBinding) {
								MethodBinding staticMethod = (MethodBinding) resolvedImport;
								if (CharOperation.equals(staticMethod.selector, selector))
									// answers closest approximation, may not check argumentTypes or visibility
									possible = findMethod(staticMethod.declaringClass, selector, argumentTypes, invocationSite);
							} else if (resolvedImport instanceof FieldBinding) {
								// check to see if there are also methods with the same name
								FieldBinding staticField = (FieldBinding) resolvedImport;
								if (CharOperation.equals(staticField.name, selector)) {
									// must find the importRef's type again since the field can be from an inherited type
									char[][] importName = importBinding.reference.tokens;
									TypeBinding referencedType = getType(importName, importName.length - 1);
									if (referencedType != null)
										// answers closest approximation, may not check argumentTypes or visibility
										possible = findMethod((ReferenceBinding) referencedType, selector, argumentTypes, invocationSite);
								}
							}
						}
						if (possible != null && possible != foundFuzzyProblem) {
							if (!possible.isValidBinding()) {
								if (foundFuzzyProblem == null)
									foundFuzzyProblem = possible; // answer as error case match
							} else if (possible.isStatic()) {
								MethodBinding compatibleMethod = computeCompatibleMethod(possible, argumentTypes, invocationSite);
								if (compatibleMethod != null) {
									if (compatibleMethod.isValidBinding()) {
										if (compatibleMethod.canBeSeenBy(unitScope.fPackage)) {
											if (visible == null || !visible.contains(compatibleMethod)) {
												ImportReference importReference = importBinding.reference;
												if (importReference != null) importReference.used = true;
												if (!skipOnDemand && !importBinding.onDemand) {
													visible = null; // forget previous matches from on demand imports
													skipOnDemand = true;
												}
												if (visible == null)
													visible = new ObjectVector(3);
												visible.add(compatibleMethod);
											}
										} else if (foundFuzzyProblem == null) {
											foundFuzzyProblem = new ProblemMethodBinding(compatibleMethod, selector, compatibleMethod.parameters, ProblemReasons.NotVisible);
										}
									} else if (foundFuzzyProblem == null) {
										foundFuzzyProblem = compatibleMethod;
									}
								} else if (foundFuzzyProblem == null) {
									foundFuzzyProblem = new ProblemMethodBinding(possible, selector, argumentTypes, ProblemReasons.NotFound);
								}
							}
						}
					}
				}
				if (visible != null) {
					MethodBinding[] temp = new MethodBinding[visible.size];
					visible.copyInto(temp);
					foundMethod = mostSpecificMethodBinding(temp, temp.length, argumentTypes, invocationSite, null);
				}
			}
		}

		if (foundMethod != null) {
			invocationSite.setActualReceiverType(foundMethod.declaringClass);
			return foundMethod;
		}
		if (foundFuzzyProblem != null)
			return foundFuzzyProblem;

		return new ProblemMethodBinding(selector, argumentTypes, ProblemReasons.NotFound);
	}

