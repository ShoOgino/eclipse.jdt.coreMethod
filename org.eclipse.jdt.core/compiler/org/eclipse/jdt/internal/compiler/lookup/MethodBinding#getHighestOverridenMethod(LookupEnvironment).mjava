/**
 * Return the highest method/constructor in supertype hierarchy with same selector and arguments
 */
public MethodBinding getHighestOverridenMethod(LookupEnvironment environment) {
	MethodBinding bestMethod = this;
    ReferenceBinding currentType = this.declaringClass;
    if (this.isConstructor()) {
    	// walk superclasses - only
    	do {
    		MethodBinding superMethod = currentType.getExactConstructor(this.parameters);
    		if (superMethod != null) {
    			bestMethod = superMethod;
    		}
    	} while ((currentType = currentType.superclass()) != null);
    	return bestMethod;
    }
    MethodVerifier verifier = environment.methodVerifier();
	// walk superclasses
	ReferenceBinding[] interfacesToVisit = null;
	int nextPosition = 0;
	do {
		MethodBinding[] superMethods = currentType.getMethods(this.selector);
		for (int i = 0, length = superMethods.length; i < length; i++) {
			if (verifier.doesMethodOverride(this, superMethods[i])) {
				bestMethod = superMethods[i];
				break;
			}
		}
		ReferenceBinding[] itsInterfaces = currentType.superInterfaces();
		if (itsInterfaces != null && itsInterfaces != Binding.NO_SUPERINTERFACES) {
			if (interfacesToVisit == null) {
				interfacesToVisit = itsInterfaces;
				nextPosition = interfacesToVisit.length;
			} else {
				int itsLength = itsInterfaces.length;
				if (nextPosition + itsLength >= interfacesToVisit.length)
					System.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[nextPosition + itsLength + 5], 0, nextPosition);
				nextInterface : for (int a = 0; a < itsLength; a++) {
					ReferenceBinding next = itsInterfaces[a];
					for (int b = 0; b < nextPosition; b++)
						if (next == interfacesToVisit[b]) continue nextInterface;
					interfacesToVisit[nextPosition++] = next;
				}
			}
		}
	} while ((currentType = currentType.superclass()) != null);
	if (bestMethod.declaringClass.id == TypeIds.T_JavaLangObject) {
		return bestMethod;
	}
	// walk superinterfaces
	for (int i = 0; i < nextPosition; i++) {
		currentType = interfacesToVisit[i];
		MethodBinding[] superMethods = currentType.getMethods(this.selector);
		for (int j = 0, length = superMethods.length; j < length; j++) {
			MethodBinding superMethod = superMethods[j];
			if (verifier.doesMethodOverride(this, superMethod)) {
				TypeBinding bestReturnType = bestMethod.returnType;
				if (bestReturnType == superMethod.returnType
						|| bestMethod.returnType.findSuperTypeOriginatingFrom(superMethod.returnType) != null) {
					bestMethod = superMethod;
				}
				break;
			}
		}
		ReferenceBinding[] itsInterfaces = currentType.superInterfaces();
		if (itsInterfaces != null && itsInterfaces != Binding.NO_SUPERINTERFACES) {
			int itsLength = itsInterfaces.length;
			if (nextPosition + itsLength >= interfacesToVisit.length)
				System.arraycopy(interfacesToVisit, 0, interfacesToVisit = new ReferenceBinding[nextPosition + itsLength + 5], 0, nextPosition);
			nextInterface : for (int a = 0; a < itsLength; a++) {
				ReferenceBinding next = itsInterfaces[a];
				for (int b = 0; b < nextPosition; b++)
					if (next == interfacesToVisit[b]) continue nextInterface;
				interfacesToVisit[nextPosition++] = next;
			}
		}
	}	
	return bestMethod;
}

