/**
 * Return true iff the return type of existingMethod is a valid replacement for
 * the one of substituteMethod in a method declaration, in the context specified 
 * thereafter. It is expected that substituteMethod is the result of the 
 * substitution of the type parameters of an inheritedMethod method according to 
 * the type parameters of existingMethod and the inheritance relationship 
 * between existingMethod's declaring type and inheritedMethod's declaring type,
 * where inheritedMethod is a method inherited by existingMethod's declaring 
 * type which is override compatible with existingMethod, except maybe for
 * their respective return types. If those conditions are not met, the result is
 * unspecified.
 * @param substituteMethod a proper substitute of a method inherited by existingMethod 
 * @param existingMethod the existing method under examination
 * @return true if the return type of existingMethod is a valid substitute for
 *         the one of substituteMethod
 */
boolean isReturnTypeSubstituable(MethodBinding substituteMethod, MethodBinding existingMethod) {
	class ReturnTypeSubstitution implements Substitution {
		TypeBinding replaced, replacer;
		ReturnTypeSubstitution(TypeBinding replaced, TypeBinding replacer) {
			this.replaced = replaced;
			this.replacer = replacer;
		}
		public LookupEnvironment environment() { 
			return environment; 
		}
		public boolean isRawSubstitution() { 
			return false; 
		}
		public TypeBinding substitute(TypeVariableBinding typeVariable) {
			return typeVariable == replaced ? replacer : typeVariable;
		}
	}
	if (substituteMethod.returnType instanceof TypeVariableBinding) {
		return ((TypeVariableBinding) substituteMethod.returnType).
			boundCheck(
				new ReturnTypeSubstitution(substituteMethod.returnType, existingMethod.returnType),
				existingMethod.returnType)  == TypeConstants.OK;
	} else if (substituteMethod.returnType instanceof ParameterizedTypeBinding) {
		if (! (existingMethod.returnType instanceof ParameterizedTypeBinding)) {
			return false;
		}
		ParameterizedTypeBinding substituteReturnType = (ParameterizedTypeBinding) substituteMethod.returnType,
			existingReturnType = (ParameterizedTypeBinding) existingMethod.returnType;
		if (substituteReturnType.type != existingReturnType.type) {
			return false;
		}
		for (int i = 0; i < substituteReturnType.arguments.length; i++) {
			TypeBinding substituteArgumentType, existingArgumentType;
			if (! (existingArgumentType = existingReturnType.arguments[i]).isCompatibleWith(
					substituteArgumentType = substituteReturnType.arguments[i])) {
				if (substituteArgumentType instanceof TypeVariableBinding) {
					if (((TypeVariableBinding) substituteArgumentType).
							boundCheck(
								new ReturnTypeSubstitution(substituteArgumentType, existingArgumentType),
								// we do not address the most general pattern of multiple type variables, nor the recursive case either
								existingArgumentType) != TypeConstants.OK) {
						return false;
					}
				} else {
					return false;
				}
			}
		}
		return true;
	}
	return false;
}

