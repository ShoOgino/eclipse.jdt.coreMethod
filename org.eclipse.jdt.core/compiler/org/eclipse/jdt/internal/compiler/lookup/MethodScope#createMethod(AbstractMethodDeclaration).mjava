/**
 * Error management:
 * 		keep null for all the errors that prevent the method to be created
 * 		otherwise return a correct method binding (but without the element
 *		that caused the problem) : i.e. Incorrect thrown exception
 */
MethodBinding createMethod(AbstractMethodDeclaration method) {
	// is necessary to ensure error reporting
	this.referenceContext = method;
	method.scope = this;
	SourceTypeBinding declaringClass = referenceType().binding;
	int modifiers = method.modifiers | ExtraCompilerModifiers.AccUnresolved;
	if (method.isConstructor()) {
		if (method.isDefaultConstructor())
			modifiers |= ExtraCompilerModifiers.AccIsDefaultConstructor;
		method.binding = new MethodBinding(modifiers, null, null, declaringClass);
		checkAndSetModifiersForConstructor(method.binding);
	} else {
		if (declaringClass.isInterface()) {// interface or annotation type
			if (method.isDefaultMethod()) {
				modifiers |= ClassFileConstants.AccPublic; // default method is not abstract
			} else {
				modifiers |= ClassFileConstants.AccPublic | ClassFileConstants.AccAbstract;
			}
		}
		method.binding =
			new MethodBinding(modifiers, method.selector, null, null, null, declaringClass);
		checkAndSetModifiersForMethod(method.binding);
	}
	this.isStatic = method.binding.isStatic();

	Argument[] argTypes = method.arguments;
	int argLength = argTypes == null ? 0 : argTypes.length;
	long sourceLevel = compilerOptions().sourceLevel;
	if (argLength > 0 && sourceLevel >= ClassFileConstants.JDK1_5) {
		Argument argument = argTypes[--argLength];
		if (argument.isVarArgs())
			method.binding.modifiers |= ClassFileConstants.AccVarargs;
		if (CharOperation.equals(argument.name, ConstantPool.This)) {
			if (argLength != 0 || sourceLevel <= ClassFileConstants.JDK1_7) {
				problemReporter().illegalThis(argument, method, sourceLevel);
			}
			if (argument.annotations != null) {
				method.receiverAnnotations = argument.annotations;
				method.bits |= ASTNode.HasTypeAnnotations;
			}
		}
		while (--argLength >= 0) {
			argument = argTypes[argLength];
			if (argument.isVarArgs())
				problemReporter().illegalVararg(argument, method);
			if (CharOperation.equals(argument.name, ConstantPool.This)) {
				if (argLength != 0 || sourceLevel <= ClassFileConstants.JDK1_7) {
					problemReporter().illegalThis(argument, method, sourceLevel);
				}
				if (argument.annotations != null) {
					method.receiverAnnotations = argument.annotations;
					method.bits |= ASTNode.HasTypeAnnotations;
				}
			}	
		}
	}

	TypeParameter[] typeParameters = method.typeParameters();
	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=324850, If they exist at all, process type parameters irrespective of source level.
    if (typeParameters == null || typeParameters.length == 0) {
	    method.binding.typeVariables = Binding.NO_TYPE_VARIABLES;
	} else {
		method.binding.typeVariables = createTypeVariables(typeParameters, method.binding);
		method.binding.modifiers |= ExtraCompilerModifiers.AccGenericSignature;
	}
	return method.binding;
}

