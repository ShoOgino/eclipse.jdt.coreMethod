	// Private subroutine for public APIs.
	private TypeBinding getAnnotatedType(TypeBinding type, TypeBinding enclosingType, TypeBinding [] typeArguments, AnnotationBinding[] annotations) {
		TypeBinding keyType = getUnannotatedType(type);
		TypeBinding[] cachedInfo = (TypeBinding[]) this.annotatedTypes.get(keyType);
		int i = 0;
		if (cachedInfo != null) {
			for (int length = cachedInfo.length; i < length; i++) {
				TypeBinding cachedType = cachedInfo[i];
				if (cachedType == null) break;
				if (cachedType.enclosingType() == enclosingType) {
					if (Util.effectivelyEqual(cachedType.getTypeAnnotations(), annotations) && Util.effectivelyEqual(cachedType.typeArguments(), typeArguments)) {
						return cachedType;
					}
				}
			}
		} else {
			this.annotatedTypes.put(keyType, cachedInfo = new TypeBinding[4]);
		}
		int length = cachedInfo.length;
		if (i == length) {
			System.arraycopy(cachedInfo, 0, cachedInfo = new TypeBinding[length * 2], 0, length);
			this.annotatedTypes.put(keyType, cachedInfo);
		}
		/* Add the new comer, retaining the same type binding id as the naked type. To materialize the new comer we can't use new since this is a general
		   purpose method designed to deal type bindings of all types. "Clone" the incoming type, specializing for any enclosing type that may itself be 
		   possibly be annotated. This is so the binding for @Outer Outer.Inner != Outer.@Inner Inner != @Outer Outer.@Inner Inner. Likewise so the bindings 
		   for @Readonly List<@NonNull String> != @Readonly List<@Nullable String> != @Readonly List<@Interned String> 
		*/
		TypeBinding unannotatedType = this.unannotatedTypeSystem.getUnannotatedType(type);
		TypeBinding annotatedType = type.clone(enclosingType);
		annotatedType.id = unannotatedType.id;
		annotatedType.setTypeAnnotations(annotations, this.environment.globalOptions.isAnnotationBasedNullAnalysisEnabled);
		return cachedInfo[i] = annotatedType;
	}

