	public void emulateOuterAccess(
		ReferenceBinding targetEnclosingType,
		boolean useDirectReference) {

		ReferenceBinding currentType = enclosingSourceType();
		if (currentType.isNestedType()
			&& currentType != targetEnclosingType){
			/*&& !targetEnclosingType.isSuperclassOf(currentType)*/

			if (useDirectReference) {
				// the target enclosing type is not in scope, we directly refer it
				// must also add a synthetic field if we're not inside a constructor
				NestedTypeBinding currentNestedType = (NestedTypeBinding) currentType;
				if (methodScope().isInsideInitializerOrConstructor())
					currentNestedType.addSyntheticArgument(targetEnclosingType);
				else
					currentNestedType.addSyntheticArgumentAndField(targetEnclosingType);
					
			} else { // indirect reference sequence
				int depth = 0;
				
				// saturate all the way up until reaching compatible enclosing type
				while (currentType.isLocalType()){
					NestedTypeBinding currentNestedType = (NestedTypeBinding) currentType;
					currentType = currentNestedType.enclosingType;
					
					if (depth == 0){
						if (methodScope().isInsideInitializerOrConstructor()) {
							// must also add a synthetic field if we're not inside a constructor
							currentNestedType.addSyntheticArgument(currentType);
						} else {
							currentNestedType.addSyntheticArgumentAndField(currentType);
						}					
					} else if (currentNestedType == targetEnclosingType 
										|| targetEnclosingType.isSuperclassOf(currentNestedType)) {
							break;
					} else {
						currentNestedType.addSyntheticArgumentAndField(currentType);
					} 
					depth++;
				}
			}
		}
	}

