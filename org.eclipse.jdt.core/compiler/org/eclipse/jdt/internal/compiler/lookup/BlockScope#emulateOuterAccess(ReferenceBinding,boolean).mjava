	public void emulateOuterAccess(
		ReferenceBinding targetEnclosingType,
		boolean useDirectReference) {

		ReferenceBinding currentType = enclosingSourceType();
		if (currentType.isNestedType()
			&& currentType != targetEnclosingType){
			/*&& !targetEnclosingType.isSuperclassOf(currentType)*/

			NestedTypeBinding currentNestedType = (NestedTypeBinding) currentType;
			if (useDirectReference) {
				// the target enclosing type is not in scope, we directly refer it
				// must also add a synthetic field if we're not inside a constructor
				if (methodScope().isInsideInitializerOrConstructor())
					currentNestedType.addSyntheticArgument(targetEnclosingType);
				else
					currentNestedType.addSyntheticArgumentAndField(targetEnclosingType);
			} else if (currentNestedType.isLocalType()) {
				// direct enclosing instance link
				// must also add a synthetic field if we're not inside a constructor
				currentType = currentNestedType.enclosingType;
				if (methodScope().isInsideInitializerOrConstructor())
					currentNestedType.addSyntheticArgument(currentType);
				else
					currentNestedType.addSyntheticArgumentAndField(currentType);
				// further indirect cases
				while (currentType.isNestedType()
					&& currentType != targetEnclosingType
					&& !targetEnclosingType.isSuperclassOf(currentType)) {

					currentNestedType = (NestedTypeBinding) currentType;
					currentType = currentNestedType.enclosingType;
					currentNestedType.addSyntheticArgumentAndField(currentType);
				}
			}
		}
	}

