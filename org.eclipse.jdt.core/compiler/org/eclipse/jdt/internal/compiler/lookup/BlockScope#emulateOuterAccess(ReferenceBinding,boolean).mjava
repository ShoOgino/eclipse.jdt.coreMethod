/**
* Record the suitable binding denoting a synthetic field or constructor argument,
* mapping to a given actual enclosing instance type in the scope context.
* Skip it if the enclosingType is actually the current scope's enclosing type.
*/

public void emulateOuterAccess(ReferenceBinding targetEnclosingType, boolean useDirectReference) {
	ReferenceBinding currentType = enclosingSourceType();
	if (currentType.isNestedType() && currentType != targetEnclosingType) {
		NestedTypeBinding currentNestedType = (NestedTypeBinding) currentType;		
		if (useDirectReference) {
			// the target enclosing type is not in scope, we directly refer it
			// must also add a synthetic field if we're not inside a constructor
			if (methodScope().isInsideInitializerOrConstructor())
				currentNestedType.addSyntheticArgument(targetEnclosingType);
			else
				currentNestedType.addSyntheticArgumentAndField(targetEnclosingType);
		} else if (currentNestedType.isLocalType()) {
			// direct enclosing instance link
			// must also add a synthetic field if we're not inside a constructor
			currentType = currentNestedType.enclosingType;
			if (methodScope().isInsideInitializerOrConstructor())
				currentNestedType.addSyntheticArgument(currentType);
			else
				currentNestedType.addSyntheticArgumentAndField(currentType);
			// further indirect cases
			while (currentType != targetEnclosingType && !targetEnclosingType.isSuperclassOf(currentType)) {
				currentNestedType = (NestedTypeBinding) currentType;
				currentType = currentNestedType.enclosingType;
				currentNestedType.addSyntheticArgumentAndField(currentType);
			}
		}
	}
}

