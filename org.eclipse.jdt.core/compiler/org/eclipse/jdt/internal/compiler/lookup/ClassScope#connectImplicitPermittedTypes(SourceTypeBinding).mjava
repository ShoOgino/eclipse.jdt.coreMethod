	// Call only when we know there's no explicit permits clause and this is a sealed type
	private void connectImplicitPermittedTypes(SourceTypeBinding sourceType) {
		List<ReferenceBinding> permitted = null;
		// And nested types
		if (sourceType.memberTypes != null) {
			for (ReferenceBinding subtype : sourceType.memberTypes) {
				if (!TypeBinding.equalsEquals(subtype, sourceType))
					if (subtype.findSuperTypeOriginatingFrom(sourceType) != null) {
						if (permitted == null)
							permitted = new ArrayList<>();
						permitted.add(subtype);
					}
			}
		}
		// Siblings
		ReferenceBinding[] siblings = null;
		if (sourceType.isMemberType()) {
			siblings = sourceType.enclosingType().memberTypes();
		} else {
			siblings = compilationUnitScope().topLevelTypes;
		}

		if (siblings != null) {
			for (ReferenceBinding sibling : siblings) {
				if (!TypeBinding.equalsEquals(sibling, sourceType)) {
					if (sibling.findSuperTypeOriginatingFrom(sourceType) != null) {
						if (permitted == null)
							permitted = new ArrayList<>();
						permitted.add(sibling);
					}
				}
			}
		}

		if (permitted == null || permitted.size() == 0) {
			problemReporter().sealedSealedTypeMissingPermits(sourceType, this.referenceContext);
		} else {
			ReferenceBinding[] permittedTypeBindings = new ReferenceBinding[permitted.size()];
			permitted.toArray(permittedTypeBindings);
			sourceType.setPermittedTypes(permittedTypeBindings);
			return;
		}
	}

