	public MethodBinding getSingleAbstractMethod(final Scope scope) {
		MethodBinding theAbstractMethod = genericType().getSingleAbstractMethod(scope);
		if (theAbstractMethod == null || !theAbstractMethod.isValidBinding())
			return theAbstractMethod;
		
		TypeBinding [] typeArguments = this.arguments; // A1 ... An 
		TypeVariableBinding [] typeParameters = genericType().typeVariables(); // P1 ... Pn
		TypeBinding [] types = new TypeBinding[typeArguments.length];  // T1 ... Tn
		for (int i = 0, length = typeArguments.length; i < length; i++) {
			TypeBinding typeArgument = typeArguments[i];
			switch (typeArgument.kind()) {
				case Binding.WILDCARD_TYPE :
					WildcardBinding wildcard = (WildcardBinding) typeArgument;
					switch(wildcard.boundKind) {
	    				case Wildcard.EXTENDS :
	    				case Wildcard.SUPER :
	    					types[i] = wildcard.bound;
	    					break;
	    				case Wildcard.UNBOUND :
	    					// if Pi has upper bound Bi that mentions none of P1...Pn, then Ti = Bi; otherwise, Ti = Object
	    					final TypeBinding upperBound = typeParameters[i].firstBound;
							if (upperBound == null || typeParametersMentioned(upperBound)) {
	    						types[i] = scope.getJavaLangObject();
	    					} else {
	    						types[i] = upperBound;
	    					}
	    					break;
					}
					break;
				default :
					types[i] = typeArgument;
					break;
			}
			if (typeParameters[i].boundCheck(null, types[i], scope) != TypeConstants.OK)
				return this.singleAbstractMethod = new ProblemMethodBinding(TypeConstants.ANONYMOUS_METHOD, null, ProblemReasons.NotAWellFormedParameterizedType);
		}
		ParameterizedTypeBinding parameterizedType = scope.environment().createParameterizedType(genericType(), types, this.enclosingType);
		return this.singleAbstractMethod = new ParameterizedMethodBinding(parameterizedType, theAbstractMethod);
	}

