/*
What do we hold onto:

1. when we resolve 'a.b.c', say we keep only 'a.b.c'
 & when we fail to resolve 'c' in 'a.b', lets keep 'a.b.c'
THEN when we come across a new/changed/removed item named 'a.b.c',
 we would find all references to 'a.b.c'
-> This approach fails because every type is resolved in every onDemand import to
 detect collision cases... so the references could be 10 times bigger than necessary.

2. when we resolve 'a.b.c', lets keep 'a.b' & 'c'
 & when we fail to resolve 'c' in 'a.b', lets keep 'a.b' & 'c'
THEN when we come across a new/changed/removed item named 'a.b.c',
 we would find all references to 'a.b' & 'c'
-> This approach does not have a space problem but fails to handle collision cases.
 What happens if a type is added named 'a.b'? We would search for 'a' & 'b' but
 would not find a match.

3. when we resolve 'a.b.c', lets keep 'a', 'a.b' & 'a', 'b', 'c'
 & when we fail to resolve 'c' in 'a.b', lets keep 'a', 'a.b' & 'a', 'b', 'c'
THEN when we come across a new/changed/removed item named 'a.b.c',
 we would find all references to 'a.b' & 'c'
OR 'a.b' -> 'a' & 'b'
OR 'a' -> '' & 'a'
-> As long as each single char[] is interned, we should not have a space problem
 and can handle collision cases.
*/
void recordReference(char[][] qualifiedName) {
	if (qualifiedReferences == null) return; // we're not recording dependencies

	int length = qualifiedName.length;
	switch (length) {
		case 0 : return;
		case 1 :
			recordReference(NoCharChar, qualifiedName[0]);
			return;
		case 2 :
			recordReference(new char[][] {qualifiedName[0]}, qualifiedName[1]);
			return;
		default :
			char[][] qName = new char[length - 1][];
			System.arraycopy(qualifiedName, 0, qName, 0, length - 1);
			recordReference(qName, qualifiedName[length - 1]);
	}
}

