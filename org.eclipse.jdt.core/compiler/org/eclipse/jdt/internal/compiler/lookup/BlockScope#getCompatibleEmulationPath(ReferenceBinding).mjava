	/*
	 * This retrieves the argument that maps to an enclosing instance of the suitable type,
	 * 	if not found then answers nil -- do not create one
	 *
	 *		#implicitThis		  	 					:  the implicit this will be ok
	 *		#((arg) this$n)								: available as a constructor arg
	 * 		#((arg) this$n access$m... access$p) 		: available as as a constructor arg + a sequence of synthetic accessors to synthetic fields
	 * 		#((fieldDescr) this$n access#m... access$p)	: available as a first synthetic field + a sequence of synthetic accessors to synthetic fields
	 * 		nil 		 														: not found
	 *
	 */
	public Object[] getCompatibleEmulationPath(ReferenceBinding targetEnclosingType) {

		MethodScope currentMethodScope = this.methodScope();
		SourceTypeBinding sourceType = currentMethodScope.enclosingSourceType();

		// identity check
		if (!currentMethodScope.isStatic 
			&& !currentMethodScope.isConstructorCall
			&& (sourceType == targetEnclosingType
				|| targetEnclosingType.isSuperclassOf(sourceType))) {
			return EmulationPathToImplicitThis; // implicit this is good enough
		}
		if (!sourceType.isNestedType()
			|| sourceType.isStatic()) { // no emulation from within non-inner types
			return null;
		}
		boolean insideConstructor =
			currentMethodScope.isInsideInitializerOrConstructor();
		// use synthetic constructor arguments if possible
		if (insideConstructor) {
			SyntheticArgumentBinding syntheticArg;
			if ((syntheticArg = ((NestedTypeBinding) sourceType).getSyntheticArgument(targetEnclosingType, this, false)) != null) {
				return new Object[] { syntheticArg };
			}
		}

		// use a direct synthetic field then
		if (!currentMethodScope.isStatic) {
			FieldBinding syntheticField;
			if ((syntheticField = sourceType.getSyntheticField(targetEnclosingType, this, false)) != null) {
				return new Object[] { syntheticField };
			}
			// could be reached through a sequence of enclosing instance link (nested members)
			Object[] path = new Object[2]; // probably at least 2 of them
			ReferenceBinding currentType = sourceType.enclosingType();
			if (insideConstructor) {
				path[0] = ((NestedTypeBinding) sourceType).getSyntheticArgument((SourceTypeBinding) currentType, this, false);
			} else {
				path[0] =
					sourceType.getSyntheticField((SourceTypeBinding) currentType, this, false);
			}
			if (path[0] != null) { // keep accumulating
				int count = 1;
				ReferenceBinding currentEnclosingType;
				while ((currentEnclosingType = currentType.enclosingType()) != null) {
					//done?
					if (currentType == targetEnclosingType
						|| targetEnclosingType.isSuperclassOf(currentType))
						break;
					syntheticField = ((NestedTypeBinding) currentType).getSyntheticField((SourceTypeBinding) currentEnclosingType, this, false);
					if (syntheticField == null)
						break;
					// append inside the path
					if (count == path.length) {
						System.arraycopy(path, 0, (path = new Object[count + 1]), 0, count);
					}
					// private access emulation is necessary since synthetic field is private
					path[count++] = ((SourceTypeBinding) syntheticField.declaringClass).addSyntheticMethod(syntheticField, true);
					currentType = currentEnclosingType;
				}
				if (currentType == targetEnclosingType
					|| targetEnclosingType.isSuperclassOf(currentType)) {
					return path;
				}
			}
		}
		return null;
	}

