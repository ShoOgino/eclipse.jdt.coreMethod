/*
For each inherited method identifier (message pattern - vm signature minus the return type)
	if current method exists
		if current's vm signature does not match an inherited signature then complain 
		else compare current's exceptions & visibility against each inherited method
	else
		if inherited methods = 1
			if inherited is abstract && type is NOT an interface or abstract, complain
		else
			if vm signatures do not match complain
			else
				find the concrete implementation amongst the abstract methods (can only be 1)
				if one exists then
					it must be a public instance method
					compare concrete's exceptions against each abstract method
				else
					complain about missing implementation only if type is NOT an interface or abstract
*/
private void checkMethods() { 
	boolean mustImplementAbstractMethods = this.type.isClass() && !this.type.isAbstract();
	char[][] methodSelectors = this.inheritedMethods.keyTable;
	for (int s = methodSelectors.length; --s >= 0;) {
		if (methodSelectors[s] != null) {
			MethodBinding[] current = (MethodBinding[]) this.currentMethods.get(methodSelectors[s]);
			MethodBinding[] inherited = (MethodBinding[]) this.inheritedMethods.valueTable[s];

			int index = -1;
			MethodBinding[] matchingInherited = new MethodBinding[inherited.length];
			if (current != null) {
				for (int i = 0, length1 = current.length; i < length1; i++) {
					while (index >= 0) matchingInherited[index--] = null; // clear the previous contents of the matching methods
					MethodBinding currentMethod = current[i];
					for (int j = 0, length2 = inherited.length; j < length2; j++) {
						if (inherited[j] != null && currentMethod.areParametersEqual(inherited[j])) {
							matchingInherited[++index] = inherited[j];
							inherited[j] = null; // do not want to find it again
						}
					}
					if (index >= 0)
						this.checkAgainstInheritedMethods(currentMethod, matchingInherited, index + 1); // pass in the length of matching
				}
			}
			for (int i = 0, length = inherited.length; i < length; i++) {
				while (index >= 0) matchingInherited[index--] = null; // clear the previous contents of the matching methods
				if (inherited[i] != null) {
					matchingInherited[++index] = inherited[i];
					for (int j = i + 1; j < length; j++) {
						if (inherited[j] != null && inherited[i].areParametersEqual(inherited[j])) {
							matchingInherited[++index] = inherited[j];
							inherited[j] = null; // do not want to find it again
						}
					}
				}
				if (index > 0) {
					this.checkInheritedMethods(matchingInherited, index + 1); // pass in the length of matching
				} else if (mustImplementAbstractMethods && index == 0 && matchingInherited[0].isAbstract()) {
					if (mustImplementAbstractMethod(matchingInherited[0])) {
						TypeDeclaration typeDeclaration = this.type.scope.referenceContext;
						if (typeDeclaration != null) {
							MethodDeclaration missingAbstractMethod = typeDeclaration.addMissingAbstractMethodFor(matchingInherited[0]);
							missingAbstractMethod.scope.problemReporter().abstractMethodMustBeImplemented(this.type, matchingInherited[0]);
						} else {
							this.problemReporter().abstractMethodMustBeImplemented(this.type, matchingInherited[0]);
						}
					}
				}
			}
		}
	}
}

