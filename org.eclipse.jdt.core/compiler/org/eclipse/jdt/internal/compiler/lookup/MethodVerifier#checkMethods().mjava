private void checkMethods() {
	boolean mustImplementAbstractMethods = this.type.isClass() && !this.type.isAbstract();
	char[][] methodSelectors = this.inheritedMethods.keyTable;
	for (int s = methodSelectors.length; --s >= 0;) {
		if (methodSelectors[s] != null) {
			MethodBinding[] current = (MethodBinding[]) this.currentMethods.get(methodSelectors[s]);
			MethodBinding[] inherited = (MethodBinding[]) this.inheritedMethods.valueTable[s];

			int index = -1;
			MethodBinding[] matchingInherited = new MethodBinding[inherited.length];
			if (current != null) {
				for (int i = 0, length1 = current.length; i < length1; i++) {
					while (index >= 0) matchingInherited[index--] = null; // clear the previous contents of the matching methods
					MethodBinding currentMethod = current[i];
					for (int j = 0, length2 = inherited.length; j < length2; j++) {
						if (inherited[j] != null && currentMethod.areParametersEqual(inherited[j])) {
							matchingInherited[++index] = inherited[j];
							inherited[j] = null; // do not want to find it again
						}
					}
					if (index >= 0)
						this.checkAgainstInheritedMethods(currentMethod, matchingInherited, index + 1); // pass in the length of matching
				}
			}
			for (int i = 0, length = inherited.length; i < length; i++) {
				while (index >= 0) matchingInherited[index--] = null; // clear the previous contents of the matching methods
				if (inherited[i] != null) {
					matchingInherited[++index] = inherited[i];
					for (int j = i + 1; j < length; j++) {
						if (inherited[j] != null && inherited[i].areParametersEqual(inherited[j])) {
							matchingInherited[++index] = inherited[j];
							inherited[j] = null; // do not want to find it again
						}
					}
				}
				if (index > 0) {
					this.checkInheritedMethods(matchingInherited, index + 1); // pass in the length of matching
				} else {
					if (mustImplementAbstractMethods && index == 0 && matchingInherited[0].isAbstract())
						if (mustImplementAbstractMethod(matchingInherited[0])) {
							TypeDeclaration typeDeclaration = this.type.scope.referenceContext;
							if (typeDeclaration != null) {
								MethodDeclaration missingAbstractMethod = typeDeclaration.addMissingAbstractMethodFor(matchingInherited[0]);
								missingAbstractMethod.scope.problemReporter().abstractMethodMustBeImplemented(this.type, matchingInherited[0]);
							} else {
								this.problemReporter().abstractMethodMustBeImplemented(this.type, matchingInherited[0]);
							}
						}
				}
			}
		}
	}
}

