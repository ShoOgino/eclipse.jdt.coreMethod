	/* Given an allocation type and arguments at the allocation site, answer a synthetic generic static factory method
	   that could instead be invoked with identical results. Return null if no compatible, visible, most specific method
	   could be found. This method is modeled after Scope.getConstructor and Scope.getMethod.
	 */
	public MethodBinding getStaticFactory (ReferenceBinding allocationType, ReferenceBinding originalEnclosingType, TypeBinding[] argumentTypes, final InvocationSite allocationSite) {
		TypeVariableBinding[] classTypeVariables = allocationType.typeVariables();
		int classTypeVariablesArity = classTypeVariables.length;
		MethodBinding[] methods = allocationType.getMethods(TypeConstants.INIT, argumentTypes.length);
		MethodBinding [] staticFactories = new MethodBinding[methods.length];
		int sfi = 0;
		for (int i = 0, length = methods.length; i < length; i++) {
			MethodBinding method = methods[i];
			int paramLength = method.parameters.length;
			boolean isVarArgs = method.isVarargs();
			if (argumentTypes.length != paramLength)
				if (!isVarArgs || argumentTypes.length < paramLength - 1)
					continue; // incompatible
			TypeVariableBinding[] methodTypeVariables = method.typeVariables();
			int methodTypeVariablesArity = methodTypeVariables.length;
	        
			MethodBinding staticFactory = new MethodBinding(method.modifiers | ClassFileConstants.AccStatic, TypeConstants.SYNTHETIC_STATIC_FACTORY,
																		null, null, null, method.declaringClass);
			staticFactory.typeVariables = new TypeVariableBinding[classTypeVariablesArity + methodTypeVariablesArity];
			final SimpleLookupTable map = new SimpleLookupTable(classTypeVariablesArity + methodTypeVariablesArity);
			// Rename each type variable T of the type to T'
			final LookupEnvironment environment = environment();
			for (int j = 0; j < classTypeVariablesArity; j++) {
				map.put(classTypeVariables[j], staticFactory.typeVariables[j] = new TypeVariableBinding(CharOperation.concat(classTypeVariables[j].sourceName, "'".toCharArray()), //$NON-NLS-1$
																			staticFactory, j, environment));
			}
			// Rename each type variable U of method U to U''.
			for (int j = classTypeVariablesArity, max = classTypeVariablesArity + methodTypeVariablesArity; j < max; j++) {
				map.put(methodTypeVariables[j - classTypeVariablesArity], 
						(staticFactory.typeVariables[j] = new TypeVariableBinding(CharOperation.concat(methodTypeVariables[j - classTypeVariablesArity].sourceName, "''".toCharArray()), //$NON-NLS-1$
																			staticFactory, j, environment)));
			}
			ReferenceBinding enclosingType = originalEnclosingType;
			while (enclosingType != null) { // https://bugs.eclipse.org/bugs/show_bug.cgi?id=345968
				if (enclosingType.kind() == Binding.PARAMETERIZED_TYPE) {
					final ParameterizedTypeBinding parameterizedType = (ParameterizedTypeBinding) enclosingType;
					final ReferenceBinding genericType = parameterizedType.genericType();
					TypeVariableBinding[] enclosingClassTypeVariables = genericType.typeVariables();
					int enclosingClassTypeVariablesArity = enclosingClassTypeVariables.length;
					for (int j = 0; j < enclosingClassTypeVariablesArity; j++) {
						map.put(enclosingClassTypeVariables[j], parameterizedType.arguments[j]);
					}
				}
				enclosingType = enclosingType.enclosingType();
			}
			final Scope scope = this;
			Substitution substitution = new Substitution() {
					public LookupEnvironment environment() {
						return scope.environment();
					}
					public boolean isRawSubstitution() {
						return false;
					}
					public TypeBinding substitute(TypeVariableBinding typeVariable) {
						TypeBinding retVal = (TypeBinding) map.get(typeVariable);
						return typeVariable.hasTypeAnnotations() ? environment().createAnnotatedType(retVal, typeVariable.getTypeAnnotations()) : retVal;
					}
				};

			// initialize new variable bounds
			for (int j = 0, max = classTypeVariablesArity + methodTypeVariablesArity; j < max; j++) {
				TypeVariableBinding originalVariable = j < classTypeVariablesArity ? classTypeVariables[j] : methodTypeVariables[j - classTypeVariablesArity];
				TypeBinding substitutedType = (TypeBinding) map.get(originalVariable);
				if (substitutedType instanceof TypeVariableBinding) {
					TypeVariableBinding substitutedVariable = (TypeVariableBinding) substitutedType;
					TypeBinding substitutedSuperclass = Scope.substitute(substitution, originalVariable.superclass);
					ReferenceBinding[] substitutedInterfaces = Scope.substitute(substitution, originalVariable.superInterfaces);
					if (originalVariable.firstBound != null) {
						TypeBinding firstBound;
						firstBound = originalVariable.firstBound == originalVariable.superclass
								? substitutedSuperclass // could be array type or interface
										: substitutedInterfaces[0];
						substitutedVariable.setFirstBound(firstBound);
					}
					switch (substitutedSuperclass.kind()) {
						case Binding.ARRAY_TYPE :
							substitutedVariable.setSuperClass(environment.getResolvedType(TypeConstants.JAVA_LANG_OBJECT, null));
							substitutedVariable.setSuperInterfaces(substitutedInterfaces);
							break;
						default:
							if (substitutedSuperclass.isInterface()) {
								substitutedVariable.setSuperClass(environment.getResolvedType(TypeConstants.JAVA_LANG_OBJECT, null));
								int interfaceCount = substitutedInterfaces.length;
								System.arraycopy(substitutedInterfaces, 0, substitutedInterfaces = new ReferenceBinding[interfaceCount+1], 1, interfaceCount);
								substitutedInterfaces[0] = (ReferenceBinding) substitutedSuperclass;
								substitutedVariable.setSuperInterfaces(substitutedInterfaces);
							} else {
								substitutedVariable.setSuperClass((ReferenceBinding) substitutedSuperclass); // typeVar was extending other typeVar which got substituted with interface
								substitutedVariable.setSuperInterfaces(substitutedInterfaces);
							}
					}
				}
			}
		    TypeVariableBinding[] returnTypeParameters = new TypeVariableBinding[classTypeVariablesArity];
			for (int j = 0; j < classTypeVariablesArity; j++) {
				returnTypeParameters[j] = (TypeVariableBinding) map.get(classTypeVariables[j]);
			}
			staticFactory.returnType = environment.createParameterizedType(allocationType, returnTypeParameters, allocationType.enclosingType());
			staticFactory.parameters = Scope.substitute(substitution, method.parameters);
			staticFactory.thrownExceptions = Scope.substitute(substitution, method.thrownExceptions);
			if (staticFactory.thrownExceptions == null) { 
				staticFactory.thrownExceptions = Binding.NO_EXCEPTIONS;
			}
			staticFactories[sfi++] = new ParameterizedMethodBinding((ParameterizedTypeBinding) environment.convertToParameterizedType(staticFactory.declaringClass),
																												staticFactory);
		}
		if (sfi == 0)
			return null;
		if (sfi != methods.length) {
			System.arraycopy(staticFactories, 0, staticFactories = new MethodBinding[sfi], 0, sfi);
		}
		MethodBinding[] compatible = new MethodBinding[sfi];
		int compatibleIndex = 0;
		for (int i = 0; i < sfi; i++) {
			MethodBinding compatibleMethod = computeCompatibleMethod(staticFactories[i], argumentTypes, allocationSite);
			if (compatibleMethod != null) {
				if (compatibleMethod.isValidBinding())
					compatible[compatibleIndex++] = compatibleMethod;
			}
		}

		if (compatibleIndex == 0) {
			return null;
		}
		MethodBinding[] visible = new MethodBinding[compatibleIndex];
		int visibleIndex = 0;
		for (int i = 0; i < compatibleIndex; i++) {
			MethodBinding method = compatible[i];
			if (method.canBeSeenBy(allocationSite, this))
				visible[visibleIndex++] = method;
		}
		if (visibleIndex == 0) {
			return null;
		}
		return visibleIndex == 1 ? visible[0] : mostSpecificMethodBinding(visible, visibleIndex, argumentTypes, allocationSite, allocationType);
	}

