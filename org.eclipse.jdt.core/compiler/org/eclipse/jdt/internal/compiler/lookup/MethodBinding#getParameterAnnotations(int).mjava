/**
 * @param index the index of the parameter of interest
 * @return the annotations on the <code>index</code>th parameter
 * @throws ArrayIndexOutOfBoundsException when <code>index</code> is not valid 
 */
public AnnotationBinding[] getParameterAnnotations(int index) {
	MethodBinding originalMethod = this.original();
	AnnotationHolder holder = originalMethod.declaringClass.retrieveAnnotationHolder(originalMethod, true);
	AnnotationBinding[][] allParameterAnnotations = holder == null ? null : holder.getParameterAnnotations();
	if (allParameterAnnotations == null && (this.tagBits & TagBits.HasParameterAnnotations) != 0) {
		// forward reference to method, where param annotations have not yet been associated to method
		if (this.declaringClass instanceof SourceTypeBinding) {
			SourceTypeBinding sourceType = (SourceTypeBinding) this.declaringClass;
			if (sourceType.scope != null) {
				AbstractMethodDeclaration methodDecl = sourceType.scope.referenceType().declarationOf(this);
				if (methodDecl.arguments != null) {
					for (int i = 0, length = methodDecl.arguments.length; i < length; i++) {
						Argument argument = methodDecl.arguments[i];
						if (argument.annotations != null) {
							ASTNode.resolveAnnotations(methodDecl.scope, argument.annotations, argument.binding);
							if (allParameterAnnotations == null) {
								allParameterAnnotations = new AnnotationBinding[length][];
							}
							allParameterAnnotations[i] = argument.binding.getAnnotations();
						}
					}
					if (allParameterAnnotations != null)
						this.setParameterAnnotations(allParameterAnnotations);
				}
			}
		}
	}
	AnnotationBinding[] resultParameterAnnotations = allParameterAnnotations == null ? null : allParameterAnnotations[	index];
	 if (resultParameterAnnotations != null) {
		 return resultParameterAnnotations;
	 }
	return Binding.NO_ANNOTATIONS;
}

