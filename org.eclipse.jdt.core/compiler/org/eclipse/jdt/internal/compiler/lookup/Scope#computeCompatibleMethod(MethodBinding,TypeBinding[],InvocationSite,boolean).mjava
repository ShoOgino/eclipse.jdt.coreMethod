	/**
	 * Internal use only
	 * Given a method, returns null if arguments cannot be converted to parameters.
	 * Will answer a subsituted method in case the method was generic and type inference got triggered;
	 * in case the method was originally compatible, then simply answer it back.
	 */
	protected final MethodBinding computeCompatibleMethod(MethodBinding method, TypeBinding[] arguments, InvocationSite invocationSite, boolean convertVarargs) {

		TypeBinding[] genericTypeArguments = invocationSite.genericTypeArguments();
		TypeBinding[] parameters = method.parameters;
		if (parameters == arguments 
				&& (method.returnType.tagBits & HasTypeVariable) == 0 
				&& genericTypeArguments == null)
			return method;

		int argLength = arguments.length;
		int paramLength = parameters.length;
		boolean isVarArgs = method.isVarargs();
		if (argLength != paramLength)
			if (!isVarArgs || argLength < paramLength - 1)
				return null; // incompatible

		TypeVariableBinding[] typeVariables = method.typeVariables;
		if (typeVariables != NoTypeVariables) { // generic method
			method = ParameterizedGenericMethodBinding.computeCompatibleMethod(method, arguments, this, invocationSite);
			if (method == null) return null; // incompatible
			if (!method.isValidBinding()) return method; // bound check issue is taking precedence
			parameters = method.parameters; // reacquire them after type inference has performed
		} else if (genericTypeArguments != null) {
			if (method instanceof ParameterizedGenericMethodBinding) {
				if (method.declaringClass.isRawType())
					// attempt to invoke generic method of raw type with type hints <String>foo()
					return new ProblemMethodBinding(method, method.selector, genericTypeArguments, TypeArgumentsForRawGenericMethod);
			} else {
				return new ProblemMethodBinding(method, method.selector, genericTypeArguments, TypeParameterArityMismatch);
			}
		}

		argumentCompatibility: {
			int lastIndex = argLength;
			if (isVarArgs) {
				lastIndex = paramLength - 1;
				if (paramLength == argLength) { // accept both X and X[] but not X[][]
					TypeBinding varArgType = parameters[lastIndex]; // is an ArrayBinding by definition
					TypeBinding lastArgument = arguments[lastIndex];
					if (varArgType != lastArgument && !lastArgument.isCompatibleWith(varArgType)) {
						// expect X[], called with X
						if (!convertVarargs)
							break argumentCompatibility;
						varArgType = ((ArrayBinding) varArgType).elementsType();
						if (!lastArgument.isCompatibleWith(varArgType))
							break argumentCompatibility;
					}
				} else if (paramLength < argLength) { // all remainig argument types must be compatible with the elementsType of varArgType
					TypeBinding varArgType = ((ArrayBinding) parameters[lastIndex]).elementsType();
					for (int i = lastIndex; i < argLength; i++)
						if (varArgType != arguments[i] && !arguments[i].isCompatibleWith(varArgType))
							break argumentCompatibility;
				} else if (lastIndex != argLength) { // can call foo(int i, X ... x) with foo(1) but NOT foo();
					break argumentCompatibility;
				}
				// now compare standard arguments from 0 to lastIndex
			}
			for (int i = 0; i < lastIndex; i++)
				if (parameters[i] != arguments[i] && !arguments[i].isCompatibleWith(parameters[i]))
					break argumentCompatibility;
			return method; // compatible
		}
		if (genericTypeArguments != null)
			return new ProblemMethodBinding(method, method.selector, arguments, ParameterizedMethodTypeMismatch);
		return null; // incompatible
	}

