	protected int parameterCompatibilityLevel(MethodBinding method, TypeBinding[] arguments) {
		TypeBinding[] parameters = method.parameters;
		int paramLength = parameters.length;
		int argLength = arguments.length;
		int lastIndex = argLength;
		int level = COMPATIBLE; // no autoboxing or varargs support needed
		if (method.isVarargs()) {
			lastIndex = paramLength - 1;
			if (paramLength == argLength) { // accept X or X[] but not X[][]
				TypeBinding param = parameters[lastIndex]; // is an ArrayBinding by definition
				TypeBinding arg = arguments[lastIndex];
				if (param != arg && !arg.isCompatibleWith(param)) {
					if (isBoxingCompatibleWith(arg, param)) {
						level = AUTOBOX_COMPATIBLE; // autoboxing support needed
					} else {
						// expect X[], called with X
						param = ((ArrayBinding) param).elementsType();
						if (!arg.isCompatibleWith(param) && !isBoxingCompatibleWith(arg, param))
							return NOT_COMPATIBLE;
						level = VARARGS_COMPATIBLE; // varargs support needed
					}
				}
			} else {
				if (paramLength < argLength) { // all remainig argument types must be compatible with the elementsType of varArgType
					TypeBinding param = ((ArrayBinding) parameters[lastIndex]).elementsType();
					for (int i = lastIndex; i < argLength; i++) {
						TypeBinding arg = arguments[i];
						if (param != arg && !arg.isCompatibleWith(param) && !isBoxingCompatibleWith(arg, param))
							return NOT_COMPATIBLE;
					}
				}  else if (lastIndex != argLength) { // can call foo(int i, X ... x) with foo(1) but NOT foo();
					return NOT_COMPATIBLE;
				}
				level = VARARGS_COMPATIBLE; // varargs support needed
			}
			// now compare standard arguments from 0 to lastIndex
		}
		for (int i = 0; i < lastIndex; i++) {
			TypeBinding param = parameters[i];
			TypeBinding arg = arguments[i];
			if (arg != param && !arg.isCompatibleWith(param)) {
				if (!isBoxingCompatibleWith(arg, param))
					return NOT_COMPATIBLE;
				level = AUTOBOX_COMPATIBLE; // autoboxing support needed
			}
		}
		return level;
	}

