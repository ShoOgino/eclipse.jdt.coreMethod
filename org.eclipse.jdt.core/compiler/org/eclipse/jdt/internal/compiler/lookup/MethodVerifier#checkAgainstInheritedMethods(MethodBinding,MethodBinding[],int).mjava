private void checkAgainstInheritedMethods(MethodBinding currentMethod, MethodBinding[] methods, int length) {
	currentMethod.modifiers |= CompilerModifiers.AccOverriding;
	for (int i = length; --i >= 0;) {
		MethodBinding inheritedMethod = methods[i];
		if (!currentMethod.isAbstract() && inheritedMethod.isAbstract())
			currentMethod.modifiers |= CompilerModifiers.AccImplementing;

		if (currentMethod.returnType != inheritedMethod.returnType) {
			this.problemReporter(currentMethod).incompatibleReturnType(currentMethod, inheritedMethod);
		} else if (currentMethod.isStatic() != inheritedMethod.isStatic()) {  // Cannot override a static method or hide an instance method
			this.problemReporter(currentMethod).staticAndInstanceConflict(currentMethod, inheritedMethod);
		} else {
			if (currentMethod.thrownExceptions != NoExceptions)
				this.checkExceptions(currentMethod, inheritedMethod);
			if (inheritedMethod.isFinal())
				this.problemReporter(currentMethod).finalMethodCannotBeOverridden(currentMethod, inheritedMethod);
			if (!this.isAsVisible(currentMethod, inheritedMethod))
				this.problemReporter(currentMethod).visibilityConflict(currentMethod, inheritedMethod);
			if (inheritedMethod.isViewedAsDeprecated())
				if (!currentMethod.isViewedAsDeprecated() || environment.options.reportDeprecationInsideDeprecatedCode)
					this.problemReporter(currentMethod).overridesDeprecatedMethod(currentMethod, inheritedMethod);
		}
	}
}

