protected void fillInDefaultNonNullness18(AbstractMethodDeclaration sourceMethod, LookupEnvironment env) {
	boolean added = false;
	int length = this.parameters.length;
	for (int i = 0; i < length; i++) {
		TypeBinding parameter = this.parameters[i];
		if (parameter.isBaseType())
			continue;
		long existing = parameter.tagBits & TagBits.AnnotationNullMASK;
		if (existing == 0L) {
			added = true;
			if (!parameter.isBaseType()) {
				// TODO(Stephan): Synthesize AnnotationBinding[] and call LE#createAnnotatedType(TB, AB[]);
				// this.parameters[i] = env.createAnnotatedType(parameter, TagBits.AnnotationNonNull);
				if (sourceMethod != null)
					sourceMethod.arguments[i].binding.type = this.parameters[i];
			}
		} else if (sourceMethod != null && (parameter.tagBits & TagBits.AnnotationNonNull) != 0) {
			sourceMethod.scope.problemReporter().nullAnnotationIsRedundant(sourceMethod, i);
		}
	}
	if (added)
		this.tagBits |= TagBits.HasParameterAnnotations;
	if (   this.returnType != null
		&& !this.returnType.isBaseType()
		&& (this.returnType.tagBits & (TagBits.AnnotationNonNull|TagBits.AnnotationNullable)) == 0)
	{
		// TODO(Stephan: Synthesize AnnotationBinding[] and call LE#createAnnotatedType(TB, AB[]);
		// this.returnType = env.createAnnotatedType(this.returnType, TagBits.AnnotationNonNull);
	} else if (sourceMethod != null && (this.returnType.tagBits & TagBits.AnnotationNonNull) != 0) {
		sourceMethod.scope.problemReporter().nullAnnotationIsRedundant(sourceMethod, -1/*signifies method return*/);
	}
}

