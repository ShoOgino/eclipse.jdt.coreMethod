	// Given parent is visible in this module, see if there is sub package named name visible in this module
	PackageBinding getVisiblePackage(PackageBinding parent, char[] name, boolean considerRequiredModules) {
		// check caches:
		char[][] parentName = parent == null ? CharOperation.NO_CHAR_CHAR : parent.compoundName;
		char[][] subPkgCompoundName = CharOperation.arrayConcat(parentName, name);
		char[] fullFlatName = CharOperation.concatWith(subPkgCompoundName, '.');
		PackageBinding pkg = this.declaredPackages.get(fullFlatName);
		if (pkg != null)
			return pkg;
		if (parent != null)
			pkg = parent.getPackage0(name);
		else
			pkg = this.environment.getPackage0(name);
		if (pkg != null) {
			if (pkg == LookupEnvironment.TheNotFoundPackage)
				return null;
			else
				return addPackage(pkg, false);
		}

		PackageBinding binding = null;
		char[][] declaringModuleNames = null;
		boolean packageMayBeIncomplete = !considerRequiredModules;
		if (this.environment.useModuleSystem) {
			IModuleAwareNameEnvironment moduleEnv = (IModuleAwareNameEnvironment) this.environment.nameEnvironment;
			declaringModuleNames = moduleEnv.getUniqueModulesDeclaringPackage(parentName, name, nameForLookup());
			if (declaringModuleNames != null) {
				if (CharOperation.containsEqual(declaringModuleNames, this.moduleName)) {
					if (parent instanceof SplitPackageBinding) {
						// parent.getPackage0() may have been too shy, so drill into the split:
						PackageBinding singleParent = ((SplitPackageBinding) parent).getIncarnation(this);
						if (singleParent != null)
							binding = singleParent.getPackage0(name);
					}
					if (binding == null) {
						// declared here, not yet known, so create it now:
						binding = new PackageBinding(subPkgCompoundName, parent, this.environment, this);
					}
				} else if (considerRequiredModules) {
					// visible but foreign (when current is unnamed or auto):
					for (char[] declaringModuleName : declaringModuleNames) {
						ModuleBinding declaringModule = this.environment.root.getModule(declaringModuleName);
						if (declaringModule != null) {
							if (declaringModule.isPackageLookupActive) {
								packageMayBeIncomplete = true;
							} else {
								PackageBinding declaredPackage = declaringModule.getDeclaredPackage(parentName, name);
								if (declaredPackage != null) {
									// don't add foreign package to 'parent' (below), but to its own parent:
									if (declaredPackage.parent != null)
										declaredPackage.parent.addPackage(declaredPackage, declaringModule);
									parent = null;
									//
									binding = SplitPackageBinding.combine(declaredPackage, binding, this);
								}
							}
						}
					}
				}
			}
		} else {
			if (this.environment.nameEnvironment.isPackage(parentName, name))
				binding = new PackageBinding(subPkgCompoundName, parent, this.environment, this);
		}

		// enrich with split-siblings from visible modules:
		if (considerRequiredModules) {
			if (parent != null && binding != null)
				parent.addPackage(binding, this); // preliminarily add to avoid creating duplicates, will be updated below
			binding = combineWithPackagesFromOtherRelevantModules(binding, subPkgCompoundName, declaringModuleNames);
		}
		if (binding == null || !binding.isValidBinding()) {
			if (parent != null
					&& !packageMayBeIncomplete  // don't remember package that may still lack some siblings
					&& !(parent instanceof SplitPackageBinding)) // don't store problem into SPB, because from different focus things may look differently
			{
				parent.knownPackages.put(name, binding == null ? LookupEnvironment.TheNotFoundPackage : binding);
			}
			return null;
		}
		// remember
		if (parentName.length == 0) {
			binding.environment.knownPackages.put(name, binding);
		} else if (parent != null) {
			binding = parent.addPackage(binding, this);
		}
		if (packageMayBeIncomplete)
			return binding;
		return addPackage(binding, false);
	}

