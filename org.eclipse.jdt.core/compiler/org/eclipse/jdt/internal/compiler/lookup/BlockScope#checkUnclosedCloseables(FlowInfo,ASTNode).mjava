/**
 * At the end of a block check the closing-status of all tracked closeables that are declared in this block.
 * Also invoked when entering unreachable code.
 */
public void checkUnclosedCloseables(FlowInfo flowInfo, ASTNode location) {
	if (this.trackingVariables == null) {
		// at a method return we also consider enclosing scopes
		if (location != null && this.parent instanceof BlockScope)
			((BlockScope) this.parent).checkUnclosedCloseables(flowInfo, location);
		return;
	}
	if (location != null && flowInfo.reachMode() != 0) return;
	for (int i=0; i<this.trackingVariables.size(); i++) {
		FakedTrackingVariable trackingVar = (FakedTrackingVariable) this.trackingVariables.get(i);
		if (location != null && trackingVar.originalBinding != null && flowInfo.isDefinitelyNull(trackingVar.originalBinding))
			continue; // reporting against a specific location, resource is null at this flow, don't complain
		int status = getNullStatusAggressively(trackingVar.binding, flowInfo);
		if (status == FlowInfo.NULL) {
			// definitely unclosed: highest priority
			reportResourceLeak(trackingVar, location, status);
			if (location == null) {
				// definitely done with this trackingVar, remove it
				this.trackingVariables.remove(trackingVar);
				i--; // ... but don't disturb the enclosing loop.
			}
			continue;
		}
		if (location == null) // at end of block and not definitely unclosed
		{
			// problems at specific locations: medium priority
			if (trackingVar.reportRecordedErrors(this)) // ... report previously recorded errors
				continue;
		} 
		if (status == FlowInfo.POTENTIALLY_NULL) {
			// potentially unclosed: lower priority
			reportResourceLeak(trackingVar, location, status);
		} else if (status == FlowInfo.NON_NULL) {
			// properly closed but not managed by t-w-r: lowest priority 
			if (environment().globalOptions.complianceLevel >= ClassFileConstants.JDK1_7)
				trackingVar.reportExplicitClosing(problemReporter());
		}
	}
}

