	protected boolean isAcceptableMethod(MethodBinding one, MethodBinding two) {
		TypeBinding[] oneParams = one.parameters;
		TypeBinding[] twoParams = two.parameters;
		int oneParamsLength = oneParams.length;
		int twoParamsLength = twoParams.length;
		if (oneParamsLength == twoParamsLength) {
			next : for (int i = 0; i < oneParamsLength; i++) {
				TypeBinding oneParam = oneParams[i];
				TypeBinding twoParam = twoParams[i];
				if (oneParam == twoParam || oneParam.isCompatibleWith(twoParam)) {
					if (two.declaringClass.isRawType()) continue next;

					TypeBinding originalOneParam = one.original().parameters[i].leafComponentType();
					switch (originalOneParam.kind()) {
					   	case Binding.TYPE_PARAMETER :
					   		if (!((TypeVariableBinding) originalOneParam).upperBound().isRawType()) break;
					   		//$FALL-THROUGH$
					   	case Binding.RAW_TYPE:
					   		// originalOneParam is RAW so it cannot be more specific than a wildcard or parameterized type
							TypeBinding originalTwoParam = two.original().parameters[i].leafComponentType();
							switch (originalTwoParam.kind()) {
							   	case Binding.TYPE_PARAMETER :
							   		if (((TypeVariableBinding) originalTwoParam).hasOnlyRawBounds())
								   		continue next;
								   	return false;
							   	case Binding.WILDCARD_TYPE :
							   	case Binding.INTERSECTION_TYPE:
							   	case Binding.PARAMETERIZED_TYPE :
							   		return false;
							}
					}
				} else {
					if (i == oneParamsLength - 1 && one.isVarargs() && two.isVarargs()) {
						TypeBinding eType = ((ArrayBinding) twoParam).elementsType();
						if (oneParam == eType || oneParam.isCompatibleWith(eType))
							return true; // special case to choose between 2 varargs methods when the last arg is Object[]
					}
					return false;
				}
			}
			return true;
		}

		if (one.isVarargs() && two.isVarargs()) {
			if (oneParamsLength > twoParamsLength) {
				// special case when autoboxing makes (int, int...) better than (Object...) but not (int...) or (Integer, int...)
				if (((ArrayBinding) twoParams[twoParamsLength - 1]).elementsType().id != TypeIds.T_JavaLangObject)
					return false;
			}
			// check that each parameter before the vararg parameters are compatible (no autoboxing allowed here)
			for (int i = (oneParamsLength > twoParamsLength ? twoParamsLength : oneParamsLength) - 2; i >= 0; i--)
				if (oneParams[i] != twoParams[i] && !oneParams[i].isCompatibleWith(twoParams[i]))
					return false;
			if (parameterCompatibilityLevel(one, twoParams) == NOT_COMPATIBLE
					&& parameterCompatibilityLevel(two, oneParams) == VARARGS_COMPATIBLE)
				return true;
		}
		return false;
	}

