	protected boolean connectTypeVariables(TypeParameter[] typeParameters) {
		boolean noProblems = true;
		if (typeParameters == null || environment().options.sourceLevel < ClassFileConstants.JDK1_5) return true;

		nextVariable : for (int i = 0, paramLength = typeParameters.length; i < paramLength; i++) {
			TypeParameter typeParameter = typeParameters[i];
			TypeVariableBinding typeVariable = typeParameter.binding;
			if (typeVariable == null) return false;

			typeVariable.superclass = getJavaLangObject();
			typeVariable.superInterfaces = NoSuperInterfaces;
			// set firstBound to the binding of the first explicit bound in parameter declaration
			typeVariable.firstBound = null; // first bound used to compute erasure

			TypeReference typeRef = typeParameter.type;
			if (typeRef == null)
				continue nextVariable;
			TypeBinding superType = this.kind == METHOD_SCOPE
				? typeRef.resolveType((BlockScope)this, false/*no bound check*/)
				: typeRef.resolveType((ClassScope)this);
			if (superType == null) {
				typeVariable.tagBits |= HierarchyHasProblems;
				noProblems = false;
				continue nextVariable;
			}
			typeRef.resolvedType = superType; // hold onto the problem type
			if (superType.isArrayType()) {
				problemReporter().boundCannotBeArray(typeRef, superType);
				continue nextVariable;
			}
			if (superType.isTypeVariable()) {
				TypeVariableBinding varSuperType = (TypeVariableBinding) superType;
				if (varSuperType.rank >= typeVariable.rank && varSuperType.declaringElement == typeVariable.declaringElement) {
					problemReporter().forwardTypeVariableReference(typeParameter, varSuperType);
					typeVariable.tagBits |= HierarchyHasProblems;
					noProblems = false;
					continue nextVariable;
				}
			}
			ReferenceBinding superRefType = (ReferenceBinding) superType;
			if (superRefType.isFinal())
				problemReporter().finalVariableBound(typeVariable, typeRef);
			if (!superType.isInterface()) {
				typeVariable.superclass = superRefType;
			} else {
				typeVariable.superInterfaces = new ReferenceBinding[] {superRefType};
				typeVariable.modifiers |= AccInterface;
			}
			typeVariable.firstBound = superRefType; // first bound used to compute erasure

			TypeReference[] boundRefs = typeParameter.bounds;
			if (boundRefs != null) {
				for (int j = 0, k = boundRefs.length; j < k; j++) {
					typeRef = boundRefs[j];
					superType = this.kind == METHOD_SCOPE
						? typeRef.resolveType((BlockScope)this, false)
						: typeRef.resolveType((ClassScope)this);
					if (superType == null) {
						typeVariable.tagBits |= HierarchyHasProblems;
						noProblems = false;
						continue nextVariable;
					}
					typeRef.resolvedType = superType; // hold onto the problem type
					if (superType.isArrayType()) {
						problemReporter().boundCannotBeArray(typeRef, superType);
						continue nextVariable;
					}
					superRefType = (ReferenceBinding) superType;
					if (!superType.isInterface()) {
						problemReporter().boundMustBeAnInterface(typeRef, superType);
						typeVariable.tagBits |= HierarchyHasProblems;
						noProblems = false;
						continue nextVariable;
					}
					if (superType.isParameterizedType()) {
						ReferenceBinding match = typeVariable.superclass.findSuperTypeErasingTo((ReferenceBinding) superType.erasure());
						boolean isCollision = match != null && match != superType;
						for (int index = typeVariable.superInterfaces.length; !isCollision && --index >= 0;) {
							ReferenceBinding temp = typeVariable.superInterfaces[index];
							isCollision = superType != temp && superType.erasure() == temp.erasure();
						}
						if (isCollision) {
							problemReporter().boundHasConflictingArguments(typeRef, superType);
							typeVariable.tagBits |= HierarchyHasProblems;
							noProblems = false;
							continue nextVariable;
						}
					}
					for (int index = typeVariable.superInterfaces.length; --index >= 0;) {
						if (superType.erasure() == typeVariable.superInterfaces[index].erasure()) {
							problemReporter().duplicateBounds(typeRef, superType);
							typeVariable.tagBits |= HierarchyHasProblems;
							noProblems = false;
							continue nextVariable;
						}
					}
					int size = typeVariable.superInterfaces.length;
					System.arraycopy(typeVariable.superInterfaces, 0, typeVariable.superInterfaces = new ReferenceBinding[size + 1], 0, size);
					typeVariable.superInterfaces[size] = superRefType;
				}
			}
		}
		return noProblems;
	}

