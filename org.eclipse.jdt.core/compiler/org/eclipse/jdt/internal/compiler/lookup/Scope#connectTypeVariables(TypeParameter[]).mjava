	protected boolean connectTypeVariables(TypeParameter[] typeParameters) {
		boolean noProblems = true;
		if (typeParameters == null || compilerOptions().sourceLevel < ClassFileConstants.JDK1_5) return true;
		TypeBinding[] types = new TypeBinding[2];
		Map invocations = new HashMap(2);
		nextVariable : for (int i = 0, paramLength = typeParameters.length; i < paramLength; i++) {
			TypeParameter typeParameter = typeParameters[i];
			TypeVariableBinding typeVariable = typeParameter.binding;
			if (typeVariable == null) return false;

			typeVariable.superclass = getJavaLangObject();
			typeVariable.superInterfaces = NoSuperInterfaces;
			// set firstBound to the binding of the first explicit bound in parameter declaration
			typeVariable.firstBound = null; // first bound used to compute erasure

			TypeReference typeRef = typeParameter.type;
			if (typeRef == null)
				continue nextVariable;
			TypeBinding superType = this.kind == METHOD_SCOPE
				? typeRef.resolveType((BlockScope)this, false/*no bound check*/)
				: typeRef.resolveType((ClassScope)this);
			if (superType == null) {
				typeVariable.tagBits |= TagBits.HierarchyHasProblems;
				noProblems = false;
				continue nextVariable;
			}
			typeRef.resolvedType = superType; // hold onto the problem type
			if (superType.isArrayType()) {
				problemReporter().boundCannotBeArray(typeRef, superType);
				continue nextVariable;
			}
			boolean isTypeVariableFirstBound =  superType.isTypeVariable();
			if (isTypeVariableFirstBound) {
				TypeVariableBinding varSuperType = (TypeVariableBinding) superType;
				if (varSuperType.rank >= typeVariable.rank && varSuperType.declaringElement == typeVariable.declaringElement) {
					problemReporter().forwardTypeVariableReference(typeParameter, varSuperType);
					typeVariable.tagBits |= TagBits.HierarchyHasProblems;
					noProblems = false;
					continue nextVariable;
				}
			}
			ReferenceBinding superRefType = (ReferenceBinding) superType;
			if (superRefType.isFinal())
				problemReporter().finalVariableBound(typeVariable, typeRef);
			if (!superType.isInterface()) {
				typeVariable.superclass = superRefType;
			} else {
				typeVariable.superInterfaces = new ReferenceBinding[] {superRefType};
			}
			typeVariable.firstBound = superRefType; // first bound used to compute erasure
			TypeReference[] boundRefs = typeParameter.bounds;
			if (boundRefs != null) {
				for (int j = 0, boundLength = boundRefs.length; j < boundLength; j++) {
					typeRef = boundRefs[j];
					superType = this.kind == METHOD_SCOPE
						? typeRef.resolveType((BlockScope)this, false)
						: typeRef.resolveType((ClassScope)this);
					if (superType == null) {
						typeVariable.tagBits |= TagBits.HierarchyHasProblems;
						noProblems = false;
						continue nextVariable;
					}
					typeRef.resolvedType = superType; // hold onto the problem type
					types[0] = superType;
					if (isTypeVariableFirstBound && j == 0) {
						problemReporter().noAdditionalBoundAfterTypeVariable(typeRef);
					}
					if (superType.isArrayType()) {
						problemReporter().boundCannotBeArray(typeRef, superType);
						continue nextVariable;
					}
					superRefType = (ReferenceBinding) superType;
					if (!superType.isInterface()) {
						problemReporter().boundMustBeAnInterface(typeRef, superType);
						typeVariable.tagBits |= TagBits.HierarchyHasProblems;
						noProblems = false;
						continue nextVariable;
					}
					// check against superclass
					if (typeVariable.firstBound == typeVariable.superclass) {
						types[1] = typeVariable.superclass;
						TypeBinding[] mecs = minimalErasedCandidates(types, invocations);
						if (mecs != null) {
							nextCandidate: for (int k = 0, max = mecs.length; k < max; k++) {
								TypeBinding mec = mecs[k];
								if (mec == null) continue nextCandidate;
								Set invalidInvocations = (Set)invocations.get(mec);
								int invalidSize = invalidInvocations.size();
								if (invalidSize > 1) {
									TypeBinding[] collisions;
									invalidInvocations.toArray(collisions = new TypeBinding[invalidSize]);
									problemReporter().superinterfacesCollide(collisions[0].erasure(), typeRef, collisions[1], collisions[0]); // swap collisions since mec types got swapped
									typeVariable.tagBits |= TagBits.HierarchyHasProblems;
									noProblems = false;
									continue nextVariable;
								}
							}			
						}
					}
					// check against superinterfaces
					for (int index = typeVariable.superInterfaces.length; --index >= 0;) {
						ReferenceBinding previousInterface = typeVariable.superInterfaces[index];
						if (previousInterface == superRefType) {
							problemReporter().duplicateBounds(typeRef, superType);
							typeVariable.tagBits |= TagBits.HierarchyHasProblems;
							noProblems = false;
							continue nextVariable;
						}
						types[1] = previousInterface;
						invocations.clear();
						TypeBinding[] mecs = minimalErasedCandidates(types, invocations);
						if (mecs != null) {
							nextCandidate: for (int m = 0, max = mecs.length; m < max; m++) {
								TypeBinding mec = mecs[m];
								if (mec == null) continue nextCandidate;
								Set invalidInvocations = (Set)invocations.get(mec);
								int invalidSize = invalidInvocations.size();
								if (invalidSize > 1) {
									TypeBinding[] collisions;
									invalidInvocations.toArray(collisions = new TypeBinding[invalidSize]);
									problemReporter().superinterfacesCollide(collisions[0].erasure(), typeRef, collisions[0], collisions[1]);
									typeVariable.tagBits |= TagBits.HierarchyHasProblems;
									noProblems = false;
									continue nextVariable;
								}
							}					
						}
					}
					int size = typeVariable.superInterfaces.length;
					System.arraycopy(typeVariable.superInterfaces, 0, typeVariable.superInterfaces = new ReferenceBinding[size + 1], 0, size);
					typeVariable.superInterfaces[size] = superRefType;
				}
			}
		}
		return noProblems;
	}

