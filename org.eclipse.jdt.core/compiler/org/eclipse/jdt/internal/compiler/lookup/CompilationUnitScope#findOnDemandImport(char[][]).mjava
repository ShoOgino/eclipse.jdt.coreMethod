private Binding findOnDemandImport(char[][] compoundName) {
	Binding binding = environment.getPackage0(compoundName[0]);
	if (binding == null) {
		if (environment.isPackage(null, compoundName[0]))
			binding = environment.getTopLevelPackage(compoundName[0]);
		else // hold onto a problem package since a real one will never be created
			addNamespaceReference(new ProblemPackageBinding(compoundName[0], NotFound));
	} else {
		if (binding == environment.theNotFoundPackage)
			binding = null; // forget the NotFound package
	}
	int i = 1;
	int length = compoundName.length;
	foundNothingOrType: if (binding != null) {
		PackageBinding packageBinding = (PackageBinding) binding;
		addNamespaceReference(packageBinding);

		while (i < length) {
			binding = packageBinding.getTypeOrPackage(compoundName[i++]);
			if (binding == null || !binding.isValidBinding()) {
				binding = null;
				break foundNothingOrType;
			}
			if (!(binding instanceof PackageBinding))
				break foundNothingOrType;

			packageBinding = (PackageBinding) binding;
			addNamespaceReference(packageBinding);
		}
		return packageBinding;
	}

	ReferenceBinding type;
	if (binding == null) {
		if (environment.defaultPackage == null)
			return new ProblemReferenceBinding(compoundName, NotFound);
		type = findType(compoundName[0], environment.defaultPackage, environment.defaultPackage);
		if (type == null || !type.isValidBinding())
			return new ProblemReferenceBinding(compoundName, NotFound);
		i = 1; // reset to look for member types inside the default package type
	} else {
		type = (ReferenceBinding) binding;
	}

	for (; i < length; i++) {
		addTypeReference(type);
		// does not look for inherited member types on purpose
		if ((type = type.getMemberType(compoundName[i])) == null)
			return new ProblemReferenceBinding(compoundName, NotFound);
	}
	addTypeReference(type);
	if (!type.canBeSeenBy(fPackage))
		return new ProblemReferenceBinding(compoundName, NotVisible);
	return type;
}

