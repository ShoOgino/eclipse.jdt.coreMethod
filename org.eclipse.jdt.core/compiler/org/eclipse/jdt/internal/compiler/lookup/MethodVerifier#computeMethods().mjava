/*
computeInheritedMethodMembers

	"8.4.6.4"
	"Compute all of the members for the type that are inherited from its supertypes.
		This includes:
			All of the methods implemented in the supertype hierarchy that are not overridden.
			PROBLEM:  Currently we do not remove overridden methods in the interface hierarchy.
			This could cause a non-existent exception error to be detected."

	| supertype allSuperinterfaces methodsSeen interfacesSeen |
	inheritedMethodMembers := LookupTable new: 50.
	allSuperinterfaces := OrderedCollection new.

	type isJavaClass ifTrue: [
		supertype := type.
		methodsSeen := EsIdentitySet new: 20.
		[(supertype := self superclassFor: supertype) == nil] whileFalse: [
			(supertype isBuilderClass or: [supertype isValidDescriptor]) ifTrue: [
				allSuperinterfaces addAll: (self superinterfacesFor: supertype).
				supertype javaUserDefinedMethodsDo: [:method |
					(method isJavaPrivate or: [method isJavaConstructor]) ifFalse: [
						(method isJavaDefault and: [method declaringClass package symbol ~= type package symbol]) ifFalse: [
							(methodsSeen includes: method selector) ifFalse: [
								methodsSeen add: method selector.
								(inheritedMethodMembers
									at: (self methodSignatureFor: method selector)
									ifAbsentPut: [OrderedCollection new: 3])
										add: method]]]]]]].

	allSuperinterfaces addAll: (self superinterfacesFor: type).
	interfacesSeen := EsIdentitySet new: allSuperinterfaces size * 2.
	[allSuperinterfaces notEmpty] whileTrue: [
		supertype := allSuperinterfaces removeFirst.
		(interfacesSeen includes: supertype) ifFalse: [
			interfacesSeen add: supertype.
			(supertype isBuilderClass or: [supertype isValidDescriptor]) ifTrue: [
				allSuperinterfaces addAll: (self superinterfacesFor: supertype).
				supertype javaUserDefinedMethodsDo: [:method |		"Interface methods are all abstract public."
					(inheritedMethodMembers
						at: (self methodSignatureFor: method selector)
						ifAbsentPut: [OrderedCollection new: 3])
							add: method]]]]
*/
private void computeMethods() {
	MethodBinding[] methods = type.methods();
	int size = methods.length;
	this.currentMethods = new HashtableOfObject(size == 0 ? 1 : size); // maps method selectors to an array of methods... must search to match paramaters & return type
	for (int m = size; --m >= 0;) {
		MethodBinding method = methods[m];
		if (!(method.isConstructor() || method.isDefaultAbstract())) { // keep all methods which are NOT constructors or default abstract
			MethodBinding[] existingMethods = (MethodBinding[]) this.currentMethods.get(method.selector);
			if (existingMethods == null)
				existingMethods = new MethodBinding[1];
			else
				System.arraycopy(existingMethods, 0,
					(existingMethods = new MethodBinding[existingMethods.length + 1]), 0, existingMethods.length - 1);
			existingMethods[existingMethods.length - 1] = method;
			this.currentMethods.put(method.selector, existingMethods);
		}
	}
}

