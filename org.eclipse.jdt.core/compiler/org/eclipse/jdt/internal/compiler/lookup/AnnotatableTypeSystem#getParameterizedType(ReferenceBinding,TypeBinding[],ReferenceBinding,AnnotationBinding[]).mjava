	public ParameterizedTypeBinding getParameterizedType(ReferenceBinding genericType, TypeBinding[] typeArguments, ReferenceBinding enclosingType, AnnotationBinding [] annotations) {
		
		if (genericType.hasTypeAnnotations())   // @NonNull (List<String>) and not (@NonNull List)<String>
			throw new IllegalStateException();

		ParameterizedTypeBinding nakedType = null;
		TypeBinding[] derivedTypes = getDerivedTypes(genericType);
		for (int i = 0, length = derivedTypes.length; i < length; i++) {
			TypeBinding derivedType = derivedTypes[i];
			if (derivedType == null)
				break;
			if (!derivedType.isParameterizedType() || derivedType.actualType() != genericType) //$IDENTITY-COMPARISON$
				continue;
			if (derivedType.enclosingType() != enclosingType || !Util.effectivelyEqual(derivedType.typeArguments(), typeArguments)) //$IDENTITY-COMPARISON$
				continue;
			if (Util.effectivelyEqual(annotations, derivedType.getTypeAnnotations()))
				return (ParameterizedTypeBinding) derivedType;
			if (!derivedType.hasTypeAnnotations())
				nakedType = (ParameterizedTypeBinding) derivedType;
		}
		if (nakedType == null)
			nakedType = super.getParameterizedType(genericType, typeArguments, enclosingType);
		
		if (!haveTypeAnnotations(genericType, enclosingType, typeArguments, annotations))
			return nakedType;
		
		TypeBinding parameterizedType = new ParameterizedTypeBinding(genericType, typeArguments, enclosingType, this.environment);
		parameterizedType.id = nakedType.id;
		parameterizedType.setTypeAnnotations(annotations, this.isAnnotationBasedNullAnalysisEnabled);
		return (ParameterizedTypeBinding) cacheDerivedType(genericType, nakedType, parameterizedType);
	}

