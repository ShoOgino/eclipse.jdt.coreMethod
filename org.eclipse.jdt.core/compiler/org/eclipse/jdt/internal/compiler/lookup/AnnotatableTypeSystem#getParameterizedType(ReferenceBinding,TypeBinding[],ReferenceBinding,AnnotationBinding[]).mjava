	public ParameterizedTypeBinding getParameterizedType(ReferenceBinding genericType, TypeBinding[] typeArguments, ReferenceBinding enclosingType, AnnotationBinding [] annotations) {
		
		if (!haveTypeAnnotations(genericType, enclosingType, typeArguments, annotations))
			return this.unannotatedTypeSystem.getParameterizedType(genericType, typeArguments, enclosingType);
		
		/* When restoring annotations from class files, we encounter a situation where the generic type comes in attributed with the annotations that should
		   really belong to the parameterized type that is being created just now. e.g @T List<String> => comes in as (@T List)<String>. The question really 
		   is List being parameterized by String and then the resultant type is annotated or is "@T List" being parameterized with String ? We don't care one
		   way or other except that we would want a uniform treatment. As a stop gap, we "repair" the situation here, so it is consistent with treatment of 
		   type references in source code.
		*/
		AnnotationBinding [] misplacedAnnotations = genericType.getTypeAnnotations();
		if (misplacedAnnotations != null && misplacedAnnotations != Binding.NO_ANNOTATIONS) {
			if (annotations != null && annotations != Binding.NO_ANNOTATIONS)
				throw new IllegalStateException(); // cannot cut both ways.
			annotations = misplacedAnnotations;
			genericType = (ReferenceBinding) this.unannotatedTypeSystem.getUnannotatedType(genericType);
		}
		// generic type is expected to come in unannotated, if it came in with any misattributed annotations, they have been duly re-attributed and it is unannotated now.	
		
		int index = 0;
		TypeBinding keyType = getUnannotatedType(genericType);
		TypeBinding[] cachedInfo = (TypeBinding[]) this.annotatedTypes.get(keyType); // promotes better instance sharing
		if (cachedInfo != null) {
			for (int max = cachedInfo.length; index < max; index++){
				TypeBinding cachedType = cachedInfo[index];
				if (cachedType == null) 
					break;
				if (!cachedType.isParameterizedType())
					continue;
				if (cachedType.enclosingType() == enclosingType && Util.effectivelyEqual(annotations, cachedType.getTypeAnnotations()) && Util.effectivelyEqual(cachedType.typeArguments(), typeArguments))
					return (ParameterizedTypeBinding) cachedType;
			}
		} else {
			this.annotatedTypes.put(keyType, cachedInfo = new TypeBinding[4]);
		}
		int length = cachedInfo.length;
		if (index == length) {
			System.arraycopy(cachedInfo, 0, cachedInfo = new TypeBinding[length * 2], 0, length);
			this.annotatedTypes.put(keyType, cachedInfo);
		}
		// Add the new comer, retaining the same type binding id as the naked type.
		ParameterizedTypeBinding unannotatedParameterizedType = this.unannotatedTypeSystem.getParameterizedType(genericType, typeArguments, enclosingType);
		TypeBinding parameterizedType = new ParameterizedTypeBinding(genericType, typeArguments, enclosingType, this.environment);
		parameterizedType.id = unannotatedParameterizedType.id;
		parameterizedType.setTypeAnnotations(annotations, this.environment.globalOptions.isAnnotationBasedNullAnalysisEnabled);
		return (ParameterizedTypeBinding) (cachedInfo[index] = parameterizedType);
	}

