	/**
	 * Collect the substitutes into a map for certain type variables inside the receiver type
	 * e.g.   Collection<T>.findSubstitute(T, Collection<List<X>>):   T --> List<X>
	 */
	public void collectSubstitutes(TypeBinding otherType, Map substitutes) {
		if (this.arguments == null) return;
		if (otherType instanceof ReferenceBinding) {
			// allow List<T> to match with LinkedList<String>
			ReferenceBinding equivalent = this;
	        ReferenceBinding otherEquivalent = ((ReferenceBinding)otherType).findSuperTypeErasingTo((ReferenceBinding)this.type.erasure());
	        if (otherEquivalent == null) {
	        	// allow LinkedList<String> to match List<T> (downcast scenario)
		    	equivalent = this.findSuperTypeErasingTo((ReferenceBinding)otherType.erasure());
	        	if (equivalent == null || !equivalent.isParameterizedType())
	        		return;
	        	otherEquivalent = (ReferenceBinding)otherType;
	        }
	        if (equivalent.isParameterizedType() && otherEquivalent.isParameterizedType()) {
	        	ParameterizedTypeBinding parameterizedType = (ParameterizedTypeBinding) equivalent;
	        	ParameterizedTypeBinding otherParameterizedType = (ParameterizedTypeBinding) otherEquivalent;
	            for (int i = 0, length = parameterizedType.arguments.length; i < length; i++) {
	                parameterizedType.arguments[i].collectSubstitutes(otherParameterizedType.arguments[i], substitutes);
	            }
	        } else if (equivalent.isParameterizedType() && otherEquivalent.isRawType()) {
	        	substitutes.clear(); // clear all variables to indicate raw generic method in the end
	        }
	    }
	}

