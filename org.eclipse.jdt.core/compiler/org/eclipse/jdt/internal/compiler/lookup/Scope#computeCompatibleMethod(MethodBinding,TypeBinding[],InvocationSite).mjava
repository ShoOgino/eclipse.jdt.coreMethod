	/**
	 * Internal use only
	 * Given a method, returns null if arguments cannot be converted to parameters.
	 * Will answer a subsituted method in case the method was generic and type inference got triggered;
	 * in case the method was originally compatible, then simply answer it back.
	 */
	protected final MethodBinding computeCompatibleMethod(MethodBinding method, TypeBinding[] arguments, InvocationSite invocationSite) {
		TypeBinding[] genericTypeArguments = invocationSite.genericTypeArguments();
		TypeBinding[] parameters = method.parameters;
		TypeVariableBinding[] typeVariables = method.typeVariables;
		if (parameters == arguments
			&& (method.returnType.tagBits & TagBits.HasTypeVariable) == 0
			&& genericTypeArguments == null
			&& typeVariables == Binding.NO_TYPE_VARIABLES)
				return method;

		int argLength = arguments.length;
		int paramLength = parameters.length;
		boolean isVarArgs = method.isVarargs();
		if (argLength != paramLength)
			if (!isVarArgs || argLength < paramLength - 1)
				return null; // incompatible

		if (typeVariables != Binding.NO_TYPE_VARIABLES) { // generic method
			boolean compliant14 = compilerOptions().complianceLevel < ClassFileConstants.JDK1_5;
			TypeBinding[] newArgs = null;
			for (int i = 0; i < argLength; i++) {
				TypeBinding param = i < paramLength ? parameters[i] : parameters[paramLength - 1];
				if (arguments[i].isBaseType() != param.isBaseType()) {
					if (newArgs == null) {
						newArgs = new TypeBinding[argLength];
						System.arraycopy(arguments, 0, newArgs, 0, argLength);
					}
					newArgs[i] = environment().computeBoxingType(arguments[i]);
				} else if (compliant14 && invocationSite instanceof MessageSend
						   && param.kind() == Binding.PARAMETERIZED_TYPE && param.erasure().id == TypeIds.T_JavaLangClass
						   && ((ParameterizedTypeBinding) param).arguments.length == 1 
						   && ((ParameterizedTypeBinding) param).arguments[0] instanceof TypeVariableBinding 
						   && arguments[i] instanceof BinaryTypeBinding && arguments[i].erasure().id == TypeIds.T_JavaLangClass) {
					/* https://bugs.eclipse.org/bugs/show_bug.cgi?id=328775. Class literals are special in that
					   they carry (and are the only expressions that can carry) full parameterization information
					   even in 1.4 source code. For inference during method selection/invocation to work properly,
					   resolve class literal expression's type to be a parameterized type if in 1.4 we encounter
					   a method that expects a parameter of the type Class<>   
					 */
					if (newArgs == null) {
						newArgs = new TypeBinding[argLength];
						System.arraycopy(arguments, 0, newArgs, 0, argLength);
					}
					ClassLiteralAccess classLiteral = (ClassLiteralAccess) ((MessageSend) invocationSite).arguments[i];
					// Integer.class --> Class<Integer>, perform boxing of base types (int.class --> Class<Integer>)
					// BundleWiring.class --> Class<BundleWiring>
					TypeBinding boxedType = boxing(classLiteral.targetType);
					newArgs[i] = classLiteral.resolvedType = environment().createParameterizedType(((ParameterizedTypeBinding)param).genericType(), new TypeBinding[]{ boxedType }, null /*not a member*/);
				}
			}
			if (newArgs != null)
				arguments = newArgs;
			method = ParameterizedGenericMethodBinding.computeCompatibleMethod(method, arguments, this, invocationSite);
			if (method == null) return null; // incompatible
			if (!method.isValidBinding()) return method; // bound check issue is taking precedence
		} else if (genericTypeArguments != null && compilerOptions().complianceLevel < ClassFileConstants.JDK1_7) {
			if (method instanceof ParameterizedGenericMethodBinding) {
				if (!((ParameterizedGenericMethodBinding) method).wasInferred)
					// attempt to invoke generic method of raw type with type hints <String>foo()
					return new ProblemMethodBinding(method, method.selector, genericTypeArguments, ProblemReasons.TypeArgumentsForRawGenericMethod);
			} else if (!method.isOverriding() || !isOverriddenMethodGeneric(method)) {
				return new ProblemMethodBinding(method, method.selector, genericTypeArguments, ProblemReasons.TypeParameterArityMismatch);
			}
		}

		if (parameterCompatibilityLevel(method, arguments) > NOT_COMPATIBLE)
			return method;
		if (genericTypeArguments != null)
			return new ProblemMethodBinding(method, method.selector, arguments, ProblemReasons.ParameterizedMethodTypeMismatch);
		return null; // incompatible
	}

