	private TypeBinding leastContainingInvocation(TypeBinding mec, Set invocations, List lubStack) {
		if (invocations == null) return mec; // no alternate invocation
		int length = invocations.size();
		Iterator iter = invocations.iterator();
		if (length == 1) return (TypeBinding) iter.next();
		int argLength = mec.typeVariables().length;
		if (argLength == 0) return mec; // should be caught by no invocation check

		// infer proper parameterized type from invocations
		TypeBinding[] bestArguments = new TypeBinding[argLength];
		while (iter.hasNext()) {
			TypeBinding invocation = (TypeBinding)iter.next();
			TypeVariableBinding[] invocationVariables = invocation.typeVariables();
			if (invocation.isGenericType()) {
				for (int i = 0; i < argLength; i++) {
					TypeBinding bestArgument = leastContainingTypeArgument(bestArguments[i], invocationVariables[i], (ReferenceBinding) mec, i, lubStack);
					if (bestArgument == null) return null;
					bestArguments[i] = bestArgument;
				}
			} else if (invocation.isParameterizedType()) {
				ParameterizedTypeBinding parameterizedType = (ParameterizedTypeBinding)invocation;
				for (int i = 0; i < argLength; i++) {
					TypeBinding bestArgument = leastContainingTypeArgument(bestArguments[i], parameterizedType.arguments[i], (ReferenceBinding) mec, i, lubStack);
					if (bestArgument == null) return null;
					bestArguments[i] = bestArgument;
				}
			} else if (invocation.isRawType()) {
				return invocation; // raw type is taking precedence
			}
		}
		return environment().createParameterizedType((ReferenceBinding) mec.erasure(), bestArguments, mec.enclosingType());
	}

