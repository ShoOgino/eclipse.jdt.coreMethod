public MethodBinding[] getMethods(char[] selector) {
	// handle forward references to potential default abstract methods
	addDefaultAbstractMethods();

	try{
		int count = 0;
		int lastIndex = -1;
		int selectorLength = selector.length;
		if ((modifiers & AccUnresolved) == 0) { // have resolved all arg types & return type of the methods
			for (int m = 0, length = methods.length; m < length; m++) {
				MethodBinding method = methods[m];
				if (method.selector.length == selectorLength && CharOperation.equals(method.selector, selector)) {
					count++;
					lastIndex = m;
				}
			}
		} else {
			boolean foundProblem = false;
			int failed = 0;
			for (int m = 0, length = methods.length; m < length; m++) {
				MethodBinding method = methods[m];
				if (method.selector.length == selectorLength && CharOperation.equals(method.selector, selector)) {
					if (resolveTypesFor(method) == null) {
						foundProblem = true;
						methods[m] = null; // unable to resolve parameters
						failed++;
					} else if (method.returnType == null) {
						foundProblem = true;
					} else {
						count++;
						lastIndex = m;
					}
				}
			}
	
			if (foundProblem || count > 1) {
				for (int m = methods.length; --m >= 0;) {
					MethodBinding method = methods[m];
					if (method != null && method.selector.length == selectorLength && CharOperation.equals(method.selector, selector)) {
						AbstractMethodDeclaration methodDecl = null;
						for (int i = 0; i < m; i++) {
							MethodBinding method2 = methods[i];
							if (method2 != null && CharOperation.equals(method.selector, method2.selector)) {
								if (method.areParametersEqual(method2)) {
									if (methodDecl == null) {
										methodDecl = method.sourceMethod(); // cannot be retrieved after binding is lost
										scope.problemReporter().duplicateMethodInType(this, methodDecl);
										methodDecl.binding = null;
										methods[m] = null;
										failed++;
									}
									scope.problemReporter().duplicateMethodInType(this, method2.sourceMethod());
									method2.sourceMethod().binding = null;
									methods[i] = null;
									failed++;
								}
							}
						}
						if (method.returnType == null && methodDecl == null) { // forget method with invalid return type... was kept to detect possible collisions
							method.sourceMethod().binding = null;
							methods[m] = null;
							failed++;
						}
					}
				}
	
				if (failed > 0) {
					int newSize = methods.length - failed;
					if (newSize == 0)
						return methods = NoMethods;
	
					MethodBinding[] newMethods = new MethodBinding[newSize];
					for (int i = 0, n = 0, max = methods.length; i < max; i++)
						if (methods[i] != null)
							newMethods[n++] = methods[i];
					methods = newMethods;
					return getMethods(selector); // try again now that the problem methods have been removed
				}
			}
		}
		if (count == 1)
			return new MethodBinding[] {methods[lastIndex]};
		if (count > 1) {
			MethodBinding[] result = new MethodBinding[count];
			count = 0;
			for (int m = 0; m <= lastIndex; m++) {
				MethodBinding method = methods[m];
				if (method.selector.length == selectorLength && CharOperation.equals(method.selector, selector))
					result[count++] = method;
			}
			return result;
		}
	} catch(AbortCompilation e){
		// ensure null methods are removed
		MethodBinding[] newMethods = null;
		int count = 0;
		for (int i = 0, max = methods.length; i < max; i++){
			MethodBinding method = methods[i];
			if (method == null && newMethods == null){
				System.arraycopy(methods, 0, newMethods = new MethodBinding[max], 0, i);
			} else if (newMethods != null && method != null) {
				newMethods[count++] = method;
			}
		}
		if (newMethods != null){
			System.arraycopy(newMethods, 0, methods = new MethodBinding[count], 0, count);
		}			
		modifiers ^= AccUnresolved;
		throw e;
	}		
	return NoMethods;
}
/* Answer the synthetic field for <actualOuterLocalVariable>
*	or null if one does not exist.
*/

