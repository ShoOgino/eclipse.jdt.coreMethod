private MethodBinding createMethod(IBinaryMethod method) {
	int methodModifiers = method.getModifiers() | AccUnresolved;

	ReferenceBinding[] exceptions = NoExceptions;
	char[][] exceptionTypes = method.getExceptionTypeNames();
	if (exceptionTypes != null) {
		int size = exceptionTypes.length;
		if (size > 0) {
			exceptions = new ReferenceBinding[size];
			for (int i = 0; i < size; i++)
				exceptions[i] = environment.getTypeFromConstantPoolName(exceptionTypes[i], 0, -1);
		}
	}

	TypeBinding[] parameters = NoParameters;
	char[] methodSignature = method.getMethodDescriptor();   // of the form (I[Ljava/jang/String;)V
	int numOfParams = 0;
	char nextChar;
	int index = 0;   // first character is always '(' so skip it
	while ((nextChar = methodSignature[++index]) != ')') {
		if (nextChar != '[') {
			numOfParams++;
			if (nextChar == 'L')
				while ((nextChar = methodSignature[++index]) != ';'){/*empty*/}
		}
	}

	// Ignore synthetic argument for member types.
	int startIndex = (method.isConstructor() && isMemberType() && !isStatic()) ? 1 : 0;
	int size = numOfParams - startIndex;
	if (size > 0) {
		parameters = new TypeBinding[size];
		index = 1;
		int end = 0;   // first character is always '(' so skip it
		for (int i = 0; i < numOfParams; i++) {
			while ((nextChar = methodSignature[++end]) == '['){/*empty*/}
			if (nextChar == 'L')
				while ((nextChar = methodSignature[++end]) != ';'){/*empty*/}

			if (i >= startIndex)   // skip the synthetic arg if necessary
				parameters[i - startIndex] = environment.getTypeFromSignature(methodSignature, index, end);
			index = end + 1;
		}
	}

	MethodBinding binding = null;
	if (method.isConstructor())
		binding = new MethodBinding(methodModifiers, parameters, exceptions, this);
	else
		binding = new MethodBinding(
			methodModifiers,
			method.getSelector(),
			environment.getTypeFromSignature(methodSignature, index + 1, -1),   // index is currently pointing at the ')'
			parameters,
			exceptions,
			this);
	return binding;
}

