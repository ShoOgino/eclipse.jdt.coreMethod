	// Internal use only
	public MethodBinding findMethod(
		ReferenceBinding receiverType,
		char[] selector,
		TypeBinding[] argumentTypes,
		InvocationSite invocationSite) {

		ReferenceBinding currentType = receiverType;
		MethodBinding matchingMethod = null;
		ObjectVector found = new ObjectVector();
		//boolean relyOnDefaultAbstractMethods = environment().options.targetJDK < CompilerOptions.JDK1_2;

		compilationUnitScope().recordTypeReference(receiverType);
		compilationUnitScope().recordTypeReferences(argumentTypes);
		if (currentType.isInterface()) {
			MethodBinding[] currentMethods = currentType.getMethods(selector);
			int currentLength = currentMethods.length;
			if (currentLength == 1) {
				matchingMethod = currentMethods[0];
			} else if (currentLength > 1) {
				for (int f = 0; f < currentLength; f++)
					found.add(currentMethods[f]);
			}
			matchingMethod = findMethodInSuperInterfaces(currentType, selector, found, matchingMethod);
			currentType = getJavaLangObject();
		}

		while (currentType != null) {
			MethodBinding[] currentMethods = currentType.getMethods(selector);
			int currentLength = currentMethods.length;
			if (currentLength == 1 && matchingMethod == null && found.size == 0) {
				matchingMethod = currentMethods[0];
			} else if (currentLength > 0) {
				if (found.size == 0 && matchingMethod != null)
					found.add(matchingMethod);
				for (int f = 0; f < currentLength; f++)
					found.add(currentMethods[f]);
			}

			//if (!relyOnDefaultAbstractMethods && currentType.isAbstract())
			if (currentType.isAbstract())
				matchingMethod = findMethodInSuperInterfaces(currentType, selector, found, matchingMethod);
			currentType = currentType.superclass();
		}

		int foundSize = found.size;
		if (foundSize == 0)
			return matchingMethod; // may be null - have not checked arg types or visibility

		MethodBinding[] compatible = new MethodBinding[foundSize];
		int compatibleIndex = 0;
		for (int i = 0; i < foundSize; i++) {
			MethodBinding methodBinding = (MethodBinding) found.elementAt(i);
			if (areParametersAssignable(methodBinding.parameters, argumentTypes))
				compatible[compatibleIndex++] = methodBinding;
		}
		if (compatibleIndex == 1)
			return compatible[0]; // have not checked visibility
		if (compatibleIndex == 0) { // try to find a close match when the parameter order is wrong or missing some parameters
			int argLength = argumentTypes.length;
			nextMethod : for (int i = 0; i < foundSize; i++) {
				MethodBinding methodBinding = (MethodBinding) found.elementAt(i);
				TypeBinding[] params = methodBinding.parameters;
				int paramLength = params.length;
				nextArg: for (int a = 0; a < argLength; a++) {
					TypeBinding arg = argumentTypes[a];
					for (int p = 0; p < paramLength; p++)
						if (params[p] == arg)
							continue nextArg;
					continue nextMethod;
				}
				return methodBinding;
			}
			return (MethodBinding) found.elementAt(0); // no good match so just use the first one found
		}

		MethodBinding[] visible = new MethodBinding[compatibleIndex];
		int visibleIndex = 0;
		for (int i = 0; i < compatibleIndex; i++) {
			MethodBinding methodBinding = compatible[i];
			if (methodBinding.canBeSeenBy(receiverType, invocationSite, this))
				visible[visibleIndex++] = methodBinding;
		}
		if (visibleIndex == 1) {
			compilationUnitScope().recordTypeReferences(visible[0].thrownExceptions);
			return visible[0];
		}
		if (visibleIndex == 0)
			return new ProblemMethodBinding(
				compatible[0].selector,
				argumentTypes,
				compatible[0].declaringClass,
				NotVisible);
		if (visible[0].declaringClass.isClass())
			return mostSpecificClassMethodBinding(visible, visibleIndex);
		else
			return mostSpecificInterfaceMethodBinding(visible, visibleIndex);
	}

