	// Internal use only
	public MethodBinding findMethod(
		ReferenceBinding receiverType,
		char[] selector,
		TypeBinding[] argumentTypes,
		InvocationSite invocationSite) {
		ReferenceBinding currentType = receiverType;
		MethodBinding matchingMethod = null;
		ObjectVector found = null;

		compilationUnitScope().addTypeReference(currentType);
		compilationUnitScope().addTypeReferences(argumentTypes);
		if (currentType.isInterface()) {
			MethodBinding[] currentMethods = currentType.getMethods(selector);
			int currentLength = currentMethods.length;
			if (currentLength == 1) {
				matchingMethod = currentMethods[0];
			} else if (currentLength > 1) {
				found = new ObjectVector();
				for (int f = 0; f < currentLength; f++)
					found.add(currentMethods[f]);
			}
			ReferenceBinding[] itsInterfaces = currentType.superInterfaces();
			if (itsInterfaces != NoSuperInterfaces) {
				ReferenceBinding[][] interfacesToVisit = new ReferenceBinding[5][];
				int lastPosition = -1;
				if (++lastPosition == interfacesToVisit.length)
					System.arraycopy(
						interfacesToVisit,
						0,
						interfacesToVisit = new ReferenceBinding[lastPosition * 2][],
						0,
						lastPosition);
				interfacesToVisit[lastPosition] = itsInterfaces;

				for (int i = 0; i <= lastPosition; i++) {
					ReferenceBinding[] interfaces = interfacesToVisit[i];
					for (int j = 0, length = interfaces.length; j < length; j++) {
						currentType = interfaces[j];
						if ((currentType.tagBits & InterfaceVisited) == 0) {
							// if interface as not already been visited
							currentType.tagBits |= InterfaceVisited;

							currentMethods = currentType.getMethods(selector);
							if ((currentLength = currentMethods.length) == 1
								&& matchingMethod == null
								&& found == null) {
								matchingMethod = currentMethods[0];
							} else if (currentLength > 0) {
								if (found == null) {
									found = new ObjectVector();
									if (matchingMethod != null)
										found.add(matchingMethod);
								}
								for (int f = 0; f < currentLength; f++)
									found.add(currentMethods[f]);
							}
							itsInterfaces = currentType.superInterfaces();
							if (itsInterfaces != NoSuperInterfaces) {
								if (++lastPosition == interfacesToVisit.length)
									System.arraycopy(
										interfacesToVisit,
										0,
										interfacesToVisit = new ReferenceBinding[lastPosition * 2][],
										0,
										lastPosition);
								interfacesToVisit[lastPosition] = itsInterfaces;
							}
						}
					}
				}
				// bit reinitialization
				for (int i = 0; i <= lastPosition; i++) {
					ReferenceBinding[] interfaces = interfacesToVisit[i];
					for (int j = 0, length = interfaces.length; j < length; j++)
						interfaces[j].tagBits &= ~InterfaceVisited;
				}
			}
			currentType =
				(matchingMethod == null && found == null) ? getJavaLangObject() : null;
		}
		while (currentType != null) {
			MethodBinding[] currentMethods = currentType.getMethods(selector);
			int currentLength = currentMethods.length;
			if (currentLength == 1 && matchingMethod == null && found == null) {
				matchingMethod = currentMethods[0];
			} else if (currentLength > 0) {
				if (found == null) {
					found = new ObjectVector();
					if (matchingMethod != null)
						found.add(matchingMethod);
				}
				for (int f = 0; f < currentLength; f++)
					found.add(currentMethods[f]);
			}
			currentType = currentType.superclass();
		}

		if (found == null)
			return matchingMethod;
		// may be null - have not checked arg types or visibility

		int foundSize = found.size;
		MethodBinding[] compatible = new MethodBinding[foundSize];
		int compatibleIndex = 0;
		for (int i = 0; i < foundSize; i++) {
			MethodBinding methodBinding = (MethodBinding) found.elementAt(i);
			if (areParametersAssignable(methodBinding.parameters, argumentTypes))
				compatible[compatibleIndex++] = methodBinding;
		}
		if (compatibleIndex == 1)
			return compatible[0]; // have not checked visibility
		if (compatibleIndex == 0)
			return (MethodBinding) found.elementAt(0);
		// no good match so just use the first one found

		MethodBinding[] visible = new MethodBinding[compatibleIndex];
		int visibleIndex = 0;
		for (int i = 0; i < compatibleIndex; i++) {
			MethodBinding methodBinding = compatible[i];
			if (methodBinding.canBeSeenBy(receiverType, invocationSite, this))
				visible[visibleIndex++] = methodBinding;
		}
		if (visibleIndex == 1) {
			compilationUnitScope().addTypeReferences(visible[0].thrownExceptions);
			return visible[0];
		}
		if (visibleIndex == 0)
			return new ProblemMethodBinding(
				compatible[0].selector,
				argumentTypes,
				compatible[0].declaringClass,
				NotVisible);
		if (visible[0].declaringClass.isClass())
			return mostSpecificClassMethodBinding(visible, visibleIndex);
		else
			return mostSpecificInterfaceMethodBinding(visible, visibleIndex);
	}

