	/* Spec : 8.4.3 & 9.4
	 */
	private void checkAndSetModifiersForConstructor(MethodBinding methodBinding) {
		
		int modifiers = methodBinding.modifiers;
		final ReferenceBinding declaringClass = methodBinding.declaringClass;
		if ((modifiers & ExtraCompilerModifiers.AccAlternateModifierProblem) != 0)
			problemReporter().duplicateModifierForMethod(declaringClass, (AbstractMethodDeclaration) referenceContext);

		if (((ConstructorDeclaration) referenceContext).isDefaultConstructor) {
			if (declaringClass.isEnum())
				modifiers = ClassFileConstants.AccPrivate;
			else if (declaringClass.isPublic())
				modifiers |= ClassFileConstants.AccPublic;
			else if (declaringClass.isProtected())
				modifiers |= ClassFileConstants.AccProtected;
		}

		// after this point, tests on the 16 bits reserved.
		int realModifiers = modifiers & ExtraCompilerModifiers.AccJustFlag;

		// check for abnormal modifiers
		int unexpectedModifiers = ~(ClassFileConstants.AccPublic | ClassFileConstants.AccPrivate | ClassFileConstants.AccProtected | ClassFileConstants.AccStrictfp);
		if (declaringClass.isEnum() && !((ConstructorDeclaration) referenceContext).isDefaultConstructor) {
			unexpectedModifiers = ~(ClassFileConstants.AccPrivate | ClassFileConstants.AccStrictfp);
			if ((realModifiers & unexpectedModifiers) != 0) {
				problemReporter().illegalModifierForEnumConstructor((AbstractMethodDeclaration) referenceContext);
				modifiers &= ~ExtraCompilerModifiers.AccJustFlag | ~unexpectedModifiers;
			} else if ((((AbstractMethodDeclaration) referenceContext).modifiers & ClassFileConstants.AccStrictfp) != 0) {
				// must check the parse node explicitly
				problemReporter().illegalModifierForMethod((AbstractMethodDeclaration) referenceContext);
			}
			modifiers |= ClassFileConstants.AccPrivate; // enum constructor is implicitly private
		} else if ((realModifiers & unexpectedModifiers) != 0) {
			problemReporter().illegalModifierForMethod((AbstractMethodDeclaration) referenceContext);
			modifiers &= ~ExtraCompilerModifiers.AccJustFlag | ~unexpectedModifiers;
		} else if ((((AbstractMethodDeclaration) referenceContext).modifiers & ClassFileConstants.AccStrictfp) != 0) {
			// must check the parse node explicitly
			problemReporter().illegalModifierForMethod((AbstractMethodDeclaration) referenceContext);
		}

		// check for incompatible modifiers in the visibility bits, isolate the visibility bits
		int accessorBits = realModifiers & (ClassFileConstants.AccPublic | ClassFileConstants.AccProtected | ClassFileConstants.AccPrivate);
		if ((accessorBits & (accessorBits - 1)) != 0) {
			problemReporter().illegalVisibilityModifierCombinationForMethod(declaringClass, (AbstractMethodDeclaration) referenceContext);

			// need to keep the less restrictive so disable Protected/Private as necessary
			if ((accessorBits & ClassFileConstants.AccPublic) != 0) {
				if ((accessorBits & ClassFileConstants.AccProtected) != 0)
					modifiers &= ~ClassFileConstants.AccProtected;
				if ((accessorBits & ClassFileConstants.AccPrivate) != 0)
					modifiers &= ~ClassFileConstants.AccPrivate;
			} else if ((accessorBits & ClassFileConstants.AccProtected) != 0 && (accessorBits & ClassFileConstants.AccPrivate) != 0) {
				modifiers &= ~ClassFileConstants.AccPrivate;
			}
		}

		// if the receiver's declaring class is a private nested type, then make sure the receiver is not private (causes problems for inner type emulation)
		if (declaringClass.isPrivate() && (modifiers & ClassFileConstants.AccPrivate) != 0)
			modifiers &= ~ClassFileConstants.AccPrivate;

		methodBinding.modifiers = modifiers;
	}

