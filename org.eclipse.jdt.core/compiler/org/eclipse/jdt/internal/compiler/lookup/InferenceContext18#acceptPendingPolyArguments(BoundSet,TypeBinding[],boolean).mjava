	private void acceptPendingPolyArguments(BoundSet acceptedResult, TypeBinding[] parameterTypes, boolean isVarArgs) {
		if (acceptedResult == null || this.invocationArguments == null) return;
		Substitution substitution = getResultSubstitution(acceptedResult);
		for (int i = 0; i < this.invocationArguments.length; i++) {
			TypeBinding targetType = getParameter(parameterTypes, i, isVarArgs);
			if (!targetType.isProperType(true))
				targetType = Scope.substitute(substitution, targetType);
			Expression expression = this.invocationArguments[i];
			expression.checkAgainstFinalTargetType(targetType);
			if (expression instanceof Invocation) {
				Invocation invocation = (Invocation) expression;
				if (!this.innerPolies.contains(invocation)) {
					MethodBinding method = invocation.binding(targetType);
					if (method instanceof ParameterizedGenericMethodBinding) {
						ParameterizedGenericMethodBinding previousBinding = (ParameterizedGenericMethodBinding) method;
						InferenceContext18 innerCtx = invocation.getInferenceContext(previousBinding);
						if (innerCtx != null) {
							// we have a non-poly generic invocation, which needs inference but is not connected via innerPolis.
							// Finish that inner inference now (incl. binding updates):
							MethodBinding innerBinding = innerCtx.inferInvocationType(invocation, previousBinding);
							if (!innerBinding.isValidBinding()) {
								if (invocation instanceof MessageSend)
									innerCtx.scope.problemReporter().invalidMethod((MessageSend) invocation, innerBinding);
								else
									innerCtx.scope.problemReporter().invalidConstructor(expression, innerBinding);
							}
							if (invocation.updateBindings(innerBinding, targetType)) { // only if we are actually improving anything
								ASTNode.resolvePolyExpressionArguments(invocation, innerBinding);
							}
						}
					}
				}
			}
		}
	}

