void checkForBridgeMethod(MethodBinding currentMethod, MethodBinding inheritedMethod, MethodBinding[] otherInheritedMethods) {
	if (currentMethod.isVarargs() != inheritedMethod.isVarargs())
		problemReporter(currentMethod).varargsConflict(currentMethod, inheritedMethod);

	MethodBinding originalInherited = inheritedMethod.original();

	// so the parameters are equal and the return type is compatible b/w the currentMethod & the substituted inheritedMethod
	if (originalInherited.returnType != currentMethod.returnType) {
		if (inheritedMethod.returnType.leafComponentType().isParameterizedType()) {
			if (currentMethod.returnType.leafComponentType().isRawType())
				problemReporter(currentMethod).unsafeReturnTypeOverride(currentMethod, originalInherited, ((MethodDeclaration) currentMethod.sourceMethod()).returnType);
//		} else if (inheritedMethod.hasSubstitutedReturnType() && originalInherited.returnType.leafComponentType().isTypeVariable()) {
		} else if (originalInherited.returnType.leafComponentType().isTypeVariable()) { // 
				if (((TypeVariableBinding) originalInherited.returnType.leafComponentType()).declaringElement == originalInherited) { // see 81618 - type variable from inherited method
					TypeBinding currentReturnType = currentMethod.returnType.leafComponentType();
					if (!currentReturnType.isTypeVariable() || ((TypeVariableBinding) currentReturnType).declaringElement != currentMethod)
						problemReporter(currentMethod).unsafeReturnTypeOverride(currentMethod, originalInherited, ((MethodDeclaration) currentMethod.sourceMethod()).returnType);
				}
		}
	}

	if (this.type.addSyntheticBridgeMethod(originalInherited, currentMethod) != null) {
		for (int i = 0, l = otherInheritedMethods.length; i < l; i++) {
			if (otherInheritedMethods[i] != null) {
				MethodBinding otherOriginal = otherInheritedMethods[i].original();
				if (otherOriginal != otherInheritedMethods[i] && detectInheritedMethodClash(originalInherited, otherOriginal))
					return;
			}
		}

		// there is an ordering issue with the comparison in checkMethods
		// its possible that compareTo(X) is walked first & removes Comparable.compareTo(T) from the inherited list before we can compare it to compareTo(Object)
		// its only a problem when the matching inherited method creates a bridge method which collides with an unwalked current method
		//		class X implements Comparable<X> {
		//			public int compareTo(Object o) { return 0; }
		//			public int compareTo(X o) { return 1; }
		//		}
		MethodBinding[] toCheck = (MethodBinding[]) this.currentMethods.get(currentMethod.selector);
		for (int i = 0, l = toCheck.length; i < l; i++)
			if (currentMethod != toCheck[i] && detectNameClash(toCheck[i], inheritedMethod))
				return;
	}
}

