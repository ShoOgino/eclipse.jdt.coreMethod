void checkForBridgeMethod(MethodBinding currentMethod, MethodBinding inheritedMethod, MethodBinding[] otherInheritedMethods) {
	MethodBinding originalInherited = inheritedMethod.original();

	// so the parameters are equal and the return type is compatible b/w the currentMethod & the substituted inheritedMethod
	if (originalInherited.returnType != currentMethod.returnType) {
		TypeBinding originalReturnType = originalInherited.returnType.leafComponentType();
		switch (originalReturnType.kind()) {
			case Binding.GENERIC_TYPE :
				// TODO (philippe) - we need this hack until SourceTypeBindings stop acting as ParameterizedTypes
				if (originalReturnType != originalInherited.declaringClass || !inheritedMethod.returnType.leafComponentType().isParameterizedType())
					break;
			case Binding.PARAMETERIZED_TYPE :
				if (!currentMethod.returnType.leafComponentType().isParameterizedType()) {
					if (currentMethod.returnType.leafComponentType().isRawType() && inheritedMethod.returnType.leafComponentType().isRawType())
						break;
					problemReporter(currentMethod).unsafeReturnTypeOverride(currentMethod, originalInherited, ((MethodDeclaration) currentMethod.sourceMethod()).returnType);
				}
				break;
			case Binding.TYPE_PARAMETER : // see 81618
				if (((TypeVariableBinding) originalReturnType).declaringElement == originalInherited) {
					TypeBinding returnType = currentMethod.returnType.leafComponentType();
					if (!returnType.isTypeVariable() || ((TypeVariableBinding) returnType).declaringElement != currentMethod)
						problemReporter(currentMethod).unsafeReturnTypeOverride(currentMethod, originalInherited, ((MethodDeclaration) currentMethod.sourceMethod()).returnType);
				}
				break;
		}
	}

	if (this.type.addSyntheticBridgeMethod(originalInherited, currentMethod) != null) {
		for (int i = 0, l = otherInheritedMethods.length; i < l; i++) {
			if (otherInheritedMethods[i] != null) {
				MethodBinding otherOriginal = otherInheritedMethods[i].original();
				if (otherOriginal != otherInheritedMethods[i] && detectInheritedMethodClash(originalInherited, otherOriginal))
					return;
			}
		}

		// there is an ordering issue with the comparison in checkMethods
		// its possible that compareTo(X) is walked first & removes Comparable.compareTo(T) from the inherited list before we can compare it to compareTo(Object)
		// its only a problem when the matching inherited method creates a bridge method which collides with an unwalked current method
		//		class X implements Comparable<X> {
		//			public int compareTo(Object o) { return 0; }
		//			public int compareTo(X o) { return 1; }
		//		}
		MethodBinding[] toCheck = (MethodBinding[]) this.currentMethods.get(currentMethod.selector);
		for (int i = 0, l = toCheck.length; i < l; i++)
			if (currentMethod != toCheck[i] && detectNameClash(toCheck[i], inheritedMethod))
				return;
	}
}

