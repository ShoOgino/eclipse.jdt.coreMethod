	/**
	 * <b>JLS 18.3:</b> Try to infer new constraints from pairs of existing type bounds.
	 * Each new constraint is first reduced and checked for TRUE or FALSE, which will
	 * abort the processing. 
	 * @param context the context that manages our inference variables
	 * @return false if any constraint resolved to false, true otherwise  
	 * @throws InferenceFailureException a compile error has been detected during inference
	 */
	boolean incorporate(InferenceContext18 context) throws InferenceFailureException {
		boolean hasUpdate;
		do {
			hasUpdate = false;
			// using a flattened copy also allows us to insert more bounds during the process
			// without disturbing the current round of incorporation:
			TypeBound[] bounds = flatten();
			int boundsCount = bounds.length;
			if (boundsCount < 2)
				return true;
			// check each pair:
			for (int i = 0; i < boundsCount; i++) {
				TypeBound boundI = bounds[i];
				for (int j = i+1; j < boundsCount; j++) {
					TypeBound boundJ = bounds[j];
					if (this.incorporatedBounds.contains(boundI) && this.incorporatedBounds.contains(boundJ))
						continue;
					ConstraintFormula newConstraint = null;
					switch (boundI.relation) {
						case ReductionResult.SAME:
							switch (boundJ.relation) {
								case ReductionResult.SAME:
									newConstraint = combineSameSame(boundI, boundJ);
									break;
								case ReductionResult.SUBTYPE:
								case ReductionResult.SUPERTYPE:
									newConstraint = combineSameSubSuper(boundI, boundJ);
									break;
							}
							break;
						case ReductionResult.SUBTYPE:
							switch (boundJ.relation) {
								case ReductionResult.SAME:
									newConstraint = combineSameSubSuper(boundJ, boundI);
									break;
								case ReductionResult.SUPERTYPE:
									newConstraint = combineSuperAndSub(boundJ, boundI);
									break;
								case ReductionResult.SUBTYPE:
									newConstraint = combineEqualSupers(boundI, boundJ);
									break;
							}
							break;
						case ReductionResult.SUPERTYPE:
							switch (boundJ.relation) {
								case ReductionResult.SAME:
									newConstraint = combineSameSubSuper(boundJ, boundI);
									break;
								case ReductionResult.SUBTYPE:
									newConstraint = combineSuperAndSub(boundI, boundJ);
									break;
								case ReductionResult.SUPERTYPE:
									newConstraint = combineEqualSupers(boundI, boundJ);
									break;
							}
					}
					if (newConstraint != null) {
						if (!reduceOneConstraint(context, newConstraint))
							return false;
						// TODO here and below: better checking if constraint really added to the boundset (optimization)?
						hasUpdate = true;
					}
					ConstraintFormula[] typeArgumentConstraints = deriveTypeArgumentConstraints(boundI, boundJ);
					if (typeArgumentConstraints != null) {
						for (int k = 0; k < typeArgumentConstraints.length; k++) {
							if (!reduceOneConstraint(context, typeArgumentConstraints[k]))
								return false;
							hasUpdate = true;
						}
					}
				}
				this.incorporatedBounds.add(boundI);
			}
			/* TODO: are we sure this will always terminate? Cf. e.g. (Discussion in 18.3):
			 *  
			 *    "The assertion that incorporation reaches a fixed point oversimplifies the matter slightly. ..."
			 */
			Iterator captIter = this.captures.entrySet().iterator();
			while (captIter.hasNext()) {
				hasUpdate = true;
				Map.Entry capt = (Entry) captIter.next();
				ParameterizedTypeBinding gAlpha = (ParameterizedTypeBinding) capt.getKey();
				ParameterizedTypeBinding gA = (ParameterizedTypeBinding) capt.getValue();
				ReferenceBinding g = (ReferenceBinding) gA.original();
				TypeVariableBinding[] parameters = g.typeVariables();
				for (int i = 0; i < parameters.length; i++) {
					// A set of bounds on α1, ..., αn, constructed from the declared bounds of P1, ..., Pn as described in 18.1.3, is immediately implied.
					TypeVariableBinding pi = parameters[i];
					InferenceVariable alpha = (InferenceVariable) gAlpha.arguments[i];
					addBounds(pi.getTypeBounds(alpha, context));

					TypeBinding ai = gA.arguments[i];
					if (ai instanceof WildcardBinding) {
						WildcardBinding wildcardBinding = (WildcardBinding)ai;
						TypeBinding t = wildcardBinding.bound;
						ThreeSets three = (ThreeSets) this.boundsPerVariable.get(alpha);
						if (three != null) {
							Iterator it;
							if (three.sameBounds != null) {
								//  α = R implies false
								it = three.sameBounds.iterator();
								while (it.hasNext()) {
									TypeBound bound = (TypeBound) it.next();
									if (!(bound.right instanceof InferenceVariable))
										return false;
								}
							}
							if (three.subBounds != null && pi.firstBound != null) {
								// If Bi is Object, α <: R implies ⟨T <: R⟩	(extends wildcard)
								// α <: R implies ⟨θ Bi <: R⟩				(else) 
								it = three.subBounds.iterator();
								while (it.hasNext()) {
									TypeBound bound = (TypeBound) it.next();
									if (!(bound.right instanceof InferenceVariable)) {
										TypeBinding r = bound.right;
										TypeBinding bi1 = pi.firstBound;
										ReferenceBinding[] otherBounds = pi.superInterfaces;
										TypeBinding bi;
										if (otherBounds == Binding.NO_SUPERINTERFACES) {
											bi = bi1;
										} else {
											int n = otherBounds.length+1;
											ReferenceBinding[] allBounds = new ReferenceBinding[n];
											allBounds[0] = (ReferenceBinding) bi1; // TODO is this safe?
											System.arraycopy(otherBounds, 0, allBounds, 1, n-1);
											bi = new IntersectionCastTypeBinding(allBounds, context.environment);
										}
										addTypeBoundsFromWildcardBound(context, wildcardBinding.boundKind, t, r, bi);
//										if (otherBounds != null) {
//											for (int j = 0; j < otherBounds.length; j++) {
//												TypeBinding tj = otherBounds[j];
//												if (TypeBinding.notEquals(tj, t))
//													addTypeBoundsFromWildcardBound(context, wildcardBinding, tj, r, bij);
//											}
//										}
									}
								}
							}
							if (three.superBounds != null) {
								//  R <: α implies ⟨R <: T⟩  (super wildcard)
								//  R <: α implies false	 (else) 
								it = three.superBounds.iterator();
								while (it.hasNext()) {
									TypeBound bound = (TypeBound) it.next();
									if (!(bound.right instanceof InferenceVariable)) {
										if (wildcardBinding.boundKind == Wildcard.SUPER)
											reduceOneConstraint(context, new ConstraintTypeFormula(bound.right, t, ReductionResult.SUBTYPE));
										else
											return false;
									}
								}
							}
						}
					} else {
						addBound(new TypeBound(alpha, context.substitute(ai), ReductionResult.SAME));
					}
				}
			}
			this.captures.clear();
		} while (hasUpdate);
		return true;
	}

