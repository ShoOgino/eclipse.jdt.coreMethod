/* Answer the type corresponding to the signature from the binary file.
* Does not ask the oracle for the type if its not found in the cache... instead an
* unresolved type is returned which must be resolved before used.
*
* NOTE: Does answer base types & array types.
*/
TypeBinding getTypeFromSignature(char[] signature, int start, int end, boolean isParameterized, TypeBinding enclosingType, 
		char[][][] missingTypeNames, TypeAnnotationWalker walker)
{
	int dimension = 0;
	while (signature[start] == '[') {
		start++;
		dimension++;
	}
	// null annotations on dimensions?
	long[] annotationTagBitsOnDimensions = null;
	if (dimension > 0 && walker != TypeAnnotationWalker.EMPTY_ANNOTATION_WALKER) {
		annotationTagBitsOnDimensions = getAnnotationTagBitsOnDimensions(dimension, walker);
	}

	if (end == -1)
		end = signature.length - 1;

	// Just switch on signature[start] - the L case is the else
	TypeBinding binding = null;
	if (start == end) {
		switch (signature[start]) {
			case 'I' :
				binding = TypeBinding.INT;
				break;
			case 'Z' :
				binding = TypeBinding.BOOLEAN;
				break;
			case 'V' :
				binding = TypeBinding.VOID;
				break;
			case 'C' :
				binding = TypeBinding.CHAR;
				break;
			case 'D' :
				binding = TypeBinding.DOUBLE;
				break;
			case 'B' :
				binding = TypeBinding.BYTE;
				break;
			case 'F' :
				binding = TypeBinding.FLOAT;
				break;
			case 'J' :
				binding = TypeBinding.LONG;
				break;
			case 'S' :
				binding = TypeBinding.SHORT;
				break;
			default :
				this.problemReporter.corruptedSignature(enclosingType, signature, start);
				// will never reach here, since error will cause abort
		}
	} else {
		ReferenceBinding refType = getTypeFromConstantPoolName(signature, start + 1, end, isParameterized, missingTypeNames); // skip leading 'L' or 'T'
		int depth = refType.depth();
		while (depth > 0 && walker != TypeAnnotationWalker.EMPTY_ANNOTATION_WALKER) {
			walker = walker.toNextNestedType();
			depth--;
		}
		long tagBits = typeAnnotationsToTagBits(walker.getAnnotationsAtCursor());
		if (tagBits != 0 && annotationTagBitsOnDimensions == null) {
			binding = createAnnotatedType(refType, tagBits);
		} else {
			if (annotationTagBitsOnDimensions != null)
				annotationTagBitsOnDimensions[dimension] = tagBits; // insert leaf type into array
			binding = refType;
		}
	}

	if (dimension == 0)
		return binding;
	if (annotationTagBitsOnDimensions != null)
		return createArrayType(binding, dimension, annotationTagBitsOnDimensions);
	return createArrayType(binding, dimension);
}

