void checkInheritedMethods(MethodBinding inheritedMethod, MethodBinding otherInheritedMethod) {
	// sent from checkMethods() to compare 2 inherited methods that are not 'equal'
	if (inheritedMethod.declaringClass.erasure() == otherInheritedMethod.declaringClass.erasure()) {
		boolean areDuplicates = inheritedMethod.hasSubstitutedParameters() && otherInheritedMethod.hasSubstitutedParameters()
			? inheritedMethod.areParametersEqual(otherInheritedMethod)
			: inheritedMethod.areParameterErasuresEqual(otherInheritedMethod);
		if (areDuplicates) {
			problemReporter().duplicateInheritedMethods(this.type, inheritedMethod, otherInheritedMethod);
			return;
		}
	}

	// the 2 inherited methods clash because of a parameterized type overrides a raw type
	//		interface I { void foo(A a); }
	//		class Y { void foo(A<String> a) {} }
	//		abstract class X extends Y implements I { }
	//		class A<T> {}
	// in this case the 2 inherited methods clash because of type variables
	//		interface I { <T, S> void foo(T t); }
	//		class Y { <T> void foo(T t) {} }
	//		abstract class X extends Y implements I {}

	if (inheritedMethod.declaringClass.isInterface() || inheritedMethod.isStatic()) return;

	detectInheritedNameClash(inheritedMethod.original(), otherInheritedMethod.original());
}

