// 8.4.8.4
void checkInheritedMethods(MethodBinding[] methods, int length, boolean[] isOverridden) {
	boolean continueInvestigation = true;
	MethodBinding concreteMethod = null;
	for (int i = 0; i < length; i++) {
		// when unexpectedly seeing a non-abstract interface method regard it as abstract, too, for this check:
		boolean isAbstract = methods[i].isAbstract() || methods[i].declaringClass.isInterface();
		if (!isAbstract) {
			if (concreteMethod != null) {
				// https://bugs.eclipse.org/195802 with https://bugs.eclipse.org/410325
				// If a replace method (from findReplacedMethod()) is the rawified version of another
				// don't count this as duplicates:
				//   (Not asking ParameterizedGenericMethodBinding.isRawMethod(),
				//    because that is true only for methods of a RawTypeBinding,
				//    but here we look for rawness regarding the method's type variables).
				if (concreteMethod.declaringClass == methods[i].declaringClass 
						&& concreteMethod.typeVariables.length != methods[i].typeVariables.length) 
				{
					if (concreteMethod.typeVariables == Binding.NO_TYPE_VARIABLES
							&& concreteMethod.original() == methods[i])
						continue;
					if (methods[i].typeVariables == Binding.NO_TYPE_VARIABLES
							&& methods[i].original() == concreteMethod)
						continue;
				}

				problemReporter().duplicateInheritedMethods(this.type, concreteMethod, methods[i]);
				continueInvestigation = false;
			}
			concreteMethod = methods[i];
		}
	}
	if (continueInvestigation) {
		super.checkInheritedMethods(methods, length, isOverridden);
	}
}

