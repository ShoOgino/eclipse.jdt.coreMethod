/**
 * Recursively check if the given annotations are redundant with equal annotations at an enclosing level.
 * @param location fallback location to report the warning against (if we can't blame a specific annotation)
 * @param annotations search these for the annotation that should be blamed in warning messages
 * @param nullBits when using declaration annotations these are the annotationTagBits, for type annotations the bitvector from {@link Binding#NullnessDefaultMASK}
 * @param useNullTypeAnnotations toggles the interpretation of 'nullBits'
 * 
 * @pre null annotation analysis is enabled
 */
protected void checkRedundantNullnessDefaultRecurse(ASTNode location, Annotation[] annotations, long nullBits, boolean useNullTypeAnnotations) {
	
	if (!isPrototype()) throw new IllegalStateException();
	
	Binding target = this.fPackage.findDefaultNullnessTarget(useNullTypeAnnotations
									? n -> n == nullBits
									: n -> (n == NONNULL_BY_DEFAULT && ((nullBits & TagBits.AnnotationNonNullByDefault) != 0)));
	if (target != null) {
		this.scope.problemReporter().nullDefaultAnnotationIsRedundant(location, annotations, target);
	}
}

