/**
 * Recursively check if the given annotations are redundant with equal annotations at an enclosing level.
 * @param location fallback location to report the warning against (if we can't blame a specific annotation)
 * @param annotations search these for the annotation that should be blamed in warning messages
 * @param nullBits when using declaration annotations these are the annotationTagBits, for type annotations the bitvector from {@link Binding#NullnessDefaultMASK}
 * @param useNullTypeAnnotations toggles the interpretation of 'nullBits'
 * 
 * @pre null annotation analysis is enabled
 */
protected void checkRedundantNullnessDefaultRecurse(ASTNode location, Annotation[] annotations, long nullBits, boolean useNullTypeAnnotations) {
	
	if (!isPrototype()) throw new IllegalStateException();
	
	if (this.fPackage.defaultNullness != NO_NULL_DEFAULT) {
		boolean isRedundant = useNullTypeAnnotations
				? this.fPackage.defaultNullness == nullBits
				: (this.fPackage.defaultNullness == NONNULL_BY_DEFAULT
						&& ((nullBits & TagBits.AnnotationNonNullByDefault) != 0));
		if (isRedundant) {
			this.scope.problemReporter().nullDefaultAnnotationIsRedundant(location, annotations, this.fPackage);
		}
		return;
	}
}

