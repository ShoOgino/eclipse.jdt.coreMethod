	public static MethodBinding computeCompatibleMethod18(MethodBinding originalMethod, TypeBinding[] arguments, final Scope scope, InvocationSite invocationSite) {
		
		ParameterizedGenericMethodBinding methodSubstitute = null;
		TypeVariableBinding[] typeVariables = originalMethod.typeVariables;
		InferenceContext18 infCtx18 = null;
		TypeBinding[] parameters = originalMethod.parameters;
		infCtx18 = invocationSite.freshInferenceContext(scope);
		CompilerOptions compilerOptions = scope.compilerOptions();
		boolean invocationTypeInferred = false;
		
		try {
			BoundSet provisionalResult = null;
			BoundSet result = null;
			// ---- 18.5.1 (Applicability): ----
			final boolean isPolyExpression = invocationSite instanceof Expression && ((Expression)invocationSite).isPolyExpression(originalMethod);
			boolean isDiamond = isPolyExpression && originalMethod.isConstructor();
			if (arguments.length == parameters.length) {
				infCtx18.inferenceKind = InferenceContext18.CHECK_LOOSE; // TODO: validate if 2 phase checking (strict/loose + vararg) is sufficient.
				infCtx18.inferInvocationApplicability(originalMethod, arguments, isDiamond);
				result = infCtx18.solve(true);
			}
			if (result == null && originalMethod.isVarargs()) {
				// check for variable-arity applicability
				infCtx18 = invocationSite.freshInferenceContext(scope); // start over
				infCtx18.inferenceKind = InferenceContext18.CHECK_VARARG;
				infCtx18.inferInvocationApplicability(originalMethod, arguments, isDiamond);
				result = infCtx18.solve(true);
			}
			if (result == null)
				return null;
			if (infCtx18.isResolved(result)) {
				infCtx18.stepCompleted = InferenceContext18.APPLICABILITY_INFERRED;
				if (invocationSite instanceof ReferenceExpression)
					((ReferenceExpression) invocationSite).inferenceKind = infCtx18.inferenceKind;   // CHECK
			} else {
				return null;
			}
			// Applicability succeeded, proceed to infer invocation type, if possible.
			TypeBinding expectedType = invocationSite.invocationTargetType();
			boolean hasReturnProblem = false;
			if (expectedType != null || !invocationSite.getExpressionContext().definesTargetType()) {
				// ---- 18.5.2 (Invocation type): ----
				provisionalResult = result;
				result = infCtx18.inferInvocationType(expectedType, invocationSite, originalMethod);
				invocationTypeInferred = true;
				hasReturnProblem |= result == null;
				if (hasReturnProblem)
					result = provisionalResult; // let's prefer a type error regarding the return type over reporting no match at all
			}
			if (result != null) {
				// assemble the solution etc:
				TypeBinding[] solutions = infCtx18.getSolutions(typeVariables, invocationSite, result);
				if (solutions != null) {
					methodSubstitute = scope.environment().createParameterizedGenericMethod(originalMethod, solutions);
					if (hasReturnProblem) { // illegally working from the provisional result?
						MethodBinding problemMethod = infCtx18.getReturnProblemMethodIfNeeded(expectedType, methodSubstitute);
						if (problemMethod instanceof ProblemMethodBinding) {
							methodSubstitute = null;
							return problemMethod;
						}
					}
					if (invocationTypeInferred) {
						if (compilerOptions.isAnnotationBasedNullAnalysisEnabled)
							NullAnnotationMatching.checkForContraditions(methodSubstitute, invocationSite, scope);
						MethodBinding problemMethod = methodSubstitute.boundCheck18(scope, arguments);
						if (problemMethod != null) {
							methodSubstitute = null;
							return problemMethod;
						}
						infCtx18.solutionsPerTargetType.put(expectedType, new Solution(methodSubstitute, result));
					} else {
						methodSubstitute = new PolyParameterizedGenericMethodBinding(methodSubstitute);
					}
					if (invocationSite instanceof Invocation)
						((Invocation) invocationSite).registerInferenceContext(methodSubstitute, infCtx18); // keep context so we can finish later
					return methodSubstitute; 
				}
			}
			return null;
		} catch (InferenceFailureException e) {
			// FIXME stop-gap measure
			scope.problemReporter().genericInferenceError(e.getMessage(), invocationSite);
			return null;
		}
	}

