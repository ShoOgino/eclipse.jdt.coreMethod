	/**
	 * Perform inference of generic method type parameters and/or expected type
	 */	
	public static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope, InvocationSite invocationSite) {
		
		ParameterizedGenericMethodBinding methodSubstitute;
		TypeVariableBinding[] typeVariables = originalMethod.typeVariables;
		TypeBinding[] substitutes = invocationSite.genericTypeArguments();
		
		if (substitutes != null) {
			if (substitutes.length != typeVariables.length) {
		        // incompatible due to wrong arity
		        return new ProblemMethodBinding(originalMethod, originalMethod.selector, substitutes, TypeParameterArityMismatch);
			}
			methodSubstitute = new ParameterizedGenericMethodBinding(originalMethod, substitutes, scope.environment());
		} else {
			// perform type inference based on argument types and expected type
			
			// collect substitutes by pattern matching parameters and arguments
			TypeBinding[] parameters = originalMethod.parameters;
			int varLength = typeVariables.length;
			HashMap collectedSubstitutes = new HashMap(varLength);
			for (int i = 0; i < varLength; i++)
				collectedSubstitutes.put(typeVariables[i], new TypeBinding[1]);
			
			// collect argument type mapping, handling varargs
			if (originalMethod.isVarargs()) {
				int paramLength = parameters.length;
				int minArgLength = paramLength - 1;
				int argLength = arguments.length;
				// process mandatory arguments
				for (int i = 0; i < minArgLength; i++)
					parameters[i].collectSubstitutes(arguments[i], collectedSubstitutes);
				// process optional arguments
				if (minArgLength < argLength) {
					TypeBinding varargType = parameters[minArgLength]; // last arg type - as is ?
					if (paramLength != argLength // argument is passed as is ?
							/*||  (arguments[minArgLength] != NullBinding
									&& (arguments[minArgLength].dimensions() != varargType.dimensions()))*/) { 
						varargType = ((ArrayBinding)varargType).elementsType(); // eliminate one array dimension
					}
					for (int i = minArgLength; i < argLength; i++)
						varargType.collectSubstitutes(arguments[i], collectedSubstitutes);
				}
			} else {
				int paramLength = parameters.length;
				for (int i = 0; i < paramLength; i++)
					parameters[i].collectSubstitutes(arguments[i], collectedSubstitutes);
			}
			boolean needReturnTypeInference = false;
			if (collectedSubstitutes.isEmpty()) {
				// raw generic method inferred
				methodSubstitute = new ParameterizedGenericMethodBinding(originalMethod, (RawTypeBinding)null, scope.environment());
			} else {
				substitutes = new TypeBinding[varLength];
				for (int i = 0; i < varLength; i++) {
					TypeBinding[] variableSubstitutes = (TypeBinding[]) collectedSubstitutes.get(typeVariables[i]);
					TypeBinding mostSpecificSubstitute = scope.lowerUpperBound(variableSubstitutes);
					if (mostSpecificSubstitute == null)
						return null; // incompatible
					if (mostSpecificSubstitute == VoidBinding) {
						needReturnTypeInference = true;
					    mostSpecificSubstitute = typeVariables[i];
					}				
					substitutes[i] = mostSpecificSubstitute;
				}
				// apply inferred variable substitutions
				methodSubstitute = new ParameterizedGenericMethodBinding(originalMethod, substitutes, scope.environment());
			}
	
			if (needReturnTypeInference && invocationSite instanceof MessageSend) {
				MessageSend message = (MessageSend) invocationSite;
				TypeBinding expectedType = message.expectedType;
				if (expectedType == null) {
					// 15.12.2.8 - if no expected type, then assume Object
					// actually it rather seems to handle the returned variable case by expecting its erasure instead
					if (methodSubstitute.returnType.isTypeVariable()) {
						expectedType = methodSubstitute.returnType.erasure();
					} else {
						expectedType =scope.getJavaLangObject(); 
					}
				}
				methodSubstitute.inferFromExpectedType(expectedType, scope);
			}
		}
		// check bounds
		if (!methodSubstitute.isRaw) {
			for (int i = 0, length = typeVariables.length; i < length; i++) {
			    TypeVariableBinding typeVariable = typeVariables[i];
			    TypeBinding substitute = substitutes[i];
			    if (!typeVariable.boundCheck(methodSubstitute, substitute))
			        // incompatible due to bound check
			        return new ProblemMethodBinding(methodSubstitute, originalMethod.selector, new TypeBinding[]{substitutes[i], typeVariables[i] }, ParameterBoundMismatch);
			}
		}

		return methodSubstitute;
	}

