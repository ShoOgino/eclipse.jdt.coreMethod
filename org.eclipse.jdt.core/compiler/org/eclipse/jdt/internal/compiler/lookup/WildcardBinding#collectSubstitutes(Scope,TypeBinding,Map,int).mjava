	/**
	 * Collect the substitutes into a map for certain type variables inside the receiver type
	 * e.g.   Collection<T>.collectSubstitutes(Collection<List<X>>, Map), will populate Map with: T --> List<X>
	 * Constraints:
	 *   A << F   corresponds to:   F.collectSubstitutes(..., A, ..., 1)
	 *   A = F   corresponds to:      F.collectSubstitutes(..., A, ..., 0)
	 *   A >> F   corresponds to:   F.collectSubstitutes(..., A, ..., 2)
	 */
	public void collectSubstitutes(Scope scope, TypeBinding actualType, Map substitutes, int constraint) {

		if ((this.tagBits & TagBits.HasTypeVariable) == 0) return;
		if (actualType == TypeBinding.NULL) return;
	
		if (actualType.isCapture()) {
			CaptureBinding capture = (CaptureBinding) actualType;
			actualType = capture.wildcard;
		}
		
		switch (constraint) {
			case TypeConstants.CONSTRAINT_EXTENDS : // A << F
				switch (this.boundKind) {
					case Wildcard.UNBOUND: // F={?}
//						if (otherType.isWildcard()) {
//							WildcardBinding otherWildcard = (WildcardBinding) otherType;
//							switch(otherWildcard.kind) {
//								case Wildcard.UNBOUND: // A={?} << F={?}  --> 0
//									break;
//								case Wildcard.EXTENDS: // A={? extends V} << F={?} ---> 0
//									break;
//								case Wildcard.SUPER: // A={? super V} << F={?} ---> 0
//									break;
//							}
//						} else { // A=V << F={?} ---> 0
//						}
						break;
					case Wildcard.EXTENDS: // F={? extends U}
						if (actualType.isWildcard()) {
							WildcardBinding actualWildcard = (WildcardBinding) actualType;
							switch(actualWildcard.boundKind) {
								case Wildcard.UNBOUND: // A={?} << F={? extends U}  --> 0
									break;
								case Wildcard.EXTENDS: // A={? extends V} << F={? extends U} ---> V << U
									this.bound.collectSubstitutes(scope, actualWildcard.bound, substitutes, TypeConstants.CONSTRAINT_EXTENDS);
						        	for (int i = 0, length = actualWildcard.otherBounds == null ? 0 : actualWildcard.otherBounds.length; i < length; i++) {
										this.bound.collectSubstitutes(scope, actualWildcard.otherBounds[i], substitutes, TypeConstants.CONSTRAINT_EXTENDS);
						        	}									
									break;
								case Wildcard.SUPER: // A={? super V} << F={? extends U} ---> 0
									break;
							}
						} else { // A=V << F={? extends U} ---> V << U
							this.bound.collectSubstitutes(scope, actualType, substitutes, TypeConstants.CONSTRAINT_EXTENDS);
						}
						break;
					case Wildcard.SUPER: // F={? super U}
						if (actualType.isWildcard()) {
							WildcardBinding actualWildcard = (WildcardBinding) actualType;
							switch(actualWildcard.boundKind) {
								case Wildcard.UNBOUND: // A={?} << F={? super U}  --> 0
									break;
								case Wildcard.EXTENDS: // A={? extends V} << F={? super U} ---> 0
									break;
								case Wildcard.SUPER: // A={? super V} << F={? super U} ---> 0
									this.bound.collectSubstitutes(scope, actualWildcard.bound, substitutes, TypeConstants.CONSTRAINT_SUPER);
						        	for (int i = 0, length = actualWildcard.otherBounds == null ? 0 : actualWildcard.otherBounds.length; i < length; i++) {
										this.bound.collectSubstitutes(scope, actualWildcard.otherBounds[i], substitutes, TypeConstants.CONSTRAINT_SUPER);
						        	}									
									break;
							}
						} else { // A=V << F={? super U} ---> V >> U
							this.bound.collectSubstitutes(scope, actualType, substitutes, TypeConstants.CONSTRAINT_SUPER);							
						}						
						break;
				}
				break;
			case TypeConstants.CONSTRAINT_EQUAL : // A == F
				switch (this.boundKind) {
					case Wildcard.UNBOUND: // F={?}
//						if (otherType.isWildcard()) {
//							WildcardBinding otherWildcard = (WildcardBinding) otherType;
//							switch(otherWildcard.kind) {
//								case Wildcard.UNBOUND: // A={?} == F={?}  --> 0
//									break;
//								case Wildcard.EXTENDS: // A={? extends V} == F={?} ---> 0
//									break;
//								case Wildcard.SUPER: // A={? super V} == F={?} ---> 0
//									break;
//							}
//						} else { // A=V == F={?} ---> 0
//						}
						break;
					case Wildcard.EXTENDS: // F={? extends U}
						if (actualType.isWildcard()) {
							WildcardBinding actualWildcard = (WildcardBinding) actualType;
							switch(actualWildcard.boundKind) {
								case Wildcard.UNBOUND: // A={?} == F={? extends U}  --> 0
									break;
								case Wildcard.EXTENDS: // A={? extends V} == F={? extends U} ---> V == U
									this.bound.collectSubstitutes(scope, actualWildcard.bound, substitutes, TypeConstants.CONSTRAINT_EQUAL);
						        	for (int i = 0, length = actualWildcard.otherBounds == null ? 0 : actualWildcard.otherBounds.length; i < length; i++) {
										this.bound.collectSubstitutes(scope, actualWildcard.otherBounds[i], substitutes, TypeConstants.CONSTRAINT_EQUAL);
						        	}											
									break;
								case Wildcard.SUPER: // A={? super V} == F={? extends U} ---> 0
									break;
							}
						} else { // A=V == F={? extends U} ---> 0
						}
						break;
					case Wildcard.SUPER: // F={? super U}
						if (actualType.isWildcard()) {
							WildcardBinding actualWildcard = (WildcardBinding) actualType;
							switch(actualWildcard.boundKind) {
								case Wildcard.UNBOUND: // A={?} == F={? super U}  --> 0
									break;
								case Wildcard.EXTENDS: // A={? extends V} == F={? super U} ---> 0
									break;
								case Wildcard.SUPER: // A={? super V} == F={? super U} ---> 0
									this.bound.collectSubstitutes(scope, actualWildcard.bound, substitutes, TypeConstants.CONSTRAINT_EQUAL);
						        	for (int i = 0, length = actualWildcard.otherBounds == null ? 0 : actualWildcard.otherBounds.length; i < length; i++) {
										this.bound.collectSubstitutes(scope, actualWildcard.otherBounds[i], substitutes, TypeConstants.CONSTRAINT_EQUAL);
						        	}	
						        	break;
							}
						} else { // A=V == F={? super U} ---> 0
						}						
						break;
				}
				break;
			case TypeConstants.CONSTRAINT_SUPER : // A >> F
				switch (this.boundKind) {
					case Wildcard.UNBOUND: // F={?}
//						if (otherType.isWildcard()) {
//							WildcardBinding otherWildcard = (WildcardBinding) otherType;
//							switch(otherWildcard.kind) {
//								case Wildcard.UNBOUND: // A={?} >> F={?}  --> 0
//									break;
//								case Wildcard.EXTENDS: // A={? extends V} >> F={?} ---> 0
//									break;
//								case Wildcard.SUPER: // A={? super V} >> F={?} ---> 0
//									break;
//							}
//						} else { // A=V >> F={?} ---> 0
//						}
						break;
					case Wildcard.EXTENDS: // F={? extends U}
						if (actualType.isWildcard()) {
							WildcardBinding actualWildcard = (WildcardBinding) actualType;
							switch(actualWildcard.boundKind) {
								case Wildcard.UNBOUND: // A={?} >> F={? extends U}  --> 0
									break;
								case Wildcard.EXTENDS: // A={? extends V} >> F={? extends U} ---> V >> U
									this.bound.collectSubstitutes(scope, actualWildcard.bound, substitutes, TypeConstants.CONSTRAINT_SUPER);
						        	for (int i = 0, length = actualWildcard.otherBounds == null ? 0 : actualWildcard.otherBounds.length; i < length; i++) {
										this.bound.collectSubstitutes(scope, actualWildcard.otherBounds[i], substitutes, TypeConstants.CONSTRAINT_SUPER);
						        	}										
									break;
								case Wildcard.SUPER: // A={? super V} >> F={? extends U} ---> 0
									break;
							}
						} else { // A=V == F={? extends U} ---> 0
						}
						break;
					case Wildcard.SUPER: // F={? super U}
						if (actualType.isWildcard()) {
							WildcardBinding actualWildcard = (WildcardBinding) actualType;
							switch(actualWildcard.boundKind) {
								case Wildcard.UNBOUND: // A={?} >> F={? super U}  --> 0
									break;
								case Wildcard.EXTENDS: // A={? extends V} >> F={? super U} ---> 0
									break;
								case Wildcard.SUPER: // A={? super V} >> F={? super U} ---> V >> U
									this.bound.collectSubstitutes(scope, actualWildcard.bound, substitutes, TypeConstants.CONSTRAINT_SUPER);
						        	for (int i = 0, length = actualWildcard.otherBounds == null ? 0 : actualWildcard.otherBounds.length; i < length; i++) {
										this.bound.collectSubstitutes(scope, actualWildcard.otherBounds[i], substitutes, TypeConstants.CONSTRAINT_SUPER);
						        	}	
						        	break;
							}
						} else { // A=V >> F={? super U} ---> 0
						}						
						break;
				}
				break;
		}
	}

