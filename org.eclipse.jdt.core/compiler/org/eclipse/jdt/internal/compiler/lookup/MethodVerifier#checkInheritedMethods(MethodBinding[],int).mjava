void checkInheritedMethods(MethodBinding[] methods, int length) {
	if (length > 1) {
		int[] overriddenInheritedMethods = findOverriddenInheritedMethods(methods, length);
		if (overriddenInheritedMethods != null) {
			// detected some overridden methods that can be ignored when checking return types
			// but cannot ignore an overridden inherited method completely when it comes to checking for bridge methods
			int index = 0;
			MethodBinding[] closestMethods = new MethodBinding[length];
			for (int i = 0; i < length; i++)
				if (overriddenInheritedMethods[i] == 0)
					closestMethods[index++] = methods[i];
			if (index > 1 && !checkInheritedReturnTypes(closestMethods, index))
				return;
		} else if (!checkInheritedReturnTypes(methods, length)) {
			return;
		}
	}

	MethodBinding concreteMethod = null;
	if (!type.isInterface()) {  // ignore concrete methods for interfaces
		for (int i = length; --i >= 0;) {  // Remember that only one of the methods can be non-abstract
			if (!methods[i].isAbstract()) {
				concreteMethod = methods[i];
				break;
			}
		}
	}
	if (concreteMethod == null) {
		if (!this.type.isAbstract()) {
			for (int i = length; --i >= 0;) {
				if (mustImplementAbstractMethod(methods[i].declaringClass)) {
					TypeDeclaration typeDeclaration = this.type.scope.referenceContext;
					if (typeDeclaration != null) {
						MethodDeclaration missingAbstractMethod = typeDeclaration.addMissingAbstractMethodFor(methods[0]);
						missingAbstractMethod.scope.problemReporter().abstractMethodMustBeImplemented(this.type, methods[0]);
					} else {
						problemReporter().abstractMethodMustBeImplemented(this.type, methods[0]);
					}
					return;
				}
			}
		}
		return;
	}

	if (length > 1) {
		MethodBinding[] abstractMethods = new MethodBinding[length - 1];
		int index = 0;
		for (int i = length; --i >= 0;)
			if (methods[i] != concreteMethod)
				abstractMethods[index++] = methods[i];
		checkConcreteInheritedMethod(concreteMethod, abstractMethods);
	}
}

