void checkInheritedMethods(MethodBinding[] methods, int length) {
	int[] overriddenInheritedMethods = findOverriddenInheritedMethods(methods, length);
	if (overriddenInheritedMethods != null) {
		// detected some overridden methods that can be ignored when checking return types
		int index = 0;
		MethodBinding[] closestMethods = new MethodBinding[length];
		for (int i = 0; i < length; i++)
			if (overriddenInheritedMethods[i] == 0)
				closestMethods[index++] = methods[i];
		methods = closestMethods;
		length = index;
	}

	if (!checkInheritedReturnTypes(methods, length))
		return;

	MethodBinding concreteMethod = null;
	if (!type.isInterface()) {  // ignore concrete methods for interfaces
		for (int i = length; --i >= 0;) {  // Remember that only one of the methods can be non-abstract
			if (!methods[i].isAbstract()) {
				concreteMethod = methods[i];
				break;
			}
		}
	}
	if (concreteMethod == null) {
		if (!this.type.isAbstract()) {
			for (int i = length; --i >= 0;) {
				if (mustImplementAbstractMethod(methods[i].declaringClass)) {
					TypeDeclaration typeDeclaration = this.type.scope.referenceContext;
					if (typeDeclaration != null) {
						MethodDeclaration missingAbstractMethod = typeDeclaration.addMissingAbstractMethodFor(methods[0]);
						missingAbstractMethod.scope.problemReporter().abstractMethodMustBeImplemented(this.type, methods[0]);
					} else {
						problemReporter().abstractMethodMustBeImplemented(this.type, methods[0]);
					}
					return;
				}
			}
		}
		return;
	}

	MethodBinding[] abstractMethods = new MethodBinding[length - 1];
	int index = 0;
	for (int i = length; --i >= 0;)
		if (methods[i] != concreteMethod)
			abstractMethods[index++] = methods[i];
	checkConcreteInheritedMethod(concreteMethod, abstractMethods);
}

