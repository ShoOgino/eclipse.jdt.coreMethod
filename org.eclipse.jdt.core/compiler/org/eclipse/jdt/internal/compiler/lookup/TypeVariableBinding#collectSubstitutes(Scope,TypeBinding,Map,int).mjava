	/**
	 * Collect the substitutes into a map for certain type variables inside the receiver type
	 * e.g.   Collection<T>.collectSubstitutes(Collection<List<X>>, Map), will populate Map with: T --> List<X>
	 */
	public void collectSubstitutes(Scope scope, TypeBinding otherType, Map substitutes, int constraint) {
		
		// cannot infer anything from a null type
		switch (otherType.kind()) {
			case Binding.BASE_TYPE :
				if (otherType == NullBinding) return;
				TypeBinding boxedType = scope.environment().computeBoxingType(otherType);
				if (boxedType == otherType) return;
				otherType = boxedType;
				break;
			case Binding.WILDCARD_TYPE :
				WildcardBinding otherWildcard = (WildcardBinding) otherType;
				if (otherWildcard.otherBounds != null) break; // intersection type
				return; // wildcards are not true type expressions (JLS 15.12.2.7, p.453 2nd discussion)
		}
	
		// reverse constraint, to reflect variable on rhs:   A << T --> T >: A
		int variableConstraint;
		switch(constraint) {
			case CONSTRAINT_EQUAL :
				variableConstraint = CONSTRAINT_EQUAL;
				break;
			case CONSTRAINT_EXTENDS :
				variableConstraint = CONSTRAINT_SUPER;
				break;
			default:
			//case CONSTRAINT_SUPER :
				variableConstraint = CONSTRAINT_EXTENDS;
				break;
		}
	    TypeBinding[][] variableSubstitutes = (TypeBinding[][])substitutes.get(this);
	    if (variableSubstitutes != null) {
		    insertLoop: {
		    	TypeBinding[] constraintSubstitutes = variableSubstitutes[variableConstraint];
		    	int length;
		    	if (constraintSubstitutes == null) {
		    		length = 0;
		    		constraintSubstitutes = new TypeBinding[1];
		    	} else {
		    		length = constraintSubstitutes.length;
			        for (int i = 0; i < length; i++) {
			        	TypeBinding substitute = constraintSubstitutes[i];
			            if (substitute == otherType) return; // already there
			            if (substitute == null) {
			                constraintSubstitutes[i] = otherType;
			                break insertLoop;
			            }
			        }
			        // no free spot found, need to grow
			        System.arraycopy(constraintSubstitutes, 0, constraintSubstitutes = new TypeBinding[2*length], 0, length);
		    	}
		        constraintSubstitutes[length] = otherType;
		        variableSubstitutes[variableConstraint] = constraintSubstitutes;
		    }
	    }
	}

