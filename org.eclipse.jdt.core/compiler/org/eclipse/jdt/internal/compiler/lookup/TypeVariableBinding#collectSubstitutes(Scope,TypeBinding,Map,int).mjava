	/**
	 * Collect the substitutes into a map for certain type variables inside the receiver type
	 * e.g.   Collection<T>.collectSubstitutes(Collection<List<X>>, Map), will populate Map with: T --> List<X>
	 * Constraints:
	 *   A << F   corresponds to:   F.collectSubstitutes(..., A, ..., 1)
	 *   A = F   corresponds to:      F.collectSubstitutes(..., A, ..., 0)
	 *   A >> F   corresponds to:   F.collectSubstitutes(..., A, ..., 2)
	 */
	public void collectSubstitutes(Scope scope, TypeBinding actualType, Map substitutes, int constraint) {
		
		// cannot infer anything from a null type
		switch (actualType.kind()) {
			case Binding.BASE_TYPE :
				if (actualType == TypeBinding.NULL) return;
				TypeBinding boxedType = scope.environment().computeBoxingType(actualType);
				if (boxedType == actualType) return;
				actualType = boxedType;
				break;
			case Binding.WILDCARD_TYPE :
				WildcardBinding actualWildcard = (WildcardBinding) actualType;
				if (actualWildcard.otherBounds != null) break; // intersection type
				return; // wildcards are not true type expressions (JLS 15.12.2.7, p.453 2nd discussion)
		}
	
		// reverse constraint, to reflect variable on rhs:   A << T --> T >: A
		int variableConstraint;
		switch(constraint) {
			case TypeConstants.CONSTRAINT_EQUAL :
				variableConstraint = TypeConstants.CONSTRAINT_EQUAL;
				break;
			case TypeConstants.CONSTRAINT_EXTENDS :
				variableConstraint = TypeConstants.CONSTRAINT_SUPER;
				break;
			default:
			//case CONSTRAINT_SUPER :
				variableConstraint =TypeConstants.CONSTRAINT_EXTENDS;
				break;
		}
	    TypeBinding[][] variableSubstitutes = (TypeBinding[][])substitutes.get(this);
	    if (variableSubstitutes != null) {
		    insertLoop: {
		    	TypeBinding[] constraintSubstitutes = variableSubstitutes[variableConstraint];
		    	int length;
		    	if (constraintSubstitutes == null) {
		    		length = 0;
		    		constraintSubstitutes = new TypeBinding[1];
		    	} else {
		    		length = constraintSubstitutes.length;
			        for (int i = 0; i < length; i++) {
			        	TypeBinding substitute = constraintSubstitutes[i];
			            if (substitute == actualType) return; // already there
			            if (substitute == null) {
			                constraintSubstitutes[i] = actualType;
			                break insertLoop;
			            }
			        }
			        // no free spot found, need to grow by one
			        System.arraycopy(constraintSubstitutes, 0, constraintSubstitutes = new TypeBinding[length+1], 0, length);
		    	}
		        constraintSubstitutes[length] = actualType;
		        variableSubstitutes[variableConstraint] = constraintSubstitutes;
		    }
	    }
	}

