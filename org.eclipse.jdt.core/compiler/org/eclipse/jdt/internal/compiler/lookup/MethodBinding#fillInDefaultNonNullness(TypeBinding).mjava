/**
 * After method verifier has finished, fill in missing nullness values from the applicable default.
 * @param annotationBinding the null annotation specified to be the default at the current code location.
 */
protected void fillInDefaultNonNullness(TypeBinding annotationBinding) {
	if (this.parameterNonNullness == null)
		this.parameterNonNullness = new Boolean[this.parameters.length];
	AbstractMethodDeclaration sourceMethod = sourceMethod();
	for (int i = 0; i < this.parameterNonNullness.length; i++) {
		if (this.parameters[i].isBaseType())
			continue;
		boolean added = false;
		if (this.parameterNonNullness[i] == null) {
			added = true;
			this.parameterNonNullness[i] = Boolean.TRUE;
			if (sourceMethod != null)
				sourceMethod.addParameterNonNullAnnotation(i, (ReferenceBinding)annotationBinding);
		} else if (this.parameterNonNullness[i].booleanValue()) {
			sourceMethod.scope.problemReporter().nullAnnotationIsRedundant(sourceMethod, i);
		}
		if (added)
			this.tagBits |= TagBits.HasParameterAnnotations;
	}
	if (   this.returnType != null
		&& !this.returnType.isBaseType()
		&& (this.tagBits & (TagBits.AnnotationNonNull|TagBits.AnnotationNullable)) == 0)
	{
		this.tagBits |= TagBits.AnnotationNonNull;
		if (sourceMethod != null)
			sourceMethod.addNullnessAnnotation((ReferenceBinding)annotationBinding);
	} else if ((this.tagBits & TagBits.AnnotationNonNull) != 0) {
		sourceMethod.scope.problemReporter().nullAnnotationIsRedundant(sourceMethod, -1/*signifies method return*/);
	}
}

