/**
 * After method verifier has finished, fill in missing nullness values from the applicable default.
 * @param annotationBinding the null annotation specified to be the default at the current code location.
 */
protected void fillInDefaultNonNullness(TypeBinding annotationBinding) {
	if (this.parameterNonNullness == null)
		this.parameterNonNullness = new Boolean[this.parameters.length];
	AbstractMethodDeclaration sourceMethod = sourceMethod();
	boolean added = false;
	int length = this.parameterNonNullness.length;
	for (int i = 0; i < length; i++) {
		if (this.parameters[i].isBaseType())
			continue;
		if (this.parameterNonNullness[i] == null) {
			added = true;
			this.parameterNonNullness[i] = Boolean.TRUE;
			if (sourceMethod != null) {
				Argument argument = sourceMethod.arguments[i];
				sourceMethod.addParameterNonNullAnnotation(argument, (ReferenceBinding)annotationBinding);
				argument.binding.tagBits |= TagBits.AnnotationNonNull;
			}
		} else if (this.parameterNonNullness[i].booleanValue()) {
			sourceMethod.scope.problemReporter().nullAnnotationIsRedundant(sourceMethod, i);
		}
	}
	if (added)
		this.tagBits |= TagBits.HasParameterAnnotations;
	if (   this.returnType != null
		&& !this.returnType.isBaseType()
		&& (this.tagBits & (TagBits.AnnotationNonNull|TagBits.AnnotationNullable)) == 0)
	{
		this.tagBits |= TagBits.AnnotationNonNull;
		if (sourceMethod != null)
			sourceMethod.addNonNullAnnotation((ReferenceBinding)annotationBinding);
	} else if ((this.tagBits & TagBits.AnnotationNonNull) != 0) {
		sourceMethod.scope.problemReporter().nullAnnotationIsRedundant(sourceMethod, -1/*signifies method return*/);
	}
}

