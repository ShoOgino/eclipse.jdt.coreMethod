	/* Note: parameters will not have type type annotations if lookup environment directly uses UTS as its typeSystem. However if this UTS is the underlying type system
	   for an ATS, they may and we need to materialize the unannotated versions and work on them.
	*/ 
	public RawTypeBinding getRawType(ReferenceBinding genericType, ReferenceBinding enclosingType) {
		ReferenceBinding unannotatedGenericType = (ReferenceBinding) getUnannotatedType(genericType);
		ReferenceBinding unannotatedEnclosingType = enclosingType == null ? null : (ReferenceBinding) getUnannotatedType(enclosingType);
	
		TypeBinding[] cachedInfo = this.types[unannotatedGenericType.id];  // by construction, cachedInfo != null now.
		int index = 0;
		for (int max = cachedInfo.length; index < max; index++) {
			TypeBinding cachedType = cachedInfo[index];
			if (cachedType == null) 
				break;
			if (!cachedType.isRawType())
				continue;
			if (cachedType.enclosingType() == unannotatedEnclosingType)
				return (RawTypeBinding) cachedType;
		}

		int length = cachedInfo.length;
		if (index == length) {
			System.arraycopy(cachedInfo, 0, cachedInfo = new TypeBinding[length * 2], 0, length);
			this.types[unannotatedGenericType.id] = cachedInfo;
		}
		
		TypeBinding rawTytpe = cachedInfo[index] = new RawTypeBinding(unannotatedGenericType, unannotatedEnclosingType, this.environment);
		int typesLength = this.types.length;
		if (this.typeid == typesLength)
			System.arraycopy(this.types, 0, this.types = new TypeBinding[typesLength * 2][], 0, typesLength);
		this.types[this.typeid] = new TypeBinding[1];
		return (RawTypeBinding) (this.types[rawTytpe.id = this.typeid++][0] = rawTytpe);
	}

