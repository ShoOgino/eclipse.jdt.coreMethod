	/**
	 * Collect the substitutes into a map for certain type variables inside the receiver type
	 * e.g.   Collection<T>.collectSubstitutes(Collection<List<X>>, Map), will populate Map with: T --> List<X>
	 * Constraints:
	 *   A << F   corresponds to:   F.collectSubstitutes(..., A, ..., 1)
	 *   A = F   corresponds to:      F.collectSubstitutes(..., A, ..., 0)
	 *   A >> F   corresponds to:   F.collectSubstitutes(..., A, ..., 2)
	 */
	public void collectSubstitutes(Scope scope, TypeBinding actualType, Map substitutes, int constraint) {
		
		if ((this.tagBits & TagBits.HasTypeVariable) == 0) return;
		if (actualType == NullBinding) return;
	
		if (this.arguments == null) return;
		if (!(actualType instanceof ReferenceBinding)) return;
		ReferenceBinding formalEquivalent, actualEquivalent;
		switch (constraint) {
			case CONSTRAINT_EQUAL :
			case CONSTRAINT_EXTENDS :
				formalEquivalent = this;
		        actualEquivalent = ((ReferenceBinding)actualType).findSuperTypeWithSameErasure(this.type);
		        if (actualEquivalent == null) return;
		        break;
			case CONSTRAINT_SUPER :
	        default:
		        formalEquivalent = this.findSuperTypeWithSameErasure(actualType);
		        if (formalEquivalent == null) return;
		        actualEquivalent = (ReferenceBinding) actualType;
		        break;
		}
        TypeBinding[] formalArguments;
        switch (formalEquivalent.kind()) {
        	case Binding.GENERIC_TYPE :
        		formalArguments = formalEquivalent.typeVariables();
        		break;
        	case Binding.PARAMETERIZED_TYPE :
        		formalArguments = ((ParameterizedTypeBinding)formalEquivalent).arguments;
        		break;
        	case Binding.RAW_TYPE :
        		substitutes.clear(); // clear all variables to indicate raw generic method in the end
        		return;
        	default :
        		return;
        }
        TypeBinding[] actualArguments;
        switch (actualEquivalent.kind()) {
        	case Binding.GENERIC_TYPE :
        		actualArguments = actualEquivalent.typeVariables();
        		break;
        	case Binding.PARAMETERIZED_TYPE :
        		actualArguments = ((ParameterizedTypeBinding)actualEquivalent).arguments;
        		break;
        	case Binding.RAW_TYPE :
        		substitutes.clear(); // clear all variables to indicate raw generic method in the end
        		return;
        	default :
        		return;
        }
        for (int i = 0, length = formalArguments.length; i < length; i++) {
        	TypeBinding formalArgument = formalArguments[i];
            formalArgument.collectSubstitutes(scope, actualArguments[i], substitutes, formalArgument.isWildcard() ? constraint : CONSTRAINT_EQUAL);
        }
	}

