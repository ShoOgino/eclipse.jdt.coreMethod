@Override
boolean hasNonNullDefaultFor(int location, boolean useTypeAnnotations, int sourceStart) {
	
	if (!isPrototype()) throw new IllegalStateException();
	
	// 1.8:
	if (useTypeAnnotations) {
		if (this.scope == null) {
			return (this.defaultNullness & location) != 0;
		}
		Scope skope = this.scope.referenceContext.initializerScope; // for @NNBD on a field
		if (skope == null)
			skope = this.scope;
		return skope.hasDefaultNullnessFor(location, sourceStart);
	}

	// find the applicable default inside->out:

	SourceTypeBinding currentType = null;
	Scope currentScope = this.scope;
	while (currentScope != null) {
		switch (currentScope.kind) {
			case Scope.METHOD_SCOPE:
				AbstractMethodDeclaration referenceMethod = ((MethodScope)currentScope).referenceMethod();
				if (referenceMethod != null && referenceMethod.binding != null) {
					long methodTagBits = referenceMethod.binding.tagBits;
					if ((methodTagBits & TagBits.AnnotationNonNullByDefault) != 0)
						return true;
					if ((methodTagBits & TagBits.AnnotationNullUnspecifiedByDefault) != 0)
						return false;
				}
				break;
			case Scope.CLASS_SCOPE:
				currentType = ((ClassScope)currentScope).referenceContext.binding;
				if (currentType != null) {
					int foundDefaultNullness = currentType.getNullDefault();
					if ((foundDefaultNullness & NullnessDefaultMASK) > NULL_UNSPECIFIED_BY_DEFAULT) {
						return true;
					}
					if (foundDefaultNullness != NO_NULL_DEFAULT) {
						return foundDefaultNullness == NONNULL_BY_DEFAULT;
					}
				}
				break;
		}
		currentScope = currentScope.parent;
	}

	// package
	if (currentType != null) {
		return currentType.getPackage().getDefaultNullness() == NONNULL_BY_DEFAULT;
	}

	return false;
}

