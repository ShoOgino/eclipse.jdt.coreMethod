// NOTE: the return type, arg & exception types of each method of a source type are resolved when needed
public MethodBinding[] methods() {
	if ((modifiers & AccUnresolved) == 0)
		return methods;

	int failed = 0;
	try {
		for (int i = 0, length = methods.length; i < length; i++) {
			if (resolveTypesFor(methods[i]) == null) {
				methods[i] = null; // unable to resolve parameters
				failed++;
			}
		}

		// find & report collision cases
		for (int i = 0, length = methods.length; i < length; i++) {
			MethodBinding method = methods[i];
			if (method != null) {
				AbstractMethodDeclaration methodDecl = null;
				for (int j = length - 1; j > i; j--) {
					MethodBinding method2 = methods[j];
					if (method2 != null && CharOperation.equals(method.selector, method2.selector)) {
						if (method.areParameterErasuresEqual(method2)) {
							if (methodDecl == null) 	methodDecl = method.sourceMethod(); // cannot be retrieved after binding is lost
							AbstractMethodDeclaration method2Decl = method2.sourceMethod();
							// could collide with special methods for enumerations
							if (methodDecl == null) {
								if (method.selector == TypeConstants.VALUEOF
										|| method.selector == TypeConstants.VALUES) {
									if (method2Decl != null) {
										scope.problemReporter().duplicateEnumSpecialMethod(this, method2Decl);
										method2Decl.binding = null;
									}
									// leave enum special method to minimize secondary error (further references to it)
									methods[j] = null;
									failed++;
								}
							} else if (method2Decl == null) {
								if (method2.selector == TypeConstants.VALUEOF
										|| method2.selector == TypeConstants.VALUES) {
									if (methodDecl != null) {
										scope.problemReporter().duplicateEnumSpecialMethod(this, methodDecl);
										methodDecl.binding = null;
									}
									// leave enum special method to minimize secondary error (further references to it)
									methods[i] = null;
									failed++;
								}
							} else {
								if (methodDecl.binding != null) {
									scope.problemReporter().duplicateMethodInType(this, methodDecl);
									methodDecl.binding = null;
								}
								if (method2Decl != null) {
									scope.problemReporter().duplicateMethodInType(this, method2Decl);
									method2Decl.binding = null;
								}
								methods[i] = null;
								methods[j] = null;
								failed+=2;
							}
						}
					}
				}
				if (method.returnType == null && methodDecl == null) { // forget method with invalid return type... was kept to detect possible collisions
					method.sourceMethod().binding = null;
					methods[i] = null;
					failed++;
				}
			}
		}
	} finally {
		if (failed > 0) {
			int newSize = methods.length - failed;
			if (newSize == 0) {
				methods = NoMethods;
			} else {
				MethodBinding[] newMethods = new MethodBinding[newSize];
				for (int i = 0, j = 0, length = methods.length; i < length; i++)
					if (methods[i] != null)
						newMethods[j++] = methods[i];
				methods = newMethods;
			}
		}

		// handle forward references to potential default abstract methods
		addDefaultAbstractMethods();

		modifiers &= ~AccUnresolved;
	}		
	return methods;
}

