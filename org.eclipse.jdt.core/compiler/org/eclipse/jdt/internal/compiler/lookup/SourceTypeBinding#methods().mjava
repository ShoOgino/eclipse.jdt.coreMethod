// NOTE: the return type, arg & exception types of each method of a source type are resolved when needed
public MethodBinding[] methods() {
	
	if ((this.tagBits & TagBits.AreMethodsComplete) != 0)
		return this.methods;
	
	// lazily sort methods
	if ((this.tagBits & TagBits.AreMethodsSorted) == 0) {
		int length = this.methods.length;
		if (length > 1) 	ReferenceBinding.sortMethods(this.methods, 0, length - 1);
		this.tagBits |= TagBits.AreMethodsSorted;
	}

	int failed = 0;
	try {
		for (int i = 0, length = this.methods.length; i < length; i++) {
			if (resolveTypesFor(this.methods[i]) == null) {
				this.methods[i] = null; // unable to resolve parameters
				failed++;
			}
		}

		// find & report collision cases
		boolean complyTo15 = this.scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_5;
		nextMethod: for (int i = 0, length = this.methods.length; i < length; i++) {
			MethodBinding method = this.methods[i];
			if (method == null) 
				continue nextMethod;
			char[] selector = method.selector;
			AbstractMethodDeclaration methodDecl = null;
			nextSibling: for (int j = i + 1; j < length; j++) {
				MethodBinding method2 = this.methods[j];
				if (method2 == null)
					continue nextSibling;
				if (!CharOperation.equals(selector, method2.selector)) 
					continue nextMethod; // methods with same selector are contiguous

				if (complyTo15 && method.returnType != null && method2.returnType != null) {
					// 8.4.2, for collision to be detected between m1 and m2:
					// signature(m1) == signature(m2) i.e. same arity, same type parameter count, can be substituted
					// signature(m1) == erasure(signature(m2)) or erasure(signature(m1)) == signature(m2)
					TypeBinding[] params1 = method.parameters;
					TypeBinding[] params2 = method2.parameters;
					int pLength = params1.length;
					if (pLength != params2.length)
						continue nextSibling;

					TypeVariableBinding[] vars = method.typeVariables;
					TypeVariableBinding[] vars2 = method2.typeVariables;
					boolean equalTypeVars = vars == vars2;
					MethodBinding subMethod = method2;
					if (!equalTypeVars) {
						MethodBinding temp = method.computeSubstitutedMethod(method2, this.scope.environment());
						if (temp != null) {
							equalTypeVars = true;
							subMethod = temp;
						}
					}
					boolean equalParams = method.areParametersEqual(subMethod);
					if (equalParams && equalTypeVars) {
						// duplicates regardless of return types
					} else if (method.returnType.erasure() == subMethod.returnType.erasure() && (equalParams || method.areParameterErasuresEqual(method2))) {
						// name clash for sure if not duplicates, report as duplicates
					} else if (!equalTypeVars && vars != Binding.NO_TYPE_VARIABLES && vars2 != Binding.NO_TYPE_VARIABLES) {
						// type variables are different so we can distinguish between methods
						continue nextSibling;
					} else if (pLength > 0) {
						// check to see if the erasure of either method is equal to the other
						int index = pLength;
						for (; --index >= 0;) {
							if (params1[index] != params2[index].erasure())
								break;
							if (params1[index] == params2[index]) {
								TypeBinding type = params1[index].leafComponentType();
								if (type instanceof SourceTypeBinding && type.typeVariables() != Binding.NO_TYPE_VARIABLES) {
									index = pLength; // handle comparing identical source types like X<T>... its erasure is itself BUT we need to answer false
									break;
								}
							}
						}
						if (index >= 0 && index < pLength) {
							for (index = pLength; --index >= 0;)
								if (params1[index].erasure() != params2[index])
									break;
						}
						if (index >= 0)
							continue nextSibling;
					}
				} else if (!method.areParametersEqual(method2)) { // prior to 1.5, parameter identity meant a collision case
					continue nextSibling;
				}
				boolean isEnumSpecialMethod = isEnum() && (CharOperation.equals(selector,TypeConstants.VALUEOF) || CharOperation.equals(selector,TypeConstants.VALUES));
				// report duplicate
				if (methodDecl == null) {
					methodDecl = method.sourceMethod(); // cannot be retrieved after binding is lost & may still be null if method is special
					if (methodDecl != null && methodDecl.binding != null) { // ensure its a valid user defined method
						if (isEnumSpecialMethod) {
							this.scope.problemReporter().duplicateEnumSpecialMethod(this, methodDecl);
						} else {
							this.scope.problemReporter().duplicateMethodInType(this, methodDecl);
						}
						methodDecl.binding = null;
						this.methods[i] = null;
						failed++;
					}
				}
				AbstractMethodDeclaration method2Decl = method2.sourceMethod();
				if (method2Decl != null && method2Decl.binding != null) { // ensure its a valid user defined method
					if (isEnumSpecialMethod) {
						this.scope.problemReporter().duplicateEnumSpecialMethod(this, method2Decl);
					} else {
						this.scope.problemReporter().duplicateMethodInType(this, method2Decl);
					}
					method2Decl.binding = null;
					this.methods[j] = null;
					failed++;
				}
			}
			if (method.returnType == null && methodDecl == null) { // forget method with invalid return type... was kept to detect possible collisions
				method.sourceMethod().binding = null;
				this.methods[i] = null;
				failed++;
			}
		}
	} finally {
		if (failed > 0) {
			int newSize = this.methods.length - failed;
			if (newSize == 0) {
				this.methods = Binding.NO_METHODS;
			} else {
				MethodBinding[] newMethods = new MethodBinding[newSize];
				for (int i = 0, j = 0, length = this.methods.length; i < length; i++)
					if (this.methods[i] != null)
						newMethods[j++] = this.methods[i];
				this.methods = newMethods;
			}
		}

		// handle forward references to potential default abstract methods
		addDefaultAbstractMethods();
		this.tagBits |= TagBits.AreMethodsComplete;
	}		
	return this.methods;
}

