// NOTE: the return type, arg & exception types of each method of a source type are resolved when needed
public MethodBinding[] methods() {
	if ((tagBits & AreMethodsComplete) != 0)
		return methods;

	int failed = 0;
	try {
		for (int i = 0, length = methods.length; i < length; i++) {
			if (resolveTypesFor(methods[i]) == null) {
				methods[i] = null; // unable to resolve parameters
				failed++;
			}
		}

		// find & report collision cases
		boolean complyTo15 = fPackage.environment.options.sourceLevel >= ClassFileConstants.JDK1_5;
		for (int i = 0, length = methods.length; i < length; i++) {
			MethodBinding method = methods[i];
			if (method != null) {
				TypeBinding methodTypeErasure = method.returnType == null ? null : method.returnType.erasure();
				char[] selector = method.selector;
				AbstractMethodDeclaration methodDecl = null;
				nextOtherMethod: for (int j = length - 1; j > i; j--) {
					MethodBinding otherMethod = methods[j];
					// check collision with otherMethod
					if (otherMethod == null) 
						continue nextOtherMethod;
					if (!CharOperation.equals(selector, otherMethod.selector))
						continue nextOtherMethod;
					if (complyTo15) {
						TypeBinding otherMethodTypeErasure = otherMethod.returnType == null ? null : otherMethod.returnType.erasure();
						if (methodTypeErasure != otherMethodTypeErasure) {
							if (method.typeVariables != NoTypeVariables && otherMethod.typeVariables != NoTypeVariables) {
								// for generic methods, no need to check arguments
								continue nextOtherMethod;
							} else {
								if (!method.areParametersEqual(otherMethod)) 
									continue nextOtherMethod;
							}							
						} else {
							if (!method.areParameterErasuresEqual(otherMethod))
								continue nextOtherMethod;
						}
					} else {
						// prior to 1.5, parameter match is enough for collision
						if (!method.areParametersEqual(otherMethod)) 
							continue nextOtherMethod;
					}
					// report duplicate
					boolean isEnumSpecialMethod = isEnum()
						&& (selector == TypeConstants.VALUEOF || selector == TypeConstants.VALUES);
					if (methodDecl == null) {
						methodDecl = method.sourceMethod(); // cannot be retrieved after binding is lost & may still be null if method is special
						if (methodDecl != null && methodDecl.binding != null) { // ensure its a valid user defined method
							if (isEnumSpecialMethod)
								scope.problemReporter().duplicateEnumSpecialMethod(this, methodDecl);
							else
								scope.problemReporter().duplicateMethodInType(this, methodDecl);
							methodDecl.binding = null;
							methods[i] = null;
							failed++;
						}
					}
					AbstractMethodDeclaration otherMethodDecl = otherMethod.sourceMethod();
					if (otherMethodDecl != null && otherMethodDecl.binding != null) { // ensure its a valid user defined method
						if (isEnumSpecialMethod)
							scope.problemReporter().duplicateEnumSpecialMethod(this, otherMethodDecl);
						else
							scope.problemReporter().duplicateMethodInType(this, otherMethodDecl);
						otherMethodDecl.binding = null;
						methods[j] = null;
						failed++;
					}
				}
				if (methodTypeErasure == null && methodDecl == null) { // forget method with invalid return type... was kept to detect possible collisions
					method.sourceMethod().binding = null;
					methods[i] = null;
					failed++;
				}
			}
		}
	} finally {
		if (failed > 0) {
			int newSize = methods.length - failed;
			if (newSize == 0) {
				methods = NoMethods;
			} else {
				MethodBinding[] newMethods = new MethodBinding[newSize];
				for (int i = 0, j = 0, length = methods.length; i < length; i++)
					if (methods[i] != null)
						newMethods[j++] = methods[i];
				methods = newMethods;
			}
		}

		// handle forward references to potential default abstract methods
		addDefaultAbstractMethods();
		tagBits |= AreMethodsComplete;
	}		
	return methods;
}

