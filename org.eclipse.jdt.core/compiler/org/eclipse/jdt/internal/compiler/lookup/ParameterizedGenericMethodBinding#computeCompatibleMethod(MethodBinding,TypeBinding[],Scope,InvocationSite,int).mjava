	/**
	 * Perform inference of generic method type parameters and/or expected type
	 * <p>
	 * In 1.8+ the following discipline has to be observed by callers:
	 * Each invocation must be subjected to two levels of inference:
	 * </p>
	 * <ul>
	 * <li> {@link Scope#APPLICABILITY Invocation Applicability Inference}, which may be applied
	 *     multiple times for the same invocation</li>
	 * <li> {@link Scope#INVOCATION_TYPE Invocation Type Inference}, which is finally performed
	 *     for the selected method and which adds information from the "target type".</li>
	 * </ul>
	 * <p>
	 * Clients can control which parts of the inference should be performed by passing the appropriate
	 * flags into argument 'inferenceLevel'. On each call path it must be ensured that one or more
	 * invocation applicability inferences are always followed by exactly one invocation type inference
	 * (unless errors have been detected).
	 * </p>
	 * <p>
	 * Initial clients are the direct callers of
	 * {@link Scope#computeCompatibleMethod(MethodBinding,TypeBinding[],InvocationSite,int)},
	 * which should either invoke both levels of inference <em>or</em> delegate the second part to
	 * {@link Scope#mostSpecificMethodBinding(MethodBinding[],int,TypeBinding[],InvocationSite,ReferenceBinding)},
	 * which is intended to ensure completing the inference on all non-error exits.
	 * </p>  
	 */
	public static MethodBinding computeCompatibleMethod(MethodBinding originalMethod, TypeBinding[] arguments, Scope scope,
			InvocationSite invocationSite, int inferenceLevel)
	{
		ParameterizedGenericMethodBinding methodSubstitute;
		TypeVariableBinding[] typeVariables = originalMethod.typeVariables;
		TypeBinding[] substitutes = invocationSite.genericTypeArguments();
		InferenceContext inferenceContext = null;
		TypeBinding[] uncheckedArguments = null;
		computeSubstitutes: {
			if (substitutes != null) {
				// explicit type arguments got supplied
				if (substitutes.length != typeVariables.length) {
			        // incompatible due to wrong arity
			        return new ProblemMethodBinding(originalMethod, originalMethod.selector, substitutes, ProblemReasons.TypeParameterArityMismatch);
				}
				methodSubstitute = scope.environment().createParameterizedGenericMethod(originalMethod, substitutes);
				break computeSubstitutes;
			}
			// perform type argument inference (15.12.2.7)
			// initializes the map of substitutes (var --> type[][]{ equal, extends, super}
			TypeBinding[] parameters = originalMethod.parameters;

// ==== 1.8: The main driver for inference of generic methods: ====
			InferenceContext18 infCtx18 = null;
			if (scope.compilerOptions().sourceLevel >= ClassFileConstants.JDK1_8) {
				if ((inferenceLevel & Scope.APPLICABILITY) != 0)
					infCtx18 = invocationSite.freshInferenceContext(scope);
				else if (invocationSite instanceof Invocation && originalMethod instanceof ParameterizedGenericMethodBinding)
					infCtx18 = ((Invocation) invocationSite).getInferenceContext((ParameterizedGenericMethodBinding) originalMethod);
			}
			if (infCtx18 != null) {
				try {
					BoundSet provisionalResult = null;
					BoundSet result = null;
					if ((inferenceLevel & Scope.APPLICABILITY) != 0) {

						// ---- 18.5.1 (Applicability): ----
						boolean isDiamond = originalMethod.isConstructor()
								&& invocationSite instanceof Expression
								&& ((Expression)invocationSite).isPolyExpression(originalMethod);
						if (arguments.length == parameters.length) {
							infCtx18.inferenceKind = InferenceContext18.CHECK_LOOSE; // TODO: validate if 2 phase checking (strict/loose + vararg) is sufficient.
							infCtx18.inferInvocationApplicability(originalMethod, arguments, isDiamond);
							provisionalResult = infCtx18.solve();
						}
						if (provisionalResult == null && originalMethod.isVarargs()) {
							// check for variable-arity applicability
							infCtx18 = invocationSite.freshInferenceContext(scope); // start over
							infCtx18.inferenceKind = InferenceContext18.CHECK_VARARG;
							infCtx18.inferInvocationApplicability(originalMethod, arguments, isDiamond);
							provisionalResult = infCtx18.solve();
						}
						if (provisionalResult != null && infCtx18.isResolved(provisionalResult)) {
							infCtx18.storedSolution = provisionalResult;
							infCtx18.stepCompleted = InferenceContext18.APPLICABILITY_INFERRED;
						}
					} else {
						provisionalResult = infCtx18.storedSolution;
					}
					result = infCtx18.currentBounds.copy(); // the result after reduction, without effects of resolve()

					TypeBinding expectedType = invocationSite.invocationTargetType();
					boolean hasReturnProblem = false;
					boolean invocationTypeInferred = false;
					if ((inferenceLevel & Scope.INVOCATION_TYPE) != 0 // requested?
							&& (expectedType != null || !invocationSite.getExpressionContext().definesTargetType())) { // possible?

						// ---- 18.5.2 (Invocation type): ----
						result = infCtx18.inferInvocationType(result, expectedType, invocationSite, originalMethod);
						invocationTypeInferred = true;
						hasReturnProblem |= result == null;
						if (hasReturnProblem)
							result = provisionalResult; // let's prefer a type error regarding the return type over reporting no match at all
					} else {
						// we're not yet ready for invocation type inference
						result = provisionalResult;
					}

					if (result != null) {
						// assemble the solution etc:
						TypeBinding[] solutions = infCtx18.getSolutions(typeVariables, invocationSite, result);
						if (solutions != null) {
							
							methodSubstitute = scope.environment().createParameterizedGenericMethod(originalMethod, solutions);
							if (hasReturnProblem) { // illegally working from the provisional result?
								MethodBinding problemMethod = infCtx18.getReturnProblemMethodIfNeeded(expectedType, methodSubstitute);
								if (problemMethod instanceof ProblemMethodBinding)
									return problemMethod;
							}
							if (invocationTypeInferred) {
								infCtx18.rebindInnerPolies(result, methodSubstitute.parameters);
								return methodSubstitute.boundCheck18(scope, arguments);
							} else {
								if (invocationSite instanceof Invocation)
									((Invocation) invocationSite).registerInferenceContext(methodSubstitute, infCtx18); // keep context so we can finish later
								return methodSubstitute;
							}
						}
					}
					return null;
				} catch (InferenceFailureException e) {
					// FIXME stop-gap measure
					scope.problemReporter().genericInferenceError(e.getMessage(), invocationSite);
					return null;
				}
			} else {
// ==== 1.8 ====
				inferenceContext = new InferenceContext(originalMethod);
				methodSubstitute = inferFromArgumentTypes(scope, originalMethod, arguments, parameters, inferenceContext);
				if (methodSubstitute == null)
					return null;
				
				// substitutes may hold null to denote unresolved vars, but null arguments got replaced with respective original variable in param method
				// 15.12.2.8 - inferring unresolved type arguments
				if (inferenceContext.hasUnresolvedTypeArgument()) {
					if (inferenceContext.isUnchecked) { // only remember unchecked status post 15.12.2.7
						int length = inferenceContext.substitutes.length;
						System.arraycopy(inferenceContext.substitutes, 0, uncheckedArguments = new TypeBinding[length], 0, length);
					}
					if (methodSubstitute.returnType != TypeBinding.VOID) {
						TypeBinding expectedType = invocationSite.invocationTargetType();
						if (expectedType != null) {
							// record it was explicit from context, as opposed to assumed by default (see below)
							inferenceContext.hasExplicitExpectedType = true;
						} else {
							expectedType = scope.getJavaLangObject(); // assume Object by default
						}
						inferenceContext.expectedType = expectedType;
					}
					methodSubstitute = methodSubstitute.inferFromExpectedType(scope, inferenceContext);
					if (methodSubstitute == null)
						return null;
				}
			}
		}

		/* bounds check: https://bugs.eclipse.org/bugs/show_bug.cgi?id=242159, Inferred types may contain self reference
		   in formal bounds. If "T extends I<T>" is a original type variable and T was inferred to be I<T> due possibly
		   to under constraints and resultant glb application per 15.12.2.8, using this.typeArguments to drive the bounds
		   check against itself is doomed to fail. For, the variable T would after substitution be I<I<T>> and would fail
		   bounds check against I<T>. Use the inferred types from the context directly - see that there is one round of
		   extra substitution that has taken place to properly substitute a remaining unresolved variable which also appears
		   in a formal bound  (So we really have a bounds mismatch between I<I<T>> and I<I<I<T>>>, in the absence of a fix.)
		*/
		Substitution substitution = null;
		if (inferenceContext != null) {
			substitution = new LingeringTypeVariableEliminator(typeVariables, inferenceContext.substitutes, scope);
		} else {
			substitution = methodSubstitute;
		}
		for (int i = 0, length = typeVariables.length; i < length; i++) {
		    TypeVariableBinding typeVariable = typeVariables[i];
		    TypeBinding substitute = methodSubstitute.typeArguments[i]; // retain for diagnostics
		    /* https://bugs.eclipse.org/bugs/show_bug.cgi?id=375394, To avoid spurious bounds check failures due to circularity in formal bounds, 
		       we should eliminate only the lingering embedded type variable references after substitution, not alien type variable references
		       that constitute the inference per se.
		     */ 
		    TypeBinding substituteForChecks;
		    if (substitute instanceof TypeVariableBinding) {
		    	substituteForChecks = substitute;
		    } else {
		    	substituteForChecks = Scope.substitute(new LingeringTypeVariableEliminator(typeVariables, null, scope), substitute); // while using this for bounds check
		    }
		    
		    if (uncheckedArguments != null && uncheckedArguments[i] == null) continue; // only bound check if inferred through 15.12.2.6
			switch (typeVariable.boundCheck(substitution, substituteForChecks, scope)) {
				case TypeConstants.MISMATCH :
			        // incompatible due to bound check
					int argLength = arguments.length;
					TypeBinding[] augmentedArguments = new TypeBinding[argLength + 2]; // append offending substitute and typeVariable
					System.arraycopy(arguments, 0, augmentedArguments, 0, argLength);
					augmentedArguments[argLength] = substitute;
					augmentedArguments[argLength+1] = typeVariable;
			        return new ProblemMethodBinding(methodSubstitute, originalMethod.selector, augmentedArguments, ProblemReasons.ParameterBoundMismatch);
				case TypeConstants.UNCHECKED :
					// tolerate unchecked bounds
					methodSubstitute.tagBits |= TagBits.HasUncheckedTypeArgumentForBoundCheck;
					break;
			}
		}
		// check presence of unchecked argument conversion a posteriori (15.12.2.6)
		return methodSubstitute;
	}

