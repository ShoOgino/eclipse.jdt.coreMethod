	private int parameterCompatibilityLevel18(MethodBinding method, TypeBinding[] arguments, boolean tiebreakingVarargsMethods, InvocationSite site) {
		if (site instanceof Invocation) {
			Invocation invocation = (Invocation) site;
			if (method instanceof ParameterizedGenericMethodBinding) {
				InferenceContext18 infCtx = invocation.getInferenceContext((ParameterizedGenericMethodBinding) method);
				if (infCtx != null)
					return COMPATIBLE; // inference is responsible, no need to recheck
			}
			// collect inner invocations where the outer did not involve any inference:
			Expression[] invocationArguments = invocation.arguments();
			if (invocationArguments != null) {
				int argLen = invocationArguments.length;
				boolean isVarArgs = false;
				for (int i = 0; i < argLen; i++) {
					Expression invocArg = invocationArguments[i];
					if (invocArg instanceof Invocation && invocArg.resolvedType != null) { // TODO any poly? ReferenceExpression?
						Invocation innerPoly = (Invocation) invocArg;
						TypeBinding targetType = InferenceContext18.getParameter(method.parameters, i, false);
						if (targetType == null && method.isVarargs()) {
							isVarArgs = true;
							targetType = InferenceContext18.getParameter(method.parameters, i, true);
						}
						TypeBinding resolvedType = invocArg.resolvedType; 
						if (!resolvedType.isCompatibleWith(targetType, this)) {
							MethodBinding innerBinding = innerPoly.binding();
							if (innerBinding instanceof ParameterizedGenericMethodBinding) { // FIXME: does this happen?
								InferenceContext18 infCtx18 = innerPoly.getInferenceContext((ParameterizedGenericMethodBinding) innerBinding);
								if (infCtx18 != null) {
									// not detected as compatible, because inference still needs to complete?
									MethodBinding solution = infCtx18.getInvocationTypeInferenceSolution(
																		innerPoly.binding().original(), innerPoly, targetType);
									if (solution != null) {
										if (solution.returnType != null && solution.returnType.isCompatibleWith(targetType, this))
											return isVarArgs ? VARARGS_COMPATIBLE : COMPATIBLE;
									} else {
										MethodBinding problemMethod = infCtx18.getReturnProblemMethodIfNeeded(targetType, innerPoly.binding());
										if (problemMethod != null && problemMethod.isValidBinding())
											return COMPATIBLE;
										return NOT_COMPATIBLE;
									}
								} else if (innerPoly instanceof AllocationExpression) {
									// not detected as compatible, because its a diamond whose type hasn't yet been inferred?
									TypeBinding[] typeArguments = resolvedType.typeArguments();
									if (typeArguments != null && typeArguments.length == 0) {
										AllocationExpression alloc = (AllocationExpression) innerPoly;
										if ((alloc.type.bits & ASTNode.IsDiamond) != 0) {
											// not-yet-inferred diamond: erasure compatibility should suffice, detail will be checked using inference
											if (invocArg.resolvedType.isCompatibleWith(targetType.erasure(), this))
												return COMPATIBLE;
											return NOT_COMPATIBLE;
										}
									}
								}
							}
						}
					}
				}
			}
		}
		return parameterCompatibilityLevel(method, arguments, tiebreakingVarargsMethods);
	}

