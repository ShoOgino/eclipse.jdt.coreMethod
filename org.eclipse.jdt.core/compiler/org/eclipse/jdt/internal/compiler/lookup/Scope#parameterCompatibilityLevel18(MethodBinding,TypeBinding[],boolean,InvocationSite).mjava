	private int parameterCompatibilityLevel18(MethodBinding method, TypeBinding[] arguments, boolean tiebreakingVarargsMethods, InvocationSite site) {
		jdk18checks:
		if (site instanceof Invocation && compilerOptions().complianceLevel >= ClassFileConstants.JDK1_8) {
			Invocation invocation = (Invocation) site;
			if (method instanceof ParameterizedGenericMethodBinding) {
				InferenceContext18 infCtx = invocation.getInferenceContext((ParameterizedGenericMethodBinding) method);
				if (infCtx != null) {
					// inference is responsible, no need to recheck
					if (infCtx.isVarArgs())
						return VARARGS_COMPATIBLE;
					return COMPATIBLE;
				}
			}
			// collect inner invocations where the outer did not involve any inference:
			Expression[] invocationArguments = invocation.arguments();
			if (invocationArguments != null) {
				InnerInferenceHelper innerInferenceHelper = invocation.innerInferenceHelper();
				int argLen = invocationArguments.length;
				boolean isVarArgs[] = new boolean[1]; // emulate an in-out parameter for compatibilityLevel18FromInner(..)
				isVarArgs[0] = method.isVarargs() && argLen != method.parameters.length; // if same lengths, isVarArgs can still be updated below
				int level = COMPATIBLE;
				for (int i = 0; i < argLen; i++) {
					int nextLevel = compatibilityLevel18FromInner(method, innerInferenceHelper, invocationArguments[i], argLen, i, isVarArgs);
					if (nextLevel == NOT_COMPATIBLE)
						return nextLevel;
					if (nextLevel == -2)
						break jdk18checks;
					level = Math.max(level,  nextLevel);
				}
				return level; // neither NOT_COMPATIBLE nor unknown(-2) seen
			}
		}
		// fall back to old method:
		return parameterCompatibilityLevel(method, arguments, tiebreakingVarargsMethods);
	}

