	private int parameterCompatibilityLevel18(MethodBinding method, TypeBinding[] arguments, boolean tiebreakingVarargsMethods, InvocationSite site) {
		if (site instanceof Invocation) {
			Invocation invocation = (Invocation) site;
			if (method instanceof ParameterizedGenericMethodBinding) {
				InferenceContext18 infCtx = invocation.getInferenceContext((ParameterizedGenericMethodBinding) method);
				if (infCtx != null) {
					// inference is responsible, no need to recheck
					if (infCtx.isVarArgs())
						return VARARGS_COMPATIBLE;
					return COMPATIBLE;
				}
			}
			// collect inner invocations where the outer did not involve any inference:
			Expression[] invocationArguments = invocation.arguments();
			if (invocationArguments != null) {
				int argLen = invocationArguments.length;
				boolean isVarArgs = false;
				for (int i = 0; i < argLen; i++) {
					Expression invocArg = invocationArguments[i];
					if (invocArg instanceof Invocation && invocArg.resolvedType != null) { // TODO any poly? ReferenceExpression?
						Invocation innerPoly = (Invocation) invocArg;
						TypeBinding targetType = InferenceContext18.getParameter(method.parameters, i, false);
						if (targetType == null && method.isVarargs()) {
							isVarArgs = true;
							targetType = InferenceContext18.getParameter(method.parameters, i, true);
						}
						TypeBinding resolvedType = invocArg.resolvedType; 
						if (!resolvedType.isCompatibleWith(targetType, this)) {
							MethodBinding innerBinding = innerPoly.binding(null); // 1. try without update
							if (innerBinding instanceof ParameterizedGenericMethodBinding) {
								ParameterizedGenericMethodBinding innerParameterized = (ParameterizedGenericMethodBinding) innerBinding;
								InferenceContext18 infCtx18 = innerPoly.getInferenceContext(innerParameterized);
								if (infCtx18 != null && infCtx18.stepCompleted < InferenceContext18.TYPE_INFERRED) {
									// not detected as compatible, because inference still needs to complete?
									invocArg.setExpectedType(targetType);
									MethodBinding solution = infCtx18.inferInvocationType(innerPoly, innerParameterized);
									if (solution != null && solution.isValidBinding()) {
										innerPoly.updateBindings(solution);
										if (solution.returnType != null && solution.returnType.isCompatibleWith(targetType, this))
											return isVarArgs ? VARARGS_COMPATIBLE : COMPATIBLE;
									}
									return NOT_COMPATIBLE;
								} else if (innerPoly instanceof AllocationExpression) {
									// not detected as compatible, because its a diamond whose type hasn't yet been inferred?
									TypeBinding[] typeArguments = resolvedType.typeArguments();
									if (typeArguments != null && typeArguments.length == 0) {
										AllocationExpression alloc = (AllocationExpression) innerPoly;
										if ((alloc.type.bits & ASTNode.IsDiamond) != 0) {
											// not-yet-inferred diamond: erasure compatibility should suffice, detail will be checked using inference
											if (invocArg.resolvedType.isCompatibleWith(targetType.erasure(), this))
												return COMPATIBLE;
											return NOT_COMPATIBLE;
										}
									}
								}
							} else if (innerPoly instanceof AllocationExpression) {
								MethodBinding updatedMethod = innerPoly.binding(targetType); // 2. try with updating
								if (updatedMethod != innerBinding && updatedMethod != null && updatedMethod.isValidBinding()) {
									if (updatedMethod.declaringClass.isCompatibleWith(targetType))
										return COMPATIBLE;
									return NOT_COMPATIBLE;
								}
							}
						}
					}
				}
			}
		}
		return parameterCompatibilityLevel(method, arguments, tiebreakingVarargsMethods);
	}

