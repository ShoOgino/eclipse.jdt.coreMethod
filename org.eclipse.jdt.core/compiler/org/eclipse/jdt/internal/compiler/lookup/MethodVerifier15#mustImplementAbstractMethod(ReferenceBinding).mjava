boolean mustImplementAbstractMethod(ReferenceBinding declaringClass) {
	if (!super.mustImplementAbstractMethod(declaringClass)) return false;

	if (!this.type.isEnum() || this.type.isAnonymousType()) return true; // want to test the actual enum type only
	if (this.type.isAbstract()) return false; // is an enum that has since been tagged as abstract by the code below

	// enum type needs to implement abstract methods if one of its constants does not supply a body
	TypeDeclaration typeDeclaration = this.type.scope.referenceContext;
	FieldDeclaration[] fields = typeDeclaration.fields;
	int length = typeDeclaration.fields == null ? 0 : typeDeclaration.fields.length;
	if (length == 0) return true; // has no constants so must implement the method itself
	for (int i = 0; i < length; i++) {
		FieldDeclaration fieldDecl = fields[i];
		if (fieldDecl.getKind() == AbstractVariableDeclaration.ENUM_CONSTANT)
			if (!(fieldDecl.initialization instanceof QualifiedAllocationExpression))
				return true;
	}

	// tag this enum as abstract since an abstract method must be implemented AND all enum constants define an anonymous body
	// as a result, each of its anonymous constants will see it as abstract and must implement each inherited abstract method
	this.type.modifiers |= IConstants.AccAbstract;
	return false;
}

