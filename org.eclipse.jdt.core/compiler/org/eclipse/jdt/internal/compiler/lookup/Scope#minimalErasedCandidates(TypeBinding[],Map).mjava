	/**
	 * Returns the most specific set of types compatible with all given types.
	 * (i.e. most specific common super types)
	 * If no types is given, will return an empty array. If not compatible 
	 * reference type is found, returns null. In other cases, will return an array 
	 * of minimal erased types, where some nulls may appear (and must simply be
	 * ignored).
	 */
	private TypeBinding[] minimalErasedCandidates(TypeBinding[] types, Map allInvocations) {
		int length = types.length;
		int indexOfFirst = -1, actualLength = 0;
		for (int i = 0; i < length; i++) {
			TypeBinding type = types[i];
			if (type == null) continue;
			if (type.isBaseType()) return null;
			if (indexOfFirst < 0) indexOfFirst = i;
			actualLength ++;
		}
		switch (actualLength) {
			case 0: return NoTypes;
			case 1: return types;
		}

		// record all supertypes of type
		// intersect with all supertypes of otherType
		TypeBinding firstType = types[indexOfFirst];
		TypeBinding[] superTypes;
		int superLength;
		if (firstType.isBaseType()) {
			return null; 
		} else if (firstType.isArrayType()) {
			superLength = 4;
			if (firstType.erasure() != firstType) {
				ArrayList someInvocations = new ArrayList(1);
				someInvocations.add(firstType);
				allInvocations.put(firstType.erasure(), someInvocations);
			}
			superTypes = new TypeBinding[] { // inject well-known array supertypes
					firstType.erasure(), 
					getJavaIoSerializable(),
					getJavaLangCloneable(),
					getJavaLangObject(),
			};
		} else {
			ArrayList typesToVisit = new ArrayList(5);
			TypeBinding firstErasure = firstType.erasure();
			if (firstErasure != firstType) {
				Set someInvocations = new HashSet(1);
				someInvocations.add(firstType);
				allInvocations.put(firstErasure, someInvocations);
			}
			typesToVisit.add(firstErasure);
			int max = 1;
			if (firstErasure.isArrayType()) {
				typesToVisit.add(getJavaIoSerializable());
				typesToVisit.add(getJavaLangCloneable());
				typesToVisit.add(getJavaLangObject());
				max += 3;
			}
			ReferenceBinding currentType = (ReferenceBinding)firstType;
			for (int i = 0; i < max; i++) {
				TypeBinding typeToVisit = (TypeBinding) typesToVisit.get(i);
				if (typeToVisit.isArrayType()) continue;
				currentType = (ReferenceBinding) typeToVisit;
				// inject super interfaces prior to superclass
				ReferenceBinding[] itsInterfaces = currentType.superInterfaces();
				for (int j = 0, count = itsInterfaces.length; j < count; j++) {
					TypeBinding itsInterface = itsInterfaces[j];
					TypeBinding itsInterfaceErasure = itsInterface.erasure();
					if (!typesToVisit.contains(itsInterfaceErasure)) {
						if (itsInterfaceErasure != itsInterface) {
							Set someInvocations = new HashSet(1);
							someInvocations.add(itsInterface);
							allInvocations.put(itsInterfaceErasure, someInvocations);
						}						
						typesToVisit.add(itsInterfaceErasure);
						max++;
					}
				}
				TypeBinding itsSuperclass = currentType.superclass();
				if (itsSuperclass != null) {
					TypeBinding itsSuperclassErasure = itsSuperclass.erasure();
					if (!typesToVisit.contains(itsSuperclassErasure)) {
						if (itsSuperclassErasure != itsSuperclass) {
							Set someInvocations = new HashSet(1);
							someInvocations.add(itsSuperclass);
							allInvocations.put(itsSuperclassErasure, someInvocations);
						}
						typesToVisit.add(itsSuperclassErasure);
						max++;
					}
				}
			}
			superLength = typesToVisit.size();
			superTypes = new TypeBinding[superLength];
			typesToVisit.toArray(superTypes);
		}
		// intersecting first type supertypes with other types' ones, nullifying non matching supertypes
		int remaining = superLength;
		nextOtherType: for (int i = indexOfFirst+1; i < length; i++) {
			TypeBinding otherType = types[i];
			if (otherType == null) continue nextOtherType;
			if (otherType.isArrayType()) {
				nextSuperType: for (int j = 0; j < superLength; j++) {
					TypeBinding superType = superTypes[j];
					if (superType == null || superType == otherType) continue nextSuperType;
					switch (superType.id) {
						case T_JavaIoSerializable :
						case T_JavaLangCloneable :
						case T_JavaLangObject :
							continue nextSuperType;
					}
					superTypes[j] = null;
					if (--remaining == 0) return null;
					
				}
				continue nextOtherType;
			}
			ReferenceBinding otherRefType = (ReferenceBinding) otherType;
			nextSuperType: for (int j = 0; j < superLength; j++) {
				TypeBinding superType = superTypes[j];
				if (superType == null) continue nextSuperType;
				TypeBinding match;
				if (superType == otherType || superType.id == T_JavaLangObject && otherType.isInterface()) {
					match = superType;
				} else {
					if (superType.isArrayType()) {
						match = null;
					} else {
						match = otherRefType.findSuperTypeWithSameErasure(superType);
					}
					if (match == null) { // incompatible super type
						superTypes[j] = null;
						if (--remaining == 0) return null;
						continue nextSuperType;
					}
				}
				// record invocation
				Set someInvocations = (Set) allInvocations.get(superType);
				if (someInvocations == null) someInvocations = new HashSet(1);
				someInvocations.add(match);
				allInvocations.put(superType, someInvocations);
			}				
		}
		// eliminate non minimal super types
		if (remaining > 1) {
			nextType: for (int i = 0; i < superLength; i++) {
				ReferenceBinding superType = (ReferenceBinding)superTypes[i];
				if (superType == null) continue nextType;
				nextOtherType: for (int j = 0; j < superLength; j++) {
					if (i == j) continue nextOtherType;
					ReferenceBinding otherType = (ReferenceBinding)superTypes[j];
					if (otherType == null) continue nextOtherType;
					if (otherType.id == T_JavaLangObject && superType.isInterface()) continue nextOtherType;
					if (superType.findSuperTypeWithSameErasure(otherType) != null) {
						superTypes[j] = null; // discard non minimal supertype
						remaining--;
					}
				}
			}
		}
		return superTypes;
	}

