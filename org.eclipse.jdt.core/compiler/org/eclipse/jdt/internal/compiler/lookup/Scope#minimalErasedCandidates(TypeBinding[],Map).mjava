	/**
	 * Returns the most specific set of types compatible with all given types.
	 * (i.e. most specific common super types)
	 * If no types is given, will return an empty array. If not compatible 
	 * reference type is found, returns null. In other cases, will return an array 
	 * of minimal erased types, where some nulls may appear (and must simply be
	 * ignored).
	 */
	protected TypeBinding[] minimalErasedCandidates(TypeBinding[] types, Map allInvocations) {
		int length = types.length;
		int indexOfFirst = -1, actualLength = 0;
		for (int i = 0; i < length; i++) {
			TypeBinding type = types[i];
			if (type == null) continue;
			if (type.isBaseType()) return null;
			if (indexOfFirst < 0) indexOfFirst = i;
			actualLength ++;
		}
		switch (actualLength) {
			case 0: return NoTypes;
			case 1: return types;
		}

		// record all supertypes of type
		// intersect with all supertypes of otherType
		TypeBinding firstType = types[indexOfFirst];
		TypeBinding[] erasedSuperTypes;
		int superLength;
		if (firstType.isBaseType()) {
			return null; 
		} else if (firstType.isArrayType()) {
			superLength = 4;
			if (firstType.erasure() != firstType) {
				Set someInvocations = new HashSet(1);
				someInvocations.add(firstType);
				allInvocations.put(firstType.erasure(), someInvocations);
			}
			erasedSuperTypes = new TypeBinding[] { // inject well-known array supertypes
					firstType.erasure(), 
					getJavaIoSerializable(),
					getJavaLangCloneable(),
					getJavaLangObject(),
			};
		} else {
			ArrayList typesToVisit = new ArrayList(5);
			TypeBinding firstErasure = (firstType.isTypeVariable() && !firstType.isCapture()) ? firstType : firstType.erasure();
			if (firstErasure != firstType) {
				Set someInvocations = new HashSet(1);
				someInvocations.add(firstType);
				allInvocations.put(firstErasure, someInvocations);
			}
			typesToVisit.add(firstType);
			int max = 1;
			if (firstErasure.isArrayType()) {
				typesToVisit.add(getJavaIoSerializable());
				typesToVisit.add(getJavaLangCloneable());
				typesToVisit.add(getJavaLangObject());
				max += 3;
			}
			ReferenceBinding currentType = (ReferenceBinding)firstType;
			for (int i = 0; i < max; i++) {
				TypeBinding typeToVisit = (TypeBinding) typesToVisit.get(i);
				if (typeToVisit.isArrayType()) continue;
				currentType = (ReferenceBinding) typeToVisit;
				// inject super interfaces prior to superclass
				ReferenceBinding[] itsInterfaces = currentType.superInterfaces();
				for (int j = 0, count = itsInterfaces.length; j < count; j++) {
					TypeBinding itsInterface = itsInterfaces[j];
					TypeBinding itsInterfaceErasure = (itsInterface.isTypeVariable() && !itsInterface.isCapture()) ? itsInterface : itsInterface.erasure();
					if (!typesToVisit.contains(itsInterfaceErasure)) {
						if (itsInterfaceErasure != itsInterface) {
							Set someInvocations = new HashSet(1);
							someInvocations.add(itsInterface);
							allInvocations.put(itsInterfaceErasure, someInvocations);
						}						
						typesToVisit.add(itsInterface);
						max++;
					}
				}
				TypeBinding itsSuperclass = currentType.superclass();
				if (itsSuperclass != null) {
					TypeBinding itsSuperclassErasure = (itsSuperclass.isTypeVariable() && !itsSuperclass.isCapture()) ? itsSuperclass : itsSuperclass.erasure();
					if (!typesToVisit.contains(itsSuperclassErasure)) {
						if (itsSuperclassErasure != itsSuperclass) {
							Set someInvocations = new HashSet(1);
							someInvocations.add(itsSuperclass);
							allInvocations.put(itsSuperclassErasure, someInvocations);
						}
						typesToVisit.add(itsSuperclass);
						max++;
					}
				}
			}
			superLength = typesToVisit.size();
			erasedSuperTypes = new TypeBinding[superLength];
			int rank = 0;
			for (Iterator iter = typesToVisit.iterator(); iter.hasNext();) {
				TypeBinding type = (TypeBinding)iter.next();
				erasedSuperTypes[rank++] = type.isTypeVariable() ? type : type.erasure();
			}
		}
		// intersecting first type supertypes with other types' ones, nullifying non matching supertypes
		int remaining = superLength;
		nextOtherType: for (int i = indexOfFirst+1; i < length; i++) {
			TypeBinding otherType = types[i];
			if (otherType == null) continue nextOtherType;
			if (otherType.isArrayType()) {
				nextSuperType: for (int j = 0; j < superLength; j++) {
					TypeBinding erasedSuperType = erasedSuperTypes[j];
					if (erasedSuperType == null || erasedSuperType == otherType) continue nextSuperType;
					switch (erasedSuperType.id) {
						case T_JavaIoSerializable :
						case T_JavaLangCloneable :
						case T_JavaLangObject :
							continue nextSuperType;
					}
					erasedSuperTypes[j] = null;
					if (--remaining == 0) return null;
					
				}
				continue nextOtherType;
			}
			ReferenceBinding otherRefType = (ReferenceBinding) otherType;
			nextSuperType: for (int j = 0; j < superLength; j++) {
				TypeBinding erasedSuperType = erasedSuperTypes[j];
				if (erasedSuperType == null) continue nextSuperType;
				TypeBinding match;
				if (erasedSuperType == otherType || erasedSuperType.id == T_JavaLangObject && otherType.isInterface()) {
					match = erasedSuperType;
				} else {
					if (erasedSuperType.isArrayType()) {
						match = null;
					} else {
						match = otherRefType.findSuperTypeWithSameErasure(erasedSuperType);
					}
					if (match == null) { // incompatible super type
						erasedSuperTypes[j] = null;
						if (--remaining == 0) return null;
						continue nextSuperType;
					}
				}
				// record invocation
				Set someInvocations = (Set) allInvocations.get(erasedSuperType);
				if (someInvocations == null) someInvocations = new HashSet(1);
				someInvocations.add(match);
				allInvocations.put(erasedSuperType, someInvocations);
			}				
		}
		// eliminate non minimal super types
		if (remaining > 1) {
			nextType: for (int i = 0; i < superLength; i++) {
				TypeBinding erasedSuperType = erasedSuperTypes[i];
				if (erasedSuperType == null) continue nextType;
				nextOtherType: for (int j = 0; j < superLength; j++) {
					if (i == j) continue nextOtherType;
					TypeBinding otherType = erasedSuperTypes[j];
					if (otherType == null) continue nextOtherType;
					if (otherType.id == T_JavaLangObject && erasedSuperType.isInterface()) continue nextOtherType;
					if (erasedSuperType instanceof ReferenceBinding) {
						if (((ReferenceBinding)erasedSuperType).findSuperTypeWithSameErasure(otherType) != null) {
							erasedSuperTypes[j] = null; // discard non minimal supertype
							remaining--;
						}
					}
				}
			}
		}
		return erasedSuperTypes;
	}

