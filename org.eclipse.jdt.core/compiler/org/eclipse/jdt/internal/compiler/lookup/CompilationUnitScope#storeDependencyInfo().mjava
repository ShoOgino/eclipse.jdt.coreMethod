public void storeDependencyInfo() {
	// add the type hierarchy of each referenced type
	// cannot do early since the hierarchy may not be fully resolved
	for (int i = 0; i < referencedTypes.size; i++) { // grows as more types are added
		ReferenceBinding type = (ReferenceBinding) referencedTypes.elementAt(i);
		if (!type.isLocalType()) {
			recordQualifiedReference(type.isMemberType()
				? CharOperation.splitOn('.', type.readableName())
				: type.compoundName);
			ReferenceBinding enclosing = type.enclosingType();
			if (enclosing != null && !referencedTypes.containsIdentical(enclosing))
				referencedTypes.add(enclosing); // to record its supertypes
		}
		ReferenceBinding superclass = type.superclass();
		if (superclass != null && !referencedTypes.containsIdentical(superclass))
				referencedTypes.add(superclass); // to record its supertypes
		ReferenceBinding[] interfaces = type.superInterfaces();
		if (interfaces != null && interfaces.length > 0)
			for (int j = 0, length = interfaces.length; j < length; j++)
				if (!referencedTypes.containsIdentical(interfaces[j]))
					referencedTypes.add(interfaces[j]); // to record its supertypes
	}

	int size = qualifiedReferences.size;
	char[][][] qualifiedRefs = new char[size][][];
	for (int i = 0; i < size; i++)
		qualifiedRefs[i] = qualifiedReferences.elementAt(i);
	referenceContext.compilationResult.qualifiedReferences = qualifiedRefs;

	size = simpleNameReferences.size;
	char[][] simpleRefs = new char[size][];
	for (int i = 0; i < size; i++)
		simpleRefs[i] = simpleNameReferences.elementAt(i);
	referenceContext.compilationResult.simpleNameReferences = simpleRefs;

// Old code to be removed
	for (int i = 0; i < typeDependencies.size; i++) { // grows as more types are added
		// add all the supertypes & associated packages
		ReferenceBinding type = (ReferenceBinding) typeDependencies.elementAt(i);

		addNamespaceReference(type.fPackage); // is this necessary? If so what about a & a.b from a.b.c?
		if (type.enclosingType() != null)
			addTypeReference(type.enclosingType());
		if (type.superclass() != null)
			addTypeReference(type.superclass());
		ReferenceBinding[] interfaces = type.superInterfaces();
		for (int j = 0, length = interfaces.length; j < length; j++)
			addTypeReference(interfaces[j]);
	}

	int length = namespaceDependencies.size;
	char[][] namespaceNames = new char[length][];
	for (int i = 0; i < length; i++)
		namespaceNames[i] = ((PackageBinding) namespaceDependencies.elementAt(i)).readableName();
	referenceContext.compilationResult.namespaceDependencies = namespaceNames;

	length = typeDependencies.size;
	int toplevelTypeCount = 0;
	for (int i = 0; i < length; i++)
		if (!((ReferenceBinding) typeDependencies.elementAt(i)).isNestedType())
			toplevelTypeCount++;
	char[][] fileNames = new char[toplevelTypeCount][];
	for (int i = 0; i < length; i++)
		if (!((ReferenceBinding) typeDependencies.elementAt(i)).isNestedType())
			fileNames[--toplevelTypeCount] = ((ReferenceBinding) typeDependencies.elementAt(i)).getFileName();

	// eliminate duplicates
	int unique = 0;
	char[] ownFileName = referenceContext.getFileName();
	next : for (int i = 0, l = fileNames.length; i < l; i++) {
		char[] fileName = fileNames[i];
		if (CharOperation.equals(fileName, ownFileName)) {
			fileNames[i] = null;
			continue next;
		}
		for (int j = i + 1; j < l; j++) {
			if (CharOperation.equals(fileName, fileNames[j])) {
				fileNames[i] = null;
				continue next;
			}
		}
		unique++;
	}
	if (unique < fileNames.length) {
		char[][] uniqueFileNames = new char[unique][];
		for (int i = fileNames.length; --i >= 0;)
			if (fileNames[i] != null)
				uniqueFileNames[--unique] = fileNames[i];
		fileNames = uniqueFileNames;
	}
	referenceContext.compilationResult.fileDependencies = fileNames;
}

