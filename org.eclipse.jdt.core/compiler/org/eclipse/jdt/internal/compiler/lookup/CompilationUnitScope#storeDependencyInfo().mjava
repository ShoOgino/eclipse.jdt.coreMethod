public void storeDependencyInfo() {
	// add the type hierarchy of each referenced type
	// cannot do early since the hierarchy may not be fully resolved
	for (int i = 0; i < referencedTypes.size; i++) { // grows as more types are added
		ReferenceBinding type = (ReferenceBinding) referencedTypes.elementAt(i);
		if (!type.isLocalType()) {
			recordQualifiedReference(type.isMemberType()
				? CharOperation.splitOn('.', type.readableName())
				: type.compoundName);
			ReferenceBinding enclosing = type.enclosingType();
			if (enclosing != null && !referencedTypes.containsIdentical(enclosing))
				referencedTypes.add(enclosing); // to record its supertypes
		}
		ReferenceBinding superclass = type.superclass();
		if (superclass != null && !referencedTypes.containsIdentical(superclass))
				referencedTypes.add(superclass); // to record its supertypes
		ReferenceBinding[] interfaces = type.superInterfaces();
		if (interfaces != null && interfaces.length > 0)
			for (int j = 0, length = interfaces.length; j < length; j++)
				if (!referencedTypes.containsIdentical(interfaces[j]))
					referencedTypes.add(interfaces[j]); // to record its supertypes
	}

	int size = qualifiedReferences.size;
	char[][][] qualifiedRefs = new char[size][][];
	for (int i = 0; i < size; i++)
		qualifiedRefs[i] = qualifiedReferences.elementAt(i);
	referenceContext.compilationResult.qualifiedReferences = qualifiedRefs;

	size = simpleNameReferences.size;
	char[][] simpleRefs = new char[size][];
	for (int i = 0; i < size; i++)
		simpleRefs[i] = simpleNameReferences.elementAt(i);
	referenceContext.compilationResult.simpleNameReferences = simpleRefs;
}

