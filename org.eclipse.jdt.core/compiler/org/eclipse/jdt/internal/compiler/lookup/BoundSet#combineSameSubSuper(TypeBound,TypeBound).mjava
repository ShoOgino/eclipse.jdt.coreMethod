	private ConstraintTypeFormula combineSameSubSuper(TypeBound boundS, TypeBound boundT) {
		//  α = S and α <: T imply ⟨S <: T⟩ 
		//  α = S and T <: α imply ⟨T <: S⟩
		InferenceVariable alpha = boundS.left;
		TypeBinding s = boundS.right;
		if (TypeBinding.equalsEquals(alpha, boundT.left)) {
			TypeBinding t = boundT.right;
			return ConstraintTypeFormula.create(s, t, boundT.relation, boundT.isSoft||boundS.isSoft);
		}
		if (TypeBinding.equalsEquals(alpha, boundT.right)) {
			TypeBinding t = boundT.left;
			return ConstraintTypeFormula.create(t, s, boundT.relation, boundT.isSoft||boundS.isSoft);
		}

		if (boundS.right instanceof InferenceVariable) {
			// reverse:
			alpha = (InferenceVariable) boundS.right;
			s = boundS.left;
			if (TypeBinding.equalsEquals(alpha, boundT.left)) {
				TypeBinding t = boundT.right;
				return ConstraintTypeFormula.create(s, t, boundT.relation, boundT.isSoft||boundS.isSoft);
			}
			if (TypeBinding.equalsEquals(alpha, boundT.right)) {
				TypeBinding t = boundT.left;
				return ConstraintTypeFormula.create(t, s, boundT.relation, boundT.isSoft||boundS.isSoft);
			}			
		}
		
		//  α = U and S <: T imply ⟨S[α:=U] <: T[α:=U]⟩ 
		TypeBinding u = boundS.right;
		if (u.isProperType(true)) {
			boolean substitute = TypeBinding.equalsEquals(alpha, boundT.left);
			TypeBinding left = substitute ? u : boundT.left;
			TypeBinding right = boundT.right.substituteInferenceVariable(alpha, u);
			substitute |= TypeBinding.notEquals(right, boundT.right);
			if (substitute) // avoid redundant constraint
				return ConstraintTypeFormula.create(left, right, boundT.relation, boundT.isSoft||boundS.isSoft);
		}
		return null;
	}

