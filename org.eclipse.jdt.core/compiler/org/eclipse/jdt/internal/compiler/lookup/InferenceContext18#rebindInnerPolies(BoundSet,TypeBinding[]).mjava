	/**
	 * After inference has finished, iterate all inner poly expressions (Invocations), that
	 * have been included in the inference. For each of these update some type information
	 * from the inference result and perhaps trigger follow-up resolving as needed.
	 * Similar for poly expressions that did not directly participate in the inference
	 * but are direct arguments of the current invocation (FunctionalExpression, ConditionalExpression).
	 */
	public void rebindInnerPolies(BoundSet bounds, TypeBinding[] parameterTypes) {
		// This updates all remaining poly expressions that are direct arguments of the current invocation:
		// (handles FunctionalExpression & ConditionalExpression)
		if (this.currentInvocation instanceof ReferenceExpression)
			return; // no inner expressions
		boolean isVarargs = this.inferenceKind == CHECK_VARARG;
		acceptPendingPolyArguments(bounds, parameterTypes, isVarargs);
		// This loops over all poly expressions for which a sub-inference was triggered:
		// (handles generic invocations)
		int len = this.innerPolies.size();
		for (int i = 0; i < len; i++) {
			Expression inner = (Expression) this.innerPolies.get(i);
			if (inner instanceof ReferenceExpression) {
				ReferenceExpression referenceExpression = (ReferenceExpression) inner;
				MethodBinding compileTimeDecl = referenceExpression.prepareForInferenceResult(this.scope);
				if	(compileTimeDecl != null) {
	  				TypeVariableBinding[] variables = compileTimeDecl.typeVariables;
					if (variables != Binding.NO_TYPE_VARIABLES) {
						TypeBinding[] arguments = getSolutions(variables, (InvocationSite) inner, bounds);
						referenceExpression.binding = this.environment.createParameterizedGenericMethod(compileTimeDecl, arguments);
					}
				}
			} else if (inner instanceof Invocation) {
				Invocation innerMessage = (Invocation) inner;
				TypeBinding innerTargetType = inner.expectedType(); // may be set from acceptPendingPolyArguments
				if (innerTargetType != null && !innerTargetType.isProperType(true))
					innerTargetType = null;
				MethodBinding binding = innerMessage.binding(innerTargetType, innerTargetType != null, this.scope);
				if (binding == null)
					continue;
				MethodBinding original = binding.shallowOriginal();

				// apply inference results onto the allocation type of inner diamonds:
				if (original.isConstructor() && inner.isPolyExpression()) {
					ReferenceBinding declaringClass = original.declaringClass;
					TypeBinding[] arguments = getSolutions(declaringClass.typeVariables(), innerMessage, bounds);
					declaringClass = this.environment.createParameterizedType(declaringClass, arguments, declaringClass.enclosingType());
					original = ((ParameterizedTypeBinding)declaringClass).createParameterizedMethod(original);
					inner.checkAgainstFinalTargetType(innerTargetType, this.scope);	
					if (this.environment.globalOptions.isAnnotationBasedNullAnalysisEnabled)
						NullAnnotationMatching.checkForContraditions(original, innerMessage, this.scope);
				}
				
				// apply results of the combined inference onto the binding of the inner invocation:
				TypeBinding[] solutions = getSolutions(original.typeVariables(), innerMessage, bounds);
				if (solutions == null) {
					if (binding instanceof ParameterizedGenericMethodBinding) {
						InferenceContext18 innerCtx = innerMessage.getInferenceContext((ParameterizedGenericMethodBinding) binding);
						if (innerCtx != null && !binding.isValidBinding()) {
							innerCtx.reportInvalidInvocation(innerMessage, binding);
						}
					}
					continue; // inner inference not requested -> not a problem
				}
				ParameterizedGenericMethodBinding innerBinding = this.environment.createParameterizedGenericMethod(original, solutions);
				
				if (innerMessage.updateBindings(innerBinding, innerTargetType)) { // only if we are actually improving anything
					ASTNode.resolvePolyExpressionArguments(innerMessage, innerBinding, this.scope);
				}
			}
		}
		this.stepCompleted = BINDINGS_UPDATED; // we're done-done
	}

