	/**
	 * After inference has finished, iterate all inner poly expressions (Invocations), that
	 * have been included in the inference. For each of these update some type information
	 * from the inference result and perhaps trigger follow-up resolving as needed.
	 * Similar for poly expressions that did not directly participate in the inference
	 * but are direct arguments of the current invocation (FunctionalExpression, ConditionalExpression).
	 */
	public void rebindInnerPolies(BoundSet bounds, TypeBinding[] parameterTypes) {
		// This updates all remaining poly expressions that are direct arguments of the current invocation:
		// (handles FunctionalExpression & ConditionalExpression)
		boolean isVarargs = this.inferenceKind == CHECK_VARARG;
		acceptPendingPolyArguments(bounds, parameterTypes, isVarargs);
		// This loops over all poly expressions for which a sub-inference was triggered:
		// (handles generic invocations)
		int len = this.innerPolies.size();
		for (int i = 0; i < len; i++) {
			Expression inner = (Expression) this.innerPolies.get(i);
			if (inner instanceof Invocation) {
				Invocation innerMessage = (Invocation) inner;
				TypeBinding innerTargetType = getParameter(parameterTypes, i, isVarargs);
				MethodBinding binding = innerMessage.binding(innerTargetType);
				if (binding == null)
					continue;
				MethodBinding original = binding.shallowOriginal();

				// apply inference results onto the allocation type of inner diamonds:
				if (original.isConstructor() && inner.isPolyExpression()) {
					ReferenceBinding declaringClass = original.declaringClass;
					TypeBinding[] arguments = getSolutions(declaringClass.typeVariables(), innerMessage, bounds);
					declaringClass = this.environment.createParameterizedType(declaringClass, arguments, declaringClass.enclosingType());
					original = ((ParameterizedTypeBinding)declaringClass).createParameterizedMethod(original);
				}
				
				// apply results of the combined inference onto the binding of the inner invocation:
				TypeBinding[] solutions = getSolutions(original.typeVariables(), innerMessage, bounds);
				if (solutions == null) {
					if (binding instanceof ParameterizedGenericMethodBinding) {
						InferenceContext18 innerCtx = innerMessage.getInferenceContext((ParameterizedGenericMethodBinding) binding);
						if (innerCtx != null && !binding.isValidBinding()) {
							if (innerMessage instanceof MessageSend)
								innerCtx.scope.problemReporter().invalidMethod((MessageSend) innerMessage, binding);
							else
								innerCtx.scope.problemReporter().invalidConstructor(inner, binding);
						}
					}
					continue; // inner inference not requested -> not a problem
				}
				ParameterizedGenericMethodBinding innerBinding = this.environment.createParameterizedGenericMethod(original, solutions);
				
				if (innerMessage.updateBindings(innerBinding, innerTargetType)) { // only if we are actually improving anything
					ASTNode.resolvePolyExpressionArguments(innerMessage, innerBinding);
				}
			}
		}
		this.stepCompleted = BINDINGS_UPDATED; // we're done-done
	}

