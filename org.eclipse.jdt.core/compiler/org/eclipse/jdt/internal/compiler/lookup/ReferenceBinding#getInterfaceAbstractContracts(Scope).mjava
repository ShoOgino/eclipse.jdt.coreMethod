private MethodBinding [] getInterfaceAbstractContracts(Scope scope) throws InvalidInputException {
	
	if (!isInterface() || !isValidBinding()) {
		throw new InvalidInputException("Not a functional interface"); //$NON-NLS-1$
	}
	
	MethodBinding [] methods = methods();
	MethodBinding [] contracts = new MethodBinding[0];
	int contractsCount = 0;
	int contractsLength = 0;
	MethodBinding aContract = null;
	int contractParameterLength = 0;
	char [] contractSelector = null;
	
	for (int i = 0, length = methods == null ? 0 : methods.length; i < length; i++) {
		final MethodBinding method = methods[i];
		if (!method.isAbstract() || method.redeclaresPublicObjectMethod(scope)) continue; // skips statics, defaults, public object methods ...
		final boolean validBinding = method.isValidBinding();
		if (aContract == null && validBinding) {
			aContract = method;
			contractParameterLength = aContract.parameters.length;
			contractSelector = aContract.selector;
		} else {
			if (!validBinding || method.parameters.length != contractParameterLength || !CharOperation.equals(contractSelector, method.selector)) {
				throw new InvalidInputException("Not a functional interface"); //$NON-NLS-1$
			}
		}
		if (contractsCount == contractsLength) {
			System.arraycopy(contracts, 0, contracts = new MethodBinding[contractsLength += 16], 0, contractsCount);
		}
		contracts[contractsCount++] = method;
	}
	ReferenceBinding [] superInterfaces = superInterfaces();
	for (int i = 0, length = superInterfaces.length; i < length; i++) {
		MethodBinding [] superInterfaceContracts = superInterfaces[i].getInterfaceAbstractContracts(scope);
		final int superInterfaceContractsLength = superInterfaceContracts == null  ? 0 : superInterfaceContracts.length;
		
		if (superInterfaceContractsLength == 0) continue;
		if (aContract == null) {
			aContract = superInterfaceContracts[0];
			contractParameterLength = aContract.parameters.length;
			contractSelector = aContract.selector;
			contracts = superInterfaceContracts;
			contractsCount = contractsLength = superInterfaceContractsLength;
		} else {
			if (superInterfaceContracts[0].parameters.length != contractParameterLength || !CharOperation.equals(contractSelector, superInterfaceContracts[0].selector)) {
				throw new InvalidInputException("Not a functional interface"); //$NON-NLS-1$
			}
			if (contractsLength < contractsCount + superInterfaceContractsLength) {
				System.arraycopy(contracts, 0, contracts = new MethodBinding[contractsLength = contractsCount + superInterfaceContractsLength], 0, contractsCount);
			}
			System.arraycopy(superInterfaceContracts, 0, contracts, contractsCount,	superInterfaceContractsLength);
			contractsCount += superInterfaceContractsLength;
		}
	}
	if (contractsCount < contractsLength) {
		System.arraycopy(contracts, 0, contracts = new MethodBinding[contractsCount], 0, contractsCount);
	}
	return contracts;
}

