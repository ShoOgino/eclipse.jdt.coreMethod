		protected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite) {
			boolean varargsStatus = visible[0].isVarargs();
			for (int i = 1; i < visibleSize; i++) {
				if (visible[i].isVarargs() != varargsStatus) {
					// visible is a mix of fixed & variable arity methods, so double check the varargs methods, but consider their vararg argument as a fixed array
					MethodBinding[] temp = new MethodBinding[visibleSize];
					int newSize = 0;
					for (int j = 0; j < visibleSize; j++)
						if (!visible[j].isVarargs() || visible[j].areParametersCompatibleWith(argumentTypes))
							temp[newSize++] = visible[j];
					visible = temp;
					visibleSize = newSize;
					break;
				}
			}
	
			MethodBinding method = null;
			nextVisible : for (int i = 0; i < visibleSize; i++) {
				method = visible[i];
				for (int j = 0; j < visibleSize; j++) {
					if (i == j) continue;
					// tiebkreak generic methods using variant where type params are substituted by their erasures
					if (!visible[j].tiebreakMethod().areParametersCompatibleWith(method.tiebreakMethod().parameters))
						continue nextVisible;
				}
				compilationUnitScope().recordTypeReferences(method.thrownExceptions);
				return method;
			}
			return new ProblemMethodBinding(visible[0].selector, visible[0].parameters, Ambiguous);
		}	

