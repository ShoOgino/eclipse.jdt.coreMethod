	protected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite) {
		int[] compatibilityLevels = new int[visibleSize];
		for (int i = 0; i < visibleSize; i++)
			compatibilityLevels[i] = parameterCompatibilityLevel(visible[i], argumentTypes);

		for (int level = 0; level <= VARARGS_COMPATIBLE; level++) {
			nextVisible : for (int i = 0; i < visibleSize; i++) {
				if (compatibilityLevels[i] != level) continue nextVisible; // skip this method for now
				MethodBinding method = visible[i];
				TypeBinding[] params = method.tiebreakMethod().parameters;
				for (int j = 0; j < visibleSize; j++) {
					if (i == j || compatibilityLevels[j] != level) continue;
					MethodBinding method2 = visible[j];
					// tiebreak generic methods using variant where type params are substituted by their erasures
					if (!method2.tiebreakMethod().areParametersCompatibleWith(params)) {
						if (method.isVarargs() && method2.isVarargs()) {
							// check the non-vararg parameters
							int paramLength = params.length;
							TypeBinding[] params2 = method2.tiebreakMethod().parameters;
							if (paramLength != params2.length)
								continue nextVisible;
							for (int p = paramLength - 2; p >= 0; p--)
								if (params[p] != params2[p] && !params[p].isCompatibleWith(params2[p]))
									continue nextVisible;

							TypeBinding elementsType = ((ArrayBinding) params2[paramLength - 1]).elementsType();
							if (params[paramLength - 1].isCompatibleWith(elementsType))
								continue; // special case to choose between 2 varargs methods when the last arg is missing or its Object[]
						}
						continue nextVisible;
//					} else if (method.isStatic()) {
//						// detect collision between static import methods
//						if (method.declaringClass != method2.declaringClass && method.original().areParametersEqual(method2.original()))
//							continue nextVisible;
					} else if (method.hasSubstitutedParameters() && method.isAbstract() == method2.isAbstract()) { // must both be abstract or concrete, not one of each
						if (method.areParametersEqual(method2)) {
							// its possible with 2 methods that one does not inherit from the other
							// need to find their methods from the receiver type
							// see cases in verify test #43
							MethodBinding original = method.original();
							MethodBinding original2 = method2.original();
							if (original.areParameterErasuresEqual(original2)) continue;
							ReferenceBinding receiverType = (ReferenceBinding) ((MessageSend) invocationSite).actualReceiverType;
							if (receiverType != method.declaringClass) {
								ReferenceBinding superType = ((ReferenceBinding) receiverType.erasure()).findSuperTypeErasingTo(original.declaringClass);
								if (superType != null) {
									MethodBinding[] superMethods = superType.getMethods(original.selector);
									for (int m = 0, l = superMethods.length; m < l; m++) {
										if (superMethods[m].original() == original) {
											original = superMethods[m];
											break;
										}
									}
								}
							}
							if (receiverType != method2.declaringClass) {
								ReferenceBinding superType = ((ReferenceBinding) receiverType.erasure()).findSuperTypeErasingTo(original2.declaringClass);
								if (superType != null) {
									MethodBinding[] superMethods = superType.getMethods(original2.selector);
									for (int m = 0, l = superMethods.length; m < l; m++) {
										if (superMethods[m].original() == original2) {
											original2 = superMethods[m];
											break;
										}
									}
								}
							}
							if (!original.areParametersEqual(original2))
								continue nextVisible; // cannot be substituted from 2 different type variables
						}
					}
				}
				compilationUnitScope().recordTypeReferences(method.thrownExceptions);
				return method;
			}
		}
		return new ProblemMethodBinding(visible[0].selector, visible[0].parameters, Ambiguous);
	}	

