	protected final MethodBinding mostSpecificMethodBinding(MethodBinding[] visible, int visibleSize, TypeBinding[] argumentTypes, InvocationSite invocationSite) {
		int[] compatibilityLevels = new int[visibleSize];
		for (int i = 0; i < visibleSize; i++)
			compatibilityLevels[i] = parameterCompatibilityLevel(visible[i], argumentTypes);

		for (int level = 0, max = VARARGS_COMPATIBLE; level <= max; level++) {
			nextVisible : for (int i = 0; i < visibleSize; i++) {
				if (compatibilityLevels[i] != level) continue nextVisible; // skip this method for now
				MethodBinding method = visible[i];
				TypeBinding[] params = method.tiebreakMethod().parameters;
				for (int j = 0; j < visibleSize; j++) {
					if (i == j || compatibilityLevels[j] != level) continue;
					max = level; // do not examine further categories
					MethodBinding method2 = visible[j];
					// tiebreak generic methods using variant where type params are substituted by their erasures
					if (!method2.tiebreakMethod().areParametersCompatibleWith(params)) {
						if (method.isVarargs() && method2.isVarargs()) {
							// check the non-vararg parameters
							int paramLength = params.length;
							TypeBinding[] params2 = method2.tiebreakMethod().parameters;
							if (paramLength != params2.length)
								continue nextVisible;
							for (int p = paramLength - 2; p >= 0; p--)
								if (params[p] != params2[p] && !params[p].isCompatibleWith(params2[p]))
									continue nextVisible;

							TypeBinding elementsType = ((ArrayBinding) params2[paramLength - 1]).elementsType();
							if (params[paramLength - 1].isCompatibleWith(elementsType))
								continue; // special case to choose between 2 varargs methods when the last arg is missing or its Object[]
						}
						continue nextVisible;
					}

					if (method == method2) continue; // interfaces may be walked twice from different paths

					// see if method & method2 are duplicates due to the current substitution or multiple static imported methods
					if (method.tiebreakMethod().areParametersEqual(method2.tiebreakMethod())) {
						if (method.declaringClass == method2.declaringClass)
							continue nextVisible; // duplicates thru substitution

						MethodBinding original = method.original();
						if (method.hasSubstitutedParameters() || original.typeVariables != NoTypeVariables) {
							ReferenceBinding declaringClass = (ReferenceBinding) method.declaringClass.erasure();
							ReferenceBinding superType = declaringClass.findSuperTypeWithSameErasure(method2.declaringClass.erasure());
							if (superType == null) {
								// accept concrete methods over abstract methods found due to the default abstract method walk
								if (!method.isAbstract() && method2.isAbstract())
									continue;
								continue nextVisible;
							}
							MethodBinding inheritedMethod = method2;
							MethodBinding inheritedOriginal = method2.original();
							if (method.hasSubstitutedParameters()) { // must find inherited method with the same substituted variables
								MethodBinding[] superMethods = superType.getMethods(inheritedMethod.selector);
								for (int m = 0, l = superMethods.length; m < l; m++) {
									if (superMethods[m].original() == inheritedOriginal) {
										inheritedMethod = superMethods[m];
										break;
									}
								}
							}
							if (original.typeVariables != NoTypeVariables)
								inheritedMethod = original.computeSubstitutedMethod(inheritedMethod == method2 ? inheritedOriginal : inheritedMethod, environment());
							if (inheritedMethod == null || !original.areParametersEqual(inheritedMethod))
								break nextVisible; // dup thru substitution, not overridden... cannot find possible match
							// method overrides method2, accept it
						} else if (method.isStatic() && method2.isStatic()) {
							ReferenceBinding declaringClass = (ReferenceBinding) method.declaringClass.erasure();
							ReferenceBinding superType = declaringClass.findSuperTypeWithSameErasure(method2.declaringClass.erasure());
							if (superType == null)
								continue nextVisible; // static methods from unrelated types
						}
					}
				}
				compilationUnitScope().recordTypeReferences(method.thrownExceptions);
				return method;
			}
		}
		return new ProblemMethodBinding(visible[0].selector, visible[0].parameters, Ambiguous);
	}	

