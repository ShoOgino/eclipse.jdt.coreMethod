int[] findOverriddenInheritedMethods(MethodBinding[] methods, int length) {
	// inherited methods are added as we walk up the superclass hierarchy, then each superinterface
	// so method[1] from a class can NOT override method[0], but methods from superinterfaces can
	// since superinterfaces can be added from different superclasses or other superinterfaces
	int[] toSkip = null;
	if (length > 1) {
		nextMethod : for (int i = 0; i < length; i++) {
			ReferenceBinding declaringClass = methods[i].declaringClass;
			if (declaringClass.isInterface()) {
				if (toSkip != null && toSkip[i] == -1) continue nextMethod;
				for (int j = i + 1; j < length; j++) {
					if (toSkip != null && toSkip[j] == -1) continue;
					ReferenceBinding declaringClass2 = methods[j].declaringClass;
					if (declaringClass == declaringClass2) continue;
					if (declaringClass.implementsInterface(declaringClass2, true)) {
						if (toSkip == null)
							toSkip = new int[length];
						toSkip[j] = -1;
					} else if (declaringClass2.implementsInterface(declaringClass, true)) {
						if (toSkip == null)
							toSkip = new int[length];
						toSkip[i] = -1;
						continue nextMethod;
					}
				}
			} else {
				// only keep methods from the closest superclass, all others from higher superclasses can be skipped
				// NOTE: methods were added in order by walking up the superclass hierarchy
				for (int j = i + 1; j < length; j++) {
					ReferenceBinding declaringClass2 = methods[j].declaringClass;
					if (declaringClass == declaringClass2) continue;
					if (declaringClass2.isInterface()) {
						i = j - 1; // start the interface comparison with this method
						continue nextMethod;
					} else {
						if (toSkip == null)
							toSkip = new int[length];
						toSkip[j] = -1;
					}
				}
			}
		}
	}
	return toSkip;
}

