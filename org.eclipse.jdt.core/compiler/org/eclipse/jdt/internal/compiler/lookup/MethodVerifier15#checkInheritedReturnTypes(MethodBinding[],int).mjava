boolean checkInheritedReturnTypes(MethodBinding[] methods, int length) {
	if (methods[0].declaringClass.isClass())
		return super.checkInheritedReturnTypes(methods, length);
	if (length <= 1) {
		return true; // no need to continue since only 1 inherited method is left
	}
	// get rid of overriden methods coming from interfaces - if any
	MethodBinding methodsToCheck[] = new MethodBinding[length];	// must not nullify methods slots in place
	int count = length;
	for (int i = 0; i < length; i++) {
		methodsToCheck[i] = methods[i];
	}
	for (int i = 0; i < length; i++) {
		MethodBinding existingMethod;
		if ((existingMethod = methodsToCheck[i]) != null) {
			for (int j = 0; j < length; j++) {
				MethodBinding inheritedMethod;
				if (i != j && (inheritedMethod = methodsToCheck[j]) != null &&
						existingMethod.declaringClass.implementsInterface(inheritedMethod.declaringClass, true)) {
					MethodBinding substitute = computeSubstituteMethod(inheritedMethod, existingMethod);
					if (substitute != null && 
							doesSubstituteMethodOverride(existingMethod, substitute) &&
							(existingMethod.returnType.isCompatibleWith(substitute.returnType) ||
									isReturnTypeSubstituable(substitute, existingMethod))) {
						count--;
						methodsToCheck[j] = null;
					}
				}
			}
		}
	}
	if (count < length) {
		if (count == 1) { 
			return true; // no need to continue since only 1 inherited method is left
		}
		for (int i = 0, j = 0; j < count; i++) {
			if (methodsToCheck[i] != null) {
				methodsToCheck[j++] = methodsToCheck[i];
			}
		}
		methods = methodsToCheck;
		length = count;
	} // else keep methods unchanged for further checks

	// its possible in 1.5 that A is compatible with B & C, but B is not compatible with C
	for (int i = 0, l = length - 1; i < l;) {
		MethodBinding method = methods[i++];
		for (int j = i; j <= l; j++) {
			if (!areReturnTypesCompatible(method, methods[j])) {
				if (this.type.isInterface())
					for (int m = length; --m >= 0;)
						if (methods[m].declaringClass.id == TypeIds.T_JavaLangObject)
							return false; // do not complain since the super interface already got blamed
				problemReporter().inheritedMethodsHaveIncompatibleReturnTypes(this.type, methods, length);
				return false;
			}
		}
	}
	return true;
}

