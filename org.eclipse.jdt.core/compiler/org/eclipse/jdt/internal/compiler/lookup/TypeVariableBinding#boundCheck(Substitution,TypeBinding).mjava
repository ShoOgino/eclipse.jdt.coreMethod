	/**
	 * Returns true if the argument type satisfies all bounds of the type parameter
	 */
	public int boundCheck(Substitution substitution, TypeBinding argumentType) {

		if (argumentType == NullBinding || argumentType == this)
			return TypeConstants.OK;
		boolean hasSubstitution = substitution != null;
		if (!(argumentType instanceof ReferenceBinding || argumentType.isArrayType()))
			return TypeConstants.MISMATCH;	
		
	    if (argumentType.isWildcard()) {
	        WildcardBinding wildcard = (WildcardBinding) argumentType;
	        switch (wildcard.boundKind) {
	        	case Wildcard.SUPER :
//		            if (boundCheck(substitution, wildcard.bound) != TypeConstants.OK) return TypeConstants.MISMATCH;
//		            break;
		            return boundCheck(substitution, wildcard.bound); // only check the lower bound
				case Wildcard.UNBOUND :
					if (this == wildcard.typeVariable()) 
						return TypeConstants.OK;
					break;	        		
	        }
	    }
		boolean unchecked = false;
		if (this.superclass.id != T_JavaLangObject) {
			TypeBinding substitutedSuperType = hasSubstitution ? Scope.substitute(substitution, this.superclass) : this.superclass;
			if (!argumentType.isCompatibleWith(substitutedSuperType)) {
			    return TypeConstants.MISMATCH;
			}
			if (argumentType instanceof ReferenceBinding) {
				ReferenceBinding referenceArgument = (ReferenceBinding) argumentType;
				TypeBinding match = referenceArgument.findSuperTypeErasingTo((ReferenceBinding)substitutedSuperType.erasure());
				if (match != null){
					// Enum#RAW is not a substitute for <E extends Enum<E>> (86838)
					if (match.isRawType() && (substitutedSuperType.isGenericType()||substitutedSuperType.isBoundParameterizedType()))
						unchecked = true;
				}
			}
		}
	    for (int i = 0, length = this.superInterfaces.length; i < length; i++) {
			TypeBinding substitutedSuperType = hasSubstitution ? Scope.substitute(substitution, this.superInterfaces[i]) : this.superInterfaces[i];
			if (!argumentType.isCompatibleWith(substitutedSuperType)) {
			    return TypeConstants.MISMATCH;
			}
			if (argumentType instanceof ReferenceBinding) {
				ReferenceBinding referenceArgument = (ReferenceBinding) argumentType;
				TypeBinding match = referenceArgument.findSuperTypeErasingTo((ReferenceBinding)substitutedSuperType.erasure());
				if (match != null){
					// Enum#RAW is not a substitute for <E extends Enum<E>> (86838)
					if (match.isRawType() && (substitutedSuperType.isGenericType()||substitutedSuperType.isBoundParameterizedType()))
						unchecked = true;
				}
			}
	    }
	    return unchecked ? TypeConstants.UNCHECKED : TypeConstants.OK;
	}

