	/**
	 * Returns true if the argument type satisfies all bounds of the type parameter
	 */
	public int boundCheck(Substitution substitution, TypeBinding argumentType) {

		if (argumentType == TypeBinding.NULL || argumentType == this)
			return TypeConstants.OK;
		boolean hasSubstitution = substitution != null;
		if (!(argumentType instanceof ReferenceBinding || argumentType.isArrayType()))
			return TypeConstants.MISMATCH;	
		// special case for re-entrant source types (selection, code assist, etc)...
		// can request additional types during hierarchy walk that are found as source types that also 'need' to connect their hierarchy
		if (this.superclass == null)
			return TypeConstants.OK;

		if (argumentType.isWildcard() && !argumentType.isIntersectionType()) {
			WildcardBinding wildcard = (WildcardBinding) argumentType;
			switch(wildcard.boundKind) {
				case Wildcard.EXTENDS :
					TypeBinding wildcardBound = wildcard.bound;
					if (wildcardBound == this) 
						return TypeConstants.OK;
					ReferenceBinding superclassBound = hasSubstitution ? (ReferenceBinding)Scope.substitute(substitution, this.superclass) : this.superclass;
					boolean isArrayBound = wildcardBound.isArrayType();
					if (!wildcardBound.isInterface()) {
						if (superclassBound.id != TypeIds.T_JavaLangObject) {
							if (isArrayBound) {
								if (!wildcardBound.isCompatibleWith(superclassBound))
									return TypeConstants.MISMATCH;
							} else {
								TypeBinding match = wildcardBound.findSuperTypeWithSameErasure(superclassBound);
								if (match != null) {
									if (!match.isIntersectingWith(superclassBound)) {
										return TypeConstants.MISMATCH;
									}
								} else {
									match =  superclassBound.findSuperTypeWithSameErasure(wildcardBound);
									if (match != null) {
										if (!match.isIntersectingWith(wildcardBound)) {
											return TypeConstants.MISMATCH;
										}
									} else {
										if (!wildcardBound.isTypeVariable() && !superclassBound.isTypeVariable()) {
											return TypeConstants.MISMATCH;
										}
									}
								}
							}
						}
					}
					ReferenceBinding[] superInterfaceBounds = hasSubstitution ? Scope.substitute(substitution, this.superInterfaces) : this.superInterfaces;
					int length = superInterfaceBounds.length;
					boolean mustImplement = isArrayBound || ((ReferenceBinding)wildcardBound).isFinal();
					for (int i = 0; i < length; i++) {
						TypeBinding superInterfaceBound = superInterfaceBounds[i];
						if (isArrayBound) {
							if (!wildcardBound.isCompatibleWith(superInterfaceBound))
									return TypeConstants.MISMATCH;
						} else {
							TypeBinding match = wildcardBound.findSuperTypeWithSameErasure(superInterfaceBound);
							if (match != null) {
								if (!match.isIntersectingWith(superInterfaceBound)) {
									return TypeConstants.MISMATCH;
								}
							} else if (mustImplement) {
									return TypeConstants.MISMATCH; // cannot be extended further to satisfy missing bounds
							}
						}

					}
					break;
					
				case Wildcard.SUPER :
					return boundCheck(substitution, wildcard.bound);
					
				case Wildcard.UNBOUND :
					break;
			}
			return TypeConstants.OK;
		}
		boolean unchecked = false;
		if (this.superclass.id != TypeIds.T_JavaLangObject) {
			TypeBinding superType = this.superclass;
			if (superType != argumentType) { // check identity before substituting (104649)
				TypeBinding substitutedSuperType = hasSubstitution ? Scope.substitute(substitution, superType) : superType;
				if (!argumentType.isCompatibleWith(substitutedSuperType)) {
				    return TypeConstants.MISMATCH;
				}
				TypeBinding match = argumentType.findSuperTypeWithSameErasure(substitutedSuperType);
				if (match != null){
					// Enum#RAW is not a substitute for <E extends Enum<E>> (86838)
					if (match.isRawType() && substitutedSuperType.isBoundParameterizedType())
						unchecked = true;
				}
			}
		}
	    for (int i = 0, length = this.superInterfaces.length; i < length; i++) {
	    	TypeBinding superType = this.superInterfaces[i];
	    	if (superType != argumentType) { // check identity before substituting (104649)
				TypeBinding substitutedSuperType = hasSubstitution ? Scope.substitute(substitution, superType) : superType;
				if (!argumentType.isCompatibleWith(substitutedSuperType)) {
				    return TypeConstants.MISMATCH;
				}
				TypeBinding match = argumentType.findSuperTypeWithSameErasure(substitutedSuperType);
				if (match != null){
					// Enum#RAW is not a substitute for <E extends Enum<E>> (86838)
					if (match.isRawType() && substitutedSuperType.isBoundParameterizedType())
						unchecked = true;
				}
	    	}
	    }
	    return unchecked ? TypeConstants.UNCHECKED : TypeConstants.OK;
	}

