	/**
	 * Returns true if the argument type satisfies all bounds of the type parameter
	 */
	public int boundCheck(Substitution substitution, TypeBinding argumentType) {

		if (argumentType == NullBinding || argumentType == this)
			return TypeConstants.OK;
		boolean hasSubstitution = substitution != null;
		if (!(argumentType instanceof ReferenceBinding || argumentType.isArrayType()))
			return TypeConstants.MISMATCH;	
		// special case for re-entrant source types (selection, code assist, etc)...
		// can request additional types during hierarchy walk that are found as source types that also 'need' to connect their hierarchy
		if (this.superclass == null)
			return TypeConstants.OK;

		if (argumentType.isWildcard()) {
			WildcardBinding wildcard = (WildcardBinding) argumentType;
			switch(wildcard.boundKind) {
				case Wildcard.EXTENDS :
					ReferenceBinding superclassBound = (ReferenceBinding)Scope.substitute(substitution, this.superclass());
					TypeBinding wildcardBound = wildcard.bound;
					boolean isArrayBound = wildcardBound.isArrayType();
					if (!wildcardBound.isInterface()) {
						if (isArrayBound) {
							if (!wildcardBound.isCompatibleWith(superclassBound))
								return TypeConstants.MISMATCH;
						} else {
							ReferenceBinding match = ((ReferenceBinding)wildcardBound).findSuperTypeErasingTo((ReferenceBinding)superclassBound.erasure());
							if (match != null) {
								if (!match.isIntersectingWith(superclassBound)) {
									return TypeConstants.MISMATCH;
								}
							} else {
								return TypeConstants.MISMATCH;
							}
						}
					}
					ReferenceBinding[] superInterfaceBounds = Scope.substitute(substitution, this.superInterfaces());
					int length = superInterfaceBounds.length;
					boolean mustImplement = isArrayBound || ((ReferenceBinding)wildcardBound).isFinal();
					for (int i = 0; i < length; i++) {
						TypeBinding superInterfaceBound = superInterfaceBounds[i];
						if (isArrayBound) {
							if (!wildcardBound.isCompatibleWith(superInterfaceBound))
									return TypeConstants.MISMATCH;
						} else {
							ReferenceBinding match = ((ReferenceBinding)wildcardBound).findSuperTypeErasingTo((ReferenceBinding)superInterfaceBound.erasure());
							if (match != null) {
								if (!match.isIntersectingWith(superInterfaceBound)) {
									return TypeConstants.MISMATCH;
								}
							} else if (mustImplement) {
									return TypeConstants.MISMATCH; // cannot be extended further to satisfy missing bounds
							}
						}

					}
					break;
					
				case Wildcard.SUPER :
					return boundCheck(substitution, wildcard.bound);
					
				case Wildcard.UNBOUND :
					break;
			}
			return TypeConstants.OK;
		}
		boolean unchecked = false;
		if (this.superclass.id != T_JavaLangObject) {
			TypeBinding substitutedSuperType = hasSubstitution ? Scope.substitute(substitution, this.superclass) : this.superclass;
			if (!argumentType.isCompatibleWith(substitutedSuperType)) {
			    return TypeConstants.MISMATCH;
			}
			if (argumentType instanceof ReferenceBinding) {
				ReferenceBinding referenceArgument = (ReferenceBinding) argumentType;
				TypeBinding match = referenceArgument.findSuperTypeErasingTo((ReferenceBinding)substitutedSuperType.erasure());
				if (match != null){
					// Enum#RAW is not a substitute for <E extends Enum<E>> (86838)
					if (match.isRawType() && (substitutedSuperType.isGenericType()||substitutedSuperType.isBoundParameterizedType()))
						unchecked = true;
				}
			} 
		}
	    for (int i = 0, length = this.superInterfaces.length; i < length; i++) {
			TypeBinding substitutedSuperType = hasSubstitution ? Scope.substitute(substitution, this.superInterfaces[i]) : this.superInterfaces[i];
			if (!argumentType.isCompatibleWith(substitutedSuperType)) {
			    return TypeConstants.MISMATCH;
			}
			if (argumentType instanceof ReferenceBinding) {
				ReferenceBinding referenceArgument = (ReferenceBinding) argumentType;
				TypeBinding match = referenceArgument.findSuperTypeErasingTo((ReferenceBinding)substitutedSuperType.erasure());
				if (match != null){
					// Enum#RAW is not a substitute for <E extends Enum<E>> (86838)
					if (match.isRawType() && (substitutedSuperType.isGenericType()||substitutedSuperType.isBoundParameterizedType()))
						unchecked = true;
				}
			}
	    }
	    return unchecked ? TypeConstants.UNCHECKED : TypeConstants.OK;
	}

