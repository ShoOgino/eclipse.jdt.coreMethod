	/**
	 * INTERNAL USE-ONLY
	 * That method generates the attributes of a code attribute.
	 * They could be:
	 * - an exception attribute for each try/catch found inside the method
	 * - a deprecated attribute
	 * - a synthetic attribute for synthetic access methods
	 *
	 * It returns the number of attributes created for the code attribute.
	 *
	 * @param methodBinding org.eclipse.jdt.internal.compiler.lookup.MethodBinding
	 * @return <CODE>int</CODE>
	 */
	public int generateMethodInfoAttribute(MethodBinding methodBinding) {
		// leave two bytes for the attribute_number
		this.contentsOffset += 2;
		if (this.contentsOffset + 2 >= this.contents.length) {
			resizeContents(2);
		}
		// now we can handle all the attribute for that method info:
		// it could be:
		// - a CodeAttribute
		// - a ExceptionAttribute
		// - a DeprecatedAttribute
		// - a SyntheticAttribute

		// Exception attribute
		ReferenceBinding[] thrownsExceptions;
		int attributeNumber = 0;
		if ((thrownsExceptions = methodBinding.thrownExceptions) != Binding.NO_EXCEPTIONS) {
			// The method has a throw clause. So we need to add an exception attribute
			// check that there is enough space to write all the bytes for the exception attribute
			int length = thrownsExceptions.length;
			int exSize = 8 + length * 2;
			if (exSize + this.contentsOffset >= this.contents.length) {
				resizeContents(exSize);
			}
			int exceptionNameIndex =
				this.constantPool.literalIndex(AttributeNamesConstants.ExceptionsName);
			this.contents[this.contentsOffset++] = (byte) (exceptionNameIndex >> 8);
			this.contents[this.contentsOffset++] = (byte) exceptionNameIndex;
			// The attribute length = length * 2 + 2 in case of a exception attribute
			int attributeLength = length * 2 + 2;
			this.contents[this.contentsOffset++] = (byte) (attributeLength >> 24);
			this.contents[this.contentsOffset++] = (byte) (attributeLength >> 16);
			this.contents[this.contentsOffset++] = (byte) (attributeLength >> 8);
			this.contents[this.contentsOffset++] = (byte) attributeLength;
			this.contents[this.contentsOffset++] = (byte) (length >> 8);
			this.contents[this.contentsOffset++] = (byte) length;
			for (int i = 0; i < length; i++) {
				int exceptionIndex = this.constantPool.literalIndexForType(thrownsExceptions[i]);
				this.contents[this.contentsOffset++] = (byte) (exceptionIndex >> 8);
				this.contents[this.contentsOffset++] = (byte) exceptionIndex;
			}
			attributeNumber++;
		}
		if (methodBinding.isDeprecated()) {
			// Deprecated attribute
			// Check that there is enough space to write the deprecated attribute
			if (this.contentsOffset + 6 >= this.contents.length) {
				resizeContents(6);
			}
			int deprecatedAttributeNameIndex =
				this.constantPool.literalIndex(AttributeNamesConstants.DeprecatedName);
			this.contents[this.contentsOffset++] = (byte) (deprecatedAttributeNameIndex >> 8);
			this.contents[this.contentsOffset++] = (byte) deprecatedAttributeNameIndex;
			// the length of a deprecated attribute is equals to 0
			this.contents[this.contentsOffset++] = 0;
			this.contents[this.contentsOffset++] = 0;
			this.contents[this.contentsOffset++] = 0;
			this.contents[this.contentsOffset++] = 0;

			attributeNumber++;
		}
		if (this.targetJDK < ClassFileConstants.JDK1_5) {
			if (methodBinding.isSynthetic()) {
				// Synthetic attribute
				// Check that there is enough space to write the deprecated attribute
				if (this.contentsOffset + 6 >= this.contents.length) {
					resizeContents(6);
				}
				int syntheticAttributeNameIndex =
					this.constantPool.literalIndex(AttributeNamesConstants.SyntheticName);
				this.contents[this.contentsOffset++] = (byte) (syntheticAttributeNameIndex >> 8);
				this.contents[this.contentsOffset++] = (byte) syntheticAttributeNameIndex;
				// the length of a synthetic attribute is equals to 0
				this.contents[this.contentsOffset++] = 0;
				this.contents[this.contentsOffset++] = 0;
				this.contents[this.contentsOffset++] = 0;
				this.contents[this.contentsOffset++] = 0;

				attributeNumber++;
			}
			if (methodBinding.isVarargs()) {
				/*
				 * handle of the target jsr14 for varargs in the source
				 * Varargs attribute
				 * Check that there is enough space to write the deprecated attribute
				 */
				if (this.contentsOffset + 6 >= this.contents.length) {
					resizeContents(6);
				}
				int varargsAttributeNameIndex =
					this.constantPool.literalIndex(AttributeNamesConstants.VarargsName);
				this.contents[this.contentsOffset++] = (byte) (varargsAttributeNameIndex >> 8);
				this.contents[this.contentsOffset++] = (byte) varargsAttributeNameIndex;
				// the length of a varargs attribute is equals to 0
				this.contents[this.contentsOffset++] = 0;
				this.contents[this.contentsOffset++] = 0;
				this.contents[this.contentsOffset++] = 0;
				this.contents[this.contentsOffset++] = 0;

				attributeNumber++;
			}
		}
		// add signature attribute
		char[] genericSignature = methodBinding.genericSignature();
		if (genericSignature != null) {
			// check that there is enough space to write all the bytes for the field info corresponding
			// to the @fieldBinding
			if (this.contentsOffset + 8 >= this.contents.length) {
				resizeContents(8);
			}
			int signatureAttributeNameIndex =
				this.constantPool.literalIndex(AttributeNamesConstants.SignatureName);
			this.contents[this.contentsOffset++] = (byte) (signatureAttributeNameIndex >> 8);
			this.contents[this.contentsOffset++] = (byte) signatureAttributeNameIndex;
			// the length of a signature attribute is equals to 2
			this.contents[this.contentsOffset++] = 0;
			this.contents[this.contentsOffset++] = 0;
			this.contents[this.contentsOffset++] = 0;
			this.contents[this.contentsOffset++] = 2;
			int signatureIndex =
				this.constantPool.literalIndex(genericSignature);
			this.contents[this.contentsOffset++] = (byte) (signatureIndex >> 8);
			this.contents[this.contentsOffset++] = (byte) signatureIndex;
			attributeNumber++;
		}
		if (this.targetJDK >= ClassFileConstants.JDK1_4) {
			AbstractMethodDeclaration methodDeclaration = methodBinding.sourceMethod();
			if (methodDeclaration != null) {
				Annotation[] annotations = methodDeclaration.annotations;
				if (annotations != null) {
					attributeNumber += generateRuntimeAnnotations(annotations);
				}
				if ((methodBinding.tagBits & TagBits.HasParameterAnnotations) != 0) {
					Argument[] arguments = methodDeclaration.arguments;
					if (arguments != null) {
						attributeNumber += generateRuntimeAnnotationsForParameters(arguments);
					}
				}
			}
		}
		if ((methodBinding.tagBits & TagBits.HasMissingType) != 0) {
			this.missingTypes = methodBinding.collectMissingTypes(this.missingTypes);
		}
		return attributeNumber;
	}

