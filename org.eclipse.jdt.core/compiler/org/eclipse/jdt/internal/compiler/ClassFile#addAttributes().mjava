	/**
	 * INTERNAL USE-ONLY
	 * This methods generate all the attributes for the receiver.
	 * For a class they could be:
	 * - source file attribute
	 * - inner classes attribute
	 * - deprecated attribute
	 */
	public void addAttributes() {
		// update the method count
		this.contents[this.methodCountOffset++] = (byte) (this.methodCount >> 8);
		this.contents[this.methodCountOffset] = (byte) this.methodCount;

		int attributesNumber = 0;
		// leave two bytes for the number of attributes and store the current offset
		int attributeOffset = this.contentsOffset;
		this.contentsOffset += 2;

		// source attribute
		if ((this.produceAttributes & ClassFileConstants.ATTR_SOURCE) != 0) {
			String fullFileName =
				new String(this.referenceBinding.scope.referenceCompilationUnit().getFileName());
			fullFileName = fullFileName.replace('\\', '/');
			int lastIndex = fullFileName.lastIndexOf('/');
			if (lastIndex != -1) {
				fullFileName = fullFileName.substring(lastIndex + 1, fullFileName.length());
			}
			// check that there is enough space to write all the bytes for the field info corresponding
			// to the @fieldBinding
			if (this.contentsOffset + 8 >= this.contents.length) {
				resizeContents(8);
			}
			int sourceAttributeNameIndex =
				this.constantPool.literalIndex(AttributeNamesConstants.SourceName);
			this.contents[this.contentsOffset++] = (byte) (sourceAttributeNameIndex >> 8);
			this.contents[this.contentsOffset++] = (byte) sourceAttributeNameIndex;
			// The length of a source file attribute is 2. This is a fixed-length
			// attribute
			this.contents[this.contentsOffset++] = 0;
			this.contents[this.contentsOffset++] = 0;
			this.contents[this.contentsOffset++] = 0;
			this.contents[this.contentsOffset++] = 2;
			// write the source file name
			int fileNameIndex = this.constantPool.literalIndex(fullFileName.toCharArray());
			this.contents[this.contentsOffset++] = (byte) (fileNameIndex >> 8);
			this.contents[this.contentsOffset++] = (byte) fileNameIndex;
			attributesNumber++;
		}
		// Deprecated attribute
		if (this.referenceBinding.isDeprecated()) {
			// check that there is enough space to write all the bytes for the field info corresponding
			// to the @fieldBinding
			if (this.contentsOffset + 6 >= this.contents.length) {
				resizeContents(6);
			}
			int deprecatedAttributeNameIndex =
				this.constantPool.literalIndex(AttributeNamesConstants.DeprecatedName);
			this.contents[this.contentsOffset++] = (byte) (deprecatedAttributeNameIndex >> 8);
			this.contents[this.contentsOffset++] = (byte) deprecatedAttributeNameIndex;
			// the length of a deprecated attribute is equals to 0
			this.contents[this.contentsOffset++] = 0;
			this.contents[this.contentsOffset++] = 0;
			this.contents[this.contentsOffset++] = 0;
			this.contents[this.contentsOffset++] = 0;
			attributesNumber++;
		}
		// add signature attribute
		char[] genericSignature = this.referenceBinding.genericSignature();
		if (genericSignature != null) {
			// check that there is enough space to write all the bytes for the field info corresponding
			// to the @fieldBinding
			if (this.contentsOffset + 8 >= this.contents.length) {
				resizeContents(8);
			}
			int signatureAttributeNameIndex =
				this.constantPool.literalIndex(AttributeNamesConstants.SignatureName);
			this.contents[this.contentsOffset++] = (byte) (signatureAttributeNameIndex >> 8);
			this.contents[this.contentsOffset++] = (byte) signatureAttributeNameIndex;
			// the length of a signature attribute is equals to 2
			this.contents[this.contentsOffset++] = 0;
			this.contents[this.contentsOffset++] = 0;
			this.contents[this.contentsOffset++] = 0;
			this.contents[this.contentsOffset++] = 2;
			int signatureIndex =
				this.constantPool.literalIndex(genericSignature);
			this.contents[this.contentsOffset++] = (byte) (signatureIndex >> 8);
			this.contents[this.contentsOffset++] = (byte) signatureIndex;
			attributesNumber++;
		}
		if (this.targetJDK >= ClassFileConstants.JDK1_5
				&& this.referenceBinding.isNestedType()
				&& !this.referenceBinding.isMemberType()) {
			// add enclosing method attribute (1.5 mode only)
			if (this.contentsOffset + 10 >= this.contents.length) {
				resizeContents(10);
			}
			int enclosingMethodAttributeNameIndex =
				this.constantPool.literalIndex(AttributeNamesConstants.EnclosingMethodName);
			this.contents[this.contentsOffset++] = (byte) (enclosingMethodAttributeNameIndex >> 8);
			this.contents[this.contentsOffset++] = (byte) enclosingMethodAttributeNameIndex;
			// the length of a signature attribute is equals to 2
			this.contents[this.contentsOffset++] = 0;
			this.contents[this.contentsOffset++] = 0;
			this.contents[this.contentsOffset++] = 0;
			this.contents[this.contentsOffset++] = 4;

			int enclosingTypeIndex = this.constantPool.literalIndexForType(this.referenceBinding.enclosingType().constantPoolName());
			this.contents[this.contentsOffset++] = (byte) (enclosingTypeIndex >> 8);
			this.contents[this.contentsOffset++] = (byte) enclosingTypeIndex;
			byte methodIndexByte1 = 0;
			byte methodIndexByte2 = 0;
			if (this.referenceBinding instanceof LocalTypeBinding) {
				MethodBinding methodBinding = ((LocalTypeBinding) this.referenceBinding).enclosingMethod;
				if (methodBinding != null) {
					int enclosingMethodIndex = this.constantPool.literalIndexForNameAndType(methodBinding.selector, methodBinding.signature(this));
					methodIndexByte1 = (byte) (enclosingMethodIndex >> 8);
					methodIndexByte2 = (byte) enclosingMethodIndex;
				}
			}
			this.contents[this.contentsOffset++] = methodIndexByte1;
			this.contents[this.contentsOffset++] = methodIndexByte2;
			attributesNumber++;
		}
		if (this.targetJDK >= ClassFileConstants.JDK1_5) {
			TypeDeclaration typeDeclaration = this.referenceBinding.scope.referenceContext;
			if (typeDeclaration != null) {
				final Annotation[] annotations = typeDeclaration.annotations;
				if (annotations != null) {
					attributesNumber += generateRuntimeAnnotations(annotations);
				}
			}
		}

		if (this.referenceBinding.isHierarchyInconsistent()) {
			ReferenceBinding superclass = this.referenceBinding.superclass;
			if (superclass != null) {
				this.missingTypes = superclass.collectMissingTypes(this.missingTypes);
			}
			ReferenceBinding[] superInterfaces = this.referenceBinding.superInterfaces();
			for (int i = 0, max = superInterfaces.length; i < max; i++) {
				this.missingTypes = superInterfaces[i].collectMissingTypes(this.missingTypes);
			}
			// add an attribute for inconsistent hierarchy
			if (this.contentsOffset + 6 >= this.contents.length) {
				resizeContents(6);
			}
			int inconsistentHierarchyNameIndex =
				this.constantPool.literalIndex(AttributeNamesConstants.InconsistentHierarchy);
			this.contents[this.contentsOffset++] = (byte) (inconsistentHierarchyNameIndex >> 8);
			this.contents[this.contentsOffset++] = (byte) inconsistentHierarchyNameIndex;
			// the length of an inconsistent hierarchy attribute is equals to 0
			this.contents[this.contentsOffset++] = 0;
			this.contents[this.contentsOffset++] = 0;
			this.contents[this.contentsOffset++] = 0;
			this.contents[this.contentsOffset++] = 0;
			attributesNumber++;
		}
		// Inner class attribute
		int numberOfInnerClasses = this.innerClassesBindings == null ? 0 : this.innerClassesBindings.size();
		if (numberOfInnerClasses != 0) {
			ReferenceBinding[] innerClasses = new ReferenceBinding[numberOfInnerClasses];
			this.innerClassesBindings.toArray(innerClasses);
			Arrays.sort(innerClasses, new Comparator() {
				public int compare(Object o1, Object o2) {
					TypeBinding binding1 = (TypeBinding) o1;
					TypeBinding binding2 = (TypeBinding) o2;
					return CharOperation.compareTo(binding1.constantPoolName(), binding2.constantPoolName());
				}
			});
			// Generate the inner class attribute
			int exSize = 8 * numberOfInnerClasses + 8;
			if (exSize + this.contentsOffset >= this.contents.length) {
				resizeContents(exSize);
			}
			// Now we now the size of the attribute and the number of entries
			// attribute name
			int attributeNameIndex =
				this.constantPool.literalIndex(AttributeNamesConstants.InnerClassName);
			this.contents[this.contentsOffset++] = (byte) (attributeNameIndex >> 8);
			this.contents[this.contentsOffset++] = (byte) attributeNameIndex;
			int value = (numberOfInnerClasses << 3) + 2;
			this.contents[this.contentsOffset++] = (byte) (value >> 24);
			this.contents[this.contentsOffset++] = (byte) (value >> 16);
			this.contents[this.contentsOffset++] = (byte) (value >> 8);
			this.contents[this.contentsOffset++] = (byte) value;
			this.contents[this.contentsOffset++] = (byte) (numberOfInnerClasses >> 8);
			this.contents[this.contentsOffset++] = (byte) numberOfInnerClasses;
			for (int i = 0; i < numberOfInnerClasses; i++) {
				ReferenceBinding innerClass = innerClasses[i];
				int accessFlags = innerClass.getAccessFlags();
				int innerClassIndex = this.constantPool.literalIndexForType(innerClass.constantPoolName());
				// inner class index
				this.contents[this.contentsOffset++] = (byte) (innerClassIndex >> 8);
				this.contents[this.contentsOffset++] = (byte) innerClassIndex;
				// outer class index: anonymous and local have no outer class index
				if (innerClass.isMemberType()) {
					// member or member of local
					int outerClassIndex = this.constantPool.literalIndexForType(innerClass.enclosingType().constantPoolName());
					this.contents[this.contentsOffset++] = (byte) (outerClassIndex >> 8);
					this.contents[this.contentsOffset++] = (byte) outerClassIndex;
				} else {
					// equals to 0 if the innerClass is not a member type
					this.contents[this.contentsOffset++] = 0;
					this.contents[this.contentsOffset++] = 0;
				}
				// name index
				if (!innerClass.isAnonymousType()) {
					int nameIndex = this.constantPool.literalIndex(innerClass.sourceName());
					this.contents[this.contentsOffset++] = (byte) (nameIndex >> 8);
					this.contents[this.contentsOffset++] = (byte) nameIndex;
				} else {
					// equals to 0 if the innerClass is an anonymous type
					this.contents[this.contentsOffset++] = 0;
					this.contents[this.contentsOffset++] = 0;
				}
				// access flag
				if (innerClass.isAnonymousType()) {
					accessFlags &= ~ClassFileConstants.AccFinal;
				} else if (innerClass.isMemberType() && innerClass.isInterface()) {
					accessFlags |= ClassFileConstants.AccStatic; // implicitely static
				}
				this.contents[this.contentsOffset++] = (byte) (accessFlags >> 8);
				this.contents[this.contentsOffset++] = (byte) accessFlags;
			}
			attributesNumber++;
		}
		if (this.missingTypes != null) {
			generateMissingTypesAttribute();
			attributesNumber++;
		}
		// update the number of attributes
		if (attributeOffset + 2 >= this.contents.length) {
			resizeContents(2);
		}
		this.contents[attributeOffset++] = (byte) (attributesNumber >> 8);
		this.contents[attributeOffset] = (byte) attributesNumber;

		// resynchronize all offsets of the classfile
		this.header = this.constantPool.poolContent;
		this.headerOffset = this.constantPool.currentOffset;
		int constantPoolCount = this.constantPool.currentIndex;
		this.header[this.constantPoolOffset++] = (byte) (constantPoolCount >> 8);
		this.header[this.constantPoolOffset] = (byte) constantPoolCount;
	}

