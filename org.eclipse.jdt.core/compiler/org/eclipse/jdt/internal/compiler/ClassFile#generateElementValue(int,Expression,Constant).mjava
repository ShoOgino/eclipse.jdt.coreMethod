	/**
	 * @param attributeOffset
	 */
	private void generateElementValue(int attributeOffset, Expression defaultValue, Constant constant) {
		if (contentsOffset + 3 >= this.contents.length) {
			resizeContents(3);
		}
		switch (constant.typeID()) {
			case T_boolean :
				contents[contentsOffset++] = (byte) 'Z';
				int booleanValueIndex =
					constantPool.literalIndex(constant.booleanValue() ? 1 : 0);
				contents[contentsOffset++] = (byte) (booleanValueIndex >> 8);
				contents[contentsOffset++] = (byte) booleanValueIndex;
				break;
			case T_byte :
				contents[contentsOffset++] = (byte) 'B';
				int integerValueIndex =
					constantPool.literalIndex(constant.intValue());
				contents[contentsOffset++] = (byte) (integerValueIndex >> 8);
				contents[contentsOffset++] = (byte) integerValueIndex;
				break;
			case T_char :
				contents[contentsOffset++] = (byte) 'C';
				integerValueIndex =
					constantPool.literalIndex(constant.intValue());
				contents[contentsOffset++] = (byte) (integerValueIndex >> 8);
				contents[contentsOffset++] = (byte) integerValueIndex;
				break;
			case T_int :
				contents[contentsOffset++] = (byte) 'I';
				integerValueIndex =
					constantPool.literalIndex(constant.intValue());
				contents[contentsOffset++] = (byte) (integerValueIndex >> 8);
				contents[contentsOffset++] = (byte) integerValueIndex;
				break;
			case T_short :
				contents[contentsOffset++] = (byte) 'S';
				integerValueIndex =
					constantPool.literalIndex(constant.intValue());
				contents[contentsOffset++] = (byte) (integerValueIndex >> 8);
				contents[contentsOffset++] = (byte) integerValueIndex;
				break;
			case T_float :
				contents[contentsOffset++] = (byte) 'F';
				int floatValueIndex =
					constantPool.literalIndex(constant.floatValue());
				contents[contentsOffset++] = (byte) (floatValueIndex >> 8);
				contents[contentsOffset++] = (byte) floatValueIndex;
				break;
			case T_double :
				contents[contentsOffset++] = (byte) 'D';
				int doubleValueIndex =
					constantPool.literalIndex(constant.doubleValue());
				contents[contentsOffset++] = (byte) (doubleValueIndex >> 8);
				contents[contentsOffset++] = (byte) doubleValueIndex;
				break;
			case T_long :
				contents[contentsOffset++] = (byte) 'J';
				int longValueIndex =
					constantPool.literalIndex(constant.longValue());
				contents[contentsOffset++] = (byte) (longValueIndex >> 8);
				contents[contentsOffset++] = (byte) longValueIndex;
				break;
			case T_String :
				contents[contentsOffset++] = (byte) 's';
				int stringValueIndex =
					constantPool.literalIndex(
						((StringConstant) constant).stringValue());
				if (stringValueIndex == -1) {
					if (!creatingProblemType) {
						// report an error and abort: will lead to a problem type classfile creation
						TypeDeclaration typeDeclaration = referenceBinding.scope.referenceContext;
						typeDeclaration.scope.problemReporter().stringConstantIsExceedingUtf8Limit(defaultValue);
					} else {
						// already inside a problem type creation : no attribute
						contentsOffset = attributeOffset;
					}
				} else {
					contents[contentsOffset++] = (byte) (stringValueIndex >> 8);
					contents[contentsOffset++] = (byte) stringValueIndex;
				}
		}
	}

