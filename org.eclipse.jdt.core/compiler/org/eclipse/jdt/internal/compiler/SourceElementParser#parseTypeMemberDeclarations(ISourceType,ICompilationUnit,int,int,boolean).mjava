public void parseTypeMemberDeclarations(
	ISourceType sourceType, 
	ICompilationUnit sourceUnit, 
	int start, 
	int end, 
	boolean needReferenceInfo) {

	boolean old = diet;
	try {
		diet = !needReferenceInfo;
		reportReferenceInfo = needReferenceInfo;
		CompilationResult compilationUnitResult = 
			new CompilationResult(sourceUnit, 0, 0); 

		CompilationUnitDeclaration unit = 
			SourceTypeConverter.buildCompilationUnit(
				new ISourceType[]{sourceType}, 
				false,
				false, 
				problemReporter(), 
				compilationUnitResult); 
		if ((unit == null) || (unit.types == null) || (unit.types.length != 1))
			return;

		this.sourceType = sourceType;

		try {
			/* automaton initialization */
			initialize();
			goForClassBodyDeclarations();
			/* scanner initialization */
			scanner.setSourceBuffer(sourceUnit.getContents());
			int sourceLength = scanner.source.length;
			scanner.resetTo(start, end);
			/* unit creation */
			referenceContext = compilationUnit = unit;

			/* initialize the astStacl */
			// the compilationUnitDeclaration should contain exactly one type
			pushOnAstStack(unit.types[0]);
			/* run automaton */
			parse();
		} finally {
			unit = compilationUnit;
			compilationUnit = null; // reset parser
		}
	} catch (AbortCompilation e) {
	} finally {
		if (scanner.recordLineSeparator) {
			requestor.acceptLineSeparatorPositions(scanner.lineEnds());
		}
		diet = old;
	}
}

