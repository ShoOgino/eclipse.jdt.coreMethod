/**
 * char[] pattern matching, accepting wild-cards '*'.
 *
 * When not case sensitive, the pattern is assumed to already be lowercased, the
 * name will be lowercased character per character as comparing.
 */
public static final boolean match(char[] pattern, char[] name, boolean isCaseSensitive) {

	if (name == null) return false; // null name cannot match
	if (pattern == null) return true; // null pattern is equivalent to '*'
	int iPattern = 0, patternLength = pattern.length;
	int iName = 0, nameLength = name.length;

	/* check first segment */
	char patternChar = 0;
	while ((iPattern < patternLength) && (patternChar = pattern[iPattern]) != '*'){
		if (iName == nameLength) return false;
		if (patternChar != (isCaseSensitive 
								? name[iName] 
								: Character.toLowerCase(name[iName]))){
			return false;
		}
		iName++;
		iPattern++;
	}
	/* check sequence of star+segment */
	int segmentStart;
	if (patternChar == '*'){
		segmentStart = ++iPattern; // skip star
	} else {
		segmentStart = 0; // force iName check
	}
	int prefixStart = iName;
	checkSegment: while (iName < nameLength && iPattern < patternLength){
		/* segment is ending */
		if ((patternChar = pattern[iPattern]) == '*'){
			segmentStart = ++iPattern; // skip start
			prefixStart = iName;
			continue checkSegment;
		}
		/* chech current name character */
		if ((isCaseSensitive 
				? name[iName] 
				: Character.toLowerCase(name[iName]))!= patternChar){
			iPattern = segmentStart; // mismatch - restart current segment
			iName = ++prefixStart;
			continue checkSegment;
		}
		iName++;
		iPattern++;
	}

	return (segmentStart == patternLength)
			|| (iName == nameLength && iPattern == patternLength)	
			|| (iPattern == patternLength - 1 && pattern[iPattern] == '*'); 
}

