/**
 * char[] pattern matching, accepting wild-cards '*' and '?'. Can match only subset of name/pattern.
 * end positions are non-inclusive.
 * When not case sensitive, the pattern is assumed to already be lowercased, the
 * name will be lowercased character per character as comparing.
 */
public static final boolean match(char[] pattern, int patternStart, int patternEnd, char[] name, int nameStart, int nameEnd, boolean isCaseSensitive) {

	if (name == null) return false; // null name cannot match
	if (pattern == null) return true; // null pattern is equivalent to '*'
	int iPattern = patternStart;
	int iName = nameStart;

	/* check first segment */
	char patternChar = 0;
	while ((iPattern < patternEnd) && (patternChar = pattern[iPattern]) != '*'){
		if (iName == nameEnd) return false;
		if (patternChar != (isCaseSensitive 
								? name[iName] 
								: Character.toLowerCase(name[iName]))
				&& patternChar != '?'){
			return false;
		}
		iName++;
		iPattern++;
	}
	/* check sequence of star+segment */
	int segmentStart;
	if (patternChar == '*'){
		segmentStart = ++iPattern; // skip star
	} else {
		segmentStart = 0; // force iName check
	}
	int prefixStart = iName;
	checkSegment: while (iName < nameEnd && iPattern < patternEnd){
		/* segment is ending */
		if ((patternChar = pattern[iPattern]) == '*'){
			segmentStart = ++iPattern; // skip start
			prefixStart = iName;
			continue checkSegment;
		}
		/* chech current name character */
		if ((isCaseSensitive 
				? name[iName] 
				: Character.toLowerCase(name[iName]))!= patternChar
					&& patternChar != '?'){
			iPattern = segmentStart; // mismatch - restart current segment
			iName = ++prefixStart;
			continue checkSegment;
		}
		iName++;
		iPattern++;
	}

	return (segmentStart == patternEnd)
			|| (iName == nameEnd && iPattern == patternEnd)	
			|| (iPattern == patternEnd - 1 && pattern[iPattern] == '*'); 
}

