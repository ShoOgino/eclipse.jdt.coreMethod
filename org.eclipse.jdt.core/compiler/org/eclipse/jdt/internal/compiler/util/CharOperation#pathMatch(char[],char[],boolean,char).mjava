/**
 * Path char[] pattern matching, accepting wild-cards '**', '*' and '?'.
 * Path pattern matching is enhancing regular pattern matching in supporting extra rule where '**' represent
 * any folder combination.
 * Special rules: 
 * - foo\  is equivalent to foo\**   TODO: implement pathMatch special rules
 * - *.java is equivalent to **\*.java
 * When not case sensitive, the pattern is assumed to already be lowercased, the
 * name will be lowercased character per character as comparing.
 */
public static final boolean pathMatch(char[] pattern, char[] path, boolean isCaseSensitive, char pathSeparator) {

	if (path == null) return false; // null name cannot match
	if (pattern == null) return true; // null pattern is equivalent to '*'

	int iPattern = 0, patternLength = pattern.length;
	int patternSegmentEnd = CharOperation.indexOf(pathSeparator, pattern);
	if (patternSegmentEnd < 0) patternSegmentEnd = patternLength;

	int iPath = 0, pathLength = path.length;
	int pathSegmentEnd = CharOperation.indexOf(pathSeparator, path);
	if (pathSegmentEnd < 0) pathSegmentEnd = pathLength;

	// special case: pattern foo is equivalent to **\foo (not absolute)
	boolean freePrefixDoubleStar = pattern[0] != pathSeparator;
	
	// special case: pattern foo\ is equivalent to foo\**
	boolean freeSuffixDoubleStar = pattern[patternLength-1] == pathSeparator;
		
	// first segments
	while (iPattern < patternLength
				&& !freePrefixDoubleStar
				&& !(patternSegmentEnd == iPattern+2
					&& pattern[iPattern] == '*' 
					&& pattern[iPattern+1] == '*')) {
					
		if (iPath >= pathLength) return false;
		if (!CharOperation.match(pattern, iPattern, patternSegmentEnd, path, iPath, pathSegmentEnd, isCaseSensitive)) {
			return false;
		}

		// jump to next segment		
		patternSegmentEnd = CharOperation.indexOf(pathSeparator, pattern, iPattern = patternSegmentEnd+1); // skip separator
		if (patternSegmentEnd < 0) patternSegmentEnd = patternLength;
		
		pathSegmentEnd = CharOperation.indexOf(pathSeparator, path, iPath = pathSegmentEnd+1); // skip separator
		if (pathSegmentEnd < 0) pathSegmentEnd = pathLength;
	}

	/* check sequence of doubleStar+segment */
	int segmentStart;
	if (patternSegmentEnd == iPattern+2
				&& pattern[iPattern] == '*' 
				&& pattern[iPattern+1] == '*'){
		patternSegmentEnd = CharOperation.indexOf(pathSeparator, pattern, iPattern = patternSegmentEnd+1); // skip separator
		if (patternSegmentEnd < 0) patternSegmentEnd = patternLength;
		segmentStart = iPattern;
	} else {
		segmentStart = 0; // force iPath check
	}
	int prefixStart = iPath;
	checkSegment: while (iPath < pathLength && iPattern < patternLength){
		/* segment is ending */
		if (patternSegmentEnd == iPattern+2
					&& pattern[iPattern] == '*' 
					&& pattern[iPattern+1] == '*') {
			patternSegmentEnd = CharOperation.indexOf(pathSeparator, pattern, iPattern = patternSegmentEnd+1); // skip separator
			if (patternSegmentEnd < 0) patternSegmentEnd = patternLength;
			segmentStart = iPattern;
			prefixStart = iPath;
			continue checkSegment;
		}
		/* chech current path segment */
		if (!CharOperation.match(pattern, iPattern, patternSegmentEnd, path, iPath, pathSegmentEnd, isCaseSensitive)) {
			// mismatch - restart current segment
			patternSegmentEnd = CharOperation.indexOf(pathSeparator, pattern, iPattern = segmentStart);
			if (patternSegmentEnd < 0) patternSegmentEnd = patternLength;

			prefixStart = CharOperation.indexOf(pathSeparator, path, prefixStart+1); // skip separator
			if (prefixStart < 0) {
				prefixStart = pathLength;
			} else {
				prefixStart++;
			}
			pathSegmentEnd = CharOperation.indexOf(pathSeparator, path, iPath = prefixStart);
			if (pathSegmentEnd < 0) pathSegmentEnd = pathLength;
			continue checkSegment;
		}
		// jump to next segment		
		patternSegmentEnd = CharOperation.indexOf(pathSeparator, pattern, iPattern = patternSegmentEnd+1); // skip separator
		if (patternSegmentEnd < 0) patternSegmentEnd = patternLength;
		
		pathSegmentEnd = CharOperation.indexOf(pathSeparator, path, iPath = pathSegmentEnd+1); // skip separator
		if (pathSegmentEnd < 0) pathSegmentEnd = pathLength;
	}

	return (segmentStart >= patternSegmentEnd)
				|| (iPath >= pathLength && iPattern >= patternLength)	
				|| (iPattern == patternLength - 2 && pattern[iPattern] == '*' && pattern[iPattern+1] == '*')
				|| (iPattern == patternLength &&  freeSuffixDoubleStar); 
}

