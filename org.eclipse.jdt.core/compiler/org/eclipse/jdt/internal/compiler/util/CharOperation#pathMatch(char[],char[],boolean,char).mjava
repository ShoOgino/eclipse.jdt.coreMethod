/**
 * Path char[] pattern matching, accepting wild-cards '**', '*' and '?'.
 * Path pattern matching is enhancing regular pattern matching in supporting extra rule where '**' represent
 * any folder combination.
 * Special rules: 
 * - foo\  is equivalent to foo\**   TODO: implement pathMatch special rules
 * - *.java is equivalent to **\*.java
 * When not case sensitive, the pattern is assumed to already be lowercased, the
 * name will be lowercased character per character as comparing.
 * TODO: should improve to avoid creating subarrays (use offset pattern match).
 */
public static final boolean pathMatch(char[] pattern, char[] path, boolean isCaseSensitive, char pathSeparator) {

	if (path == null) return false; // null name cannot match
	if (pattern == null) return true; // null pattern is equivalent to '*'
	
	char[][] patternSegments = splitOn(pathSeparator, pattern);
	char[][] pathSegments = splitOn(pathSeparator, path);
	char[] patternSegment = null;
	
	int iPatternSegment = 0, patternSegmentLength = patternSegments.length;
	int iPathSegment = 0, pathSegmentLength = pathSegments.length;
	
	final char[] doubleStar = new char[] { '*', '*' };
	for (int i = 0; i < patternSegmentLength; i++) {
		if (patternSegments[i].length == 2 && patternSegments[i][0] == '*' && patternSegments[i][1] == '*') {
			patternSegments[i] = doubleStar;
		}
	}
	
	// first segments
	while (iPatternSegment < patternSegmentLength && (patternSegment = patternSegments[iPatternSegment]) != doubleStar) {
		if (iPathSegment == pathSegmentLength) return false;
		if (!match(patternSegment, pathSegments[iPathSegment], isCaseSensitive)) {
			return false;
		}
		
		iPatternSegment++;
		iPathSegment++;
	}

	/* check sequence of doubleStar+segment */
	int segmentStart;
	if (patternSegment == doubleStar){
		segmentStart = ++iPatternSegment; // skip star
	} else {
		segmentStart = 0; // force iName check
	}
	int prefixStart = iPathSegment;
	checkSegment: while (iPathSegment < pathSegmentLength && iPatternSegment < patternSegmentLength){
		/* segment is ending */
		if ((patternSegment = patternSegments[iPatternSegment]) == doubleStar){
			segmentStart = ++iPatternSegment; // skip start
			prefixStart = iPathSegment;
			continue checkSegment;
		}
		/* chech current path segment */
		if (!match(patternSegment, pathSegments[iPathSegment], isCaseSensitive)) {
			iPatternSegment = segmentStart; // mismatch - restart current segment
			iPathSegment = ++prefixStart;
			continue checkSegment;
		}
		iPathSegment++;
		iPatternSegment++;
	}

	return (segmentStart == patternSegmentLength)
			|| (iPathSegment == pathSegmentLength && iPatternSegment == patternSegmentLength)	
			|| (iPatternSegment == patternSegmentLength - 1 && patternSegments[iPatternSegment] == doubleStar); 
}

