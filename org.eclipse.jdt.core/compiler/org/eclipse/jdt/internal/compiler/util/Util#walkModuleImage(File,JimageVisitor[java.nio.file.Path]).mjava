	/**
	 * Given the path of a modular image file, this method walks the archive content and
	 * notifies the supplied visitor about packages and files visited.
	 * Note: At the moment, there's no way to open any arbitrary image. Currently,
	 * this method uses the JRT file system provider to look inside the JRE.
	 *   
	 * @param image a java.io.File handle to the JRT image.
	 * @param visitor an instance of JimageVisitor to be notified of the entries in the JRT image.
	 * @throws IOException
	 */
	public static void walkModuleImage(File image, final JimageVisitor<java.nio.file.Path> visitor) throws IOException {
		java.nio.file.FileSystem fs = FileSystems.getFileSystem(JRT_URI);
		Iterable<java.nio.file.Path> roots = fs.getRootDirectories();
		for (java.nio.file.Path path : roots) {
			try (DirectoryStream<java.nio.file.Path> stream = Files.newDirectoryStream(path)) {
				for (final java.nio.file.Path subdir: stream) {
					Files.walkFileTree(subdir, new FileVisitor<java.nio.file.Path>() {

						@Override
						public FileVisitResult preVisitDirectory(java.nio.file.Path dir, BasicFileAttributes attrs) throws IOException {
							java.nio.file.Path relative = subdir.relativize(dir);
							// This being a stop-gap solution, let's assume we don't have any types in a single level package
							if (relative.getNameCount() <= 1) return FileVisitResult.CONTINUE;
							cachePackage(relative.toString(), subdir.toString());
							return visitor.visitPackage(relative, attrs);
						}

						@Override
						public FileVisitResult visitFile(java.nio.file.Path file, BasicFileAttributes attrs) throws IOException {
							return visitor.visitFile(subdir.relativize(file), attrs);
						}

						@Override
						public FileVisitResult visitFileFailed(java.nio.file.Path file, IOException exc) throws IOException {
							return FileVisitResult.CONTINUE;
						}

						@Override
						public FileVisitResult postVisitDirectory(java.nio.file.Path dir, IOException exc) throws IOException {
							return FileVisitResult.CONTINUE;
						}
					});
			    }
			} catch (Exception e) {
				throw new IOException(e.getMessage());
			}
		}
	}

