	private void addMissingAbstractProblemMethod(MethodDeclaration methodDeclaration, MethodBinding methodBinding, IProblem problem, CompilationResult compilationResult) {
		// always clear the strictfp/native/abstract bit for a problem method
		methodBinding.modifiers &= ~(AccStrictfp | AccNative | AccAbstract);
		
		generateMethodInfoHeader(methodBinding);
		int methodAttributeOffset = contentsOffset;
		int attributeNumber = generateMethodInfoAttribute(methodBinding);
		
		// Code attribute
		attributeNumber++;
		
		int codeAttributeOffset = contentsOffset;
		generateCodeAttributeHeader();
		StringBuffer buffer = new StringBuffer(25);
		buffer.append("\t"  + problem.getMessage() + "\n" ); //$NON-NLS-1$ //$NON-NLS-2$
		buffer.insert(0, Util.bind("compilation.unresolvedProblem" )); //$NON-NLS-1$
		String problemString = buffer.toString();
		this.problemLine = problem.getSourceLineNumber();
		
		final ProblemReporter problemReporter = methodDeclaration.scope.problemReporter();
		codeStream.init(this);
		codeStream.preserveUnusedLocals = true;
		codeStream.initializeMaxLocals(methodBinding);

		// return codeStream.generateCodeAttributeForProblemMethod(comp.options.runtimeExceptionNameForCompileError, "")
		int[] exceptionHandler =
			codeStream.generateCodeAttributeForProblemMethod(
				problemReporter.options.runtimeExceptionNameForCompileError,
				problemString);
				
		completeCodeAttributeForMissingAbstractProblemMethod(
			methodBinding,
			codeAttributeOffset,
			exceptionHandler,
			compilationResult.lineSeparatorPositions);
			
		completeMethodInfo(methodAttributeOffset, attributeNumber);
	}

