/**
 * Answers true if a sub-pattern matches the subpart of the given name using CamelCase rules, or false otherwise.  
 * char[] CamelCase matching does NOT accept explicit wild-cards '*' and '?' and is inherently case sensitive. 
 * Can match only subset of name/pattern, considering end positions as non-inclusive.
 * The subpattern is defined by the patternStart and patternEnd positions.
 * <br>
 * CamelCase denotes the convention of writing compound names without spaces, and capitalizing every term.
 * This function recognizes both upper and lower CamelCase, depending whether the leading character is capitalized
 * or not. The leading part of an upper CamelCase pattern is assumed to contain a sequence of capitals which are appearing
 * in the matching name; e.g. 'NPE' will match 'NullPointerException', but not 'NewPerfData'. A lower CamelCase pattern
 * uses a lowercase first character. In Java, type names follow the upper CamelCase convention, whereas method or field
 * names follow the lower CamelCase convention.
 * <br>
 * The pattern may contain trailing lowercase characters, which will be match in a case sensitive way. These characters must
 * appear in sequence in the name, after the last matching capital of the pattern. For instance, 'NPExcep' will match
 * 'NullPointerException', but not 'NullPointerExCEPTION'.
 * 
 * For example:
 * <ol>
 * <li><pre>
 *    pattern = { 'N', 'P', 'E' }
 *    patternStart = 1
 *    patternEnd = 3
 *    name = { 'N', 'u','l', 'l', 'P', 'o', 'i', 'n', 't', 'e', 'r', 'E', 'x', 'c', 'e', 'p', 't', 'i', 'o', 'n' }
 *    nameStart = 0
 *    nameEnd = 20
 *    result => true
 * </pre>
 * </li>
 * <li><pre>
 *    pattern = { 'n', p', 'e' }
 *    patternStart = 1
 *    patternEnd = 3
 *    name = { 'N', 'u','l', 'l', 'P', 'o', 'i', 'n', 't', 'e', 'r', 'E', 'x', 'c', 'e', 'p', 't', 'i', 'o', 'n' }
 *    nameStart = 0
 *    nameEnd = 20
 *    result => false
 * </pre>
 * </li>
 * </ol>
 * 
 * @param pattern the given pattern
 * @param patternStart the given pattern start
 * @param patternEnd the given pattern end
 * @param name the given name
 * @param nameStart the given name start
 * @param nameEnd the given name end
 * @return true if a sub-pattern matches the subpart of the given name, false otherwise
 * @since 3.2
 */
public static final boolean camelCaseMatch(char[] pattern, int patternStart, int patternEnd, char[] name, int nameStart, int nameEnd) {
	if (name == null)
		return false; // null name cannot match
	if (pattern == null)
		return true; // null pattern is equivalent to '*'
	int iPattern = patternStart;
	int iName = nameStart;
	if (patternEnd <= 0) {
		patternEnd = pattern.length;
		if (patternEnd == 0) return nameEnd == 0;
	}
	if (nameEnd < 0)
		nameEnd = name.length;
	char patternChar, nameChar;
	checkCamelCase: while (iPattern < patternEnd) {
					
		if ((patternChar = pattern[iPattern]) < ScannerHelper.MAX_OBVIOUS
				? ScannerHelper.ObviousIdentCharNatures[patternChar] == ScannerHelper.C_LOWER_LETTER
				: Character.isLowerCase(patternChar)) {
			if (iPattern == 0 && name[iName] == patternChar) {
				// pattern char == name char (lowercase first char)
				iName++;
				iPattern++;
				continue checkCamelCase;
			}
			// end of uppercase part of pattern
			break checkCamelCase;
		}
		checkName: while (iName < nameEnd) {
			if ((nameChar = name[iName]) != patternChar) {
				if (nameChar < ScannerHelper.MAX_OBVIOUS) {
					switch (ScannerHelper.ObviousIdentCharNatures[nameChar]) {
						case ScannerHelper.C_LOWER_LETTER :
						case ScannerHelper.C_LETTER :
						case ScannerHelper.C_DIGIT :
							// lowercase/digit char is ignored
							iName++;
							continue checkName;
					}
				} else if (Character.isJavaIdentifierPart(nameChar) 
								&& !Character.isUpperCase(nameChar)) {
					// lowercase name char is ignored
					iName++;
					continue checkName;
				}
				// mismatch, either uppercase in name or non case char ('/' etc)--> reject
				return false;
			} else {
				// pattern char == name char (uppercase)
				iName++;
				iPattern++;
				continue checkCamelCase;
			}	
		}
		if (iPattern == patternEnd) return true;
		if (iName == nameEnd) return false;
		continue checkCamelCase;
	}
		
	// check trailing part in case sensitive way
	while (iPattern < patternEnd && iName < nameEnd) {
		if (pattern[iPattern] != name[iName]) {
			return false;
		}
		iPattern++;
		iName++;
	}
	return iPattern == patternEnd;
}	

