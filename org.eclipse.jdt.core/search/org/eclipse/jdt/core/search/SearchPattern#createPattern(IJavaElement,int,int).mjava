	/**
	 * Returns a search pattern based on a given Java element. 
	 * The pattern is used to trigger the appropriate search, and can be parameterized as follows:
	 *
	 * @param element the Java element the search pattern is based on
	 * @param limitTo determines the nature of the expected matches
	 * 	<ul>
	 * 		<li><code>IJavaSearchConstants.DECLARATIONS</code>: will search declarations matching with the corresponding
	 * 			element. In case the element is a method, declarations of matching methods in subtypes will also
	 *  		be found, allowing to find declarations of abstract methods, etc.</li>
	 *
	 *		 <li><code>IJavaSearchConstants.REFERENCES</code>: will search references to the given element.</li>
	 *
	 *		 <li><code>IJavaSearchConstants.ALL_OCCURRENCES</code>: will search for either declarations or references as specified
	 *  		above.</li>
	 *
	 *		 <li><code>IJavaSearchConstants.IMPLEMENTORS</code>: for interface, will find all types which implements a given interface.</li>
	 *	</ul>
	 * @param matchRule Same possible values than those described in method {@link #createPattern(String,int,int,int)} plus another possible
	 * 	new value {@link #R_ERASURE_MATCH} which can be combined with the others. When match rule includes {@link #R_ERASURE_MATCH},
	 * 	the search engine finds all types whose erasures match the given pattern erasure.
	 * 	By default, the search engine only finds exact or compatible matches for generic or parameterized types.
	 * @return a search pattern for a Java element or <code>null</code> if the given element is ill-formed
	 * @since 3.1
	 */
	public static SearchPattern createPattern(IJavaElement element, int limitTo, int matchRule) {
		SearchPattern searchPattern = null;
		int lastDot;
		switch (element.getElementType()) {
			case IJavaElement.FIELD :
				IField field = (IField) element; 
				IType declaringClass = field.getDeclaringType();
				char[] declaringSimpleName = declaringClass.getElementName().toCharArray();
				char[] declaringQualification = declaringClass.getPackageFragment().getElementName().toCharArray();
				char[][] enclosingNames = enclosingTypeNames(declaringClass);
				if (enclosingNames.length > 0)
					declaringQualification = CharOperation.concat(declaringQualification, CharOperation.concatWith(enclosingNames, '.'), '.');
				char[] name = field.getElementName().toCharArray();
				char[] typeSimpleName;
				char[] typeQualification;
				String typeSignature;
				try {
					typeSignature = field.getTypeSignature();
					char[] signature = typeSignature.toCharArray();
					char[] typeErasure = Signature.toCharArray(Signature.getTypeErasure(signature));
					CharOperation.replace(typeErasure, '$', '.');
					if ((lastDot = CharOperation.lastIndexOf('.', typeErasure)) == -1) {
						typeSimpleName = typeErasure;
						typeQualification = null;
					} else {
						typeSimpleName = CharOperation.subarray(typeErasure, lastDot + 1, typeErasure.length);
						typeQualification = CharOperation.subarray(typeErasure, 0, lastDot);
						if (!field.isBinary()) {
							// prefix with a '*' as the full qualification could be bigger (because of an import)
							CharOperation.concat(IIndexConstants.ONE_STAR, typeQualification);
						}
					}
				} catch (JavaModelException e) {
					return null;
				}
				// Create field pattern
				boolean findDeclarations = false;
				boolean readAccess = false;
				boolean writeAccess = false;
				switch (limitTo) {
					case IJavaSearchConstants.DECLARATIONS :
						findDeclarations = true;
						break;
					case IJavaSearchConstants.REFERENCES :
						readAccess = true;
						writeAccess = true;
						break;
					case IJavaSearchConstants.READ_ACCESSES :
						readAccess = true;
						break;
					case IJavaSearchConstants.WRITE_ACCESSES :
						writeAccess = true;
						break;
					case IJavaSearchConstants.ALL_OCCURRENCES :
						findDeclarations = true;
						readAccess = true;
						writeAccess = true;
						break;
				}
				searchPattern = 
					new FieldPattern(
						findDeclarations,
						readAccess,
						writeAccess,
						name, 
						declaringQualification, 
						declaringSimpleName, 
						typeQualification, 
						typeSimpleName,
						typeSignature,
						matchRule);
				break;
			case IJavaElement.IMPORT_DECLARATION :
				String elementName = element.getElementName();
				lastDot = elementName.lastIndexOf('.');
				if (lastDot == -1) return null; // invalid import declaration
				IImportDeclaration importDecl = (IImportDeclaration)element;
				if (importDecl.isOnDemand()) {
					searchPattern = createPackagePattern(elementName.substring(0, lastDot), limitTo, matchRule);
				} else {
					searchPattern = 
						createTypePattern(
							elementName.substring(lastDot+1).toCharArray(),
							elementName.substring(0, lastDot).toCharArray(),
							null,
							null,
							null,
							limitTo,
							matchRule);
				}
				break;
			case IJavaElement.LOCAL_VARIABLE :
				LocalVariable localVar = (LocalVariable) element;
				switch (limitTo) {
					case IJavaSearchConstants.DECLARATIONS :
						searchPattern = 
							new LocalVariablePattern(
								true, // declarations
								false, // no read access
								false, // no write access
								localVar,
								matchRule);
						break;
					case IJavaSearchConstants.REFERENCES :
						searchPattern = 
							new LocalVariablePattern(
								false,
								true, // read access
								true, // write access
								localVar,
								matchRule);
						break;
					case IJavaSearchConstants.READ_ACCESSES :
						searchPattern = 
							new LocalVariablePattern(
								false,
								true, // read access only
								false,
								localVar,
								matchRule);
						break;
					case IJavaSearchConstants.WRITE_ACCESSES :
						searchPattern = 
							new LocalVariablePattern(
								false,
								false,
								true, // write access only
								localVar,
								matchRule);
						break;
					case IJavaSearchConstants.ALL_OCCURRENCES :
						searchPattern =
							new LocalVariablePattern(
								true,
								true, // read access
								true, // write access
								localVar,
								matchRule);
						break;
				}
				break;
			case IJavaElement.METHOD :
				IMethod method = (IMethod) element;
				boolean isConstructor;
				try {
					isConstructor = method.isConstructor();
				} catch (JavaModelException e) {
					return null;
				}
				declaringClass = method.getDeclaringType();
				declaringSimpleName = declaringClass.getElementName().toCharArray();
				declaringQualification = declaringClass.getPackageFragment().getElementName().toCharArray();
				enclosingNames = enclosingTypeNames(declaringClass);
				if (enclosingNames.length > 0)
					declaringQualification = CharOperation.concat(declaringQualification, CharOperation.concatWith(enclosingNames, '.'), '.');
				char[] selector = method.getElementName().toCharArray();
				char[] returnSimpleName;
				char[] returnQualification;
				boolean varargs = false;
				String returnSignature;
				try {
					returnSignature = method.getReturnType();
					char[] signature = returnSignature.toCharArray();
					char[] returnErasure = Signature.toCharArray(Signature.getTypeErasure(signature));
					CharOperation.replace(returnErasure, '$', '.');
					if ((lastDot = CharOperation.lastIndexOf('.', returnErasure)) == -1) {
						returnSimpleName = returnErasure;
						returnQualification = null;
					} else {
						returnSimpleName = CharOperation.subarray(returnErasure, lastDot + 1, returnErasure.length);
						returnQualification = CharOperation.subarray(returnErasure, 0, lastDot);
						if (!method.isBinary()) {
							// prefix with a '*' as the full qualification could be bigger (because of an import)
							CharOperation.concat(IIndexConstants.ONE_STAR, returnQualification);
						}
					}
					varargs = Flags.isVarargs(method.getFlags());
				} catch (JavaModelException e) {
					return null;
				}
				String[] parameterTypes = method.getParameterTypes();
				int paramCount = parameterTypes.length;
				char[][] parameterSimpleNames = new char[paramCount][];
				char[][] parameterQualifications = new char[paramCount][];
				String[] parameterSignatures = new String[paramCount];
				for (int i = 0; i < paramCount; i++) {
					parameterSignatures[i] = parameterTypes[i];
					char[] signature = parameterSignatures[i].toCharArray();
					char[] paramErasure = Signature.toCharArray(Signature.getTypeErasure(signature));
					CharOperation.replace(paramErasure, '$', '.');
					if ((lastDot = CharOperation.lastIndexOf('.', paramErasure)) == -1) {
						parameterSimpleNames[i] = paramErasure;
						parameterQualifications[i] = null;
					} else {
						parameterSimpleNames[i] = CharOperation.subarray(paramErasure, lastDot + 1, paramErasure.length);
						parameterQualifications[i] = CharOperation.subarray(paramErasure, 0, lastDot);
						if (!method.isBinary()) {
							// prefix with a '*' as the full qualification could be bigger (because of an import)
							CharOperation.concat(IIndexConstants.ONE_STAR, parameterQualifications[i]);
						}
					}
				}

				// Create method/constructor pattern
				boolean findMethodDeclarations = true;
				boolean findMethodReferences = true;
				switch (limitTo) {
					case IJavaSearchConstants.DECLARATIONS :
						findMethodReferences = false;
						break;
					case IJavaSearchConstants.REFERENCES :
						findMethodDeclarations = false;
						break;
					case IJavaSearchConstants.ALL_OCCURRENCES :
						break;
				}
				if (isConstructor) {
					searchPattern =
						new ConstructorPattern(
							findMethodDeclarations,
							findMethodReferences,
							declaringSimpleName, 
							declaringQualification, 
							parameterQualifications, 
							parameterSimpleNames,
							parameterSignatures,
							method,
							varargs,
							matchRule);
				} else {
					searchPattern =
						new MethodPattern(
							findMethodDeclarations,
							findMethodReferences,
							selector, 
							declaringQualification, 
							declaringSimpleName, 
							returnQualification, 
							returnSimpleName, 
							returnSignature,
							parameterQualifications, 
							parameterSimpleNames,
							parameterSignatures,
							varargs,
							method,
							matchRule);
				}
				break;
			case IJavaElement.TYPE :
				IType type = (IType)element;
				searchPattern = 	createTypePattern(
							type.getElementName().toCharArray(), 
							type.getPackageFragment().getElementName().toCharArray(),
							enclosingTypeNames(type),
							null,
							type,
							limitTo,
							matchRule);
				break;
			case IJavaElement.PACKAGE_DECLARATION :
			case IJavaElement.PACKAGE_FRAGMENT :
				searchPattern = createPackagePattern(element.getElementName(), limitTo, matchRule);
				break;
		}
		if (searchPattern != null)
			MatchLocator.setFocus(searchPattern, element);
		return searchPattern;
	}

