	/**
	 * Returns a search pattern based on a given Java element. 
	 * The pattern is used to trigger the appropriate search, and can be parameterized as follows:
	 *
	 * @param element the Java element the search pattern is based on
	 * @param limitTo determines the nature of the expected matches
	 *	<ul>
	 * 	<li>{@link IJavaSearchConstants#DECLARATIONS}: will search declarations matching
	 * 			with the corresponding element. In case the element is a method, declarations of matching
	 * 			methods in subtypes will also be found, allowing to find declarations of abstract methods, etc.
	 *				Some additional flags may be specified while searching declaration:
	 *				<ul>
	 *					<li>{@link IJavaSearchConstants#IGNORE_DECLARING_TYPE}: declaring type will be ignored
	 *							during the search.<br>
	 *							For example using following test case:
	 *							<pre>
	 *								class A { A method() { return null; } }
	 *								class B extends A { B method() { return null; } }
	 *								class C { A method() { return null; } }
	 *							</pre>
	 *							search for <code>method</code> declaration with this flag
	 *							will return 2 matches: in A and in C
	 *					</li>
	 *					<li>{@link IJavaSearchConstants#IGNORE_RETURN_TYPE}: return type will be ignored
	 *							during the search.<br>
	 *							Using same example, search for <code>method</code> declaration with this flag
	 *							will return 2 matches: in A and in B.
	 *					</li>
	 *				<ul>
	 *				Note that these two flags may be combined and both declaring and return types can be ignored
	 *				during the search. Then, using same example, search for <code>method</code> declaration
	 *				with these 2 flags will return 3 matches: in A, in B  and in C
	 * 	</li>
	 *		 <li>{@link IJavaSearchConstants#REFERENCES}: will search references to the given element.</li>
	 *		 <li>{@link IJavaSearchConstants#ALL_OCCURRENCES}: will search for either declarations or
	 *				references as specified above.
	 *		</li>
	 *		 <li>{@link IJavaSearchConstants#IMPLEMENTORS}: for interface, will find all types
	 *				which implements a given interface.
	 *		</li>
	 *	</ul>
	 * @param matchRule one of {@link #R_EXACT_MATCH}, {@link #R_PREFIX_MATCH}, {@link #R_PATTERN_MATCH},
	 * 	{@link #R_REGEXP_MATCH}, {@link #R_CAMELCASE_MATCH} combined with one of following values:
	 * 	{@link #R_CASE_SENSITIVE}, {@link #R_ERASURE_MATCH} or {@link #R_EQUIVALENT_MATCH}.
	 *		e.g. {@link #R_EXACT_MATCH} | {@link #R_CASE_SENSITIVE} if an exact and case sensitive match is requested, 
	 *		{@link #R_PREFIX_MATCH} if a prefix non case sensitive match is requested or {@link #R_EXACT_MATCH} |{@link #R_ERASURE_MATCH}
	 *		if a non case sensitive and erasure match is requested.<br>
	 * 	Note that {@link #R_ERASURE_MATCH} or {@link #R_EQUIVALENT_MATCH} have no effect on non-generic types
	 * 	or methods search.<br>
	 * 	Note also that default behavior for generic types or methods is to find exact matches.
	 * @return a search pattern for a Java element or <code>null</code> if the given element is ill-formed
	 * @since 3.1
	 */
	public static SearchPattern createPattern(IJavaElement element, int limitTo, int matchRule) {
		SearchPattern searchPattern = null;
		int lastDot;
		boolean ignoreDeclaringType = false;
		boolean ignoreReturnType = false;
		int maskedLimitTo = limitTo & ~(IJavaSearchConstants.IGNORE_DECLARING_TYPE+IJavaSearchConstants.IGNORE_RETURN_TYPE);
		if (maskedLimitTo == IJavaSearchConstants.DECLARATIONS || maskedLimitTo == IJavaSearchConstants.ALL_OCCURRENCES) {
			ignoreDeclaringType = (limitTo & IJavaSearchConstants.IGNORE_DECLARING_TYPE) != 0;
			ignoreReturnType = (limitTo & IJavaSearchConstants.IGNORE_RETURN_TYPE) != 0;
		}
		char[] declaringSimpleName = null;
		char[] declaringQualification = null;
		switch (element.getElementType()) {
			case IJavaElement.FIELD :
				IField field = (IField) element; 
				if (!ignoreDeclaringType) {
					IType declaringClass = field.getDeclaringType();
					declaringSimpleName = declaringClass.getElementName().toCharArray();
					declaringQualification = declaringClass.getPackageFragment().getElementName().toCharArray();
					char[][] enclosingNames = enclosingTypeNames(declaringClass);
					if (enclosingNames.length > 0) {
						declaringQualification = CharOperation.concat(declaringQualification, CharOperation.concatWith(enclosingNames, '.'), '.');
					}
				}
				char[] name = field.getElementName().toCharArray();
				char[] typeSimpleName = null;
				char[] typeQualification = null;
				String typeSignature = null;
				if (!ignoreReturnType) {
					try {
						typeSignature = field.getTypeSignature();
						char[] signature = typeSignature.toCharArray();
						char[] typeErasure = Signature.toCharArray(Signature.getTypeErasure(signature));
						CharOperation.replace(typeErasure, '$', '.');
						if ((lastDot = CharOperation.lastIndexOf('.', typeErasure)) == -1) {
							typeSimpleName = typeErasure;
							typeQualification = null;
						} else {
							typeSimpleName = CharOperation.subarray(typeErasure, lastDot + 1, typeErasure.length);
							typeQualification = CharOperation.subarray(typeErasure, 0, lastDot);
							if (!field.isBinary()) {
								// prefix with a '*' as the full qualification could be bigger (because of an import)
								CharOperation.concat(IIndexConstants.ONE_STAR, typeQualification);
							}
						}
					} catch (JavaModelException e) {
						return null;
					}
				}
				// Create field pattern
				boolean findDeclarations = false;
				boolean readAccess = false;
				boolean writeAccess = false;
				switch (maskedLimitTo) {
					case IJavaSearchConstants.DECLARATIONS :
						findDeclarations = true;
						break;
					case IJavaSearchConstants.REFERENCES :
						readAccess = true;
						writeAccess = true;
						break;
					case IJavaSearchConstants.READ_ACCESSES :
						readAccess = true;
						break;
					case IJavaSearchConstants.WRITE_ACCESSES :
						writeAccess = true;
						break;
					case IJavaSearchConstants.ALL_OCCURRENCES :
						findDeclarations = true;
						readAccess = true;
						writeAccess = true;
						break;
				}
				searchPattern = 
					new FieldPattern(
						findDeclarations,
						readAccess,
						writeAccess,
						name, 
						declaringQualification, 
						declaringSimpleName, 
						typeQualification, 
						typeSimpleName,
						typeSignature,
						matchRule);
				break;
			case IJavaElement.IMPORT_DECLARATION :
				String elementName = element.getElementName();
				lastDot = elementName.lastIndexOf('.');
				if (lastDot == -1) return null; // invalid import declaration
				IImportDeclaration importDecl = (IImportDeclaration)element;
				if (importDecl.isOnDemand()) {
					searchPattern = createPackagePattern(elementName.substring(0, lastDot), maskedLimitTo, matchRule);
				} else {
					searchPattern = 
						createTypePattern(
							elementName.substring(lastDot+1).toCharArray(),
							elementName.substring(0, lastDot).toCharArray(),
							null,
							null,
							null,
							maskedLimitTo,
							matchRule);
				}
				break;
			case IJavaElement.LOCAL_VARIABLE :
				LocalVariable localVar = (LocalVariable) element;
				boolean findVarDeclarations = false;
				boolean findVarReadAccess = false;
				boolean findVarWriteAccess = false;
				switch (maskedLimitTo) {
					case IJavaSearchConstants.DECLARATIONS :
						findVarDeclarations = true;
						break;
					case IJavaSearchConstants.REFERENCES :
						findVarReadAccess = true;
						findVarWriteAccess = true;
						break;
					case IJavaSearchConstants.READ_ACCESSES :
						findVarReadAccess = true;
						break;
					case IJavaSearchConstants.WRITE_ACCESSES :
						findVarWriteAccess = true;
						break;
					case IJavaSearchConstants.ALL_OCCURRENCES :
						findVarDeclarations = true;
						findVarReadAccess = true;
						findVarWriteAccess = true;
						break;
				}
				searchPattern = 
					new LocalVariablePattern(
						findVarDeclarations,
						findVarReadAccess,
						findVarWriteAccess,
						localVar,
						matchRule);
				break;
			case IJavaElement.TYPE_PARAMETER:
				ITypeParameter typeParam = (ITypeParameter) element;
				boolean findParamDeclarations = true;
				boolean findParamReferences = true;
				switch (maskedLimitTo) {
					case IJavaSearchConstants.DECLARATIONS :
						findParamReferences = false;
						break;
					case IJavaSearchConstants.REFERENCES :
						findParamDeclarations = false;
						break;
				}
				searchPattern = 
					new TypeParameterPattern(
						findParamDeclarations,
						findParamReferences,
						typeParam,
						matchRule);
				break;
			case IJavaElement.METHOD :
				IMethod method = (IMethod) element;
				boolean isConstructor;
				try {
					isConstructor = method.isConstructor();
				} catch (JavaModelException e) {
					return null;
				}
				IType declaringClass = method.getDeclaringType();
				if (ignoreDeclaringType) {
					if (isConstructor) declaringSimpleName = declaringClass.getElementName().toCharArray();
				} else {
					declaringSimpleName = declaringClass.getElementName().toCharArray();
					declaringQualification = declaringClass.getPackageFragment().getElementName().toCharArray();
					char[][] enclosingNames = enclosingTypeNames(declaringClass);
					if (enclosingNames.length > 0) {
						declaringQualification = CharOperation.concat(declaringQualification, CharOperation.concatWith(enclosingNames, '.'), '.');
					}
				}
				char[] selector = method.getElementName().toCharArray();
				char[] returnSimpleName = null;
				char[] returnQualification = null;
				String returnSignature = null;
				if (!ignoreReturnType) {
					try {
						returnSignature = method.getReturnType();
						char[] signature = returnSignature.toCharArray();
						char[] returnErasure = Signature.toCharArray(Signature.getTypeErasure(signature));
						CharOperation.replace(returnErasure, '$', '.');
						if ((lastDot = CharOperation.lastIndexOf('.', returnErasure)) == -1) {
							returnSimpleName = returnErasure;
							returnQualification = null;
						} else {
							returnSimpleName = CharOperation.subarray(returnErasure, lastDot + 1, returnErasure.length);
							returnQualification = CharOperation.subarray(returnErasure, 0, lastDot);
							if (!method.isBinary()) {
								// prefix with a '*' as the full qualification could be bigger (because of an import)
								CharOperation.concat(IIndexConstants.ONE_STAR, returnQualification);
							}
						}
					} catch (JavaModelException e) {
						return null;
					}
				}
				String[] parameterTypes = method.getParameterTypes();
				int paramCount = parameterTypes.length;
				char[][] parameterSimpleNames = new char[paramCount][];
				char[][] parameterQualifications = new char[paramCount][];
				String[] parameterSignatures = new String[paramCount];
				for (int i = 0; i < paramCount; i++) {
					parameterSignatures[i] = parameterTypes[i];
					char[] signature = parameterSignatures[i].toCharArray();
					char[] paramErasure = Signature.toCharArray(Signature.getTypeErasure(signature));
					CharOperation.replace(paramErasure, '$', '.');
					if ((lastDot = CharOperation.lastIndexOf('.', paramErasure)) == -1) {
						parameterSimpleNames[i] = paramErasure;
						parameterQualifications[i] = null;
					} else {
						parameterSimpleNames[i] = CharOperation.subarray(paramErasure, lastDot + 1, paramErasure.length);
						parameterQualifications[i] = CharOperation.subarray(paramErasure, 0, lastDot);
						if (!method.isBinary()) {
							// prefix with a '*' as the full qualification could be bigger (because of an import)
							CharOperation.concat(IIndexConstants.ONE_STAR, parameterQualifications[i]);
						}
					}
				}

				// Create method/constructor pattern
				boolean findMethodDeclarations = true;
				boolean findMethodReferences = true;
				switch (maskedLimitTo) {
					case IJavaSearchConstants.DECLARATIONS :
						findMethodReferences = false;
						break;
					case IJavaSearchConstants.REFERENCES :
						findMethodDeclarations = false;
						break;
					case IJavaSearchConstants.ALL_OCCURRENCES :
						break;
				}
				if (isConstructor) {
					searchPattern =
						new ConstructorPattern(
							findMethodDeclarations,
							findMethodReferences,
							declaringSimpleName, 
							declaringQualification, 
							parameterQualifications, 
							parameterSimpleNames,
							parameterSignatures,
							method,
							matchRule);
				} else {
					searchPattern =
						new MethodPattern(
							findMethodDeclarations,
							findMethodReferences,
							selector, 
							declaringQualification, 
							declaringSimpleName, 
							returnQualification, 
							returnSimpleName, 
							returnSignature,
							parameterQualifications, 
							parameterSimpleNames,
							parameterSignatures,
							method,
							matchRule);
				}
				break;
			case IJavaElement.TYPE :
				IType type = (IType)element;
				searchPattern = 	createTypePattern(
							type.getElementName().toCharArray(), 
							type.getPackageFragment().getElementName().toCharArray(),
							ignoreDeclaringType ? null : enclosingTypeNames(type),
							null,
							type,
							maskedLimitTo,
							matchRule);
				break;
			case IJavaElement.PACKAGE_DECLARATION :
			case IJavaElement.PACKAGE_FRAGMENT :
				searchPattern = createPackagePattern(element.getElementName(), maskedLimitTo, matchRule);
				break;
		}
		if (searchPattern != null)
			MatchLocator.setFocus(searchPattern, element);
		return searchPattern;
	}

