	/**
	 * Type pattern are formed by [qualification.]type
	 * e.g. java.lang.Object
	 *		Runnable
	 */
	/* (non-Javadoc)
	 * SEARCH_15
	 * 	Modified to be able to identify type arguments in pattern
	 * 	Note that:
	 * 		1) '?' is understood as a wildcard when it is inside <>
	 * 		2) '*' is not treated yet inside <>
	 * 		3) that nested <> are not treated yet
	 * 		4) that only one type arguments definition is allowed
	 * 			(ie. Gen<Exception>.Member<Object> will be treated same as
	 * 			 Gen<Exception>.Member pattern)
	 * 	Using regexp syntax, we can described allowed patterns as:
	 * 		[qualification.] type [ '<' [ [ '?' {'extends'|'super'} ] type ( ',' [ '?' {'extends'|'super'} ] type )* ] '>' ]
	 */
	private static SearchPattern createTypePattern(String patternString, int limitTo, int matchRule) {
		
		Scanner scanner = new Scanner(false /*comment*/, true /*whitespace*/, false /*nls*/, ClassFileConstants.JDK1_3/*sourceLevel*/, null /*taskTags*/, null/*taskPriorities*/, true/*taskCaseSensitive*/); 
		scanner.setSource(patternString.toCharArray());
		String type = null;
		int token;
		try {
			token = scanner.getNextToken();
		} catch (InvalidInputException e) {
			return null;
		}
		boolean storeType = true, storeParam = true;
		int parameterized = 0;
		int paramPtr = -1;
		char[][] paramNames = null;
		int[] wildcards = new int[10];
		while (token != TerminalTokens.TokenNameEOF) {
			if (token != TerminalTokens.TokenNameWHITESPACE) {
				if (storeParam) {
					switch (token) {
						case TerminalTokens.TokenNameMULTIPLY:
							if (parameterized > 0) {
								// SEARCH_15 (frederic) Not treated yet...
							}
							break;
						case TerminalTokens.TokenNameQUESTION:
							if (parameterized > 0) {
								if (wildcards[paramPtr] == -1) {
									wildcards[paramPtr] = Wildcard.UNBOUND;
								} else {
									// SEARCH_15 (frederic) Invalid syntax
								}
							}
							break;
						case TerminalTokens.TokenNameextends:
							if (parameterized > 0) {
								if (wildcards[paramPtr] == Wildcard.UNBOUND) {
									wildcards[paramPtr] = Wildcard.EXTENDS;
								} else {
									// SEARCH_15 (frederic) Invalid syntax
								}
							}
							break;
						case TerminalTokens.TokenNamesuper:
							if (parameterized > 0) {
								if (wildcards[paramPtr] == Wildcard.UNBOUND) {
									wildcards[paramPtr] = Wildcard.SUPER;
								} else {
									// SEARCH_15 (frederic) Invalid syntax
								}
							}
							break;
						case TerminalTokens.TokenNameCOMMA:
							if (parameterized == 1) {
								paramPtr++;
								wildcards[paramPtr] = -1;
							}
							break;
						case TerminalTokens.TokenNameGREATER:
							if (parameterized == 1) storeParam = false;
							parameterized--;
							break;
						case TerminalTokens.TokenNameLESS:
							if (parameterized == 0) {
								paramNames = new char[10][]; // 10 parameters max
								paramPtr++;
								wildcards[paramPtr] = -1;
								storeType = false;
							}
							parameterized++;
							break;
						case TerminalTokens.TokenNameIdentifier:
							if (parameterized == 1 && storeParam) {
								if (paramPtr < paramNames.length) {
									if (paramNames[paramPtr] == null) {
										// never store id at this index
										paramNames[paramPtr] = scanner.getCurrentIdentifierSource();
									}
								} else {
									// syntax error
								}
							}
							break;
					}
				}
				if (storeType) { // store type if not in type arguments declaration
					if (type == null)
						type = new String(scanner.getCurrentTokenSource());
					else
						type += new String(scanner.getCurrentTokenSource());
				}
				storeType = parameterized == 0;
			}
			try {
				token = scanner.getNextToken();
			} catch (InvalidInputException e) {
				return null;
			}
		}
		if (type == null) return null;
		// Resize param names array if necessary
		if (paramPtr >= 0) {
			System.arraycopy(paramNames, 0, paramNames = new char[paramPtr+1][], 0, paramPtr+1);
			System.arraycopy(wildcards, 0, wildcards = new int[paramPtr+1], 0, paramPtr+1);
		}
	
		char[] qualificationChars = null, typeChars = null;
	
		// extract declaring type infos
		if (type != null) {
			char[] typePart = type.toCharArray();
			int lastDotPosition = CharOperation.lastIndexOf('.', typePart);
			if (lastDotPosition >= 0) {
				qualificationChars = CharOperation.subarray(typePart, 0, lastDotPosition);
				if (qualificationChars.length == 1 && qualificationChars[0] == '*')
					qualificationChars = null;
				typeChars = CharOperation.subarray(typePart, lastDotPosition+1, typePart.length);
			} else {
				qualificationChars = null;
				typeChars = typePart;
			}
			if (typeChars.length == 1 && typeChars[0] == '*')
				typeChars = null;
		}
		switch (limitTo) {
			case IJavaSearchConstants.DECLARATIONS : // cannot search for explicit member types
				return new QualifiedTypeDeclarationPattern(qualificationChars, typeChars, IIndexConstants.TYPE_SUFFIX, matchRule);
			case IJavaSearchConstants.REFERENCES :
				return new TypeReferencePattern(qualificationChars, typeChars, paramNames, false /* not generic */, wildcards, matchRule);
			case IJavaSearchConstants.IMPLEMENTORS : 
				return new SuperTypeReferencePattern(qualificationChars, typeChars, true, matchRule);
			case IJavaSearchConstants.ALL_OCCURRENCES :
				return new OrPattern(
					new QualifiedTypeDeclarationPattern(qualificationChars, typeChars, IIndexConstants.TYPE_SUFFIX, matchRule),// cannot search for explicit member types
					new TypeReferencePattern(qualificationChars, typeChars, matchRule));
		}
		return null;
	}

