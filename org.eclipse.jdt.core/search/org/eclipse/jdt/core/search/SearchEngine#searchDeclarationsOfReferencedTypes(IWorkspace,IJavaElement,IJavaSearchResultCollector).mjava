/**
 * Searches for all declarations of the types referenced in the given element.
 * The element can be a compilation unit, a type, or a method.
 * Reports the type declarations using the given collector.
 * <p>
 * Consider the following code:
 * <code>
 * <pre>
 *		class A {
 *		}
 *		class B extends A {
 *		}
 *		interface I {
 *		  int VALUE = 0;
 *		}
 *		class X {
 *			void test() {
 *				B b = new B();
 *				this.foo(b, I.VALUE);
 *			};
 *		}
 * </pre>
 * <code>
 * then searching for declarations of referenced types in method <code>X.test()</code>
 * would collect the class <code>B</code> and the interface <code>I</code>.
 * </p>
 *
 * @param workspace the workspace
 * @param enclosingElement the method, type, or compilation unit to be searched in
 * @param resultCollector a callback object to which each match is reported
 * @exception JavaModelException if the search failed. Reasons include:
 *	<ul>
 *		<li>the element doesn't exist
 *		<li>the classpath is incorrectly set
 *	</ul>
 */	
public void searchDeclarationsOfReferencedTypes(IWorkspace workspace, IJavaElement enclosingElement, IJavaSearchResultCollector resultCollector) throws JavaModelException {
	MatchLocator locator = new MatchLocator(
		(SearchPattern)createSearchPattern("*", IJavaSearchConstants.TYPE, IJavaSearchConstants.REFERENCES, true), //$NON-NLS-1$
		IInfoConstants.DeclarationInfo,
		resultCollector,
		new JavaWorkspaceScope());
	// TBD: limit search to type or method by passing start and end of enclosing element
	locator.locateMatches(
		new String[] {enclosingElement.getUnderlyingResource().getFullPath().toString()}, 
		workspace);
}

