/**
 * Searches for all top-level types and member types in the given scope.
 * The search can be selecting specific types (given a package or a type name
 * prefix and match modes). 
 * 
 * @param workspace the workspace to search in
 * @param packageName the full name of the package of the searched types, or a prefix for this
 *						package, or a wild-carded string for this package.
 * @param typeName the dot-separated qualified name of the searched type (the qualification include
 *					the enclosing types if the searched type is a member type), or a prefix
 *					for this type, or a wild-carded string for this type.
 * @param matchMode one of
 * <ul>
 *		<li><code>IJavaSearchConstants.EXACT_MATCH</code> if the package name and type name are the full names
 *			of the searched types.</li>
 *		<li><code>IJavaSearchConstants.PREFIX_MATCH</code> if the package name and type name are prefixes of the names
 *			of the searched types.</li>
 *		<li><code>IJavaSearchConstants.PATTERN_MATCH</code> if the package name and type name contain wild-cards.</li>
 * </ul>
 * @param isCaseSensitive whether the search should be case sensitive
 * @param searchFor one of
 * <ul>
 * 		<li><code>IJavaSearchConstants.CLASS</code> if searching for classes only</li>
 * 		<li><code>IJavaSearchConstants.INTERFACE</code> if searching for interfaces only</li>
 * 		<li><code>IJavaSearchConstants.TYPE</code> if searching for both classes and interfaces</li>
 * </ul>
 * @param scope the scope to search in
 * @param nameRequestor the requestor that collects the results of the search
 * @param waitingPolicy one of
 * <ul>
 *		<li><code>IJavaSearchConstants.FORCE_IMMEDIATE_SEARCH</code> if the search should start immediately</li>
 *		<li><code>IJavaSearchConstants.CANCEL_IF_NOT_READY_TO_SEARCH</code> if the search should be cancelled if the
 *			underlying indexer has not finished indexing the workspace</li>
 *		<li><code>IJavaSearchConstants.WAIT_UNTIL_READY_TO_SEARCH</code> if the search should wait for the
 *			underlying indexer to finish indexing the workspace</li>
 * </ul>
 * @param progressMonitor the progress monitor to report progress to, or <code>null</code> if no progress
 *							monitor is provided
 * @exception JavaModelException if the search failed. Reasons include:
 *	<ul>
 *		<li>the classpath is incorrectly set</li>
 *	</ul>
 */
public void searchAllTypeNames(
	IWorkspace workspace,
	char[] packageName, 
	char[] typeName,
	int matchMode, 
	boolean isCaseSensitive,
	int searchFor, 
	IJavaSearchScope scope, 
	final ITypeNameRequestor nameRequestor,
	int waitingPolicy,
	IProgressMonitor progressMonitor)  throws JavaModelException {

	IndexManager indexManager = JavaModelManager.getJavaModelManager().getIndexManager();
		
	char classOrInterface;
	switch(searchFor){
		case IJavaSearchConstants.CLASS :
			classOrInterface = IIndexConstants.CLASS_SUFFIX;
			break;
		case IJavaSearchConstants.INTERFACE :
			classOrInterface = IIndexConstants.INTERFACE_SUFFIX;
			break;
		default : 
			classOrInterface = IIndexConstants.TYPE_SUFFIX;
			break;
	}
	SearchPattern pattern = new TypeDeclarationPattern(
		packageName,
		null, // do find member types
		typeName,
		classOrInterface,
		matchMode, 
		isCaseSensitive);
	
	IIndexSearchRequestor searchRequestor = new IndexSearchAdapter(){
		public void acceptClassDeclaration(String resourcePath, char[] simpleTypeName, char[][] enclosingTypeNames, char[] pkgName) {
			if (enclosingTypeNames != IIndexConstants.ONE_ZERO_CHAR) { // filter out local and anonymous classes
				nameRequestor.acceptClass(pkgName, simpleTypeName, enclosingTypeNames, resourcePath);
			}
		}		
		public void acceptInterfaceDeclaration(String resourcePath, char[] simpleTypeName, char[][] enclosingTypeNames, char[] pkgName) {
			if (enclosingTypeNames != IIndexConstants.ONE_ZERO_CHAR) { // filter out local and anonymous classes
				nameRequestor.acceptInterface(pkgName, simpleTypeName, enclosingTypeNames, resourcePath);
			}
		}		
	};

	try {
		if (progressMonitor != null) {
			progressMonitor.beginTask(Util.bind("engine.searching"), 100); //$NON-NLS-1$
		}
		indexManager.performConcurrentJob(
			new PatternSearchJob(pattern, scope, IInfoConstants.NameInfo | IInfoConstants.PathInfo, searchRequestor, indexManager),
			waitingPolicy,
			progressMonitor == null ? null : new SubProgressMonitor(progressMonitor, 100));	
	} finally {
		if (progressMonitor != null) {
			progressMonitor.done();
		}
	}
}

