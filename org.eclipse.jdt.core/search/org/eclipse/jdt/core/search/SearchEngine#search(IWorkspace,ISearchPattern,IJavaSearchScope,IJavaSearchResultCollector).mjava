/**
 * Searches for matches of a given search pattern. Search patterns can be created using helper
 * methods (from a String pattern or a Java element) and encapsulate the description of what is
 * being searched (e.g. search method declarations in a case sensitive way).
 *
 * @param workspace the workspace
 * @param searchPattern the pattern to be searched for
 * @param scope the search result has to be limited to the given scope
 * @param resultCollector a callback object to which each match is reported
 * @exception JavaModelException if the search failed. Reasons include:
 *	<ul>
 *		<li>the classpath is incorrectly set
 *	</ul>
 */
public void search(IWorkspace workspace, ISearchPattern searchPattern, IJavaSearchScope scope, IJavaSearchResultCollector resultCollector) throws JavaModelException {

	/* search is starting */
	resultCollector.aboutToStart();

	try {	
		if (searchPattern == null) return;

		/* initialize progress monitor */
		IProgressMonitor progressMonitor = resultCollector.getProgressMonitor();
		if (progressMonitor != null) {
			progressMonitor.beginTask(Util.bind("engine.searching"), 105); // 5 for getting paths, 100 for locating matches //$NON-NLS-1$
		}

		/* index search */
		PathCollector pathCollector = new PathCollector();

		IndexManager indexManager = ((JavaModelManager)JavaModelManager.getJavaModelManager())
										.getIndexManager();
		int detailLevel = IInfoConstants.PathInfo | IInfoConstants.PositionInfo;
		MatchLocator matchLocator = new MatchLocator((SearchPattern)searchPattern, detailLevel, resultCollector, scope);
		if (indexManager != null) {
			indexManager.performConcurrentJob(
				new PatternSearchJob(
					(SearchPattern)searchPattern, 
					scope, 
					detailLevel, 
					pathCollector, 
					indexManager, 
					progressMonitor),
				IJavaSearchConstants.WAIT_UNTIL_READY_TO_SEARCH,
				progressMonitor);

			if (progressMonitor != null) {
				progressMonitor.worked(5);
			}
				
			/* eliminating false matches and locating them */
			if (progressMonitor != null && progressMonitor.isCanceled()) throw new OperationCanceledException();
			matchLocator.locateMatches(pathCollector.getPaths(), workspace);
		}

		if (progressMonitor != null) {
			progressMonitor.done();
		}

		matchLocator.locatePackageDeclarations(workspace);
	} finally {
		/* search has ended */
		resultCollector.done();
	}
}

