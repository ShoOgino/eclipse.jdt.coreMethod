/**
 * Searches for matches of a given search pattern. Search patterns can be created using helper
 * methods (from a String pattern or a Java element) and encapsulate the description of what is
 * being searched (e.g. search method declarations in a case sensitive way).
 *
 * @param workspace the workspace
 * @param searchPattern the pattern to be searched for
 * @param scope the search result has to be limited to the given scope
 * @param resultCollector a callback object to which each match is reported
 * @exception JavaModelException if the search failed. Reasons include:
 *	<ul>
 *		<li>the classpath is incorrectly set
 *	</ul>
 */
public void search(IWorkspace workspace, ISearchPattern searchPattern, IJavaSearchScope scope, IJavaSearchResultCollector resultCollector) throws JavaModelException {
	
	if (VERBOSE) {
		System.out.println("Searching for " + searchPattern + " in " + scope); //$NON-NLS-1$//$NON-NLS-2$
	}

	/* search is starting */
	resultCollector.aboutToStart();

	try {	
		if (searchPattern == null) return;

		/* initialize progress monitor */
		IProgressMonitor progressMonitor = resultCollector.getProgressMonitor();
		if (progressMonitor != null) {
			progressMonitor.beginTask(Util.bind("engine.searching"), 100); //$NON-NLS-1$
		}

		/* index search */
		PathCollector pathCollector = new PathCollector();
		
		// In the case of a hierarchy scope make sure that the hierarchy is not computed.
		// MatchLocator will filter out elements not in the hierarchy
		SearchPattern pattern = (SearchPattern)searchPattern;
		if (scope instanceof HierarchyScope) {
			((HierarchyScope)scope).needsRefresh = false;
			pattern.needsResolve = true; // force resolve to compute type bindings
		}

		IndexManager indexManager = ((JavaModelManager)JavaModelManager.getJavaModelManager())
										.getIndexManager();
		int detailLevel = IInfoConstants.PathInfo | IInfoConstants.PositionInfo;
		MatchLocator matchLocator = 
			new MatchLocator(
				pattern, 
				detailLevel, 
				resultCollector, 
				scope,
				progressMonitor == null ? null : new SubProgressMonitor(progressMonitor, 95)
		);

		indexManager.performConcurrentJob(
			new PatternSearchJob(
				pattern, 
				scope, 
				pattern.focus,
				detailLevel, 
				pathCollector, 
				indexManager),
			IJavaSearchConstants.WAIT_UNTIL_READY_TO_SEARCH,
			progressMonitor == null ? null : new SubProgressMonitor(progressMonitor, 5));
			
		/* eliminating false matches and locating them */
		if (progressMonitor != null && progressMonitor.isCanceled()) throw new OperationCanceledException();
		matchLocator.locateMatches(
			pathCollector.getPaths(), 
			workspace,
			filterWorkingCopies(this.workingCopies, pattern.focus)
		);
		

		if (progressMonitor != null && progressMonitor.isCanceled()) throw new OperationCanceledException();
		
		if (progressMonitor != null) {
			progressMonitor.done();
		}

		matchLocator.locatePackageDeclarations(workspace);
	} finally {
		/* search has ended */
		resultCollector.done();
	}
}

