	public boolean flush() throws IndexException {
		boolean wasInterrupted = false;
		assert this.fLocked;
		ArrayList<Chunk> dirtyChunks= new ArrayList<>();
		int scanIndex = NUM_HEADER_CHUNKS;

		while (scanIndex < this.fChunksUsed) {
			synchronized (this.fCache) {
				int countMax = Math.min(MAX_ITERATIONS_PER_LOCK, this.fChunksUsed - scanIndex);
				for (int count = 0; count < countMax; count++) {
					Chunk chunk = this.fChunks[scanIndex++];

					if (chunk != null) {
						if (chunk.fDirty) {
							dirtyChunks.add(chunk); // Keep in fChunks until it is flushed.
						} else if (chunk.fCacheIndex < 0) {
							if (DEBUG_PAGE_CACHE) {
								System.out.println(
										"CHUNK " + chunk.fSequenceNumber + ": removing from vector in flush - instance " //$NON-NLS-1$//$NON-NLS-2$
												+ System.identityHashCode(chunk));
							}
							// Non-dirty chunk that has been removed from cache.
							this.fChunks[chunk.fSequenceNumber]= null;
						}
					}
				}
			}
		}
		// Also handles header chunk.
		wasInterrupted = flushAndUnlockChunks(dirtyChunks, true) || wasInterrupted;

		return wasInterrupted;
	}

