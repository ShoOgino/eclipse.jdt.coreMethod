	/**
	 * Reads and attaches any generic type parameters at the current start position in the given wrapper.
	 * Sets wrapper.start to the character following the type parameters.
	 * @throws CoreException
	 */
	private void readTypeParameters(NdBinding type, ITypeAnnotationWalker annotationWalker, SignatureWrapper wrapper)
			throws CoreException {
		char[] genericSignature = wrapper.signature;
		if (genericSignature.length == 0 || wrapper.charAtStart() != '<') {
			return;
		}

		int parameterIndex = 0;
		int boundIndex = 0;
		int indexOfClosingBracket = wrapper.skipAngleContents(wrapper.start) - 1;
		wrapper.start++;
		NdTypeParameter parameter = null;
		while (wrapper.start < indexOfClosingBracket) {
			int colonPos = CharOperation.indexOf(':', genericSignature, wrapper.start, indexOfClosingBracket);

			if (colonPos > wrapper.start) {
				char[] identifier = CharOperation.subarray(genericSignature, wrapper.start, colonPos);
				parameter = new NdTypeParameter(type, identifier);
				wrapper.start = colonPos + 1;
				parameterIndex++;
				boundIndex = 0;
			}

			// Class files insert an empty bound if there is an interface bound but no class bound. We just omit
			// the bound entirely.
			while (genericSignature[wrapper.start] == ':') {
				wrapper.start++;
			}

			NdTypeSignature boundSignature = createTypeSignature(
					annotationWalker.toTypeParameter(true, parameterIndex).toTypeBound((short)boundIndex),
					wrapper);

			new NdTypeBound(parameter, boundSignature);
			boundIndex++;
		}

		if (genericSignature[wrapper.start] == '>') {
			wrapper.start++;
		}
	}

