	public void put(Nd nd, long address, long newTargetAddress) {
		long fieldStart = address + this.offset;
		if (this.backPointer == null) {
			throw new IllegalStateException("FieldNodePointer must be associated with a FieldBackPointer"); //$NON-NLS-1$
		}

		long oldTargetAddress = TARGET.get(nd, fieldStart);
		if (oldTargetAddress == newTargetAddress) {
			return;
		}

		if (oldTargetAddress != 0) {
			int oldIndex = BACKPOINTER_INDEX.get(nd, fieldStart);

			this.backPointer.remove(nd, oldTargetAddress, oldIndex);

			short targetTypeId = NdNode.NODE_TYPE.get(nd, oldTargetAddress);

			ITypeFactory<T> typeFactory = nd.getTypeFactory(targetTypeId);

			if (typeFactory.getDeletionSemantics() == StructDef.DeletionSemantics.REFCOUNTED 
					&& typeFactory.isReadyForDeletion(nd, oldTargetAddress)) {
				nd.scheduleDeletion(oldTargetAddress);
			}
		}
		TARGET.put(nd, fieldStart, newTargetAddress);
		if (newTargetAddress != 0) {
			// Note that newValue is the address of the backpointer list and record (the address of the struct
			// containing the forward pointer) is the value being inserted into the list.
			BACKPOINTER_INDEX.put(nd, fieldStart, this.backPointer.add(nd, newTargetAddress, address));
		} else {
			if (this.pointsToOwner) {
				nd.scheduleDeletion(address);
			}
		}
	}

