	/**
	 * Returns the closest ancestor of the given type, or null if none. Note that
	 * this looks for an exact match. It will not return subtypes of the given type.
	 */
	@SuppressWarnings("unchecked")
	public <T extends NdTreeNode> T getAncestorOfType(Class<T> ancestorType) {
		long targetType = getNd().getNodeType(ancestorType);

		Nd nd = getNd();
		long current = PARENT.getAddress(nd, this.address);

		while (current != 0) {
			short currentType = NODE_TYPE.get(nd, current);

			if (currentType == targetType) {
				NdNode result = load(nd, current);

				if (ancestorType.isInstance(result)) {
					return (T) result;
				} else {
					nd.describeProblem().addProblemAddress(NODE_TYPE, current).throwException("The node at address " //$NON-NLS-1$
							+ current + " should have been an instance of " + ancestorType.getName() //$NON-NLS-1$
							+  " but was an instance of " + result.getClass().getName()); //$NON-NLS-1$
				}
			}

			current = PARENT.getAddress(nd, current);
		}

		return null;
	}

