	@SuppressWarnings("nls")
	public void releaseWriteLock(int establishReadLocks, boolean flush) {
		synchronized (this.mutex) {
			Thread current = Thread.currentThread();
			if (current != this.writeLockOwner) {
				throw new IllegalStateException("Index wasn't locked by this thread!!!");
			}
			this.writeLockOwner = null;
		}
		boolean wasInterrupted = false;
		try {
			// When all locks are released we can clear the result cache.
			if (establishReadLocks == 0) {
				processDeletions();
				this.db.putLong(Database.WRITE_NUMBER_OFFSET, ++this.fWriteNumber);
				clearResultCache();
			}
			wasInterrupted = this.db.giveUpExclusiveLock(flush) || wasInterrupted;
		} finally {
			assert this.lockCount == -1;
			this.lastWriteAccess= System.currentTimeMillis();
			synchronized (this.mutex) {
				if (sDEBUG_LOCKS) {
					long timeHeld = this.lastWriteAccess - this.timeWriteLockAcquired;
					if (timeHeld >= LONG_WRITE_LOCK_REPORT_THRESHOLD) {
						System.out.println("Index write lock held for " + timeHeld + " ms");
					}
					decWriteLock(establishReadLocks);
				}
	
				if (this.lockCount < 0)
					this.lockCount= establishReadLocks;
				this.mutex.notifyAll();
				this.db.setLocked(this.lockCount != 0);
			}
		}

		if (wasInterrupted) {
			throw new OperationCanceledException();
		}
	}

