	/**
	 * Adds the given method to the given type
	 *
	 * @throws CoreException
	 */
	private void addMethod(NdType type, IBinaryMethod next, IBinaryType binaryType)
			throws CoreException {
		NdMethod method = new NdMethod(type);

		attachAnnotations(method, next.getAnnotations());

		ITypeAnnotationWalker typeAnnotations = getTypeAnnotationWalker(next.getTypeAnnotations());
		SignatureWrapper signature = GenericSignatures.getGenericSignature(next);
		SignatureWrapper descriptor = new SignatureWrapper(next.getMethodDescriptor());
		readTypeParameters(method, typeAnnotations, signature);

		skipChar(signature, '(');
		skipChar(descriptor, '(');

		List<char[]> parameterFieldDescriptors = new ArrayList<>();
		while (!descriptor.atEnd()) {
			if (descriptor.charAtStart() == ')') {
				skipChar(descriptor, ')');
				break;
			}
			parameterFieldDescriptors.add(readNextFieldDescriptor(descriptor));
		}

		char[][] parameterNames = next.getArgumentNames();
		int numArgumentsInGenericSignature = countMethodArguments(signature);
		int numCompilerDefinedParameters = Math.max(0,
				parameterFieldDescriptors.size() - numArgumentsInGenericSignature);
		
		boolean compilerDefinedParametersAreIncludedInSignature = (next.getGenericSignature() == null);

		// If there is no generic signature, then fall back to heuristics based on what we know about
		// where the java compiler likes to create compiler-defined arguments
		if (compilerDefinedParametersAreIncludedInSignature) {
			// Constructors for non-static member types get a compiler-defined first argument
			if (binaryType.isMember() 
					&& next.isConstructor() 
					&& ((binaryType.getModifiers() & Modifier.STATIC) == 0)
					&& parameterFieldDescriptors.size() > 0) {

				numCompilerDefinedParameters = 1;
			} else {
				numCompilerDefinedParameters = 0;
			}
		}

		int parameterNameIdx = 0;
		int annotatedParametersCount = next.getAnnotatedParametersCount();

		short descriptorParameterIdx = 0;
		char[] binaryTypeName = binaryType.getName();
		while (!signature.atEnd()) {
			if (signature.charAtStart() == ')') {
				skipChar(signature, ')');
				break;
			}
			char[] nextFieldDescriptor = parameterFieldDescriptors.get(descriptorParameterIdx);
			/**
			 * True iff this a parameter which is part of the field descriptor but not the generic signature -- that is,
			 * it is a compiler-defined parameter.
			 */
			boolean isCompilerDefined = descriptorParameterIdx < numCompilerDefinedParameters;
			SignatureWrapper nextFieldSignature = signature;
			if (isCompilerDefined && !compilerDefinedParametersAreIncludedInSignature) {
				nextFieldSignature = new SignatureWrapper(nextFieldDescriptor);
			}
			NdMethodParameter parameter = new NdMethodParameter(method,
					createTypeSignature(typeAnnotations.toMethodParameter(descriptorParameterIdx), nextFieldSignature,
							nextFieldDescriptor));

			parameter.setCompilerDefined(isCompilerDefined);

			if (descriptorParameterIdx < annotatedParametersCount) {
				IBinaryAnnotation[] parameterAnnotations = next.getParameterAnnotations(descriptorParameterIdx,
						binaryTypeName);

				if (parameterAnnotations != null) {
					for (IBinaryAnnotation nextAnnotation : parameterAnnotations) {
						createAnnotation(nextAnnotation).setParent(parameter);
					}
				}
			}
			if (!isCompilerDefined && parameterNames != null && parameterNames.length > parameterNameIdx) {
				parameter.setName(parameterNames[parameterNameIdx++]);
			}
			descriptorParameterIdx++;
		}

		skipChar(descriptor, ')');
		char[] nextFieldDescriptor = readNextFieldDescriptor(descriptor);
		method.setReturnType(createTypeSignature(typeAnnotations.toMethodReturn(), signature, nextFieldDescriptor));

		char[][] exceptionTypes = next.getExceptionTypeNames();
		int throwsIdx = 0;
		while (!signature.atEnd() && signature.charAtStart() == '^') {
			signature.start++;
			new NdMethodException(method, createTypeSignature(typeAnnotations.toThrows(throwsIdx), signature,
					JavaNames.binaryNameToFieldDescriptor(exceptionTypes[throwsIdx])));
			throwsIdx++;
		}

		// char[][] exceptionTypeNames = next.getExceptionTypeNames();
		// int numExceptions = exceptionTypeNames == null ? 0 : exceptionTypeNames.length;
		//
		// if (throwsIdx != numExceptions) {
		// throw new IllegalStateException(
		// "The number of exceptions in getExceptionTypeNames() didn't match the number of exceptions in the generic
		// signature"); //$NON-NLS-1$
		// }

		Object defaultValue = next.getDefaultValue();
		if (defaultValue != null) {
			method.setDefaultValue(createConstantFromMixedType(defaultValue));
		}

		method.setMethodId(createMethodId(binaryType.getName(), next.getSelector(), next.getMethodDescriptor()));
		method.setModifiers(next.getModifiers());
		method.setTagBits(next.getTagBits());
	}

