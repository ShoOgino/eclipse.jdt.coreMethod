	/**
	 * Interrupting the thread with {@link Thread#interrupt()} won't interrupt the write. Returns true iff an attempt
	 * was made to interrupt the thread with {@link Thread#interrupt()}.
	 * 
	 * @throws IndexException
	 */
	private boolean flushAndUnlockChunks(final ArrayList<Chunk> dirtyChunks, boolean isComplete) throws IndexException {
		boolean wasInterrupted = false;
		assert !Thread.holdsLock(this.fCache);
		final boolean haveDirtyChunks = !dirtyChunks.isEmpty();
		if (haveDirtyChunks || this.fHeaderChunk.fDirty) {
			wasInterrupted = markFileIncomplete() || wasInterrupted;
		}
		if (haveDirtyChunks) {
			for (Chunk chunk : dirtyChunks) {
				if (chunk.fDirty) {
					boolean wasCanceled = false;
					if (DEBUG_PAGE_CACHE) {
						System.out.println("CHUNK " + chunk.fSequenceNumber + ": flushing - instance "  //$NON-NLS-1$//$NON-NLS-2$
								+ System.identityHashCode(chunk));
					}
					try {
						final ByteBuffer buf;
						synchronized (this.fCache) {
							buf = ByteBuffer.wrap(chunk.getBytes());
							chunk.fDirty = false;
							chunkCleaned(chunk);
						}
						wasCanceled = write(buf, (long) chunk.fSequenceNumber * Database.CHUNK_SIZE);
					} catch (IOException e) {
						throw new IndexException(new DBStatus(e));
					}

					wasInterrupted = wasCanceled || wasInterrupted;
				}
			}
		}

		if (isComplete) {
			if (this.fHeaderChunk.fDirty || this.fIsMarkedIncomplete) {
				this.fHeaderChunk.putInt(VERSION_OFFSET, this.fVersion);
				wasInterrupted = this.fHeaderChunk.flush() || wasInterrupted;
				this.fIsMarkedIncomplete= false;
			}
		}
		return wasInterrupted;
	}

