	private void flushAndUnlockChunks(final ArrayList<Chunk> dirtyChunks, boolean isComplete) throws IndexException {
		assert !Thread.holdsLock(this.fCache);
		synchronized (this.fHeaderChunk) {
			final boolean haveDirtyChunks = !dirtyChunks.isEmpty();
			if (haveDirtyChunks || this.fHeaderChunk.fDirty) {
				markFileIncomplete();
			}
			if (haveDirtyChunks) {
				for (Chunk chunk : dirtyChunks) {
					if (chunk.fDirty) {
						chunk.flush();
					}
				}

				// Only after the chunks are flushed we may unlock and release them.
				synchronized (this.fCache) {
					for (Chunk chunk : dirtyChunks) {
						chunk.fLocked= false;
						if (chunk.fCacheIndex < 0) {
							this.fChunks[chunk.fSequenceNumber]= null;
						}
					}
				}
			}

			if (isComplete) {
				if (this.fHeaderChunk.fDirty || this.fIsMarkedIncomplete) {
					this.fHeaderChunk.putInt(VERSION_OFFSET, this.fVersion);
					this.fHeaderChunk.flush();
					this.fIsMarkedIncomplete= false;
				}
			}
		}
	}

