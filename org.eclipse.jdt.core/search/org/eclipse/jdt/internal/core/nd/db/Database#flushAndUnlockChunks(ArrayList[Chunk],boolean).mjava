	/**
	 * Interrupting the thread with {@link Thread#interrupt()} won't interrupt the write. Returns true iff an attempt
	 * was made to interrupt the thread with {@link Thread#interrupt()}.
	 * 
	 * @throws IndexException
	 */
	private boolean flushAndUnlockChunks(final ArrayList<Chunk> dirtyChunks, boolean isComplete) throws IndexException {
		boolean wasInterrupted = false;
		assert !Thread.holdsLock(this.fCache);
		final boolean haveDirtyChunks = !dirtyChunks.isEmpty();
		if (haveDirtyChunks || this.fHeaderChunk.fDirty) {
			wasInterrupted = markFileIncomplete() || wasInterrupted;
		}
		if (haveDirtyChunks) {
			for (Chunk chunk : dirtyChunks) {
				if (chunk.fDirty) {
					boolean wasCanceled = false;
					if (DEBUG_PAGE_CACHE) {
						System.out.println("CHUNK " + chunk.fSequenceNumber + ": flushing - instance "  //$NON-NLS-1$//$NON-NLS-2$
								+ System.identityHashCode(chunk));
					}
					try {
						final ByteBuffer buf;
						synchronized (this.fCache) {
							buf = ByteBuffer.wrap(chunk.getBytes());
							chunk.fDirty = false;
						}
						wasCanceled = write(buf, (long) chunk.fSequenceNumber * Database.CHUNK_SIZE);
					} catch (IOException e) {
						throw new IndexException(new DBStatus(e));
					}

					wasInterrupted = wasCanceled || wasInterrupted;
				}
			}

			// Only after the chunks are flushed we may unlock and release them.
			int totalSize = dirtyChunks.size();
			int scanIndex = 0;
			while (scanIndex < totalSize) {
				synchronized (this.fCache) {
					int countMax = Math.min(MAX_ITERATIONS_PER_LOCK, totalSize - scanIndex);
					for (int count = 0; count < countMax; count++) {
						Chunk chunk = this.fChunks[scanIndex++];

						if (chunk != null) {
							if (chunk.fCacheIndex < 0) {
								if (DEBUG_PAGE_CACHE) {
									System.out.println("CHUNK " + chunk.fSequenceNumber //$NON-NLS-1$
											+ ": removing from vector in flushAndUnlockChunks - instance " //$NON-NLS-1$
											+ System.identityHashCode(chunk));
								}
								this.fChunks[chunk.fSequenceNumber]= null;
							}
						}
					}
				}
			}
		}

		if (isComplete) {
			if (this.fHeaderChunk.fDirty || this.fIsMarkedIncomplete) {
				this.fHeaderChunk.putInt(VERSION_OFFSET, this.fVersion);
				wasInterrupted = this.fHeaderChunk.flush() || wasInterrupted;
				this.fIsMarkedIncomplete= false;
			}
		}
		return wasInterrupted;
	}

