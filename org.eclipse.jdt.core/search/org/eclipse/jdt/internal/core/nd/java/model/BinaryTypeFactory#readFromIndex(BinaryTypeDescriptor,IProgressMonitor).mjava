	/**
	 * Tries to read the given IBinaryType from the index. The return value is lightweight and may be cached
	 * with minimal memory cost. Returns an IBinaryType if the type was found in the index and the index
	 * was up-to-date. Throws a NotInIndexException if the index does not contain an up-to-date cache of the
	 * requested file. Returns null if the index contains an up-to-date cache of the requested file and it was
	 * able to determine that the requested class does not exist in that file.
	 */
	public static IBinaryType readFromIndex(BinaryTypeDescriptor descriptor, IProgressMonitor monitor) throws JavaModelException, NotInIndexException {
		char[] className = JavaNames.fieldDescriptorToSimpleName(descriptor.fieldDescriptor);

		// If the new index is enabled, check if we have this class file cached in the index already		
		char[] fieldDescriptor = descriptor.fieldDescriptor;
		
		if (!CharArrayUtils.equals(PACKAGE_INFO, className)) {
			JavaIndex index = JavaIndex.getIndex();
			Nd nd = index.getNd();

			// We don't currently cache package-info files in the index
			if (descriptor.location != null) {
				// Acquire a read lock on the index
				try (IReader lock = nd.acquireReadLock()) {
					try {
						if (index.isUpToDate(descriptor.location)) {
							TypeRef typeRef = TypeRef.create(nd, descriptor.location, fieldDescriptor);
							NdType type = typeRef.get();

							if (type == null) {
								return null;
							}

							IndexBinaryType result = new IndexBinaryType(typeRef, descriptor.indexPath);

							// We already have the database lock open and have located the element, so we may as
							// well prefetch the inexpensive attributes.
							result.initSimpleAttributes();

							return result;
						}
					} catch (CoreException e) {
						throw new JavaModelException(e);
					}
				} catch (IndexException e) {
					// Index corrupted. Rebuild it.
					index.rebuildIndex();
				}
			}
		}
		
		throw new NotInIndexException();
	}

