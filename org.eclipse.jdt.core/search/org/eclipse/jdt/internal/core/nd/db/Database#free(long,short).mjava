	/**
	 * Free an allocated block.
	 *
	 * @param address
	 *            memory address to be freed
	 * @param poolId
	 *            the same ID that was previously passed into malloc when allocating this memory address
	 */
	public void free(long address, short poolId) throws IndexException {
		assert this.fExclusiveLock;
		if (address == 0) {
			return;
		}
		long blockSize;
		long block = address - BLOCK_HEADER_SIZE;
		Chunk chunk = getChunk(block);
		blockSize = -chunk.getShort(block);
		// We use a block size of 0 to indicate a large block that fills a range of chunks
		if (blockSize == 0) {
			int offsetIntoChunk = (int) (address % CHUNK_SIZE);
			assert offsetIntoChunk == LargeBlock.HEADER_SIZE + BLOCK_HEADER_SIZE;
			// Deallocating a large block
			// This was a large block. It uses a sequence of full chunks.
			int chunkNum = (int) (address / CHUNK_SIZE);
			int numChunks = -getBlockHeaderForChunkNum(chunkNum);
			if (numChunks < 0) {
				// Already freed.
				throw new IndexException(new Status(IStatus.ERROR, Package.PLUGIN_ID, 0,
						"Already freed large block " + address, new Exception())); //$NON-NLS-1$
			}
			blockSize = numChunks * CHUNK_SIZE;
			freeLargeChunk(chunkNum, numChunks);
		} else {
			// Deallocating a normal block
			// TODO Look for opportunities to merge small blocks
			if (blockSize < 0) {
				// Already freed.
				throw new IndexException(new Status(IStatus.ERROR, Package.PLUGIN_ID, 0,
						"Already freed record " + address, new Exception())); //$NON-NLS-1$
			}
			addBlock(chunk, (int) blockSize, block);
		}

		this.freed += blockSize;
		this.memoryUsage.recordFree(poolId, blockSize);
	}

