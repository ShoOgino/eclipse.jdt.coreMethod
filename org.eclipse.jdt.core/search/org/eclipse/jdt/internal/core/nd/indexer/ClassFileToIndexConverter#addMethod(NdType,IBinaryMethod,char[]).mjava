	/**
	 * Adds the given method to the given type
	 *
	 * @throws CoreException
	 */
	private void addMethod(NdType type, IBinaryMethod next, char[] binaryTypeName) throws CoreException {
		NdMethod method = new NdMethod(type);

		attachAnnotations(method, next.getAnnotations());

		ITypeAnnotationWalker typeAnnotations = getTypeAnnotationWalker(next.getTypeAnnotations());
		SignatureWrapper signature = GenericSignatures.getGenericSignature(next);
		SignatureWrapper descriptor = new SignatureWrapper(next.getMethodDescriptor());
		readTypeParameters(method, typeAnnotations, signature);

		skipChar(signature, '(');
		skipChar(descriptor, '(');

		int annotatedParametersCount = next.getAnnotatedParametersCount();
		char[][] parameterNames = next.getArgumentNames();
		short parameterIdx = 0;
		while (!signature.atEnd()) {
			if (signature.charAtStart() == ')') {
				signature.start++;
				break;
			}
			char[] nextFieldDescriptor = readNextFieldDescriptor(descriptor);
			NdMethodParameter parameter = new NdMethodParameter(method, createTypeSignature(
					typeAnnotations.toMethodParameter(parameterIdx), signature, nextFieldDescriptor));

			if (parameterIdx < annotatedParametersCount) {
				IBinaryAnnotation[] parameterAnnotations = next.getParameterAnnotations(parameterIdx, binaryTypeName);

				if (parameterAnnotations != null) {
					for (IBinaryAnnotation nextAnnotation : parameterAnnotations) {
						createAnnotation(nextAnnotation).setParent(parameter);
					}
				}
			}
			if (parameterNames != null && parameterNames.length > parameterIdx) {
				parameter.setName(parameterNames[parameterIdx]);
			}
			parameterIdx++;
		}

		skipChar(descriptor, ')');
		char[] nextFieldDescriptor = readNextFieldDescriptor(descriptor);
		method.setReturnType(createTypeSignature(typeAnnotations.toMethodReturn(), signature, nextFieldDescriptor));

		char[][] exceptionTypes = next.getExceptionTypeNames();
		int throwsIdx = 0;
		while (!signature.atEnd() && signature.charAtStart() == '^') {
			signature.start++;
			new NdMethodException(method, createTypeSignature(typeAnnotations.toThrows(throwsIdx), signature,
					JavaNames.binaryNameToFieldDescriptor(exceptionTypes[throwsIdx])));
			throwsIdx++;
		}

		// char[][] exceptionTypeNames = next.getExceptionTypeNames();
		// int numExceptions = exceptionTypeNames == null ? 0 : exceptionTypeNames.length;
		//
		// if (throwsIdx != numExceptions) {
		// throw new IllegalStateException(
		// "The number of exceptions in getExceptionTypeNames() didn't match the number of exceptions in the generic
		// signature"); //$NON-NLS-1$
		// }

		Object defaultValue = next.getDefaultValue();
		if (defaultValue != null) {
			method.setDefaultValue(createConstantFromMixedType(defaultValue));
		}

		method.setMethodId(createMethodId(binaryTypeName, next.getSelector(), next.getMethodDescriptor()));
		method.setModifiers(next.getModifiers());
		method.setTagBits(next.getTagBits());
	}

