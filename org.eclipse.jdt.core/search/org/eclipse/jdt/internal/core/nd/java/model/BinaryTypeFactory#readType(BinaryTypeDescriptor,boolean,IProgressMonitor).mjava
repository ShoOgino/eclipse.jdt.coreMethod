	/**
	 * Reads the given binary type. If the type can be found in the index with a fingerprint that exactly matches
	 * the file on disk, the type is read from the index. Otherwise the type is read from disk. Returns null if
	 * no such type exists.
	 */
	public static IBinaryType readType(BinaryTypeDescriptor descriptor, boolean fullyInitialize,
			IProgressMonitor monitor) throws JavaModelException {
		
		if (JavaIndex.isEnabled()) {
			try {
				return readFromIndex(descriptor, monitor);
			} catch (NotInIndexException e) {
				// fall back to reading the zip file, below
			}
		}

		ZipFile zip = null;
		try {
			zip = JavaModelManager.getJavaModelManager().getZipFile(new Path(new String(descriptor.workspacePath)));
			char[] entryNameCharArray = CharArrayUtils.concat(
					JavaNames.fieldDescriptorToBinaryName(descriptor.fieldDescriptor), SuffixConstants.SUFFIX_class);
			String entryName = new String(entryNameCharArray);
			ZipEntry ze = zip.getEntry(entryName);
			if (ze != null) {
				byte contents[];
				try {
					contents = org.eclipse.jdt.internal.compiler.util.Util.getZipEntryByteContent(ze, zip);
				} catch (IOException ioe) {
					throw new JavaModelException(ioe, IJavaModelStatusConstants.IO_EXCEPTION);
				}
				ClassFileReader reader;
				try {
					reader = new ClassFileReader(contents, descriptor.indexPath, fullyInitialize);
				} catch (ClassFormatException e) {
					if (JavaCore.getPlugin().isDebugging()) {
						e.printStackTrace(System.err);
					}
					return null;
				}
				return reader;
			}
		} catch (CoreException e) {
			throw new JavaModelException(e);
		} finally {
			JavaModelManager.getJavaModelManager().closeZipFile(zip);
		}
		return null;
	}

