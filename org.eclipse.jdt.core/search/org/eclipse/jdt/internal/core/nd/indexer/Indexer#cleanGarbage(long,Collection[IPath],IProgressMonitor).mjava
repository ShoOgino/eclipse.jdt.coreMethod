	private int cleanGarbage(long currentTimeMillis, Collection<IPath> allRootLocations, IProgressMonitor monitor) {
		// TODO: lazily clean up unneeded files here... but only do so if we're under heavy space pressure
		// or it's been a long time since the file was last scanned. Being too eager about removing old files
		// means that operations which temporarily cause a file to become unreferenced will run really slowly

		// We should also eagerly clean up any partially-indexed files we discover during the scan. That is,
		// if we discover a file with a timestamp of 0, it indicates that the indexer or all of Eclipse crashed
		// midway through indexing the file. Such garbage should be cleaned up as soon as possible, since it
		// will never be useful.

		JavaIndex index = JavaIndex.getIndex(this.nd);

		int result = 0; 
		HashSet<IPath> paths = new HashSet<>();
		paths.addAll(allRootLocations);
		SubMonitor subMonitor = SubMonitor.convert(monitor, 3);

		List<NdResourceFile> garbage = new ArrayList<>();
		List<NdResourceFile> needsUpdate = new ArrayList<>();

		// Build up the list of NdResourceFiles that either need to be garbage collected or
		// have their read timestamps updated.
		try (IReader reader = this.nd.acquireReadLock()) {
			List<NdResourceFile> resourceFiles = index.getAllResourceFiles();

			result = resourceFiles.size();
			SubMonitor testMonitor = subMonitor.split(1).setWorkRemaining(resourceFiles.size());
			for (NdResourceFile next : resourceFiles) {
				testMonitor.split(1);
				if (!next.isDoneIndexing()) {
					garbage.add(next);
				} else {
					IPath nextPath = new Path(next.getLocation().toString());
					long timeLastUsed = next.getTimeLastUsed();
					long timeSinceLastUsed = currentTimeMillis - timeLastUsed;

					if (paths.contains(nextPath)) {
						if (timeSinceLastUsed > USAGE_TIMESTAMP_UPDATE_PERIOD) {
							needsUpdate.add(next);
						}
					} else {
						if (timeSinceLastUsed > GARBAGE_CLEANUP_TIMEOUT) {
							garbage.add(next);
						}
					}
				}
			}
		}

		SubMonitor deleteMonitor = subMonitor.split(1).setWorkRemaining(garbage.size());
		for (NdResourceFile next : garbage) {
			this.nd.acquireWriteLock(deleteMonitor.split(1));
			try {
				if (next.isInIndex()) {
					next.delete();
				}
			} finally {
				this.nd.releaseWriteLock();
			}
		}

		SubMonitor updateMonitor = subMonitor.split(1).setWorkRemaining(needsUpdate.size());
		for (NdResourceFile next : needsUpdate) {
			this.nd.acquireWriteLock(updateMonitor.split(1));
			try {
				if (next.isInIndex()) {
					next.setTimeLastUsed(currentTimeMillis);
				}
			} finally {
				this.nd.releaseWriteLock();
			}
		}

		return result;
	}

