	private int cleanGarbage(long currentTimeMillis, Collection<IPath> allRootLocations, IProgressMonitor monitor) {
		// TODO: lazily clean up unneeded files here... but only do so if we're under heavy space pressure
		// or it's been a long time since the file was last scanned. Being too eager about removing old files
		// means that operations which temporarily cause a file to become unreferenced will run really slowly

		// We should also eagerly clean up any partially-indexed files we discover during the scan. That is,
		// if we discover a file with a timestamp of 0, it indicates that the indexer or all of Eclipse crashed
		// midway through indexing the file. Such garbage should be cleaned up as soon as possible, since it
		// will never be useful.

		JavaIndex index = JavaIndex.getIndex(this.nd);

		int result = 0; 
		HashSet<IPath> paths = new HashSet<>();
		paths.addAll(allRootLocations);
		SubMonitor subMonitor = SubMonitor.convert(monitor, 3);
		this.nd.acquireWriteLock(subMonitor.split(1));
		try {
			List<NdResourceFile> resourceFiles = index.getAllResourceFiles();
			List<NdResourceFile> garbage = new ArrayList<>();

			result = resourceFiles.size();
			SubMonitor testMonitor = subMonitor.split(1).setWorkRemaining(resourceFiles.size());
			for (NdResourceFile next : resourceFiles) {
				testMonitor.split(1);
				if (!next.isDoneIndexing()) {
					garbage.add(next);
				} else {
					IPath nextPath = new Path(next.getLocation().toString());
					if (paths.contains(nextPath)) {
						next.setTimeLastUsed(currentTimeMillis);
					} else {
						long timeLastUsed = next.getTimeLastUsed();

						long timeSinceLastUsed = currentTimeMillis - timeLastUsed;
						if (timeSinceLastUsed > GARBAGE_CLEANUP_TIMEOUT) {
							garbage.add(next);
						}
					}
				}
			}

			SubMonitor deleteMonitor = subMonitor.split(1).setWorkRemaining(garbage.size());
			for (NdResourceFile next : garbage) {
				deleteMonitor.split(1);
				next.delete();
			}
		} finally {
			this.nd.releaseWriteLock();
		}

		return result;
	}

