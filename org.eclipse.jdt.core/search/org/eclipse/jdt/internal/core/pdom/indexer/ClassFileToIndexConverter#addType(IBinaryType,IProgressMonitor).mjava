	public PDOMType addType(IBinaryType binaryType, IProgressMonitor monitor) throws CoreException {
		char[] binaryName = binaryType.getName();
		logInfo("adding binary type " + new String(binaryName));

		PDOMTypeId name = createTypeIdFromBinaryName(binaryName);
		PDOMType type = name.findTypeByResourceAddress(this.resource.address);

		if (type == null) {
			type = new PDOMType(getPDOM(), this.resource);
		}

		ITypeAnnotationWalker typeAnnotations = getTypeAnnotationWalker(binaryType.getTypeAnnotations());
		ITypeAnnotationWalker supertypeAnnotations = typeAnnotations.toSupertype((short)-1, binaryType.getSuperclassName());

		type.setTypeId(name);

		char[][] interfaces = binaryType.getInterfaceNames();
		if (interfaces == null) {
			interfaces = EMPTY_CHAR_ARRAY_ARRAY;
		}
		// Create the default generic signature if the .class file didn't supply one
		char[] genericSignature = binaryType.getGenericSignature();
		if (genericSignature == null) {
			int startIndex = binaryType.getSuperclassName() != null ? 3 : 0; 
			char[][] toCatenate = new char[startIndex + (interfaces.length * 3)][];
			char[] prefix = new char[]{'L'};
			char[] suffix = new char[]{';'};

			if (binaryType.getSuperclassName() != null) {
				toCatenate[0] = prefix;
				toCatenate[1] = binaryType.getSuperclassName();
				toCatenate[2] = suffix;
			}

			for (int idx = 0; idx < interfaces.length; idx++) {
				int catIndex = startIndex + idx * 3;
				toCatenate[catIndex] = prefix;
				toCatenate[catIndex + 1] = interfaces[idx];
				toCatenate[catIndex + 2] = suffix;
			}

			genericSignature = CharUtil.concat(toCatenate);
		}

		type.setModifiers(binaryType.getModifiers());
		type.setDeclaringType(createTypeIdFromBinaryName(binaryType.getEnclosingTypeName()));

		SignatureWrapper signatureWrapper = new SignatureWrapper(genericSignature);
		readTypeParameters(type, typeAnnotations, signatureWrapper);
		type.setSuperclass(createTypeSignature(supertypeAnnotations, signatureWrapper));

		short interfaceIdx = 0;
		while (signatureWrapper.start < signatureWrapper.signature.length) {
			// Note that there may be more interfaces listed in the generic signature than in the interfaces list.
			// Although the VM spec doesn't discuss this case specifically, there are .class files in the wild with
			// this characteristic. In such cases, we take what's in the generic signature and discard what's in the
			// interfaces list.
			char[] interfaceSpec = interfaceIdx < interfaces.length ? interfaces[interfaceIdx] : EMPTY_CHAR_ARRAY;
			new PDOMTypeInterface(getPDOM(), type, createTypeSignature(
					typeAnnotations.toSupertype(interfaceIdx, interfaceSpec),
					signatureWrapper));
			interfaceIdx++;
		}

		IBinaryAnnotation[] annotations = binaryType.getAnnotations();
		if (annotations != null) {
			for (IBinaryAnnotation next : annotations) {
				createAnnotation(next).setParent(type);
			}
		}

		type.setDeclaringMethod(createMethodId(binaryType.getEnclosingTypeName(), binaryType.getEnclosingMethod()));

		IBinaryField[] fields = binaryType.getFields();

		if (fields != null) {
			for (IBinaryField nextField : fields) {
				PDOMVariable variable = new PDOMVariable(getPDOM(), type);

				variable.setType(createTypeIdFromFieldDescriptor(nextField.getTypeName()));
				variable.setName(new String(nextField.getName()));

				IBinaryAnnotation[] binaryAnnotations = nextField.getAnnotations();
				if (binaryAnnotations != null) {
					for (IBinaryAnnotation nextAnnotation : binaryAnnotations) {
						createAnnotation(nextAnnotation).setParent(variable);
					}
				}

				variable.setConstant(PDOMConstant.create(getPDOM(), nextField.getConstant()));
				variable.setModifiers(nextField.getModifiers());

				// TODO(sxenos): Finish pulling in the rest of the fields from IBinaryField
			}
		}

		return type;
	}

