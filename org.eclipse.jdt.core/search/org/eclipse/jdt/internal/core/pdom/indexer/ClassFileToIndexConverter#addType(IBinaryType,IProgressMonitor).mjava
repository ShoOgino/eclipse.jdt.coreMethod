	public PDOMType addType(IBinaryType binaryType, IProgressMonitor monitor) throws CoreException {
		char[] binaryName = binaryType.getName();
		logInfo("adding binary type " + new String(binaryName)); //$NON-NLS-1$

		PDOMTypeId name = createTypeIdFromBinaryName(binaryName);
		PDOMType type = name.findTypeByResourceAddress(this.resource.address);

		if (type == null) {
			type = new PDOMType(getPDOM(), this.resource);
		}

		ITypeAnnotationWalker typeAnnotations = getTypeAnnotationWalker(binaryType.getTypeAnnotations());
		ITypeAnnotationWalker supertypeAnnotations = typeAnnotations.toSupertype((short)-1, binaryType.getSuperclassName());

		type.setTypeId(name);

		char[][] interfaces = binaryType.getInterfaceNames();
		if (interfaces == null) {
			interfaces = EMPTY_CHAR_ARRAY_ARRAY;
		}
		// Create the default generic signature if the .class file didn't supply one
		SignatureWrapper signatureWrapper = getGenericSignature(binaryType);

		type.setModifiers(binaryType.getModifiers());
		type.setDeclaringType(createTypeIdFromBinaryName(binaryType.getEnclosingTypeName()));

		readTypeParameters(type, typeAnnotations, signatureWrapper);
		type.setSuperclass(createTypeSignature(supertypeAnnotations, signatureWrapper));

		short interfaceIdx = 0;
		while (signatureWrapper.start < signatureWrapper.signature.length) {
			// Note that there may be more interfaces listed in the generic signature than in the interfaces list.
			// Although the VM spec doesn't discuss this case specifically, there are .class files in the wild with
			// this characteristic. In such cases, we take what's in the generic signature and discard what's in the
			// interfaces list.
			char[] interfaceSpec = interfaceIdx < interfaces.length ? interfaces[interfaceIdx] : EMPTY_CHAR_ARRAY;
			new PDOMTypeInterface(getPDOM(), type, createTypeSignature(
					typeAnnotations.toSupertype(interfaceIdx, interfaceSpec),
					signatureWrapper));
			interfaceIdx++;
		}

		IBinaryAnnotation[] annotations = binaryType.getAnnotations();
		if (annotations != null) {
			for (IBinaryAnnotation next : annotations) {
				createAnnotation(next).setParent(type);
			}
		}

		type.setDeclaringMethod(createMethodId(binaryType.getEnclosingTypeName(), binaryType.getEnclosingMethod()));

		IBinaryField[] fields = binaryType.getFields();

		if (fields != null) {
			for (IBinaryField nextField : fields) {
				PDOMVariable variable = new PDOMVariable(getPDOM(), type);

				//variable.setType(createTypeIdFromFieldDescriptor(nextField.getTypeName()));
				variable.setName(new String(nextField.getName()));

				IBinaryAnnotation[] binaryAnnotations = nextField.getAnnotations();
				if (binaryAnnotations != null) {
					for (IBinaryAnnotation nextAnnotation : binaryAnnotations) {
						createAnnotation(nextAnnotation).setParent(variable);
					}
				}

				variable.setConstant(PDOMConstant.create(getPDOM(), nextField.getConstant()));
				variable.setModifiers(nextField.getModifiers());
				SignatureWrapper nextTypeSignature = getGenericSignatureFor(nextField);

				ITypeAnnotationWalker annotationWalker = getTypeAnnotationWalker(nextField.getTypeAnnotations());
				variable.setType(createTypeSignature(annotationWalker, nextTypeSignature));
			}
		}

		return type;
	}

