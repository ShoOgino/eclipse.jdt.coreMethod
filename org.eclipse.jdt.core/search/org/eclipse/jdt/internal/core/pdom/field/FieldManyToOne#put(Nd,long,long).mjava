	public void put(Nd pdom, long address, long newTargetAddress) {
		long fieldStart = address + this.offset;
		if (this.backPointer == null) {
			throw new IllegalStateException("FieldNodePointer must be associated with a FieldBackPointer"); //$NON-NLS-1$
		}

		long oldTargetAddress = TARGET.get(pdom, fieldStart);
		if (oldTargetAddress == newTargetAddress) {
			return;
		}

		if (oldTargetAddress != 0) {
			int oldIndex = BACKPOINTER_INDEX.get(pdom, fieldStart);

			this.backPointer.remove(pdom, oldTargetAddress, oldIndex);

			if (oldTargetAddress != 0) {
				short targetTypeId = NdNode.NODE_TYPE.get(pdom, oldTargetAddress);

				ITypeFactory<T> typeFactory = pdom.getTypeFactory(targetTypeId);

				if (typeFactory.getDeletionSemantics() == StructDef.DeletionSemantics.REFCOUNTED 
						&& typeFactory.isReadyForDeletion(pdom, oldTargetAddress)) {
					pdom.scheduleDeletion(oldTargetAddress);
				}
			}
		}
		TARGET.put(pdom, fieldStart, newTargetAddress);
		if (newTargetAddress != 0) {
			// Note that newValue is the address of the backpointer list and record (the address of the struct
			// containing the forward pointer) is the value being inserted into the list.
			BACKPOINTER_INDEX.put(pdom, fieldStart, this.backPointer.add(pdom, newTargetAddress, address));
		} else {
			if (this.pointsToOwner) {
				pdom.scheduleDeletion(address);
			}
		}
	}

