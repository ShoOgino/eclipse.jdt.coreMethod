	/**
	 * Parses a ClassTypeSignature (as described in section 4.7.9.1 of the Java VM Specification Java SE 8 Edition).
	 * The read pointer should be located just after the identifier. The caller is expected to have already read
	 * the field descriptor for the type.
	 * 
	 * @param annotations
	 * @param wrapper
	 * @param genericSignature
	 * @param fieldDescriptor
	 * @return
	 * @throws CoreException
	 */
	private PDOMTypeSignature parseClassTypeSignature(PDOMTypeSignature parentTypeOrNull,
			ITypeAnnotationWalker annotations, SignatureWrapper wrapper) throws CoreException {
		char[] identifier = wrapper.nextName();
		char[] fieldDescriptor;

		if (parentTypeOrNull != null) {
			fieldDescriptor = CharUtil.concat(parentTypeOrNull.getRawType().getFieldDescriptor().getChars(),
					new char[] {'$'},
					identifier);
		} else {
			fieldDescriptor = identifier;
		}

		char[] genericSignature = wrapper.signature;
		boolean hasGenericArguments = (genericSignature.length > wrapper.start) && genericSignature[wrapper.start] == '<';
		PDOMTypeId rawType = createTypeIdFromFieldDescriptor(fieldDescriptor);
		PDOMTypeSignature result = rawType;

		// Special optimization for signatures with no type annotations, no arrays, and no generic arguments that
		// are not an inner type of a class that can't use this optimization. Basically, if there would be no attributes
		// set on a PDOMComplexTypeSignature besides what it picks up from its raw type, we just use the raw type.
		IBinaryAnnotation[] annotationList = annotations.getAnnotationsAtCursor(0);
		if (annotationList.length != 0 || hasGenericArguments
				|| !Objects.equals(parentTypeOrNull, rawType.getDeclaringType())) {
			PDOMComplexTypeSignature typeSignature = new PDOMComplexTypeSignature(getPDOM());
			typeSignature.setRawType(rawType);
			attachAnnotations(typeSignature, annotations);
	
			if (hasGenericArguments) {
				wrapper.start++;
				short argumentIndex = 0;
				while (wrapper.start < genericSignature.length && (genericSignature[wrapper.start] != '>')) {
					PDOMTypeArgument typeArgument = new PDOMTypeArgument(getPDOM(), typeSignature);
	
					switch(genericSignature[wrapper.start]) {
						case '+': {
							typeArgument.setWildcard(PDOMTypeArgument.WILDCARD_SUPER);
							wrapper.start++;
							break;
						}
						case '-': {
							typeArgument.setWildcard(PDOMTypeArgument.WILDCARD_EXTENDS);
							wrapper.start++;
							break;
						}
						case '*': {
							typeArgument.setWildcard(PDOMTypeArgument.WILDCARD_QUESTION);
							wrapper.start++;
							argumentIndex++;
							continue;
						}
					}
	
					PDOMTypeSignature nextSignature = createTypeSignature(annotations.toTypeArgument(argumentIndex), wrapper);
					typeArgument.setType(nextSignature);
					argumentIndex++;
				}
	
				// Skip over the trailing '>'
				wrapper.start++;
			}
			result = typeSignature;

			if (parentTypeOrNull != null) {
				result.setDeclaringType(parentTypeOrNull);
			}
		}

		if (wrapper.start >= genericSignature.length) {
			throw new IndexException("Read beyond end of the type signature!"); //$NON-NLS-1$
		}

		switch (genericSignature[wrapper.start]) {
			case ';': 
				wrapper.start++; 
				break;
			case '.':
				PDOMTypeSignature nestedType = parseClassTypeSignature(result, annotations.toNextNestedType(), wrapper);
				
				PDOMTypeSignature detectedNestedType = nestedType.getDeclaringType();
				
				// Perform a sanity-test
				assertThat(Objects.equals(detectedNestedType, result),
						"Incorrect declaring type for nested type");
				assertThat(Objects.equals(nestedType.getDeclaringType().getRawType(), result.getRawType()),
						"Incorrect declaring type for nested raw type");

				result = nestedType;
				break;
		}

		return result;
	}

