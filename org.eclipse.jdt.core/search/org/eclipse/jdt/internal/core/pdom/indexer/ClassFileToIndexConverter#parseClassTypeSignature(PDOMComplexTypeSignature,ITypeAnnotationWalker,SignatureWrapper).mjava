	/**
	 * Parses a ClassTypeSignature (as described in section 4.7.9.1 of the Java VM Specification Java SE 8 Edition).
	 * The read pointer should be located just after the identifier. The caller is expected to have already read
	 * the field descriptor for the type.
	 *
	 * @param annotations
	 * @param wrapper
	 * @param genericSignature
	 * @param fieldDescriptor
	 * @return
	 * @throws CoreException
	 */
	private PDOMTypeSignature parseClassTypeSignature(PDOMComplexTypeSignature parentTypeOrNull,
			ITypeAnnotationWalker annotations, SignatureWrapper wrapper) throws CoreException {
		char[] identifier = wrapper.nextName();
		char[] fieldDescriptor;

		if (parentTypeOrNull != null) {
			fieldDescriptor = CharUtil.concat(parentTypeOrNull.getRawType().getFieldDescriptor().getChars(),
					new char[] {'$'},
					identifier);
		} else {
			fieldDescriptor = identifier;
		}

		char[] genericSignature = wrapper.signature;
		boolean hasGenericArguments = (genericSignature.length > wrapper.start) && genericSignature[wrapper.start] == '<';
		boolean isRawTypeWithNestedClass = genericSignature[wrapper.start] == '.';
		PDOMTypeId rawType = createTypeIdFromFieldDescriptor(fieldDescriptor);
		PDOMTypeSignature result = rawType;

		boolean checkForSemicolon = true;
		// Special optimization for signatures with no type annotations, no arrays, and no generic arguments that
		// are not an inner type of a class that can't use this optimization. Basically, if there would be no attributes
		// set on a PDOMComplexTypeSignature besides what it picks up from its raw type, we just use the raw type.
		IBinaryAnnotation[] annotationList = annotations.getAnnotationsAtCursor(0);
		if (annotationList.length != 0 || hasGenericArguments || parentTypeOrNull != null || isRawTypeWithNestedClass) {
			PDOMComplexTypeSignature typeSignature = new PDOMComplexTypeSignature(getPDOM());
			typeSignature.setRawType(rawType);
			attachAnnotations(typeSignature, annotations);

			if (hasGenericArguments) {
				wrapper.start++;
				short argumentIndex = 0;
				while (wrapper.start < genericSignature.length && (genericSignature[wrapper.start] != '>')) {
					PDOMTypeArgument typeArgument = new PDOMTypeArgument(getPDOM(), typeSignature);

					switch(genericSignature[wrapper.start]) {
						case '+': {
							typeArgument.setWildcard(PDOMTypeArgument.WILDCARD_SUPER);
							wrapper.start++;
							break;
						}
						case '-': {
							typeArgument.setWildcard(PDOMTypeArgument.WILDCARD_EXTENDS);
							wrapper.start++;
							break;
						}
						case '*': {
							typeArgument.setWildcard(PDOMTypeArgument.WILDCARD_QUESTION);
							wrapper.start++;
							argumentIndex++;
							continue;
						}
					}

					PDOMTypeSignature nextSignature = createTypeSignature(annotations.toTypeArgument(argumentIndex), wrapper);
					typeArgument.setType(nextSignature);
					argumentIndex++;
				}

				// Skip over the trailing '>'
				wrapper.start++;
			}
			result = typeSignature;

			if (parentTypeOrNull != null) {
				typeSignature.setGenericDeclaringType(parentTypeOrNull);
			}

			if (genericSignature[wrapper.start] == '.') {
				// Don't check for a semicolon if we hit this branch since the recursive call to parseClassTypeSignature
				// will do this
				checkForSemicolon = false;
				result = parseClassTypeSignature(typeSignature, annotations.toNextNestedType(), wrapper);
			}
		}

		if (checkForSemicolon && wrapper.start < genericSignature.length && genericSignature[wrapper.start] == ';') {
			wrapper.start++;
		}

		return result;
	}

