/**
 * Reads in a string from the specified data input stream. The 
 * string has been encoded using a modified UTF-8 format. 
 * <p>
 * The first two bytes are read as an unsigned short.
 * This value gives the number of following bytes that are in the encoded string,
 * not the length of the resulting string. The following bytes are then 
 * interpreted as bytes encoding characters in the UTF-8 format 
 * and are converted into characters. 
 * <p>
 * This method blocks until all the bytes are read, the end of the 
 * stream is detected, or an exception is thrown. 
 *
 * @param      stream   a data input stream.
 * @return     UTF decoded string as a char array
 * @exception  EOFException if this end of data input is reached while reading it.
 * @exception  IOException if an I/O error occurs while reading data input.
 * @exception  UTFDataFormatException  if the bytes do not represent a
 *               valid UTF-8 encoding of a Unicode string.
 */
private char[] readStreamChars(FileInputStream stream) throws IOException {
	// read chars array length
	int length = (streamBuffer[this.bufferIndex++]&0xFF)<<8;
	int bufferSize = BUFFER_READ_SIZE;
	if (stream != null && this.bufferIndex == bufferSize) {
		this.bufferIndex = 0;
		int readSize = this.streamEnd - this.streamPos;
		this.streamPos += stream.read(this.streamBuffer, 0, readSize < bufferSize ? readSize : bufferSize);
	}
	length += (this.streamBuffer[this.bufferIndex++]&0xFF);
	if (stream != null && this.bufferIndex == bufferSize) {
		this.bufferIndex = 0;
		int readSize = this.streamEnd - this.streamPos;
		this.streamPos += stream.read(this.streamBuffer, 0, readSize < bufferSize ? readSize : bufferSize);
	}
	// fill the chars from bytes buffer
	char[] word = new char[length];
	int idx = this.bufferIndex;
	int i = 0;
	while (i < length) {
		byte b = streamBuffer[idx++];
		switch (b & 0xF0) {
			case 0x00 :
			case 0x10 :
			case 0x20 :
			case 0x30 :
			case 0x40 :
			case 0x50 :
			case 0x60 :
			case 0x70 :
				word[i++]= (char) b;
				break;
			case 0xC0 :
			case 0xD0 :
				if (stream != null && idx == bufferSize) {
					int readSize = this.streamEnd - this.streamPos;
					this.streamPos += stream.read(this.streamBuffer, 0, readSize < bufferSize ? readSize : bufferSize);
					idx = 0;
				}
				char next = (char) streamBuffer[idx++];
				if ((next & 0xC0) != 0x80) {
					throw new UTFDataFormatException();
				}
				char ch = (char) ((b & 0x1F) << 6);
				ch |= next & 0x3F;
				word[i++] = ch;
				break;
			case 0xE0 :
				if (stream != null && idx == bufferSize) {
					int readSize = this.streamEnd - this.streamPos;
					this.streamPos += stream.read(this.streamBuffer, 0, readSize < bufferSize ? readSize : bufferSize);
					idx = 0;
				}
				char first = (char) streamBuffer[idx++];
				if (stream != null && idx == bufferSize) {
					int readSize = this.streamEnd - this.streamPos;
					this.streamPos += stream.read(this.streamBuffer, 0, readSize < bufferSize ? readSize : bufferSize);
					idx = 0;
				}
				char second = (char) streamBuffer[idx++];
				if ((first & second & 0xC0) != 0x80) {
					throw new UTFDataFormatException();
				}
				ch = (char) ((b & 0x0F) << 12);
				ch |= ((first& 0x3F) << 6);
				ch |= second & 0x3F;
				word[i++] = ch;
				break;
			default:
				throw new UTFDataFormatException();
		}
		// as we read more bytes, chars array may be read before the end of the buffer
		if (stream != null && idx == bufferSize) {
			int readSize = this.streamEnd - this.streamPos;
			this.streamPos += stream.read(this.streamBuffer, 0, readSize < bufferSize ? readSize : bufferSize);
			idx = 0;
		}
	}
	this.bufferIndex = idx; // rsync buffer index
	return word;
}

