/*
 *  Compute index list, which may trigger some index recreation work.
 *  Only cache available indexes if all of them were ready (if not, next call will recompute from scratch)
 */
private IIndex[] computeIndexes() {
	
	boolean areAllIndexesReady = true;
	
	ArrayList indexesInScope = new ArrayList();
	IPath[] projectsAndJars = this.searchScope.enclosingProjectsAndJars();
	IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();
	IJavaElement projectOrJarFocus = this.focus == null ? null : getProjectOrJar(this.focus);
	for (int i = 0; i < projectsAndJars.length; i++) {
		IPath location;
		IPath path = projectsAndJars[i];
		if ((!root.getProject(path.lastSegment()).exists()) // if project does not exist
			&& path.segmentCount() > 1
			&& ((location = root.getFile(path).getLocation()) == null
				|| !new java.io.File(location.toOSString()).exists()) // and internal jar file does not exist
			&& !new java.io.File(path.toOSString()).exists()) { // and external jar file does not exist
				continue;
		}
		if (projectOrJarFocus == null || canSeeFocus(projectOrJarFocus, this.isPolymorphicSearch, path)) {
			IIndex index = this.indexManager.getIndex(path, true /*reuse index file*/, false /*do not create if none*/);
			if (index == null) areAllIndexesReady = false;
			if (index != null && indexesInScope.indexOf(index) == -1) {
				indexesInScope.add(index);
			}
		}
	}
	IIndex[] availableIndexes = new IIndex[indexesInScope.size()];
	indexesInScope.toArray(availableIndexes);

	// only cache available indexes if all of them were ready (if not, next call will recompute)
	if (areAllIndexesReady) this.indexes = availableIndexes;
	return availableIndexes;
}

