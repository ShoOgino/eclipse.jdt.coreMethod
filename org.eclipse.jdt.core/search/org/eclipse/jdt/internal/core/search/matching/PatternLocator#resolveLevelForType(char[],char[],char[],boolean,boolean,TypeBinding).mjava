/* (non-Javadoc)
 * Resolve level for type with a given binding with all pattern information.
 */
protected int resolveLevelForType (char[] simpleNamePattern,
									char[] qualificationPattern,
									char[] patternTypeSignature,
									boolean mustResolve,
									boolean declaration,
									TypeBinding type) {
	// standard search with no generic additional information must succeed
	int level = resolveLevelForType(simpleNamePattern, qualificationPattern, type);
	if (level == IMPOSSIBLE_MATCH) return IMPOSSIBLE_MATCH;
	if (type == null || patternTypeSignature == null) return level;

	// pattern has no type parameter, return standard result
	char[][] patternTypeArguments = Signature.getTypeArguments(patternTypeSignature);
	if (patternTypeArguments == null || patternTypeArguments.length == 0) {
		return level;
	}

	// pattern has type parameter(s) or type argument(s)
	boolean isRawType = type.isRawType();
	if (type.isGenericType()) {
		// Binding is generic, get its type variable(s)
		TypeVariableBinding[] typeVariables = null;
		if (type instanceof SourceTypeBinding) {
			SourceTypeBinding sourceTypeBinding = (SourceTypeBinding) type;
			typeVariables = sourceTypeBinding.typeVariables;
		} else if (type instanceof BinaryTypeBinding) {
			BinaryTypeBinding binaryTypeBinding = (BinaryTypeBinding) type;
			if (mustResolve)
				typeVariables = binaryTypeBinding.typeVariables(); // TODO (frederic) verify performance
		}
		// type variables length must match at least specified type names length
		if (typeVariables == null || typeVariables.length == 0) {
			return IMPOSSIBLE_MATCH;
		}
		int length = patternTypeArguments.length;
		if (typeVariables.length != length) return IMPOSSIBLE_MATCH;
		// TODO (frederic) do we need to verify each parameter?
		return level; // we can't do better
	} else if (!type.isParameterizedType() && !isRawType) {
		// Standard types (ie. neither generic nor parameterized nor raw types)
		// cannot match pattern with type parameters or arguments
		return IMPOSSIBLE_MATCH;
	} else {
		// Binding is parameterized type
		ParameterizedTypeBinding paramTypeBinding = (ParameterizedTypeBinding) type;
		if (paramTypeBinding.arguments == null) {
			// binding has no type parameters => ok for raw types
			if (isRawType) return level;
			// need to verify hierarchy for member types (raw type of generic member
			// are stored as parameterized types...)
			if (type.isMemberType() && qualificationPattern != null) {
				int lastDot = CharOperation.lastIndexOf('.', qualificationPattern);
				char[] enclosingQualificationPattern = lastDot==-1 ? null : CharOperation.subarray(qualificationPattern, 0, lastDot);
				char[] enclosingSimpleNamePattern = lastDot==-1 ? qualificationPattern : CharOperation.subarray(qualificationPattern, lastDot+1, qualificationPattern.length);
				if (resolveLevelForType(enclosingSimpleNamePattern, enclosingQualificationPattern, patternTypeSignature, mustResolve, declaration, paramTypeBinding.enclosingType()) == IMPOSSIBLE_MATCH) {
					return IMPOSSIBLE_MATCH;
				}
				return level;
			}
			return IMPOSSIBLE_MATCH;
		}

		// type parameters length must match at least specified type names length
		int length = patternTypeArguments.length;
		if (paramTypeBinding.arguments.length != length) return IMPOSSIBLE_MATCH;

		// for generic type declaration, verification is different than for parameterized type
		if (declaration) {
			// TODO (frederic) more verification to do here with type parameter bounds?
			return level;
		}

		// verify each pattern type parameter
		nextTypeArgument: for (int i= 0; i<length; i++) {
			char[] typeArgument = patternTypeArguments[i];
			TypeBinding argTypeBinding = paramTypeBinding.arguments[i];
			// get corresponding pattern wildcard
			switch (patternTypeArguments[i][0]) {
				case Signature.C_STAR : // unbound parameter always match
				case Signature.C_SUPER : // needs pattern type parameter binding
					// skip to next type argument as it will be resolved later
					continue;
				case Signature.C_EXTENDS :
					// remove wildcard from patter type argument
					typeArgument = CharOperation.subarray(typeArgument, 1, typeArgument.length);
				default :
					// no wildcard
					break;
			}
			// get pattern type argument from its signature
			typeArgument = Signature.toCharArray(typeArgument);

			// Verify that names match...
			// First if type argument is a wildcard
			if (argTypeBinding.isWildcard()) {
				WildcardBinding wildcardBinding = (WildcardBinding) argTypeBinding;
				switch (wildcardBinding.kind) {
					case Wildcard.EXTENDS:
						// We cannot know in this case...
						level = INACCURATE_MATCH;
					case Wildcard.UNBOUND:
						// there's no bound name to match => valid
						continue;
				}
				// try to match name in hierarchy
				ReferenceBinding boundBinding = (ReferenceBinding) wildcardBinding.bound;
				while (boundBinding != null) {
					if (CharOperation.equals(typeArgument, boundBinding.shortReadableName(), this.isCaseSensitive) ||
						CharOperation.equals(typeArgument, boundBinding.readableName(), this.isCaseSensitive)) {
						// found name in hierarchy => match
						continue nextTypeArgument;
					}
					boundBinding = boundBinding.superclass();
				}
				return IMPOSSIBLE_MATCH;
			}
			
			// try to match names when there's no wildcard
			// first get real binding
			ReferenceBinding refBinding = null;
			if (argTypeBinding.isArrayType()) {
				TypeBinding leafBinding = ((ArrayBinding) argTypeBinding).leafComponentType;
				if (!leafBinding.isBaseType()) {
					refBinding = (ReferenceBinding) leafBinding;
				}
			} else if (!argTypeBinding.isBaseType()) {
				refBinding = (ReferenceBinding) argTypeBinding;
			}
			// Compare name
			if (refBinding == null) {
				// Based type
				if (!CharOperation.equals(typeArgument, argTypeBinding.shortReadableName(), this.isCaseSensitive) &&
					!CharOperation.equals(typeArgument, argTypeBinding.readableName(), this.isCaseSensitive)) {
					return IMPOSSIBLE_MATCH;
				}
			} else {
				while (refBinding != null) {
					if (CharOperation.equals(typeArgument, refBinding.shortReadableName(), this.isCaseSensitive) ||
						CharOperation.equals(typeArgument, refBinding.readableName(), this.isCaseSensitive)) {
						// found name in hierarchy => match
						continue nextTypeArgument;
					}
					refBinding = refBinding.superclass();
				}
				return IMPOSSIBLE_MATCH;
			}
		}
		return level;
	}
}

