/**
 * @see SearchPattern#matchesBinary(Object, Object)
 */
public boolean matchesBinary(Object binaryInfo, Object enclosingBinaryInfo) {
	if (!this.findDeclarations) return false; // only relevant when finding declarations
	if (!(binaryInfo instanceof IBinaryMethod)) return false;

	IBinaryMethod method = (IBinaryMethod) binaryInfo;
	if (!matchesName(this.selector, method.getSelector())) return false;

	// declaring type
	if (enclosingBinaryInfo != null && (this.declaringSimpleName != null || this.declaringQualification != null)) {
		IBinaryType declaringType = (IBinaryType) enclosingBinaryInfo;
		char[] declaringTypeName = (char[]) declaringType.getName().clone();
		CharOperation.replace(declaringTypeName, '/', '.');
		if (!matchesType(this.declaringSimpleName, this.declaringQualification, declaringTypeName))
			return false;
	}

	// parameter types
	boolean checkReturnType = this.declaringSimpleName == null && (this.returnSimpleName != null || this.returnQualification != null);
	int parameterCount = this.parameterSimpleNames == null ? -1 : this.parameterSimpleNames.length;
	if (checkReturnType || parameterCount > -1) {
		String methodDescriptor = new String(method.getMethodDescriptor()).replace('/', '.');

		// look at return type only if declaring type is not specified
		if (checkReturnType) {
			String returnTypeSignature = Signature.toString(Signature.getReturnType(methodDescriptor));
			if (!matchesType(this.returnSimpleName, this.returnQualification, returnTypeSignature.toCharArray()))
				return false;
		}

		if (parameterCount > -1) {
			String[] arguments = Signature.getParameterTypes(methodDescriptor);
			if (parameterCount != arguments.length) return false;
			for (int i = 0; i < parameterCount; i++)
				if (!matchesType(this.parameterSimpleNames[i], this.parameterQualifications[i], Signature.toString(arguments[i]).toCharArray()))
					return false;
		}
	}
	return true;
}

