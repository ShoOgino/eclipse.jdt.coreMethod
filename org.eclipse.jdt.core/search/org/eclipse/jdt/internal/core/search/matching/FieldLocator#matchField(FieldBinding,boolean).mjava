protected int matchField(FieldBinding field, boolean matchName) {
	if (field == null) return INACCURATE_MATCH;

	if (matchName && !matchesName(this.pattern.name, field.readableName())) return IMPOSSIBLE_MATCH;

	FieldPattern fieldPattern = (FieldPattern)this.pattern;
	ReferenceBinding receiverBinding = field.declaringClass;
	if (receiverBinding == null) {
		if (field == ArrayBinding.ArrayLength)
			// optimized case for length field of an array
			return fieldPattern.declaringQualification == null && fieldPattern.declaringSimpleName == null
				? ACCURATE_MATCH
				: IMPOSSIBLE_MATCH;
		return INACCURATE_MATCH;
	}

	// Note there is no dynamic lookup for field access
	int declaringLevel = resolveLevelForType(fieldPattern.declaringSimpleName, fieldPattern.declaringQualification, receiverBinding);
	if (declaringLevel == IMPOSSIBLE_MATCH) return IMPOSSIBLE_MATCH;

	// look at field type only if declaring type is not specified
	if (fieldPattern.declaringSimpleName == null) return declaringLevel;

	int typeLevel = resolveLevelForType(fieldPattern.typeSimpleName, fieldPattern.typeQualification, field.type);
	
		// SEARCH_15 (frederic) Specific field pattern verification for generics (not fully tested yet...)
		if (typeLevel == IMPOSSIBLE_MATCH) {
			return IMPOSSIBLE_MATCH;
		}
		TypeBinding typeBinding = field.type;
		if (typeBinding != null) {
			boolean isParameterized = typeBinding.isParameterizedType();
			boolean isRawType = typeBinding.isRawType();
			if (fieldPattern.typeNames== null) {
				if (isParameterized && !isRawType) return IMPOSSIBLE_MATCH;
			} else {
				if (!isParameterized) return IMPOSSIBLE_MATCH;
				ParameterizedTypeBinding paramTypeBinding = (ParameterizedTypeBinding) typeBinding;
				if (paramTypeBinding.arguments == null) {
					return IMPOSSIBLE_MATCH;
				}
				int length = fieldPattern.typeNames.length;
				if (paramTypeBinding.arguments.length != length) return IMPOSSIBLE_MATCH;
				for (int i= 0; i<length; i++) {
					char[] argType = fieldPattern.typeNames[i];
					TypeBinding argTypeBinding = paramTypeBinding.arguments[i];
					if (!CharOperation.equals(argType, argTypeBinding.shortReadableName(), fieldPattern.isCaseSensitive) &&
						!CharOperation.equals(argType, argTypeBinding.readableName(), fieldPattern.isCaseSensitive)) {
						return IMPOSSIBLE_MATCH;
					}
				}
			}
		}
		/* Try to pull-up generics verification in PatternLocator?
		int typeLevel = resolveLevelForType(
				fieldPattern.typeSimpleName,
				fieldPattern.typeQualification,
				fieldPattern.typeNames,
				fieldPattern.mustResolve(),
				true // parameterized,
				field.type);
		*/
		// end

	return declaringLevel > typeLevel ? typeLevel : declaringLevel; // return the weaker match
}

