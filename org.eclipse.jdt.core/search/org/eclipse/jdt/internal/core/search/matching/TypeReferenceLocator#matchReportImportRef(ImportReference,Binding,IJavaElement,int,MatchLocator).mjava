protected void matchReportImportRef(ImportReference importRef, Binding binding, IJavaElement element, int accuracy, MatchLocator locator) throws CoreException {
	if (this.isDeclarationOfReferencedTypesPattern) {
		if ((element = findElement(element, accuracy)) != null) {
			SimpleSet knownTypes = ((DeclarationOfReferencedTypesPattern) this.pattern).knownTypes; 
			while (binding instanceof ReferenceBinding) {
				ReferenceBinding typeBinding = (ReferenceBinding) binding;
				reportDeclaration(typeBinding, 1, locator, knownTypes);
				binding = typeBinding.enclosingType();
			}
		}
		return;
	}

	ReferenceBinding typeBinding = null;
	if (binding instanceof ReferenceBinding)
		typeBinding = (ReferenceBinding) binding;

	char[][] typeTokens = importRef.tokens;
	int lastIndex = typeTokens.length-1;
	char[][] tokens = null;
	// try to match all enclosing types for which the token matches as well.
	while (typeBinding != null && lastIndex >= 0) {
		if (matchesName(this.pattern.simpleName, typeTokens[lastIndex--])) {
			int level = resolveLevelForType(this.pattern.simpleName, this.pattern.qualification, typeBinding);
			if (level != IMPOSSIBLE_MATCH) {
				tokens = new char[lastIndex+2][];
				System.arraycopy(typeTokens, 0, tokens, 0, lastIndex+2);
				break;
			}
		}
		typeBinding = typeBinding.enclosingType();
	}
	if (tokens == null) {
		tokens = typeBinding == null || typeBinding instanceof ProblemReferenceBinding
			? new char[][] {this.pattern.simpleName}
			: importRef.tokens;
		if (!this.isCaseSensitive) {
			int length = tokens.length;
			char[][] lowerCaseTokens = new char[length][];
			for (int i = 0; i < length; i++)
				lowerCaseTokens[i] = CharOperation.toLowerCase(tokens[i]);
			tokens = lowerCaseTokens;
		}
	}
	locator.reportAccurateReference(importRef.sourceStart, importRef.sourceEnd, tokens, element, accuracy);
}

