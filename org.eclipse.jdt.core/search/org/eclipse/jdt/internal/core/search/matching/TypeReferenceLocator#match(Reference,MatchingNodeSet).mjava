//public void match(ConstructorDeclaration node, MatchingNodeSet nodeSet) - SKIP IT
//public void match(Expression node, MatchingNodeSet nodeSet) - SKIP IT
//public void match(FieldDeclaration node, MatchingNodeSet nodeSet) - SKIP IT
//public void match(MethodDeclaration node, MatchingNodeSet nodeSet) - SKIP IT
//public void match(MessageSend node, MatchingNodeSet nodeSet) - SKIP IT
public void match(Reference node, MatchingNodeSet nodeSet) { // interested in NameReference & its subtypes
	if (!(node instanceof NameReference)) return;

	if (this.pattern.simpleName == null) {
		nodeSet.addMatch(node, this.pattern.mustResolve ? POTENTIAL_MATCH : ACCURATE_MATCH);
	} else if (node instanceof SingleNameReference) {
		if (matchesName(this.pattern.simpleName, ((SingleNameReference) node).token))
			nodeSet.addMatch(node, POTENTIAL_MATCH); // resolution is needed to find out if it is a type ref 
	} else {
		char[][] tokens = ((QualifiedNameReference) node).tokens;
		for (int i = 0, max = tokens.length; i < max; i++) {
			if (matchesName(this.pattern.simpleName, tokens[i])) {
				nodeSet.addMatch(node, POTENTIAL_MATCH); // resolution is needed to find out if it is a type ref
				return;
			}
		}
	}
}

