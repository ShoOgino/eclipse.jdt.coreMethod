private void locateMatchesInCompilationUnit() throws CoreException {
	// get source
	final char[] source = getContents((IFile)this.currentResource);

	// get main type name
	String pathString = this.currentResource.toString();
	int lastDot = pathString.lastIndexOf('/');
	// remove folder path and extension ".java"
	final char[] mainTypeName = pathString.substring(lastDot+1, pathString.length()-5).toCharArray(); 

	// parse
	ICompilationUnit sourceUnit = new ICompilationUnit() {
		public char[] getContents() {
			return source;
		}
		public char[] getFileName() {
			return MatchLocator.this.currentResource.getName().toCharArray();
		}
		public char[] getMainTypeName() {
			return mainTypeName;
		}
	};
	MatchSet set = new MatchSet(this);
	this.parser.matchSet = set;
	CompilationResult compilationResult = new CompilationResult(sourceUnit, 0, 0);  
	CompilationUnitDeclaration parsedUnit = this.parser.parse(sourceUnit, compilationResult);

	if (parsedUnit != null) {
		// report matches that don't need resolve
		set.cuHasBeenResolved = false;
		set.accuracy = IJavaSearchResultCollector.EXACT_MATCH;
		set.reportMatching(parsedUnit);
		
		// resolve if needed
		if (set.needsResolve()) {
			if (parsedUnit.types != null) {
				/**
				 * First approximation: reset the lookup environment -> this will recreate the bindings for the current CU
				 * Optimization: the binding resolution should be done for all compilation units at once
				 */
				this.lookupEnvironment.reset();

				try {
					lookupEnvironment.buildTypeBindings(parsedUnit);
					if (parsedUnit.scope != null) {
						lookupEnvironment.completeTypeBindings(parsedUnit, true);
						parsedUnit.scope.faultInTypes();
						parsedUnit.resolve();
						//this.pattern.initializeFromLookupEnvironment(this.lookupEnvironment);
					}
					// report matches that needed resolve
					set.cuHasBeenResolved = true;
					set.accuracy = IJavaSearchResultCollector.EXACT_MATCH;
					set.reportMatching(parsedUnit);
				} catch (AbortCompilation e) {
					// could not resolve (reasons include "could not find library class") -> ignore and report the unresolved nodes
					set.cuHasBeenResolved = false;
					set.accuracy = IJavaSearchResultCollector.POTENTIAL_MATCH;
					set.reportMatching(parsedUnit);
				}
			}
		}
	}
}

