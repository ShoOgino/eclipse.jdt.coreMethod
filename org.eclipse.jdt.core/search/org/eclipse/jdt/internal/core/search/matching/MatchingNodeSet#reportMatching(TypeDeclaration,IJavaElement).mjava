/**
 * Visit the given type declaration and report the nodes that match exactly the
 * search pattern (ie. the ones in the matching nodes set)
 * Note that the type declaration has already been checked.
 */
public void reportMatching(TypeDeclaration type, IJavaElement parent) throws CoreException {
	// create type handle
	IJavaElement enclosingElement;
	if (parent == null) {
		enclosingElement = this.locator.createTypeHandle(type.name);
	} else if (parent instanceof IType) {
		enclosingElement = this.locator.createTypeHandle((IType) parent, type.name);
		if (enclosingElement == null) return;
	} else {
		enclosingElement = parent;
	}

	// super types
	boolean searchInsideTypes = (this.matchContainer & PatternLocator.CLASS_CONTAINER) != 0;
	if (type instanceof AnonymousLocalTypeDeclaration) {
		TypeReference superType = ((AnonymousLocalTypeDeclaration) type).allocation.type;
		if (superType != null) {
			Integer level = (Integer) this.matchingNodes.removeKey(superType);
			if (level != null && searchInsideTypes)
				this.locator.reportSuperTypeReference(superType, enclosingElement, level.intValue());
		}
	} else {
		TypeReference superClass = type.superclass;
		if (superClass != null) {
			Integer level = (Integer) this.matchingNodes.removeKey(superClass);
			if (level != null && searchInsideTypes)
				this.locator.reportSuperTypeReference(superClass, enclosingElement, level.intValue());
		}
		TypeReference[] superInterfaces = type.superInterfaces;
		if (superInterfaces != null) {
			for (int i = 0, l = superInterfaces.length; i < l; i++) {
				TypeReference superInterface = superInterfaces[i];
				Integer level = (Integer) this.matchingNodes.removeKey(superInterface);
				if (level != null && searchInsideTypes)
					this.locator.reportSuperTypeReference(superInterface, enclosingElement, level.intValue());
			}
		}
	}

	// filter out element not in hierarchy scope
	boolean typeInHierarchy = type.binding == null || this.locator.typeInHierarchy(type.binding);

	FieldDeclaration[] fields = type.fields;
	if (fields != null) {
		if (this.matchingNodes.elementSize == 0) return; // reported all the matching nodes
		for (int i = 0, l = fields.length; i < l; i++) {
			FieldDeclaration field = fields[i];
			Integer level = (Integer) this.matchingNodes.removeKey(field);
			if (level != null && typeInHierarchy && searchInsideTypes)
				this.locator.reportFieldDeclaration(field, enclosingElement, level.intValue());
			reportMatching(field, enclosingElement, type, typeInHierarchy);
		}
	}

	AbstractMethodDeclaration[] methods = type.methods;
	if (methods != null) {
		if (this.matchingNodes.elementSize == 0) return; // reported all the matching nodes
		for (int i = 0, l = methods.length; i < l; i++) {
			AbstractMethodDeclaration method = methods[i];
			Integer level = (Integer) this.matchingNodes.removeKey(method);
			if (level != null && typeInHierarchy && searchInsideTypes)
				this.locator.reportMethodDeclaration(method, enclosingElement, level.intValue());
			reportMatching(method, enclosingElement, typeInHierarchy);
		}
	}

	MemberTypeDeclaration[] memberTypes = type.memberTypes;
	if (memberTypes != null) {
		for (int i = 0, l = memberTypes.length; i < l; i++) {
			if (this.matchingNodes.elementSize == 0) return; // reported all the matching nodes
			MemberTypeDeclaration memberType = memberTypes[i];
			Integer level = (Integer) this.matchingNodes.removeKey(memberType);
			if (level != null && typeInHierarchy && searchInsideTypes)
				this.locator.reportTypeDeclaration(memberType, enclosingElement, level.intValue());
			reportMatching(memberType, enclosingElement);
		}
	}
}

