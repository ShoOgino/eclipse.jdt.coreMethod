/**
 * Returns whether this package reference pattern matches the given qualified name reference.
 * Look at resolved information only if specified.
 */
protected int matchLevel(QualifiedNameReference qNameRef, boolean resolve) {
	if (!resolve)
		return matchTokens(qNameRef.tokens);

	Binding binding = qNameRef.binding;
	if (binding == null) return INACCURATE_MATCH;

	TypeBinding typeBinding = null;
	char[][] tokens = qNameRef.tokens;
	int lastIndex = tokens.length - 1;
	switch (qNameRef.bits & AstNode.RestrictiveFlagMASK) {
		case BindingIds.FIELD : // reading a field
			typeBinding = qNameRef.actualReceiverType;
			// no valid match amongst fields
			int otherBindingsCount = qNameRef.otherBindings == null ? 0 : qNameRef.otherBindings.length;			
			lastIndex -= otherBindingsCount + 1;
			if (lastIndex < 0) return IMPOSSIBLE_MATCH;
			break;
		case BindingIds.LOCAL : // reading a local variable
			return IMPOSSIBLE_MATCH; // no package match in it
		case BindingIds.TYPE : //=============only type ==============
			typeBinding = (TypeBinding)binding;
			break;
		/*
		 * Handling of unbound qualified name references. The match may reside in the resolved fragment,
		 * which is recorded inside the problem binding, along with the portion of the name until it became a problem.
		 */
		case BindingIds.VARIABLE : //============unbound cases===========
		case BindingIds.TYPE | BindingIds.VARIABLE :						
			if (binding instanceof ProblemBinding) {
				ProblemBinding pbBinding = (ProblemBinding) binding;
				typeBinding = pbBinding.searchType; // second chance with recorded type so far
				char[] partialQualifiedName = pbBinding.name;
				lastIndex = CharOperation.occurencesOf('.', partialQualifiedName) - 1; // index of last bound token is one before the pb token
				if (typeBinding == null || lastIndex < 0) return INACCURATE_MATCH;
			}
			break;					
	}
	return matchLevel(typeBinding);
}

