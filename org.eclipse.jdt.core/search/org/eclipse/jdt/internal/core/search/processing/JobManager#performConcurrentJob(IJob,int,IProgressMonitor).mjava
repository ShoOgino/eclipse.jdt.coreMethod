	/**
	 * This API is allowing to run one job in concurrence with background processing.
	 * Indeed since other jobs are performed in background, resource sharing might be 
	 * an issue.Therefore, this functionality allows a given job to be run without
	 * colliding with background ones.
	 * Note: multiple thread might attempt to perform concurrent jobs at the same time,
	 * 			and shoud synchronize (it is deliberately left to clients to decide whether
	 *			concurrent jobs might interfere or not, i.e. multiple read jobs are ok).
	 *
	 * Waiting policy can be:
	 * 		IJobConstants.ForceImmediateSearch
	 * 		IJobConstants.CancelIfNotReadyToSearch
	 * 		IJobConstants.WaitUntilReadyToSearch
	 *
	 */
	public boolean performConcurrentJob(
		IJob searchJob,
		int waitingPolicy,
		IProgressMonitor progress) {

		if (VERBOSE)
			System.out.println("-> performing concurrent job ("+ Thread.currentThread()+"): START - " + searchJob); //$NON-NLS-1$//$NON-NLS-2$
		boolean status = IJob.FAILED;
		int concurrentJobWork = 100;
		if (awaitingJobsCount() > 0) {
			switch (waitingPolicy) {

				case IJob.ForceImmediate :
					if (VERBOSE)
						System.out.println(
							"-> performing concurrent job ("+ Thread.currentThread()+"): NOT READY - ForceImmediate - " + searchJob);//$NON-NLS-1$//$NON-NLS-2$
					boolean wasEnabled = isEnabled();
					try {
						disable(); // pause indexing
						status = searchJob.execute(progress == null ? null : new SubProgressMonitor(progress, concurrentJobWork));
						if (VERBOSE)
							System.out.println("-> performing concurrent job ("+ Thread.currentThread()+"): END - " + searchJob); //$NON-NLS-1$//$NON-NLS-2$
					} finally {
						if (wasEnabled)
							enable();
					}
					return status;
				case IJob.CancelIfNotReady :
					if (VERBOSE)
						System.out.println(
							"-> performing concurrent job ("+ Thread.currentThread()+"): NOT READY - CancelIfNotReady - " + searchJob); //$NON-NLS-1$//$NON-NLS-2$
					progress.setCanceled(true);
					break;

				case IJob.WaitUntilReady :
					int awaitingWork;
					IJob previousJob = null;
					IJob currentJob;
					IProgressMonitor subProgress = null;
					int totalWork = this.awaitingJobsCount();
					if (progress != null && totalWork > 0) {
						subProgress = new SubProgressMonitor(progress, 50);
						subProgress.beginTask("", totalWork); //$NON-NLS-1$
						concurrentJobWork = 50;
					}
					while ((awaitingWork = awaitingJobsCount()) > 0) {
						if (subProgress != null && subProgress.isCanceled())
							throw new OperationCanceledException();
						currentJob = currentJob();
						// currentJob can be null when jobs have been added to the queue but job manager is not enabled
						if (currentJob != null && currentJob != previousJob) {
							if (VERBOSE)
								System.out.println(
									"-> performing concurrent job ("+ Thread.currentThread()+"): NOT READY - WaitUntilReady - " + searchJob);//$NON-NLS-1$//$NON-NLS-2$
							if (subProgress != null) {
								subProgress.subTask(
									Util.bind("manager.filesToIndex", Integer.toString(awaitingWork))); //$NON-NLS-1$
								subProgress.worked(1);
							}
							previousJob = currentJob;
						}
						try {
							Thread.currentThread().sleep(50);
						} catch (InterruptedException e) {
						}
					}
					if (subProgress != null) {
						subProgress.done();
					}
			}
		}
		status = searchJob.execute(progress == null ? null : new SubProgressMonitor(progress, concurrentJobWork));
		if (VERBOSE)
			System.out.println("-> performing concurrent job ("+ Thread.currentThread()+"): END - " + searchJob); //$NON-NLS-1$//$NON-NLS-2$
		return status;
	}

