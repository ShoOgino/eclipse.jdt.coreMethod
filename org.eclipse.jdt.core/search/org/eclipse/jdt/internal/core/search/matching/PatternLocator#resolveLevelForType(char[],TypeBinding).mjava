/**
 * Returns whether the given type binding matches the given qualified pattern.
 * Returns ACCURATE_MATCH if it does.
 * Returns INACCURATE_MATCH if resolve failed.
 * Returns IMPOSSIBLE_MATCH if it doesn't.
 */
protected int resolveLevelForType(char[] qualifiedPattern, TypeBinding type) {
	if (qualifiedPattern == null) return ACCURATE_MATCH;
	if (type == null) return INACCURATE_MATCH;

	// Type variable cannot be specified through pattern => this kind of binding cannot match it (see bug 79803)
	if (type.isTypeVariable()) return IMPOSSIBLE_MATCH;

	// NOTE: if case insensitive search then qualifiedPattern is assumed to be lowercase

	char[] qualifiedPackageName = type.qualifiedPackageName();
	char[] qualifiedSourceName = qualifiedSourceName(type);
	char[] fullyQualifiedTypeName = qualifiedPackageName.length == 0
		? qualifiedSourceName
		: CharOperation.concat(qualifiedPackageName, qualifiedSourceName, '.');
	if (this.isCamelCase) {
		if (!this.isCaseSensitive || (qualifiedPattern.length>0 && fullyQualifiedTypeName.length>0 && qualifiedPattern[0] == fullyQualifiedTypeName[0])) {
			if (CharOperation.camelCaseMatch(qualifiedPattern, fullyQualifiedTypeName)) {
				return ACCURATE_MATCH;
			}
			if (!this.isCaseSensitive && (this.matchMode & SearchPattern.R_PREFIX_MATCH) != 0) {
				if (CharOperation.prefixEquals(qualifiedPattern, fullyQualifiedTypeName, this.isCaseSensitive)) {
					return ACCURATE_MATCH;
				}
			}
		}
	}
	return CharOperation.match(qualifiedPattern, fullyQualifiedTypeName, this.isCaseSensitive)
		? ACCURATE_MATCH
		: IMPOSSIBLE_MATCH;
}

