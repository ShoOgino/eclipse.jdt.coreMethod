	private void indexClassFile(byte[] contents, char[] documentName)
		throws IOException {
		try {
			ClassFileReader reader = new ClassFileReader(contents, documentName);
			// we don't want to index local and anonymous classes
			if (reader.isLocal() || reader.isAnonymous())
				return;

			int[] constantPoolOffsets = reader.getConstantPoolOffsets();

			// first add type references
			char[] className = replace('/', '.', reader.getName());
			// looks like java/lang/String
			// need to extract the package name and the simple name
			int packageNameIndex = CharOperation.lastIndexOf('.', className);
			char[] packageName = null;
			char[] name = null;
			if (packageNameIndex >= 0) {
				packageName = CharOperation.subarray(className, 0, packageNameIndex);
				name =
					CharOperation.subarray(className, packageNameIndex + 1, className.length);
			} else {
				name = className;
			}
			char[] enclosingTypeName = null;
			if (reader.isNestedType()) {
				name = reader.getInnerSourceName();
				char[] fullEnclosingName = reader.getEnclosingTypeName();
				int nameLength = fullEnclosingName.length - packageNameIndex - 1;
				enclosingTypeName = new char[nameLength];
				System.arraycopy(
					fullEnclosingName,
					packageNameIndex + 1,
					enclosingTypeName,
					0,
					nameLength);
			}
			// eliminate invalid innerclasses (1G4KCF7)
			if (name == null)
				return;

			char[][] superinterfaces = replace('/', '.', reader.getInterfaceNames());
			if (DEBUG) {
				if (packageName != null) {
					System.out.println("package name = " + new String(packageName));
				}
				if (name != null) {
					System.out.println("class name = " + new String(name));
				}
				if (superinterfaces != null) {
					for (int i = 0, max = superinterfaces.length; i < max; i++) {
						System.out.println(
							"superinterfaces[" + i + "]= " + new String(superinterfaces[i]));
					}
				}
			}
			char[][] enclosingTypeNames =
				enclosingTypeName == null ? null : new char[][] { enclosingTypeName };
			if (reader.isInterface()) {
				addInterfaceDeclaration(
					reader.getModifiers(),
					packageName,
					name,
					enclosingTypeNames,
					superinterfaces);
			} else {
				char[] superclass = replace('/', '.', reader.getSuperclassName());
				if (DEBUG) {
					if (superclass != null) {
						System.out.println("superclass name = " + new String(superclass));
					}
				}
				addClassDeclaration(
					reader.getModifiers(),
					packageName,
					name,
					enclosingTypeNames,
					superclass,
					superinterfaces);
			}

			// first reference all methods declarations and field declarations
			MethodInfo[] methods = (MethodInfo[]) reader.getMethods();
			if (methods != null) {
				for (int i = 0, max = methods.length; i < max; i++) {
					MethodInfo method = methods[i];
					char[] descriptor = method.getMethodDescriptor();
					char[][] parameterTypes = decodeParameterTypes(descriptor);
					char[] returnType = decodeReturnType(descriptor);
					char[][] exceptionTypes = replace('/', '.', method.getExceptionTypeNames());
					if (DEBUG) {
						if (method.getSelector() != null) {
							System.out.println("method selector = " + new String(method.getSelector()));
						}
						if (parameterTypes != null) {
							for (int j = 0, max2 = parameterTypes.length; j < max2; j++) {
								System.out.println(
									"parameterTypes[" + j + "]= " + new String(parameterTypes[j]));
							}
						}
						if (returnType != null) {
							System.out.println("return type = " + new String(returnType));
						}
						if (exceptionTypes != null) {
							for (int j = 0, max2 = exceptionTypes.length; j < max2; j++) {
								System.out.println(
									"exceptionTypes[" + j + "]= " + new String(exceptionTypes[j]));
							}
						}
					}
					if (method.isConstructor()) {
						addConstructorDeclaration(className, parameterTypes, exceptionTypes);
					} else {
						if (!method.isClinit()) {
							addMethodDeclaration(
								method.getSelector(),
								parameterTypes,
								returnType,
								exceptionTypes);
						}
					}
				}
			}
			FieldInfo[] fields = (FieldInfo[]) reader.getFields();
			if (fields != null) {
				for (int i = 0, max = fields.length; i < max; i++) {
					FieldInfo field = fields[i];
					char[] fieldName = field.getName();
					char[] fieldType = decodeFieldType(replace('/', '.', field.getTypeName()));
					if (DEBUG) {
						if (fieldName != null) {
							System.out.println("field name = " + new String(fieldName));
						}
						if (fieldType != null) {
							System.out.println("field type = " + new String(fieldType));
						}
					}
					addFieldDeclaration(fieldType, fieldName);
				}
			}

			// record all references found inside the .class file
			if (needReferences) {
				extractReferenceFromConstantPool(contents, reader);
			}
		} catch (ClassFormatException e) {
		}
	}

