/**
 * Returns whether this type pattern matches the given import reference.
 * Look at resolved information only if specified.
 */
private int matchLevel(ImportReference importRef, boolean resolve) {

	char[][] tokens = importRef.tokens;
	int importLength = tokens.length;
	
	if (this.qualification != null) {
		char[] pattern;
		if (this.simpleName == null) {
			pattern = this.qualification;
		} else {
			pattern = CharOperation.concat(this.qualification, this.simpleName, '.');
		}
		char[] qualifiedTypeName = CharOperation.concatWith(importRef.tokens, '.');
		switch (this.matchMode) {
			case EXACT_MATCH :
			case PREFIX_MATCH :
				if (CharOperation.prefixEquals(pattern, qualifiedTypeName, this.isCaseSensitive)) {
					return POSSIBLE_MATCH;
				} 
				break;
			case PATTERN_MATCH:
				if (CharOperation.match(pattern, qualifiedTypeName, this.isCaseSensitive)) {
					return POSSIBLE_MATCH;
				}
				break;
		}
		return IMPOSSIBLE_MATCH;
	} else {
		if (this.simpleName == null) {
			return this.needsResolve ? POSSIBLE_MATCH : ACCURATE_MATCH;
		} else {
			for (int i = 0; i < importLength; i++){
				if (this.matchesName(this.simpleName, tokens[i])){
					return this.needsResolve ? POSSIBLE_MATCH : ACCURATE_MATCH;
				}
			}
			return IMPOSSIBLE_MATCH;
		}
	}
}

