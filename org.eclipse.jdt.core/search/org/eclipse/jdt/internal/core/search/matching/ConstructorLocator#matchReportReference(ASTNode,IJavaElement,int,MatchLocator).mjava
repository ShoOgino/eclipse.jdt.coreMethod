protected void matchReportReference(ASTNode reference, IJavaElement element, int accuracy, MatchLocator locator) throws CoreException {

	MethodBinding constructorBinding = null;
	boolean isSynthetic = false;
	if (reference instanceof ExplicitConstructorCall) {
		isSynthetic = ((ExplicitConstructorCall) reference).isImplicitSuper();
		constructorBinding = ((ExplicitConstructorCall) reference).binding;
	} else if (reference instanceof AllocationExpression) {
		constructorBinding = ((AllocationExpression) reference).binding;
	} else if (reference instanceof TypeDeclaration || reference instanceof FieldDeclaration) {
		super.matchReportReference(reference, element, accuracy, locator);
	}

	// Look to refine accuracy
	int rule = SearchPattern.R_EXACT_MATCH;
	int refinedAccuracy = accuracy;
	if (constructorBinding instanceof ParameterizedGenericMethodBinding) { // parameterized generic method
		ParameterizedGenericMethodBinding parameterizedMethodBinding = (ParameterizedGenericMethodBinding) constructorBinding;
		refinedAccuracy = refineAccuracy(accuracy, parameterizedMethodBinding.typeArguments, locator, this.pattern.constructorArguments, this.pattern.hasConstructorParameters());
		
		if (constructorBinding.declaringClass.isParameterizedType() || constructorBinding.declaringClass.isRawType()) {
			ParameterizedTypeBinding parameterizedBinding = (ParameterizedTypeBinding)constructorBinding.declaringClass;
			if (!this.pattern.hasTypeArguments() && this.pattern.hasConstructorArguments()) {
				// special case for constructor pattern which defines arguments but no type
				// in this case, we only use refined accuracy for constructor
			} else if (this.pattern.hasTypeArguments() && !this.pattern.hasConstructorArguments()) {
				// special case for constructor pattern which defines no constructor arguments but has type ones
				// in this case, we do not use refined accuracy
				refinedAccuracy = refineAccuracy(accuracy, parameterizedBinding, this.pattern.getTypeArguments(), this.pattern.hasTypeParameters(), 0, locator);
			} else {
				refinedAccuracy = refineAccuracy(refinedAccuracy, parameterizedBinding, this.pattern.getTypeArguments(), this.pattern.hasTypeParameters(), 0, locator);
			}
			if (refinedAccuracy == -1) return;
		} else if (this.pattern.hasTypeArguments()) {
			rule = SearchPattern.R_ERASURE_MATCH;
		}
	} else if (constructorBinding instanceof ParameterizedMethodBinding) {
		if (constructorBinding.declaringClass.isParameterizedType() || constructorBinding.declaringClass.isRawType()) {
			ParameterizedTypeBinding parameterizedBinding = (ParameterizedTypeBinding)constructorBinding.declaringClass;
			if (!this.pattern.hasTypeArguments() && this.pattern.hasConstructorArguments()) {
				// special case for constructor pattern which defines arguments but no type
				refinedAccuracy = refineAccuracy(refinedAccuracy, parameterizedBinding, new char[][][] {this.pattern.constructorArguments}, this.pattern.hasTypeParameters(), 0, locator);
			} else {
				refinedAccuracy = refineAccuracy(refinedAccuracy, parameterizedBinding, this.pattern.getTypeArguments(), this.pattern.hasTypeParameters(), 0, locator);
			}
			if (refinedAccuracy == -1) return;
		} else if (this.pattern.hasTypeArguments()) {
			rule = SearchPattern.R_ERASURE_MATCH;
		}
	} else if (this.pattern.hasConstructorArguments()) { // binding has no type params, compatible erasure if pattern does
		rule = SearchPattern.R_ERASURE_MATCH;
	}

	// See whether it is necessary to report or not
	boolean report = refinedAccuracy != -1; // impossible match
	if (report && (refinedAccuracy & SearchPattern.R_ERASURE_MATCH) != 0) { // erasure match
		if ((refinedAccuracy & SearchPattern.R_EQUIVALENT_MATCH) != 0) { // raw match
			report = this.isEquivalentMatch || this.isErasureMatch; // report only if pattern is equivalent or erasure
		} else {
			report = this.isErasureMatch; // report only if pattern is erasure
		}
	}
	else if (report && (refinedAccuracy & SearchPattern.R_EQUIVALENT_MATCH) != 0) { // equivalent match
		report  = this.isEquivalentMatch || this.isErasureMatch; // report only if pattern is equivalent or erasure
	}
	if (!report) return;

	// Set rule
	if (rule != SearchPattern.R_ERASURE_MATCH) {
		rule |= refinedAccuracy & RULE_MASK;
	}
	refinedAccuracy = refinedAccuracy & (~RULE_MASK);

	// Report match
	int offset = reference.sourceStart;
	SearchMatch match = locator.newMethodReferenceMatch(element,
			accuracy,
			offset,
			reference.sourceEnd - offset + 1,
			true, //isConstructor,
			isSynthetic,
			reference);
	match.setMatchRule(rule);
	locator.report(match);
}

