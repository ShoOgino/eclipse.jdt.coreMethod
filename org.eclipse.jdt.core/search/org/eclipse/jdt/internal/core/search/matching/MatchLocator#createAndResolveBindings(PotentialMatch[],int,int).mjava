	/**
	 * Add the initial set of compilation units into the loop
	 *  ->  build compilation unit declarations, their bindings and record their results.
	 */
	protected void createAndResolveBindings(PotentialMatch[] potentialMatches, int start, int length) {

		for (int i = start, maxUnits = start+length; i < maxUnits; i++) {
			if (this.progressMonitor != null && this.progressMonitor.isCanceled()) {
				throw new OperationCanceledException();
			}
			PotentialMatch potentialMatch = potentialMatches[i];
			try {
				if (potentialMatch != null) {
					this.parser.matchSet = potentialMatch.matchingNodeSet;
				}
				CompilationResult unitResult =
					new CompilationResult(potentialMatch, i, maxUnits, this.options.maxProblemsPerUnit);
					
				if (SearchEngine.VERBOSE) {
					System.out.println("Parsing " + potentialMatch.openable.toStringWithAncestors()); //$NON-NLS-1$
				}

				// diet parsing for large collection of units
				CompilationUnitDeclaration parsedUnit;
				if (totalUnits < parseThreshold) {
					parsedUnit = this.parser.parse(potentialMatch, unitResult);
				} else {
					parsedUnit = this.parser.dietParse(potentialMatch, unitResult);
				}
								
				// initial type binding creation
				if (parsedUnit != null && !parsedUnit.isEmpty()) {
					this.lookupEnvironment.buildTypeBindings(parsedUnit);
				}
				
				this.addCompilationUnit(potentialMatch, parsedUnit);
				
				// progress reporting
				if (this.progressMonitor != null) {
					this.progressMonitor.worked(4);
				}
			} finally {
				this.parser.matchSet = null;
				potentialMatches[i] = null; // no longer hold onto the unit
			}
		}
		// binding resolution
		lookupEnvironment.completeTypeBindings();
	}

