/*
 * Return whether the given type binding or one of its possible super interfaces
 * matches a type in the declaring type names hierarchy.
 */
protected boolean resolveLevelAsSuperInvocation(ReferenceBinding type, TypeBinding[] argumentTypes, boolean verifyMethod) {
	char[][] compoundName = type.compoundName;
	for (int i = 0, max = this.allSuperDeclaringTypeNames.length; i < max; i++) {
		if (CharOperation.equals(this.allSuperDeclaringTypeNames[i], compoundName)) {
			if (!verifyMethod) return true;
			// need to verify if the type implements the pattern method
			MethodBinding[] methods = type.getMethods(this.pattern.selector);
			for (int j=0, length=methods.length; j<length; j++) {
				MethodBinding method = methods[j];
				TypeBinding[] parameters = method.parameters;
				if (argumentTypes.length == parameters.length) {
					boolean found = true;
					for (int k=0,l=parameters.length; k<l; k++) {
						if (parameters[k].erasure() != argumentTypes[k].erasure()) {
							found = false;
							break;
						}
					}
					if (found) {
						return true;
					}
				}
			}
			break;
		}
	}

	// maybe super interfaces?
	if (type.isInterface()) {
		ReferenceBinding[] interfaces = type.superInterfaces();
		if (interfaces == null) return false;
		for (int i = 0; i < interfaces.length; i++) {
			if (resolveLevelAsSuperInvocation(interfaces[i], argumentTypes, true)) {
				return true;
			}
		}
	}
	return false;
}

