	/**
	 * Searches for matches to a given query. Search queries can be created using helper
	 * methods (from a String pattern or a Java element) and encapsulate the description of what is
	 * being searched (for example, search method declarations in a case sensitive way).
	 *
	 * @param scope the search result has to be limited to the given scope
	 * @param resultCollector a callback object to which each match is reported
	 */
	public void findMatches(SearchParticipant[] participants, IJavaSearchScope scope, SearchRequestor requestor, IProgressMonitor monitor) throws CoreException {
		
		if (monitor != null && monitor.isCanceled()) throw new OperationCanceledException();
		
		/* initialize progress monitor */
		if (monitor != null) {
			monitor.beginTask(Util.bind("engine.searching"), 100); //$NON-NLS-1$
		}

		if (SearchEngine.VERBOSE) {
			System.out.println("Searching for " + this + " in " + scope); //$NON-NLS-1$//$NON-NLS-2$
		}
	
		IndexManager indexManager = JavaModelManager.getJavaModelManager().getIndexManager();
		try {
			requestor.beginReporting();
			
			for (int iParticipant = 0, length = participants == null ? 0 : participants.length; iParticipant < length; iParticipant++) {
				
				if (monitor != null && monitor.isCanceled()) throw new OperationCanceledException();
	
				SearchParticipant participant = participants[iParticipant];
				try {
					participant.beginSearching();
					requestor.enterParticipant(participant);
		
					// find index matches			
					PathCollector pathCollector = new PathCollector();
					indexManager.performConcurrentJob(
						new PatternSearchJob(
							(SearchPattern)this, 
							participant,
							scope, 
							pathCollector),
						IJavaSearchConstants.WAIT_UNTIL_READY_TO_SEARCH,
						monitor);
					if (monitor != null && monitor.isCanceled()) throw new OperationCanceledException();
		
					// locate index matches if any (note that all search matches could have been issued during index querying)
					String[] indexMatchPaths = pathCollector.getPaths();
					pathCollector = null; // release
					int indexMatchLength = indexMatchPaths == null ? 0 : indexMatchPaths.length;
					SearchDocument[] indexMatches = new SearchDocument[indexMatchLength];
					for (int iMatch = 0;iMatch < indexMatchLength; iMatch++) {
						String documentPath = indexMatchPaths[iMatch];
						indexMatches[iMatch] = participant.getDocument(documentPath);
					}
					participant.locateMatches(indexMatches, (SearchPattern)this, scope, requestor, monitor);
				} finally {		
					requestor.exitParticipant(participant);
					participant.doneSearching();
				}

				if (monitor != null && monitor.isCanceled()) throw new OperationCanceledException();
			}
		} finally {
			requestor.endReporting();
			if (monitor != null) monitor.done();
		}
	}			

