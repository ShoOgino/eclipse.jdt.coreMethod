/*
 * Refine accuracy for a match at a specified depth of enclosing type until find top level one.
 * This is done comparing for each type argument pattern and match bindings.
 */
private int refineAccuracy(int accuracy, ParameterizedTypeBinding parameterizedBinding, char[][][] patternTypeArguments, int depth, MatchLocator locator) {

	// Refine at this depth only if there's type arguments
	int patternTypeArgsLength = patternTypeArguments[depth].length;
	if (patternTypeArgsLength != 0) {
		// First compare lengthes
		TypeBinding[] argumentsBinding = parameterizedBinding.arguments;
		int typeArgumentsLength = argumentsBinding == null ? 0 : argumentsBinding.length;
		if (patternTypeArgsLength != typeArgumentsLength) return -1;
		
		// Compare binding for each type argument
		for (int i=0; i<typeArgumentsLength; i++) {
			// Get binding for pattern argument
			char[] patternTypeArgument = patternTypeArguments[depth][i];
			char patternWildcard = patternTypeArgument[0];
			char[] patternTypeName = patternTypeArgument;
			char wildcard = patternTypeArgument[0];
			switch (wildcard) {
				case Signature.C_STAR:
					continue; // unbound parameter always match
				case Signature.C_EXTENDS :
				case Signature.C_SUPER :
					patternTypeName = CharOperation.subarray(patternTypeArgument, 1, patternTypeArgument.length);
				default :
					break;
			}
			patternTypeName = Signature.toCharArray(patternTypeName);
			TypeBinding patternBinding = locator.getType(patternTypeArgument, patternTypeName);
			
			// If have no binding for pattern arg, then we won't be able to refine accuracy
			if (patternBinding == null) return accuracy;
				
			// Verify tha pattern binding is compatible with match type argument binding
			TypeBinding argumentBinding = argumentsBinding[i];
			switch (patternWildcard) {
				case Signature.C_STAR : // UNBOUND pattern
					// unbound always match => skip to next argument
					continue;
				case Signature.C_EXTENDS : // EXTENDS pattern
					if (argumentBinding.isWildcard()) {
						WildcardBinding wildcardBinding = (WildcardBinding) argumentBinding;
						switch (wildcardBinding.kind) {
							case Wildcard.EXTENDS:
								if (wildcardBinding.bound== null || wildcardBinding.bound.isCompatibleWith(patternBinding))
									// valid when arg extends a subclass of pattern
									continue;
								break;
							case Wildcard.SUPER:
								break;
							case Wildcard.UNBOUND:
								continue;
						}
					} else if (argumentBinding.isCompatibleWith(patternBinding)) {
						// valid when arg is a subclass of pattern 
						continue;
					}
					break;
				case Signature.C_SUPER : // SUPER pattern
					if (argumentBinding.isWildcard()) {
						WildcardBinding wildcardBinding = (WildcardBinding) argumentBinding;
						switch (wildcardBinding.kind) {
							case Wildcard.EXTENDS:
								break;
							case Wildcard.SUPER:
								if (wildcardBinding.bound== null || patternBinding.isCompatibleWith(wildcardBinding.bound))
									// valid only when arg super a superclass of pattern
									continue;
								break;
							case Wildcard.UNBOUND:
								continue;
						}
					} else if (patternBinding.isCompatibleWith(argumentBinding)) {
						// valid only when arg is a superclass of pattern
						continue;
					}
					break;
				default:
					if (argumentBinding.isWildcard()) {
						WildcardBinding wildcardBinding = (WildcardBinding) argumentBinding;
						switch (wildcardBinding.kind) {
							case Wildcard.EXTENDS:
								if (wildcardBinding.bound== null || patternBinding.isCompatibleWith(wildcardBinding.bound))
									// valid only when arg extends a superclass of pattern
									continue;
								break;
							case Wildcard.SUPER:
								if (wildcardBinding.bound== null || wildcardBinding.bound.isCompatibleWith(patternBinding))
									// valid only when arg super a subclass of pattern
									continue;
								break;
							case Wildcard.UNBOUND:
								continue;
						}
					} else if (argumentBinding == patternBinding)
						// valid only when arg is equals to pattern
						continue;
					break;
			}
			
			// Refine the accuracy to impossible
			return -1;
		}
	}

	// Recurse refining on enclosing types if any
	TypeBinding enclosingType = parameterizedBinding.enclosingType();
	if (enclosingType != null && enclosingType.isParameterizedType() && (depth+1) < patternTypeArguments.length) {
		return refineAccuracy(accuracy, (ParameterizedTypeBinding)enclosingType, patternTypeArguments, depth+1, locator);
	}
	
	// Refine the accuracy to accurate
	return SearchMatch.A_ACCURATE;
}

