/**
 * Reports the match of the given qualified name reference.
 */
protected void matchReportReference(QualifiedNameReference qNameRef, IJavaElement element, int accuracy, MatchLocator locator) throws CoreException {
	char[][] tokens = null;
	Binding binding = qNameRef.binding;
	TypeBinding typeBinding = null;
	char[][] nameTokens = qNameRef.tokens;
	int lastIndex = nameTokens.length-1;
	switch (qNameRef.bits & AstNode.RestrictiveFlagMASK) {
		case BindingIds.FIELD : // reading a field
			typeBinding = ((FieldBinding)binding).declaringClass;
			int otherBindingsCount = qNameRef.otherBindings == null ? 0 : qNameRef.otherBindings.length;			
			lastIndex -= otherBindingsCount + 1;
			break;
		case BindingIds.TYPE : //=============only type ==============
			typeBinding = (TypeBinding)binding;
	}
	// try to match all enclosing types for which the token matches as well.
	while (typeBinding != null && lastIndex >= 0){
		if (this.matchesName(this.simpleName, nameTokens[lastIndex--])) {
			int level = this.matchLevelForType(this.simpleName, this.qualification, typeBinding);
			if (level != IMPOSSIBLE_MATCH) {
				tokens = new char[lastIndex+2][];
				System.arraycopy(nameTokens, 0, tokens, 0, lastIndex+2);
				break;
			}
		}
		if (typeBinding instanceof ReferenceBinding){
			typeBinding = ((ReferenceBinding)typeBinding).enclosingType();
		} else {
			typeBinding = null;
		}
	} 
	if (tokens == null) {
		tokens = qNameRef.tokens;
	}
	locator.reportAccurateReference(qNameRef.sourceStart, qNameRef.sourceEnd, tokens, element, accuracy);
}

