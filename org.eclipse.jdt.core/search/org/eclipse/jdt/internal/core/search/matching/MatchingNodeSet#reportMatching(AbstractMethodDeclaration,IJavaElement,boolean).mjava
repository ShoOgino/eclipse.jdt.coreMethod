/**
 * Visit the given method declaration and report the nodes that match exactly the
 * search pattern (ie. the ones in the matching nodes set)
 * Note that the method declaration has already been checked.
 */
private void reportMatching(AbstractMethodDeclaration method, IJavaElement parent, boolean typeInHierarchy) throws CoreException {
	// declaration in this method
	// (NB: declarations must be searched first (see bug 20631 Declaration of local binary type not found)
	if ((method.bits & AstNode.HasLocalTypeMASK) != 0) {
		LocalDeclarationVisitor localDeclarationVisitor = new LocalDeclarationVisitor();
		localDeclarationVisitor.enclosingElement = 
			(parent instanceof IType) ?
				this.locator.createMethodHandle(method, (IType)parent) :
				parent;
		try {
			method.traverse(localDeclarationVisitor, (ClassScope)null);
		} catch (WrappedCoreException e) {
			throw e.coreException;
		}
	}
	
	// references in this method
	if (typeInHierarchy) {
		AstNode[] nodes = this.matchingNodes(method.declarationSourceStart, method.declarationSourceEnd);
		for (int i = 0; i < nodes.length; i++) {
			AstNode node = nodes[i];
			Integer level = (Integer)this.matchingNodes.get(node);
			if ((this.matchContainer & SearchPattern.METHOD) != 0) {
				this.locator.reportReference(
					node, 
					method, 
					parent, 
					level.intValue() == SearchPattern.ACCURATE_MATCH ?
						IJavaSearchResultCollector.EXACT_MATCH :
						IJavaSearchResultCollector.POTENTIAL_MATCH);
				this.matchingNodes.remove(node);
			}
		}
	}
	if (this.potentialMatchingNodes(method.declarationSourceStart, method.declarationSourceEnd).length == 0) {
		// no need to resolve the statements in the method
		method.statements = null;
	}
}

