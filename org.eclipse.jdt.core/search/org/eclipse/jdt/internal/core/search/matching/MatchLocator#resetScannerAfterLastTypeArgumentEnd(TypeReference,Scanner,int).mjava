/* (non-Javadoc)
 * Reset scanner after last type argument end. This may be called recursively for nested parameterized
 * type arguments.
 * Returns depth of nesting for the last argument.
 */
private int resetScannerAfterLastTypeArgumentEnd(TypeReference typeRef, Scanner scanner, int depth) {
	// Default end is current type argument end
	int end = typeRef.sourceEnd;
	// Get last list of type arguments for parameterized qualified type reference
	TypeReference[] typeArguments = null;
	if (typeRef instanceof ParameterizedQualifiedTypeReference) {
		ParameterizedQualifiedTypeReference pqtRef = (ParameterizedQualifiedTypeReference) typeRef;
		TypeReference[] last = null;
		for (int i=pqtRef.typeArguments.length-1; i>=0 && last==null; i++) {
			last = pqtRef.typeArguments[i];
		}
		// If no children arguments then current type reference is the last type argument
		if (last == null) {
			scanner.resetTo(end+1, scanner.eofPosition-1);
			return depth;
		}
		typeArguments = last;
	}
	// Get last type argument for single type reference of last list of argument of parameterized qualified type reference
	if (typeRef instanceof ParameterizedSingleTypeReference || typeArguments != null) {
		if (typeArguments == null) {
			typeArguments = ((ParameterizedSingleTypeReference)typeRef).typeArguments;
		}
		TypeReference last = null;
		for (int i=typeArguments.length-1; i>=0 && last==null; i++) {
			last = typeArguments[i];
		}
		// If no child argument then current type reference is the last type argument
		if (last == null) {
			scanner.resetTo(end+1, scanner.eofPosition-1);
			return depth;
		}
		// Loop on last type argument to find its last type argument...
		return resetScannerAfterLastTypeArgumentEnd(last, scanner, depth+1);
	}
	// Current type reference is not parameterized. So, it is the last type argument
	scanner.resetTo(end+1, scanner.eofPosition-1);
	return depth;
}

