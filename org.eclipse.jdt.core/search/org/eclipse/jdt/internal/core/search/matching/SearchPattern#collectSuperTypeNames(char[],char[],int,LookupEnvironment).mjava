/**
 * Collects the super type names of the given declaring type.
 * Returns NOT_FOUND_DECLARING_TYPE if the declaring type was not found.
 * Returns null if the declaring type pattern doesn't require an exact match.
 */
protected char[][][] collectSuperTypeNames(char[] declaringQualification, char[] declaringSimpleName, int matchMode, LookupEnvironment env) {

	char[][] declaringTypeName = null;
	if (declaringQualification != null 
			&& declaringSimpleName != null
			&& matchMode == EXACT_MATCH) {
		char[][] qualification = CharOperation.splitOn('.', declaringQualification);
		declaringTypeName = CharOperation.arrayConcat(qualification, declaringSimpleName);
	}
	if (declaringTypeName != null) {
		for (int i = 0, max = declaringTypeName.length; i < max; i++) {
			ReferenceBinding matchingDeclaringType = env.askForType(declaringTypeName);
			if (matchingDeclaringType != null 
				&& (matchingDeclaringType.isValidBinding()
					|| matchingDeclaringType.problemId() != ProblemReasons.NotFound)) {
				return this.collectSuperTypeNames(matchingDeclaringType);
			}
			// if nothing is in the cache, it could have been a member type (A.B.C.D --> A.B.C$D)
			int last = declaringTypeName.length - 1;
			if (last == 0) break; 
			declaringTypeName[last-1] = CharOperation.concat(declaringTypeName[last-1], declaringTypeName[last], '$'); // try nested type
			declaringTypeName = CharOperation.subarray(declaringTypeName, 0, last);
		}
		return NOT_FOUND_DECLARING_TYPE; // the declaring type was not found 
	} else {
		// non exact match: use the null value so that matches is more tolerant
		return null;
	}
}

