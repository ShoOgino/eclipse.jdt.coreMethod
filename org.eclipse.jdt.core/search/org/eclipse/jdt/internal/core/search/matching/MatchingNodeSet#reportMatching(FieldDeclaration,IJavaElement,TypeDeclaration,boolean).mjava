/**
 * Visit the given field declaration and report the nodes that match exactly the
 * search pattern (ie. the ones in the matching nodes set)
 * Note that the field declaration has already been checked.
 */
private void reportMatching(FieldDeclaration field, IJavaElement parent, TypeDeclaration type, boolean typeInHierarchy) throws CoreException {
	// handle the nodes for the local type first
	if ((field.bits & AstNode.HasLocalTypeMASK) != 0) {
		LocalDeclarationVisitor localDeclarationVisitor = new LocalDeclarationVisitor(
			(parent instanceof IType)
				? (field.isField()
					? (IJavaElement) this.locator.createFieldHandle(field, (IType) parent)
					: (IJavaElement) this.locator.createInitializerHandle(type, field, (IType) parent))
				: parent);
		try {
			field.traverse(localDeclarationVisitor, null);
		} catch (WrappedCoreException e) {
			throw e.coreException;
		}
	}

	if (typeInHierarchy) {
		AstNode[] nodes = matchingNodes(field.declarationSourceStart, field.declarationSourceEnd);
		if (nodes != null) {
			for (int i = 0, l = nodes.length; i < l; i++) {
				AstNode node = nodes[i];
				Integer level = (Integer) this.matchingNodes.removeKey(node);
				if ((this.matchContainer & SearchPattern.FIELD) != 0)
					this.locator.reportReference(node, type, field, parent, level.intValue());
			}
		}
	}
}

