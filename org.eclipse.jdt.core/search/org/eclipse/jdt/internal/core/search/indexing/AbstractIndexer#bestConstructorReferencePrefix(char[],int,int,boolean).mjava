/**
 * Constructor reference entries are encoded as follow: 'constructorRef/' TypeName '/' Arity:
 * 	e.g.&nbsp;constructorRef/X/0&nbsp;constructorRef/Y/1
 *
 */
 public static final char[] bestConstructorReferencePrefix(char[] typeName, int arity, int matchMode, boolean isCaseSensitive) {

	if (!isCaseSensitive || typeName == null) return CONSTRUCTOR_REF;
	switch(matchMode){
		case EXACT_MATCH :
			if (arity >= 0){
				char[] countChars;
				if (arity < 10) {
					countChars = COUNTS[arity];
				} else {
					countChars = String.valueOf(arity).toCharArray();
				}
				return concat(CONSTRUCTOR_REF, typeName, countChars, SEPARATOR);
			}
		case PREFIX_MATCH :
			return CharOperation.concat(CONSTRUCTOR_REF, typeName);
		case PATTERN_MATCH :
			int starPos = CharOperation.indexOf('*', typeName);
			switch(starPos) {
				case -1 :
					return CharOperation.concat(CONSTRUCTOR_REF, typeName);
				default : 
					int refLength = CONSTRUCTOR_REF.length;
					char[] result = new char[refLength+starPos];
					System.arraycopy(CONSTRUCTOR_REF, 0, result, 0, refLength);
					System.arraycopy(typeName, 0, result, refLength, starPos);
					return result;
				case 0 : // fall through
			}
		default:
			return CONSTRUCTOR_REF;
	}
}

