/**
 * Reports the match of the given qualified type reference.
 */
protected void matchReportReference(QualifiedTypeReference qTypeRef, IJavaElement element, int accuracy, MatchLocator locator) throws CoreException {
	char[][] tokens = null;
	TypeBinding typeBinding = qTypeRef.binding;
	if (typeBinding instanceof ArrayBinding) {
		typeBinding = ((ArrayBinding)typeBinding).leafComponentType;
	}
	char[][] typeTokens = qTypeRef.tokens;
	int lastIndex = typeTokens.length-1;
	// try to match all enclosing types for which the token matches as well.
	while (typeBinding != null && lastIndex >= 0){
		if (matchesName(this.simpleName, typeTokens[lastIndex--])) {
			int level = this.matchLevelForType(this.simpleName, this.qualification, typeBinding);
			if (level != IMPOSSIBLE_MATCH) {
				tokens = new char[lastIndex+2][];
				System.arraycopy(typeTokens, 0, tokens, 0, lastIndex+2);
				break;
			}
		}
		if (typeBinding instanceof ReferenceBinding){
			typeBinding = ((ReferenceBinding)typeBinding).enclosingType();
		} else {
			typeBinding = null;
		}
	}
	if (tokens == null) {
		if (typeBinding == null || typeBinding instanceof ProblemReferenceBinding) {
			tokens = new char[][] {this.simpleName};
		} else {
			tokens = qTypeRef.tokens;
		}
		if (!this.isCaseSensitive) {
			int length = tokens.length;
			char[][] lowerCaseTokens = new char[length][];
			for (int i = 0; i < length; i++) {
				char[] token = tokens[i];
				lowerCaseTokens[i] = CharOperation.toLowerCase(token);
			}
			tokens = lowerCaseTokens;
		}
	}
	locator.reportAccurateReference(qTypeRef.sourceStart, qTypeRef.sourceEnd, tokens, element, accuracy);
}

