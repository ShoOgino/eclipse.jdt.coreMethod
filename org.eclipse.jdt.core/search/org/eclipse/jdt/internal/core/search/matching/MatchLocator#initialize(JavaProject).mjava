	/**
	 * Create a new parser for the given project, as well as a lookup environment.
	 */
	public void initialize(JavaProject project) throws JavaModelException {
		// create lookup environment
		CompilerOptions options = new CompilerOptions(project.getOptions(true));
		ProblemReporter problemReporter =
			new ProblemReporter(
				DefaultErrorHandlingPolicies.proceedWithAllProblems(),
				options,
				new DefaultProblemFactory());
		this.lookupEnvironment =
			new LookupEnvironment(this, options, problemReporter, this.nameEnvironment);
			
		// create parser
		this.parser = new MatchLocatorParser(problemReporter, options.sourceLevel >= CompilerOptions.JDK1_4);
		
		// reset parsed units (they could hold onto obsolete bindings: see bug 16052)
		MatchingOpenable[] openables = this.matchingOpenables.getMatchingOpenables(project.getPackageFragmentRoots());
		for (int i = 0, length = openables.length; i < length; i++) {
			MatchingOpenable matchingOpenable = openables[i];
			matchingOpenable.reset();
		}
		this.parsedUnits = new HashtableOfObject(10);
		
		// remember project's name lookup
		this.nameLookup = project.getNameLookup();

		// create hierarchy resolver if scope is a hierarchy scope
		if (this.scope instanceof HierarchyScope) {
			IType focusType = ((HierarchyScope)this.scope).focusType;
			if (focusType != null) {
					char[] fullyQualifiedName = focusType.getFullyQualifiedName().toCharArray();
					this.hierarchyResolver = new HierarchyResolver(this.lookupEnvironment, null/*hierarchy is not going to be computed*/);
					this.hierarchyResolver.setFocusType(CharOperation.splitOn('.', fullyQualifiedName));
			} else {
				this.hierarchyResolver = null;
			}
		} else {
			this.hierarchyResolver = null;
		}
	}

