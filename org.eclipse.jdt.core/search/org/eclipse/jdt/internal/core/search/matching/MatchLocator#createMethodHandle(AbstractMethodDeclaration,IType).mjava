	/**
	 * Creates an IMethod from the given method declaration and type. 
	 */
	public IMethod createMethodHandle(
		AbstractMethodDeclaration method,
		IType type) {
		if (type == null) return null;
		Argument[] arguments = method.arguments;
		int length = arguments == null ? 0 : arguments.length;
		if (type.isBinary()) {
			String selector = new String(method.selector);
			IMethod[] methods;
			try {
				methods = type.getMethods();
			} catch (JavaModelException e) {
				return null;
			}
			for (int i = 0; i < methods.length; i++) {
				IMethod methodHandle = methods[i];
				if (methodHandle.getElementName().equals(selector) && length == methodHandle.getNumberOfParameters()) {
					boolean sameParameters = true;
					String[] parameterTypes = methodHandle.getParameterTypes();
					for (int j = 0; j < length; j++) {
						TypeReference parameterType = arguments[j].type;
						char[] typeName = CharOperation.concatWith(parameterType.getTypeName(), '.');
						for (int k = 0; k < parameterType.dimensions(); k++) {
							typeName = CharOperation.concat(typeName, "[]" .toCharArray()); //$NON-NLS-1$
						}
						String parameterTypeName = parameterTypes[j];
						if (!Signature.toString(parameterTypeName).endsWith(new String(typeName))) {
							sameParameters = false;
							break;
						}
					}
					if (sameParameters) {
						IJavaProject project = type.getJavaProject();
						// check if the method's project is the same as the type's project
						// they could be different in the case of a jar shared by several projects
						// (the handles are equals and thus the java model cache contains only one of them)
						// see bug 7945 Search results not selected in external jar  
						if (!project.equals(methodHandle.getJavaProject())) {
							return type.getMethod(selector, parameterTypes);
						} else {
							return methodHandle;
						}
					}
				}
			}
			return null;
		} else {
			String[] parameterTypeSignatures = new String[length];
			for (int i = 0; i < length; i++) {
				TypeReference parameterType = arguments[i].type;
				char[] typeName = CharOperation.concatWith(parameterType.getTypeName(), '.');
				for (int j = 0; j < parameterType.dimensions(); j++) {
					typeName = CharOperation.concat(typeName, "[]" .toCharArray()); //$NON-NLS-1$
				}
				parameterTypeSignatures[i] = Signature.createTypeSignature(typeName, false);
			}
			return type.getMethod(new String(method.selector), parameterTypeSignatures);
		}
	}

