/**
 * Creates an IMethod from the given method declaration and type. 
 */
protected IJavaElement createHandle(AbstractMethodDeclaration method, IJavaElement parent) {
	if (!(parent instanceof IType)) return parent;

	IType type = (IType) parent;
	Argument[] arguments = method.arguments;
	int argCount = arguments == null ? 0 : arguments.length;
	if (type.isBinary()) {
		// don't cache the methods of the binary type
		// fall thru if its a constructor with a synthetic argument... find it the slower way
		ClassFileReader reader = classFileReader(type);
		if (reader != null) {
			IBinaryMethod[] methods = reader.getMethods();
			if (methods != null) {
				boolean firstIsSynthetic = false;
				if (reader.isMember() && method.isConstructor() && !Flags.isStatic(reader.getModifiers())) { // see https://bugs.eclipse.org/bugs/show_bug.cgi?id=48261
					firstIsSynthetic = true;
					argCount++;
				}
				nextMethod : for (int i = 0, methodsLength = methods.length; i < methodsLength; i++) {
					IBinaryMethod binaryMethod = methods[i];
					char[] selector = binaryMethod.isConstructor() ? type.getElementName().toCharArray() : binaryMethod.getSelector();
					if (CharOperation.equals(selector, method.selector)) {
						char[] signature = binaryMethod.getGenericSignature();
						if (signature == null) signature = binaryMethod.getMethodDescriptor();
						char[][] parameterTypes = Signature.getParameterTypes(signature);
						if (argCount != parameterTypes.length) continue nextMethod;
						if (arguments != null) {
							for (int j = 0; j < argCount; j++) {
								char[] typeName;
								if (j == 0 && firstIsSynthetic) {
									typeName = type.getDeclaringType().getFullyQualifiedName().toCharArray();
								} else {
									TypeReference typeRef = arguments[firstIsSynthetic ? j - 1 : j].type;
									typeName = CharOperation.concatWith(typeRef.getTypeName(), '.');
									for (int k = 0, dim = typeRef.dimensions(); k < dim; k++)
										typeName = CharOperation.concat(typeName, new char[] {'[', ']'});
								}
								char[] parameterTypeName = ClassFileMatchLocator.convertClassFileFormat(parameterTypes[j]);
								if (!CharOperation.endsWith(Signature.toCharArray(Signature.getTypeErasure(parameterTypeName)), typeName))
									continue nextMethod;
								parameterTypes[j] = parameterTypeName;
							}
						}
						return createMethodHandle(type, new String(selector), CharOperation.toStrings(parameterTypes));
					}
				}
			}
		}
		return null;
	}

	String[] parameterTypeSignatures = new String[argCount];
	if (arguments != null) {
		for (int i = 0; i < argCount; i++) {
			TypeReference typeRef = arguments[i].type;
			char[] typeName = CharOperation.concatWith(typeRef.getParameterizedTypeName(), '.');
//			for (int j = 0, dim = typeRef.dimensions(); j < dim; j++)
//				typeName = CharOperation.concat(typeName, new char[] {'[', ']'});
			parameterTypeSignatures[i] = Signature.createTypeSignature(typeName, false);
		}
	}

	return createMethodHandle(type, new String(method.selector), parameterTypeSignatures);
}

