/**
 * Returns whether the given type binding matches the given qualified pattern.
 * Returns ACCURATE_MATCH if it does.
 * Returns INACCURATE_MATCH if resolve failed.
 * Returns IMPOSSIBLE_MATCH if it doesn't.
 */
protected int resolveLevelForArgumentType(char[] simpleNamePattern, char[] qualificationPattern, TypeBinding argumentType) {
	if (simpleNamePattern == null && qualificationPattern == null) return ACCURATE_MATCH;
	if (argumentType  == null) return INACCURATE_MATCH;

	// NOTE: if case insensitive search then qualifiedPattern is assumed to be lowercase

	if (argumentType.isMemberType()) {
		char[] sourceName = argumentType.sourceName();
		return CharOperation.match(simpleNamePattern, sourceName, this.isCaseSensitive)
			? ACCURATE_MATCH
			: IMPOSSIBLE_MATCH;
	
	} else {
		char[] qualifiedSourceName = CharOperation.concat(argumentType.qualifiedSourceName(), argumentType.sourceName(), '.');
		if (argumentType instanceof ReferenceBinding) {
			ReferenceBinding type = (ReferenceBinding) argumentType;
			if (type.isLocalType()) {
				qualifiedSourceName = CharOperation.concat(qualifiedSourceName(type.enclosingType()), new char[] {'.', '1', '.'}, type.sourceName());
			}
		}
		char[] qualifiedPackageName = argumentType.qualifiedPackageName();
		char[] fullyQualifiedTypeName = qualifiedPackageName.length == 0
			? qualifiedSourceName
			: CharOperation.concat(qualifiedPackageName, qualifiedSourceName, '.');
		return CharOperation.match(qualifiedPattern(simpleNamePattern, qualificationPattern), fullyQualifiedTypeName, this.isCaseSensitive)
			? ACCURATE_MATCH
			: IMPOSSIBLE_MATCH;
	}
}

