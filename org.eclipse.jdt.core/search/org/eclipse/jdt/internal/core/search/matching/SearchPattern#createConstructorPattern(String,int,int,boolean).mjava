/**
 * Constructor pattern are formed by [declaringQualification.]type[(parameterTypes)]
 * e.g. java.lang.Object()
 *		Main(*)
 */
private static SearchPattern createConstructorPattern(String patternString, int limitTo, int matchMode, boolean isCaseSensitive) {

	Scanner scanner = new Scanner(false, true); // tokenize white spaces
	scanner.setSourceBuffer(patternString.toCharArray());
	final int InsideName = 1;
	final int InsideParameter = 2;
	
	String declaringQualification = null, typeName = null, parameterType = null;
	String[] parameterTypes = null;
	int parameterCount = -1;
	boolean foundClosingParenthesis = false;
	int mode = InsideName;
	int token;
	try {
		token = scanner.getNextToken();
	} catch (InvalidInputException e) {
		return null;
	}
	while (token != TerminalSymbols.TokenNameEOF){
		switch(mode){

			// read declaring type and selector
			case InsideName :
				switch (token) {
					case TerminalSymbols.TokenNameDOT:
						if (declaringQualification == null){
							if (typeName == null) return null;
							declaringQualification = typeName;
						} else {
							String tokenSource = new String(scanner.getCurrentTokenSource());
							declaringQualification += tokenSource + typeName;
						}
						typeName = null;
						break;
					case TerminalSymbols.TokenNameLPAREN:
						parameterTypes = new String[5];
						parameterCount = 0;
						mode = InsideParameter;
						break;
					case Scanner.TokenNameWHITESPACE:
						break;
					case TerminalSymbols.TokenNameIdentifier:
					case TerminalSymbols.TokenNameMULTIPLY:
						if (typeName == null) {
							typeName = new String(scanner.getCurrentTokenSource());
						} else {
							typeName += new String(scanner.getCurrentTokenSource());
						}
						break;
					default:
						return null;
				}
				break;
			// read parameter types
			case InsideParameter :
				switch (token) {
					case Scanner.TokenNameWHITESPACE:
						break;
					case TerminalSymbols.TokenNameCOMMA:
						if (parameterType == null) return null;
						if (parameterTypes.length == parameterCount){
							System.arraycopy(parameterTypes, 0, parameterTypes = new String[parameterCount*2], 0, parameterCount);
						}
						parameterTypes[parameterCount++] = parameterType;
						parameterType = null;
						break;
					case TerminalSymbols.TokenNameRPAREN:
						foundClosingParenthesis = true;
						if (parameterType != null){
							if (parameterTypes.length == parameterCount){
								System.arraycopy(parameterTypes, 0, parameterTypes = new String[parameterCount*2], 0, parameterCount);
							}
							parameterTypes[parameterCount++] = parameterType;
						}
						break;
					case TerminalSymbols.TokenNameDOT:
					case TerminalSymbols.TokenNameIdentifier:
					case TerminalSymbols.TokenNameMULTIPLY:
					case TerminalSymbols.TokenNameLBRACKET:
					case TerminalSymbols.TokenNameRBRACKET:
					case TerminalSymbols.TokenNameboolean:
					case TerminalSymbols.TokenNamebyte:
					case TerminalSymbols.TokenNamechar:
					case TerminalSymbols.TokenNamedouble:
					case TerminalSymbols.TokenNamefloat:
					case TerminalSymbols.TokenNameint:
					case TerminalSymbols.TokenNamelong:
					case TerminalSymbols.TokenNameshort:
					case TerminalSymbols.TokenNamevoid:
						if (parameterType == null){
							parameterType = new String(scanner.getCurrentTokenSource());
						} else {
							parameterType += new String(scanner.getCurrentTokenSource());
						}
						break;
					default:
						return null;
				}
				break;
		}
		try {
			token = scanner.getNextToken();
		} catch (InvalidInputException e) {
			return null;
		}
	}
	// parenthesis mismatch
	if (parameterCount>0 && !foundClosingParenthesis) return null;
	if (typeName == null) return null;

	char[] typeNameChars = typeName.toCharArray();
	if (typeNameChars.length == 1 && typeNameChars[0] == '*') typeNameChars = null;
		
	char[] declaringQualificationChars = null;
	if (declaringQualification != null) declaringQualificationChars = declaringQualification.toCharArray();
	char[][] parameterTypeQualifications = null, parameterTypeSimpleNames = null;

	// extract parameter types infos
	if (parameterCount >= 0){
		parameterTypeQualifications = new char[parameterCount][];
		parameterTypeSimpleNames = new char[parameterCount][];
		for (int i = 0; i < parameterCount; i++){
			char[] parameterTypePart = parameterTypes[i].toCharArray();
			int lastDotPosition = CharOperation.lastIndexOf('.', parameterTypePart);
			if (lastDotPosition >= 0){
				parameterTypeQualifications[i] = CharOperation.subarray(parameterTypePart, 0, lastDotPosition);
				if (parameterTypeQualifications[i].length == 1 && parameterTypeQualifications[i][0] == '*') {
					parameterTypeQualifications[i] = null;
				} else {
					// prefix with a '*' as the full qualification could be bigger 
					// (i.e. because of an import)
					parameterTypeQualifications[i] = CharOperation.concat(ONE_STAR, parameterTypeQualifications[i]);
				}
				parameterTypeSimpleNames[i] = CharOperation.subarray(parameterTypePart, lastDotPosition+1, parameterTypePart.length);
			} else {
				parameterTypeQualifications[i] = null;
				parameterTypeSimpleNames[i] = parameterTypePart;
			}
			if (parameterTypeSimpleNames[i].length == 1 && parameterTypeSimpleNames[i][0] == '*') parameterTypeSimpleNames[i] = null;
		}
	}	
	SearchPattern searchPattern = null;
	switch (limitTo){
		case IJavaSearchConstants.DECLARATIONS :
			searchPattern = 
				new ConstructorDeclarationPattern(
					typeNameChars, 
					matchMode, 
					isCaseSensitive, 
					declaringQualificationChars, 
					parameterTypeQualifications, 
					parameterTypeSimpleNames);
			break;
		case IJavaSearchConstants.REFERENCES :
			searchPattern = 
				new ConstructorReferencePattern(
					typeNameChars, 
					matchMode, 
					isCaseSensitive, 
					declaringQualificationChars, 
					parameterTypeQualifications, 
					parameterTypeSimpleNames,
					null);
			break;
		case IJavaSearchConstants.ALL_OCCURRENCES :
			searchPattern = new OrPattern(
				new ConstructorDeclarationPattern(
					typeNameChars, 
					matchMode, 
					isCaseSensitive, 
					declaringQualificationChars, 
					parameterTypeQualifications, 
					parameterTypeSimpleNames),
				new ConstructorReferencePattern(
					typeNameChars, 
					matchMode, 
					isCaseSensitive, 
					declaringQualificationChars, 
					parameterTypeQualifications, 
					parameterTypeSimpleNames,
					null));
			break;
	}
	return searchPattern;

}

