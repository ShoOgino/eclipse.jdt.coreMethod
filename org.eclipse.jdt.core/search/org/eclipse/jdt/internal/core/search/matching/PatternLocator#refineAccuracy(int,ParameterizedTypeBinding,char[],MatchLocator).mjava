/*
 * Refine accuracy for a match.
 * Typically this happens while search references to parameterized type.
 * In this case we need locator to be able to resolve type arguments and verify
 * if binding is compatible with pattern...
 */
protected int refineAccuracy(int accuracy, ParameterizedTypeBinding parameterizedBinding, char[] typeSignature, MatchLocator locator) {

	// Try to make accuracy more... accurate
	if (locator.unitScope != null) {
		char[][] patternTypeArguments = Signature.getTypeArguments(typeSignature);
		int patternTypeArgsLength = patternTypeArguments.length;
		if (patternTypeArgsLength == 0) {
			TypeBinding enclosingType = parameterizedBinding.enclosingType();
			if (enclosingType != null && enclosingType.isParameterizedType()) {
				int idx = CharOperation.lastIndexOf('.', typeSignature);
				if (idx > 0) {
					char[] enclosingTypeSignature = new char[idx+1];
					System.arraycopy(typeSignature, 0, enclosingTypeSignature, 0, idx);
					enclosingTypeSignature[idx] = Signature.C_SEMICOLON;
					return refineAccuracy(accuracy, (ParameterizedTypeBinding)enclosingType, enclosingTypeSignature, locator);
				}
			}
			return accuracy;
		}
		TypeBinding[] argumentsBinding = parameterizedBinding.arguments;
		int typeArgumentsLength = argumentsBinding == null ? 0 : argumentsBinding.length;
		if (patternTypeArgsLength != typeArgumentsLength) return -1;
		for (int i=0; i<typeArgumentsLength; i++) {
			char[] patternTypeArgument = patternTypeArguments[i];
			char wildcard = patternTypeArgument[0];
			switch (wildcard) {
				case Signature.C_STAR :
					// unbound parameter always match
					continue;
				case Signature.C_EXTENDS :
				case Signature.C_SUPER :
					patternTypeArgument = CharOperation.subarray(patternTypeArgument, 1, patternTypeArgument.length);
				default :
					break;
			}
			patternTypeArgument = Signature.toCharArray(patternTypeArgument);
			TypeBinding patternBinding = locator.getType(patternTypeArgument);
			if (patternBinding != null) {
				TypeBinding argumentBinding = argumentsBinding[i];
				// We can bind pattern type name => verify that types are compatible
				if (argumentBinding == patternBinding) continue;
				if (argumentBinding.isWildcard()) {
					TypeBinding bound = ((WildcardBinding) argumentBinding).bound;
					switch (wildcard) {
						default : //UNBOUND
							// unbound always match => skip to next argument
							continue;
						case Signature.C_EXTENDS :
							if (bound == null || bound.isCompatibleWith(patternBinding))
								// argument type match a subclass of bound => skip to next argument
								continue;
							break;
						case Signature.C_SUPER :
							if (bound == null || patternBinding.isCompatibleWith(bound))
								// argument type match a superclass in bound hierarchy => skip to next argument
								continue;
							break;
					}
				}
				return -1; // finally the match was impossible
			}
		}
	}
	return SearchMatch.A_ACCURATE;
}

