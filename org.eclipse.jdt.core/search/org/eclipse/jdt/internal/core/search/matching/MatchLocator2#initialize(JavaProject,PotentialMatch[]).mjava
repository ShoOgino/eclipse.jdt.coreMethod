	/**
	 * Create a new parser for the given project, as well as a lookup environment.
	 */
	public void initialize(JavaProject project, PotentialMatch[] potentialMatches) throws JavaModelException {
		// create name environment
		if (this.nameEnvironment != null) { // cleanup
			this.nameEnvironment.cleanup();
		}
		INameEnvironment wrappedEnvironment;
		if (potentialMatches.length == 1) {
			// if only one potential match, a file name environment costs too much,
			// so use the existing searchable  environment which will populate the java model
			// only for this potential match and its required types.
			wrappedEnvironment = project.getSearchableNameEnvironment();
		} else {
			wrappedEnvironment = new ClasspathNameEnvironment(project);
		}
		this.nameEnvironment = new JavaSearchNameEnvironment2(wrappedEnvironment, potentialMatches);

		// create lookup environment
		this.options = new CompilerOptions(project.getOptions(true));
		ProblemReporter problemReporter =
			new ProblemReporter(
				DefaultErrorHandlingPolicies.proceedWithAllProblems(),
				this.options,
				new DefaultProblemFactory());
		this.lookupEnvironment =
			new LookupEnvironment(this, this.options, problemReporter, this.nameEnvironment);
			
		// create parser
		this.parser = new MatchLocatorParser(problemReporter, this.options.sourceLevel >= CompilerOptions.JDK1_4);
				
		// remember project's name lookup
		this.nameLookup = project.getNameLookup();
		
		// initialize queue of units
		this.totalUnits = 0;
		int maxUnits = potentialMatches.length;
		this.unitsToProcess = new CompilationUnitDeclaration[maxUnits];
		this.matchesToProcess = new PotentialMatch[maxUnits];

	}

