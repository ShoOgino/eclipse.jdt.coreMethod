	/**
	 * Locate the matches in the given files and report them using the search requestor. 
	 */
	public void locateMatches(String[] filePaths, IWorkspace workspace, IWorkingCopy[] workingCopies)
		throws JavaModelException {
			
		// sort file paths projects
		Util.sort(filePaths); 
		
		// initialize handle factory (used as a cache of handles so as to optimize space)
		if (this.handleFactory == null) {
			this.handleFactory = new HandleFactory(workspace);
		}
		
		// initialize locator with working copies
		this.workingCopies = workingCopies;
		HashSet wcPaths = new HashSet(); // a set of Strings
		if (workingCopies != null) {
			for (int i = 0, length = workingCopies.length; i < length; i++) {
				IWorkingCopy workingCopy = workingCopies[i];
				try {
					IResource res = workingCopy.getOriginalElement().getUnderlyingResource();
					wcPaths.add(res.getFullPath().toString());
				} catch (JavaModelException e) {
					// continue with next working copy
				}
			}
		}
		
		// initialize pattern for polymorphic search (ie. method reference pattern)
		this.pattern.initializePolymorphicSearch(this, this.collector.getProgressMonitor());
		
		JavaProject previousJavaProject = null;
		int length = filePaths.length;
		double increment = 100.0 / length;
		double totalWork = 0;
		int lastProgress = 0;
		this.initializeMatchingOpenables(workingCopies);
		for (int i = 0; i < length; i++) {
			IProgressMonitor monitor = this.collector.getProgressMonitor();
			if (monitor != null && monitor.isCanceled()) {
				throw new OperationCanceledException();
			}
			String pathString = filePaths[i];
			
			// skip paths that are hidden by a working copy
			if (wcPaths.contains(pathString)) continue;
			
			Openable openable = this.handleFactory.createOpenable(pathString);
			if (openable == null)
				continue; // match is outside classpath

			// create new parser and lookup environment if this is a new project
			IResource resource = null;
			JavaProject javaProject = null;
			try {
				javaProject = (JavaProject) openable.getJavaProject();
				resource = openable.getUnderlyingResource();
				if (resource == null) { // case of a file in an external jar
					resource = javaProject.getProject();
				}
				if (!javaProject.equals(previousJavaProject)) {
					// locate matches in previous project
					if (previousJavaProject != null) {
						try {
							this.locateMatches(previousJavaProject);
						} catch (JavaModelException e) {
							if (e.getException() instanceof CoreException) {
								throw e;
							} else {
								// problem with classpath in this project -> skip it
							}
						}
						this.initializeMatchingOpenables(workingCopies);
					}

					// create parser for this project
					this.createParser(javaProject);
					previousJavaProject = javaProject;
				}
			} catch (JavaModelException e) {
				// file doesn't exist -> skip it
				continue;
			}

			// add matching openable
			this.addMatchingOpenable(resource, openable);

			if (monitor != null) {
				totalWork = totalWork + increment;
				int worked = (int) totalWork - lastProgress;
				monitor.worked(worked);
				lastProgress = (int) totalWork;
			}
		}

		// last project
		if (previousJavaProject != null) {
			try {
				this.locateMatches(previousJavaProject);
			} catch (JavaModelException e) {
				if (e.getException() instanceof CoreException) {
					throw e;
				} else {
					// problem with classpath in last project -> skip it
				}
			}
			this.initializeMatchingOpenables(workingCopies);
		}

	}

