	/**
	 * Locate the matches in the given files and report them using the search requestor. 
	 */
	public void locateMatches(String[] filePaths, IWorkspace workspace, IWorkingCopy[] workingCopies)
		throws JavaModelException {
			
		// initialize handle factory (used as a cache of handles so as to optimize space)
		if (this.handleFactory == null) {
			this.handleFactory = new HandleFactory(workspace);
		}
		
		// initialize locator with working copies
		this.workingCopies = workingCopies;
		
		// substitute compilation units with working copies
		HashMap wcPaths = new HashMap(); // a map from path to working copies
		int wcLength;
		if (workingCopies != null && (wcLength = workingCopies.length) > 0) {
			String[] newPaths = new String[wcLength];
			for (int i = 0; i < wcLength; i++) {
				IWorkingCopy workingCopy = workingCopies[i];
				try {
					IResource res = workingCopy.getOriginalElement().getUnderlyingResource();
					String path = res.getFullPath().toString();
					wcPaths.put(path, workingCopy);
					newPaths[i] = path;
				} catch (JavaModelException e) {
					// continue with next working copy
				}
			}
			int filePathsLength = filePaths.length;
			System.arraycopy(filePaths, 0, filePaths = new String[filePathsLength+wcLength], 0, filePathsLength);
			System.arraycopy(newPaths, 0, filePaths, filePathsLength, wcLength);
		}
		
		// sort file paths projects
		Util.sort(filePaths); 
		
		// initialize pattern for polymorphic search (ie. method reference pattern)
		this.pattern.initializePolymorphicSearch(this, this.collector.getProgressMonitor());
		
		JavaProject previousJavaProject = null;
		int length = filePaths.length;
		double increment = 100.0 / length;
		double totalWork = 0;
		int lastProgress = 0;
		this.matchingOpenables = new MatchingOpenableSet();
		for (int i = 0; i < length; i++) {
			IProgressMonitor monitor = this.collector.getProgressMonitor();
			if (monitor != null && monitor.isCanceled()) {
				throw new OperationCanceledException();
			}
			String pathString = filePaths[i];
			
			// skip duplicate paths
			if (i > 0 && pathString.equals(filePaths[i-1])) continue;
			
			Openable openable;
			IWorkingCopy workingCopy = (IWorkingCopy)wcPaths.get(pathString);
			if (workingCopy != null) {
				openable = (Openable)workingCopy;
			} else {
				openable = this.handleFactory.createOpenable(pathString);
				if (openable == null)
					continue; // match is outside classpath
			}

			// create new parser and lookup environment if this is a new project
			IResource resource = null;
			JavaProject javaProject = null;
			try {
				javaProject = (JavaProject) openable.getJavaProject();
				if (workingCopy != null) {
					resource = workingCopy.getOriginalElement().getUnderlyingResource();
				} else {
					resource = openable.getUnderlyingResource();
				}
				if (resource == null) { // case of a file in an external jar
					resource = javaProject.getProject();
				}
				if (!javaProject.equals(previousJavaProject)) {
					// locate matches in previous project
					if (previousJavaProject != null) {
						try {
							this.locateMatches(previousJavaProject);
						} catch (JavaModelException e) {
							if (e.getException() instanceof CoreException) {
								throw e;
							} else {
								// problem with classpath in this project -> skip it
							}
						}
						this.matchingOpenables = new MatchingOpenableSet();
					}

					// create parser for this project
					this.createParser(javaProject);
					previousJavaProject = javaProject;
				}
			} catch (JavaModelException e) {
				// file doesn't exist -> skip it
				continue;
			}

			// add matching openable
			this.addMatchingOpenable(resource, openable);

			if (monitor != null) {
				totalWork = totalWork + increment;
				int worked = (int) totalWork - lastProgress;
				monitor.worked(worked);
				lastProgress = (int) totalWork;
			}
		}

		// last project
		if (previousJavaProject != null) {
			try {
				this.locateMatches(previousJavaProject);
			} catch (JavaModelException e) {
				if (e.getException() instanceof CoreException) {
					throw e;
				} else {
					// problem with classpath in last project -> skip it
				}
			}
			this.matchingOpenables = new MatchingOpenableSet();
		} 

	}

