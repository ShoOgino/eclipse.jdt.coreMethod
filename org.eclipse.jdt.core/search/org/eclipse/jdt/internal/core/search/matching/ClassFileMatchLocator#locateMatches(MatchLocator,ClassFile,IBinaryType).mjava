/**
 * Locate declaration in the current class file. This class file is always in a jar.
 */
public void locateMatches(MatchLocator locator, ClassFile classFile, IBinaryType info) throws CoreException {
	// check class definition
	SearchPattern pattern = locator.pattern;
	BinaryType binaryType = (BinaryType) classFile.getType();
	if (matchBinary(pattern, info, null)) {
		binaryType = new ResolvedBinaryType((JavaElement) binaryType.getParent(), binaryType.getElementName(), binaryType.getKey());
		locator.reportBinaryMemberDeclaration(null, binaryType, null, info, SearchMatch.A_ACCURATE);
	}

	int accuracy = SearchMatch.A_ACCURATE;
	if (((InternalSearchPattern)pattern).mustResolve) {
		try {
			BinaryTypeBinding binding = locator.cacheBinaryType(binaryType, info);
			if (binding != null) {
				// filter out element not in hierarchy scope
				if (!locator.typeInHierarchy(binding)) return;

				MethodBinding[] methods = binding.availableMethods(); // resilience
				for (int i = 0, l = methods.length; i < l; i++) {
					MethodBinding method = methods[i];
					if (locator.patternLocator.resolveLevel(method) == PatternLocator.ACCURATE_MATCH) {
						char[] methodSignature = method.genericSignature();
						if (methodSignature == null) methodSignature = method.signature();
						IMethod methodHandle = binaryType.getMethod(
							new String(method.isConstructor() ? binding.compoundName[binding.compoundName.length-1] : method.selector),
							CharOperation.toStrings(Signature.getParameterTypes(convertClassFileFormat(methodSignature))));
						locator.reportBinaryMemberDeclaration(null, methodHandle, method, info, SearchMatch.A_ACCURATE);
					}
				}

				FieldBinding[] fields = binding.availableFields();
				for (int i = 0, l = fields.length; i < l; i++) {
					FieldBinding field = fields[i];
					if (locator.patternLocator.resolveLevel(field) == PatternLocator.ACCURATE_MATCH) {
						IField fieldHandle = binaryType.getField(new String(field.name));
						locator.reportBinaryMemberDeclaration(null, fieldHandle, field, info, SearchMatch.A_ACCURATE);
					}
				}

				// no need to check binary info since resolve was successful
				return;
			}
		} catch (AbortCompilation e) { // if compilation was aborted it is a problem with the class path
		}
		// report as a potential match if binary info matches the pattern		
		accuracy = SearchMatch.A_INACCURATE;
	}

	IBinaryMethod[] methods = info.getMethods();
	if (methods != null) {
		for (int i = 0, l = methods.length; i < l; i++) {
			IBinaryMethod method = methods[i];
			if (matchBinary(pattern, method, info)) {
				char[] name;
				if (method.isConstructor()) {
					name = info.getName();
					int lastSlash = CharOperation.lastIndexOf('/', name);
					if (lastSlash != -1) {
						name = CharOperation.subarray(name, lastSlash+1, name.length);
					}
				} else {
					name = method.getSelector();
				}
				String selector = new String(name);
				String[] parameterTypes = CharOperation.toStrings(Signature.getParameterTypes(convertClassFileFormat(method.getMethodDescriptor())));
				IMethod methodHandle = binaryType.getMethod(selector, parameterTypes);
				methodHandle = new ResolvedBinaryMethod(binaryType, selector, parameterTypes, methodHandle.getKey());
				locator.reportBinaryMemberDeclaration(null, methodHandle, null, info, accuracy);
			}
		}
	}

	IBinaryField[] fields = info.getFields();
	if (fields != null) {
		for (int i = 0, l = fields.length; i < l; i++) {
			IBinaryField field = fields[i];
			if (matchBinary(pattern, field, info)) {
				String fieldName = new String(field.getName());
				IField fieldHandle = binaryType.getField(fieldName);
				fieldHandle = new ResolvedBinaryField(binaryType, fieldName, fieldHandle.getKey());
				locator.reportBinaryMemberDeclaration(null, fieldHandle, null, info, accuracy);
			}
		}
	}
}

