/**
 * Locate declaration in the current class file. This class file is always in a jar.
 */
public void locateMatches(MatchLocator locator, ClassFile classFile, IBinaryType info) throws CoreException {
	// check class definition
	SearchPattern pattern = locator.pattern;
	BinaryType binaryType = (BinaryType) classFile.getType();
	if (matchBinary(pattern, info, null))
		locator.reportBinaryMemberDeclaration(null, binaryType, info, SearchMatch.A_ACCURATE);

	int accuracy = SearchMatch.A_ACCURATE;
	if (((InternalSearchPattern)pattern).mustResolve) {
		try {
			BinaryTypeBinding binding = locator.cacheBinaryType(binaryType, info);
			if (binding != null) {
				// filter out element not in hierarchy scope
				if (!locator.typeInHierarchy(binding)) return;

				MethodBinding[] methods = binding.methods();
				for (int i = 0, l = methods.length; i < l; i++) {
					MethodBinding method = methods[i];
					if (locator.patternLocator.resolveLevel(method) == PatternLocator.ACCURATE_MATCH) {
						IMethod methodHandle = binaryType.getMethod(
							new String(method.isConstructor() ? binding.compoundName[binding.compoundName.length-1] : method.selector),
							CharOperation.toStrings(Signature.getParameterTypes(convertClassFileFormat(method.signature()))));
						locator.reportBinaryMemberDeclaration(null, methodHandle, info, SearchMatch.A_ACCURATE);
					}
				}

				FieldBinding[] fields = binding.fields();
				for (int i = 0, l = fields.length; i < l; i++) {
					FieldBinding field = fields[i];
					if (locator.patternLocator.resolveLevel(field) == PatternLocator.ACCURATE_MATCH) {
						IField fieldHandle = binaryType.getField(new String(field.name));
						locator.reportBinaryMemberDeclaration(null, fieldHandle, info, SearchMatch.A_ACCURATE);
					}
				}

				// no need to check binary info since resolve was successful
				return;
			}
		} catch (AbortCompilation e) { // if compilation was aborted it is a problem with the class path
		}
		// report as a potential match if binary info matches the pattern		
		accuracy = SearchMatch.A_INACCURATE;
	}

	IBinaryMethod[] methods = info.getMethods();
	if (methods != null) {
		for (int i = 0, l = methods.length; i < l; i++) {
			IBinaryMethod method = methods[i];
			if (matchBinary(pattern, method, info)) {
				char[] name;
				if (method.isConstructor()) {
					name = info.getName();
					int lastSlash = CharOperation.lastIndexOf('/', name);
					if (lastSlash != -1) {
						name = CharOperation.subarray(name, lastSlash+1, name.length);
					}
				} else {
					name = method.getSelector();
				}
				IMethod methodHandle = binaryType.getMethod(
					new String(name),
					CharOperation.toStrings(Signature.getParameterTypes(convertClassFileFormat(method.getMethodDescriptor()))));
				locator.reportBinaryMemberDeclaration(null, methodHandle, info, accuracy);
			}
		}
	}

	IBinaryField[] fields = info.getFields();
	if (fields != null) {
		for (int i = 0, l = fields.length; i < l; i++) {
			IBinaryField field = fields[i];
			if (matchBinary(pattern, field, info)) {
				IField fieldHandle = binaryType.getField(new String(field.getName()));
				locator.reportBinaryMemberDeclaration(null, fieldHandle, info, accuracy);
			}
		}
	}
}

