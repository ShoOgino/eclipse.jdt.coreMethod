	/*
	 * Creates hierarchy resolver if needed. 
	 * Returns whether focus is visible.
	 */
	protected boolean createHierarchyResolver(PotentialMatch[] potentialMatches) {
		// create hierarchy resolver if scope is a hierarchy scope
		if (this.scope instanceof HierarchyScope) {
			IType focusType = ((HierarchyScope)this.scope).focusType;
			if (focusType != null) {
				// cache focus type if not a potential match
				char[][] compoundName = CharOperation.splitOn('.', focusType.getFullyQualifiedName().toCharArray());
				boolean isPotentialMatch = false;
				for (int i = 0, length = potentialMatches.length; i < length; i++) {
					if (CharOperation.equals(potentialMatches[i].compoundName, compoundName)) {
						isPotentialMatch = true;
						break;
					}
				}
				if (!isPotentialMatch) {
					if (focusType.isBinary()) {
						// cache binary type
						try {
							this.cacheBinaryType(focusType);
						} catch (JavaModelException e) {
							return false;
						}
					} else {
						// cache all types in the focus' compilation unit (even secondary types)
						this.accept((ICompilationUnit)focusType.getCompilationUnit());
					}
				}
				
				// resolve focus type
				this.hierarchyResolver = new HierarchyResolver(this.lookupEnvironment, null/*hierarchy is not going to be computed*/);
				if (this.hierarchyResolver.setFocusType(compoundName) == null) {
					// focus type is not visible from this project
					return false;
				}
			} else {
				this.hierarchyResolver = null;
			}
		} else {
			this.hierarchyResolver = null;
		}
		return true;
	}

