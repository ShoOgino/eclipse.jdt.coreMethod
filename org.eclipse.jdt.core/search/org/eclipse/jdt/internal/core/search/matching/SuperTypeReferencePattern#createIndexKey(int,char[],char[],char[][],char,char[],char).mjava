public static char[] createIndexKey(
	int modifiers,
	char[] packageName,
	char[] typeName,
	char[][] enclosingTypeNames,
	char classOrInterface,
	char[] superTypeName,
	char superClassOrInterface) {

	SuperTypeReferencePattern record = getSuperTypeReferenceRecord();
	record.modifiers = modifiers;
	record.pkgName = packageName;
	record.classOrInterface = classOrInterface;
	record.superClassOrInterface = superClassOrInterface;
	if (superTypeName == null)
		superTypeName = OBJECT;
	record.enclosingTypeName = CharOperation.concatWith(enclosingTypeNames, '$');
	record.simpleName = CharOperation.lastSegment(typeName, '.');
	record.superSimpleName = CharOperation.lastSegment(superTypeName, '.');
	record.superQualification = null;
	if (record.superSimpleName != superTypeName) {
		int length = superTypeName.length - record.superSimpleName.length - 1;
		record.superQualification = new char[length];
		System.arraycopy(superTypeName, 0, record.superQualification, 0, length);
	}

	// if the supertype name contains a $, then split it into: source name and append the $ prefix to the qualification
	//	e.g. p.A$B ---> p.A$ + B
	char[] superTypeSourceName = CharOperation.lastSegment(record.superSimpleName, '$');
	if (superTypeSourceName != record.superSimpleName) {
		int start = record.superQualification == null ? 0 : record.superQualification.length + 1;
		int prefixLength = record.superSimpleName.length - superTypeSourceName.length;
		char[] mangledQualification = new char[start + prefixLength];
		if (record.superQualification != null) {
			System.arraycopy(record.superQualification, 0, mangledQualification, 0, start-1);
			mangledQualification[start-1] = '.';
		}
		System.arraycopy(record.superSimpleName, 0, mangledQualification, start, prefixLength);
		record.superQualification = mangledQualification;
		record.superSimpleName = superTypeSourceName;
	} 
	
	return record.encodeIndexKey();
}

