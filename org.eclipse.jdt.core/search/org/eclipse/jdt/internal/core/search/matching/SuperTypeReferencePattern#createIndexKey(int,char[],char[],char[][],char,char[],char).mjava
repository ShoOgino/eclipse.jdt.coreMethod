public static char[] createIndexKey(
	int modifiers,
	char[] packageName,
	char[] typeName,
	char[][] enclosingTypeNames,
	char classOrInterface,
	char[] superTypeName,
	char superClassOrInterface) {

	SuperTypeReferencePattern pattern = new SuperTypeReferencePattern(R_EXACT_MATCH | R_CASE_SENSITIVE);
	pattern.modifiers = modifiers;
	pattern.pkgName = packageName;
	pattern.classOrInterface = classOrInterface;
	pattern.superClassOrInterface = superClassOrInterface;
	if (superTypeName == null)
		superTypeName = OBJECT;
	pattern.enclosingTypeName = CharOperation.concatWith(enclosingTypeNames, '$');
	pattern.simpleName = CharOperation.lastSegment(typeName, '.');
	pattern.superSimpleName = CharOperation.lastSegment(superTypeName, '.');
	pattern.superQualification = null;
	if (pattern.superSimpleName != superTypeName) {
		int length = superTypeName.length - pattern.superSimpleName.length - 1;
		pattern.superQualification = new char[length];
		System.arraycopy(superTypeName, 0, pattern.superQualification, 0, length);
	}

	// if the supertype name contains a $, then split it into: source name and append the $ prefix to the qualification
	//	e.g. p.A$B ---> p.A$ + B
	char[] superTypeSourceName = CharOperation.lastSegment(pattern.superSimpleName, '$');
	if (superTypeSourceName != pattern.superSimpleName) {
		int start = pattern.superQualification == null ? 0 : pattern.superQualification.length + 1;
		int prefixLength = pattern.superSimpleName.length - superTypeSourceName.length;
		char[] mangledQualification = new char[start + prefixLength];
		if (pattern.superQualification != null) {
			System.arraycopy(pattern.superQualification, 0, mangledQualification, 0, start-1);
			mangledQualification[start-1] = '.';
		}
		System.arraycopy(pattern.superSimpleName, 0, mangledQualification, start, prefixLength);
		pattern.superQualification = mangledQualification;
		pattern.superSimpleName = superTypeSourceName;
	} 
	
	return pattern.encodeIndexKey();
}

