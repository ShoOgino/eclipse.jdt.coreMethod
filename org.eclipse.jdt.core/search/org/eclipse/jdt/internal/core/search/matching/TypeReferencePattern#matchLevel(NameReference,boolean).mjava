/**
 * Returns whether this type pattern matches the given name reference.
 * Look at resolved information only if specified.
 */
protected int matchLevel(NameReference nameRef, boolean resolve) {
	if (!resolve) {
		if (this.simpleName == null)
			return this.mustResolve ? POTENTIAL_MATCH : ACCURATE_MATCH;
		if (nameRef instanceof SingleNameReference)
			return matchesName(this.simpleName, ((SingleNameReference)nameRef).token)
				? POTENTIAL_MATCH // can only be a possible match since resolution is needed to find out if it is a type ref
				: IMPOSSIBLE_MATCH;

		char[][] tokens = ((QualifiedNameReference) nameRef).tokens;
		for (int i = 0, max = tokens.length; i < max; i++)
			if (this.matchesName(this.simpleName, tokens[i]))
				// can only be a possible match since resolution is needed to find out if it is a type ref
				return POTENTIAL_MATCH;
		return IMPOSSIBLE_MATCH;
	}

	Binding binding = nameRef.binding;

	if (nameRef instanceof SingleNameReference) {
		if (binding instanceof ProblemReferenceBinding)
			binding = ((ProblemReferenceBinding) binding).original;
		if (binding instanceof VariableBinding) return IMPOSSIBLE_MATCH;
		if (!(binding instanceof TypeBinding)) return INACCURATE_MATCH;
		return matchLevelForType(this.simpleName, this.qualification, (TypeBinding) binding);
	}

	TypeBinding typeBinding = null;
	QualifiedNameReference qNameRef = (QualifiedNameReference) nameRef;
	char[][] tokens = qNameRef.tokens;
	int lastIndex = tokens.length-1;
	switch (qNameRef.bits & AstNode.RestrictiveFlagMASK) {
		case BindingIds.FIELD : // reading a field
			typeBinding = nameRef.actualReceiverType;
			// no valid match amongst fields
			int otherBindingsCount = qNameRef.otherBindings == null ? 0 : qNameRef.otherBindings.length;			
			lastIndex -= otherBindingsCount + 1;
			if (lastIndex < 0) return IMPOSSIBLE_MATCH;
			break;
		case BindingIds.LOCAL : // reading a local variable
			return IMPOSSIBLE_MATCH; // no type match in it
		case BindingIds.TYPE : //=============only type ==============
			if (binding instanceof ProblemReferenceBinding)
				binding = ((ProblemReferenceBinding) binding).original;
			if (!(binding instanceof TypeBinding)) return INACCURATE_MATCH;
			typeBinding = (TypeBinding) binding;
			break;
		/*
		 * Handling of unbound qualified name references. The match may reside in the resolved fragment,
		 * which is recorded inside the problem binding, along with the portion of the name until it became a problem.
		 */
		case BindingIds.VARIABLE : //============unbound cases===========
		case BindingIds.TYPE | BindingIds.VARIABLE :						
			if (binding instanceof ProblemBinding) {
				ProblemBinding pbBinding = (ProblemBinding) binding;
				typeBinding = pbBinding.searchType; // second chance with recorded type so far
				char[] partialQualifiedName = pbBinding.name;
				lastIndex = CharOperation.occurencesOf('.', partialQualifiedName) - 1; // index of last bound token is one before the pb token
				if (typeBinding == null || lastIndex < 0) return INACCURATE_MATCH;
			} else if (binding instanceof ProblemReferenceBinding) {
				ProblemReferenceBinding pbBinding = (ProblemReferenceBinding)binding;
				binding = pbBinding.original;
				if (!(binding instanceof TypeBinding)) return INACCURATE_MATCH;
				typeBinding = (TypeBinding) binding;
				char[][] partialQualifiedName = pbBinding.compoundName;
				lastIndex = partialQualifiedName == null ? -1 : partialQualifiedName.length - 1; // index of last bound token is one before the pb token
				if (typeBinding == null || lastIndex < 0) return INACCURATE_MATCH;
			}
			break;
	}
	// try to match all enclosing types for which the token matches as well.
	while (typeBinding != null && lastIndex >= 0) {
		if (this.matchesName(this.simpleName, tokens[lastIndex--])) {
			int level = this.matchLevelForType(this.simpleName, this.qualification, typeBinding);
			if (level != IMPOSSIBLE_MATCH) return level;
		}
		if (typeBinding instanceof ReferenceBinding)
			typeBinding = ((ReferenceBinding) typeBinding).enclosingType();
		else
			typeBinding = null;
	}
	return IMPOSSIBLE_MATCH;
}

