/**
 * Returns whether this type pattern matches the given name reference.
 * Look at resolved information only if specified.
 */
private int matchLevel(NameReference nameRef, boolean resolve) {
	if (!resolve) {
		if (this.simpleName == null) {
			return this.needsResolve ? POSSIBLE_MATCH : ACCURATE_MATCH;
		} else {
			if (nameRef instanceof SingleNameReference) {
				if (this.matchesName(this.simpleName, ((SingleNameReference)nameRef).token)) {
					return this.needsResolve ? POSSIBLE_MATCH : ACCURATE_MATCH;
				} else {
					return IMPOSSIBLE_MATCH;
				}
			} else { // QualifiedNameReference
				char[][] tokens = ((QualifiedNameReference)nameRef).tokens;
				for (int i = 0, max = tokens.length; i < max; i++){
					if (this.matchesName(this.simpleName, tokens[i])) 
						return this.needsResolve ? POSSIBLE_MATCH : ACCURATE_MATCH;
				}
				return IMPOSSIBLE_MATCH;
			}				
		}
	} else {
		Binding binding = nameRef.binding;
		if (binding == null) {
			return INACCURATE_MATCH;
		} else {
			if (nameRef instanceof SingleNameReference) {
				if (binding instanceof TypeBinding) {
					return this.matchLevelForType(this.simpleName, this.qualification, (TypeBinding) binding);
				} else {
					return IMPOSSIBLE_MATCH; // must be a type binding
				}
			} else { // QualifiedNameReference
				TypeBinding typeBinding = null;
				QualifiedNameReference qNameRef = (QualifiedNameReference)nameRef;
				char[][] tokens = qNameRef.tokens;
				int lastIndex = tokens.length-1;
				switch (qNameRef.bits & AstNode.RestrictiveFlagMASK) {
					case BindingIds.FIELD : // reading a field
						typeBinding = ((FieldBinding)binding).declaringClass;
						// no valid match amongst fields
						int otherBindingsCount = qNameRef.otherBindings == null ? 0 : qNameRef.otherBindings.length;			
						lastIndex -= otherBindingsCount + 1;
						if (lastIndex < 0) return IMPOSSIBLE_MATCH;
						break;
					case BindingIds.LOCAL : // reading a local variable
						return IMPOSSIBLE_MATCH; // no type match in it
					case BindingIds.TYPE : //=============only type ==============
						typeBinding = (TypeBinding)binding;
				}
				// try to match all enclosing types for which the token matches as well.
				while (typeBinding != null && lastIndex >= 0){
					if (this.matchesName(this.simpleName, tokens[lastIndex--])) {
						int level = this.matchLevelForType(this.simpleName, this.qualification, typeBinding);
						if (level != IMPOSSIBLE_MATCH) {
							return level;
						}
					}
					if (typeBinding instanceof ReferenceBinding){
						typeBinding = ((ReferenceBinding)typeBinding).enclosingType();
					} else {
						typeBinding = null;
					}
				}
				return IMPOSSIBLE_MATCH;
			}
		}
	}
}

