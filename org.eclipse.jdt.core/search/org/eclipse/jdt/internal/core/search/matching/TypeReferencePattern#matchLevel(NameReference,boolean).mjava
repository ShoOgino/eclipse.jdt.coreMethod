/**
 * Returns whether this type pattern matches the given name reference.
 * Look at resolved information only if specified.
 */
private int matchLevel(NameReference nameRef, boolean resolve) {
	if (!resolve) {
		if (this.simpleName == null) {
			return this.needsResolve ? POSSIBLE_MATCH : ACCURATE_MATCH;
		} else {
			if (nameRef instanceof SingleNameReference) {
				if (this.matchesName(this.simpleName, ((SingleNameReference)nameRef).token)) {
					// can only be a possible match since resolution is needed 
					// to find out if it is a type ref
					return POSSIBLE_MATCH;
				} else {
					return IMPOSSIBLE_MATCH;
				}
			} else { // QualifiedNameReference
				char[][] tokens = ((QualifiedNameReference)nameRef).tokens;
				for (int i = 0, max = tokens.length; i < max; i++){
					if (this.matchesName(this.simpleName, tokens[i])) {
						// can only be a possible match since resolution is needed 
						// to find out if it is a type ref
						return POSSIBLE_MATCH;
					}
				}
				return IMPOSSIBLE_MATCH;
			}				
		}
	} else {
		Binding binding = nameRef.binding;

		if (nameRef instanceof SingleNameReference) {
			if (binding == null || binding instanceof ProblemBinding){
				return INACCURATE_MATCH;
			} else if (binding instanceof TypeBinding) {
				return this.matchLevelForType(this.simpleName, this.qualification, (TypeBinding) binding);
			} else {
				return IMPOSSIBLE_MATCH; // must be a type binding
			}
		} else { // QualifiedNameReference
			TypeBinding typeBinding = null;
			QualifiedNameReference qNameRef = (QualifiedNameReference)nameRef;
			char[][] tokens = qNameRef.tokens;
			int lastIndex = tokens.length-1;
			switch (qNameRef.bits & AstNode.RestrictiveFlagMASK) {
				case BindingIds.FIELD : // reading a field
					typeBinding = nameRef.actualReceiverType;
					// no valid match amongst fields
					int otherBindingsCount = qNameRef.otherBindings == null ? 0 : qNameRef.otherBindings.length;			
					lastIndex -= otherBindingsCount + 1;
					if (lastIndex < 0) return IMPOSSIBLE_MATCH;
					break;
				case BindingIds.LOCAL : // reading a local variable
					return IMPOSSIBLE_MATCH; // no type match in it
				case BindingIds.TYPE : //=============only type ==============
					if (!(binding instanceof TypeBinding)) {
						return INACCURATE_MATCH;
					}
					typeBinding = (TypeBinding)binding;
					break;
				/*
				 * Handling of unbound qualified name references. The match may reside in the resolved fragment,
				 * which is recorded inside the problem binding, along with the portion of the name until it became a problem.
				 */
				case BindingIds.VARIABLE : //============unbound cases===========
				case BindingIds.TYPE | BindingIds.VARIABLE :						
					if (binding instanceof ProblemBinding) {
						ProblemBinding pbBinding = (ProblemBinding) binding;
						typeBinding = pbBinding.searchType; // second chance with recorded type so far
						char[] partialQualifiedName = pbBinding.name;
						lastIndex = CharOperation.occurencesOf('.', partialQualifiedName) - 1; // index of last bound token is one before the pb token
						if (typeBinding == null || lastIndex < 0) return INACCURATE_MATCH;
					} else if (binding instanceof ProblemReferenceBinding) {
						return INACCURATE_MATCH;
					}
					break;
			}
			// try to match all enclosing types for which the token matches as well.
			while (typeBinding != null && lastIndex >= 0){
				if (this.matchesName(this.simpleName, tokens[lastIndex--])) {
					int level = this.matchLevelForType(this.simpleName, this.qualification, typeBinding);
					if (level != IMPOSSIBLE_MATCH) {
						return level;
					}
				}
				if (typeBinding instanceof ReferenceBinding){
					typeBinding = ((ReferenceBinding)typeBinding).enclosingType();
				} else {
					typeBinding = null;
				}
			}
			return IMPOSSIBLE_MATCH;
		}
	}
}

