public SearchMatch newDeclarationMatch(ASTNode reference, IJavaElement element, Binding elementBinding, int accuracy, int length, MatchLocator locator) {
	if (elementBinding != null) {
		MethodBinding methodBinding = (MethodBinding) elementBinding;
		// Redo arguments verif as in this case previous filter may accept different ones
		boolean equals = true;
		if (this.pattern.parameterSimpleNames != null) {
			int paramLength = this.pattern.parameterSimpleNames.length;
			for (int i=0; equals && i<paramLength; i++) {
				int level = resolveLevelForType(this.pattern.parameterSimpleNames[i], this.pattern.parameterQualifications[i], methodBinding.parameters[i]);
				if (level == IMPOSSIBLE_MATCH) equals = false;
			}
		}
		// If arguments are not equals then try to see if method arguments can match erasures in hierarchy
		if (!equals && this.pattern.findDeclarations && this.mayBeGeneric) {
			if (isErasureMethodOverride(methodBinding.declaringClass, methodBinding)) {
				return super.newDeclarationMatch(reference, element, elementBinding, accuracy, length, locator);
			}
			if (isTypeInSuperDeclaringTypeNames(methodBinding.declaringClass.compoundName)) {
				MethodBinding patternBinding = locator.getMethodBinding(this.pattern);
				if (patternBinding != null) {
					patternBinding = patternBinding.original();
					if (!isErasureMethodOverride(patternBinding.declaringClass, patternBinding)) {
						return null;
					}
				}
				return super.newDeclarationMatch(reference, element, elementBinding, accuracy, length, locator);
			}
			return null;
		}
	}
	return super.newDeclarationMatch(reference, element, elementBinding, accuracy, length, locator);
}

