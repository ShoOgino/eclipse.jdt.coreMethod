	/**
	 * @param value
	 *            The JDT representation of a compile-time constant. See
	 *            {@link ElementValuePair#getValue()} for possible object types:
	 *            <ul>
	 *            <li>{@link org.eclipse.jdt.internal.compiler.impl.Constant} for member
	 *            of primitive type or String</li>
	 *            <li>{@link TypeBinding} for a member value of type
	 *            {@link java.lang.Class}</li>
	 *            <li>{@link FieldBinding} for an enum constant</li>
	 *            <li>{@link AnnotationBinding} for an annotation instance</li>
	 *            <li><code>Object[]</code> for a member value of array type, where the
	 *            array entries are one of the above</li>
	 *            </ul>
	 * @param type
	 *            The JDT representation of the type of the constant, as determined
	 *            by the return type of the element.  This is needed because the type
	 *            of the value may have been widened (e.g., byte to int) by the compiler
	 *            and we need to call the proper visitor.  This is used only for base types.
	 *            If it is null or not a BaseTypeBinding, it is ignored and the type is
	 *            determined from the type of the value.
	 */
	public AnnotationValueImpl(BaseProcessingEnvImpl env, Object value, TypeBinding type) {
		_env = env;
		int kind[] = new int[1];
		if (value instanceof Object[]) {
			Object[] values = (Object[])value;
			List<AnnotationValue> convertedValues = new ArrayList<AnnotationValue>(values.length);
			for (Object oneValue : values) {
				TypeBinding valueType = null;
				if (type instanceof ArrayBinding) {
					valueType = ((ArrayBinding)type).elementsType();
				}
				convertedValues.add(new AnnotationValueImpl(_env, oneValue, valueType));
			}
			_value = Collections.unmodifiableList(convertedValues);
			_kind = T_ArrayType;
		}
		else {
			_value = convertToJavaType(value, type, kind);
			_kind = kind[0];
		}
	}

