    /* (non-Javadoc)
     * @see javax.lang.model.util.Types#asMemberOf(javax.lang.model.type.DeclaredType, javax.lang.model.element.Element)
     */
    @Override
    public TypeMirror asMemberOf(DeclaredType containing, Element element) {
//        throw new UnsupportedOperationException("NYI: TypesImpl.asMemberOf(" + containing + ", " + element + ")"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
    	ElementImpl elementImpl = (ElementImpl) element;
    	DeclaredTypeImpl declaredTypeImpl = (DeclaredTypeImpl) containing;
    	ReferenceBinding referenceBinding = (ReferenceBinding) declaredTypeImpl._binding;
    	switch(element.getKind()) {
    		case CONSTRUCTOR :
    		case METHOD :
    			MethodBinding methodBinding = (MethodBinding) elementImpl._binding;
    			if (TypeBinding.notEquals(methodBinding.declaringClass, referenceBinding)) {
    				throw new IllegalArgumentException("element is not valid for the containing declared type"); //$NON-NLS-1$
    			}
    			for (MethodBinding method : referenceBinding.methods()) {
    				if (CharOperation.equals(method.selector, methodBinding.selector)
    						&& method.areParameterErasuresEqual(methodBinding)) {
    					return this._env.getFactory().newTypeMirror(method);
    				}
    			}
    			break;
    		case FIELD :
    		case ENUM_CONSTANT:
    			FieldBinding fieldBinding = (FieldBinding) elementImpl._binding;
    			if (TypeBinding.notEquals(fieldBinding.declaringClass, referenceBinding)) {
    				throw new IllegalArgumentException("element is not valid for the containing declared type"); //$NON-NLS-1$
    			}
    			for (FieldBinding field : referenceBinding.fields()) {
    				if (CharOperation.equals(field.name, fieldBinding.name)) {
    					return this._env.getFactory().newTypeMirror(field);
    				}
    			}
    			break;
    		case ENUM :
    		case ANNOTATION_TYPE :
    		case INTERFACE :
    		case CLASS :
    			ReferenceBinding referenceBinding2 = (ReferenceBinding) elementImpl._binding;
    			if (TypeBinding.notEquals(referenceBinding2.enclosingType(), referenceBinding)) {
    				throw new IllegalArgumentException("element is not valid for the containing declared type"); //$NON-NLS-1$
    			}
    			for (ReferenceBinding referenceBinding3 : referenceBinding.memberTypes()) {
    				if (CharOperation.equals(referenceBinding3.compoundName, referenceBinding3.compoundName)) {
    					return this._env.getFactory().newTypeMirror(referenceBinding3);
    				}
    			}
    			break;
    		default:
    			break;
    	}
		throw new IllegalArgumentException("element is not valid for the containing declared type: element kind " + element.getKind()); //$NON-NLS-1$
    }

