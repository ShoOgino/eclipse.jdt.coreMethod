    @Override
    public TypeMirror asMemberOf(DeclaredType containing, Element element) {
//        throw new UnsupportedOperationException("NYI: TypesImpl.asMemberOf(" + containing + ", " + element + ")"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
    	ElementImpl elementImpl = (ElementImpl) element;
    	DeclaredTypeImpl declaredTypeImpl = (DeclaredTypeImpl) containing;
    	ReferenceBinding referenceBinding = (ReferenceBinding) declaredTypeImpl._binding;
    	switch(element.getKind()) {
    		case CONSTRUCTOR :
    		case METHOD :
    			MethodBinding methodBinding = (MethodBinding) elementImpl._binding;
    			while (referenceBinding != null) {
                    for (MethodBinding method : referenceBinding.methods()) {
                        if (CharOperation.equals(method.selector, methodBinding.selector)
                                && method.areParameterErasuresEqual(methodBinding)) {
                            return this._env.getFactory().newTypeMirror(method);
                        }
                    }
                    referenceBinding = referenceBinding.superclass();
                }
    			break;
    		case FIELD :
    		case ENUM_CONSTANT:
    			FieldBinding fieldBinding = (FieldBinding) elementImpl._binding;
                while (referenceBinding != null) {
                    for (FieldBinding field : referenceBinding.fields()) {
                        if (CharOperation.equals(field.name, fieldBinding.name)) {
                            return this._env.getFactory().newTypeMirror(field);
                        }
                    }
                    referenceBinding = referenceBinding.superclass();
                }
    			break;
    		case ENUM :
    		case ANNOTATION_TYPE :
    		case INTERFACE :
    		case CLASS :
    			ReferenceBinding elementBinding = (ReferenceBinding) elementImpl._binding;
                while (referenceBinding != null) {
                    // If referenceBinding is a ParameterizedTypeBinding, this will return only ParameterizedTypeBindings
                    // for member types, even if the member happens to be a static nested class. That's probably a bug;
                    // static nested classes are not parameterized by their outer class.
                    for (ReferenceBinding memberReferenceBinding : referenceBinding.memberTypes()) {
                        if (CharOperation.equals(elementBinding.compoundName, memberReferenceBinding.compoundName)) {
                            return this._env.getFactory().newTypeMirror(memberReferenceBinding);
                        }
                    }
                    referenceBinding = referenceBinding.superclass();
                }
    			break;
    		default:
                throw new IllegalArgumentException("element " + element + //$NON-NLS-1$
                        " has unrecognized element kind " + element.getKind()); //$NON-NLS-1$
            }
            throw new IllegalArgumentException("element " + element + //$NON-NLS-1$
                    " is not a member of the containing type " + containing +  //$NON-NLS-1$
                    " nor any of its superclasses"); //$NON-NLS-1$
    }

