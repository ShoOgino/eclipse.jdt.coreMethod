/**
 * Ensures that the reconciler does nothing when the source
 * to reconcile with is the same as the current contents.
 * TODO (frederic) disabled as we cannot rely on this test result
 */
public void _testPerfSearchAllTypeNamesAndReconcile() throws CoreException {
	tagAsSummary("Model>Reconcile>Parser", false); // do NOT put in fingerprint

	// Wait for indexing end
	waitUntilIndexesReady();

	// Warm up
	ICompilationUnit workingCopy = null;
	this.scope = SearchEngine.createJavaSearchScope(new IJavaElement[] { JDT_CORE_PROJECT });
	try {
		ProblemRequestor requestor = new ProblemRequestor();
		workingCopy = PARSER_WORKING_COPY.getWorkingCopy(new WorkingCopyOwner() {}, requestor, null);
		if (WARMUP_COUNT > 0) {
			for (int i=0; i<WARMUP_COUNT; i++) {
				searchAllTypeNames();
				CompilationUnit unit = workingCopy.reconcile(AST.JLS3, true, null, null);
				assertNotNull("Compilation Unit should not be null!", unit);
				assertNotNull("Bindings were not resolved!", unit.getPackage().resolveBinding());
			}
		}

		// Measures
		int iterations = 2;
		resetCounters();
		for (int i=0; i<MEASURES_COUNT; i++) {
			runGc();
			startMeasuring();
			for (int n=0; n<iterations; n++) {
				searchAllTypeNames();
				workingCopy.reconcile(AST.JLS3, true, null, null);
			}
			stopMeasuring();
		}
	}
	finally {
		workingCopy.discardWorkingCopy();
	}
	
	// Commit
	commitMeasurements();
	assertPerformance();

}

