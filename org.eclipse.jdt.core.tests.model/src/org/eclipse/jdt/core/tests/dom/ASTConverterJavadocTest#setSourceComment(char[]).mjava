	/*
	 * Convert Javadoc source to match Javadoc.toString().
	 * Store converted comments and their corresponding tags respectively
	 * in this.comments and this.allTags fields
	 */
	protected void setSourceComment(char[] source) {
		this.comments = new ArrayList();
		this.allTags = new ArrayList();
		StringBuffer buffer = null;
		int comment = 0;
		boolean end = false, lineStarted = false;
		String tag = null;
		List tags = new ArrayList();
		int length = source.length;
		char previousChar=0, currentChar=0;
		for (int i=0; i<length; i++) {
			previousChar = currentChar;
			// get next char
			currentChar = source[i];
			int charLength = 1;
			if (currentChar == '\\' && source[i+1] == 'u') {
				//-------------unicode traitement ------------
				int c1, c2, c3, c4;
				charLength++;
				while (source[i+charLength] == 'u') charLength++;
				if (((c1 = Character.getNumericValue(source[i+charLength++])) > 15
					|| c1 < 0)
					|| ((c2 = Character.getNumericValue(source[i+charLength++])) > 15 || c2 < 0)
					|| ((c3 = Character.getNumericValue(source[i+charLength++])) > 15 || c3 < 0)
					|| ((c4 = Character.getNumericValue(source[i+charLength])) > 15 || c4 < 0)) {
					throw new RuntimeException("Invalid unicode in source at "+i);
				}
				currentChar = (char) (((c1 * 16 + c2) * 16 + c3) * 16 + c4);
				i+=charLength;
			}

			// 
			switch (comment) {
				case 0: 
					switch (currentChar) {
						case '/':
							comment = 1; // first char for comments...
							buffer = new StringBuffer();
							if (charLength == 1) {
								buffer.append(currentChar);
							} else  {
								for (int k=i-charLength; k<=i; k++) buffer.append(source[k]);
							}
							break;
						case '\'':
							while (i<length) {
								// get next char
								currentChar = source[i];
								if (currentChar == '\\' && source[i+1] == 'u') {
									//-------------unicode traitement ------------
									i++;
									int c1, c2, c3, c4;
									i++;
									while (source[i] == 'u') i++;
									if (((c1 = Character.getNumericValue(source[i++])) > 15
										|| c1 < 0)
										|| ((c2 = Character.getNumericValue(source[i++])) > 15 || c2 < 0)
										|| ((c3 = Character.getNumericValue(source[i++])) > 15 || c3 < 0)
										|| ((c4 = Character.getNumericValue(source[i++])) > 15 || c4 < 0)) {
										throw new RuntimeException("Invalid unicode in source at "+i);
									}
									currentChar = (char) (((c1 * 16 + c2) * 16 + c3) * 16 + c4);
								}
								if (currentChar == '\\') {
									// get next char
									currentChar = source[i];
									if (currentChar == '\\' && source[i+1] == 'u') {
										//-------------unicode traitement ------------
										i++;
										int c1, c2, c3, c4;
										i++;
										while (source[i] == 'u') i++;
										if (((c1 = Character.getNumericValue(source[i++])) > 15
											|| c1 < 0)
											|| ((c2 = Character.getNumericValue(source[i++])) > 15 || c2 < 0)
											|| ((c3 = Character.getNumericValue(source[i++])) > 15 || c3 < 0)
											|| ((c4 = Character.getNumericValue(source[i++])) > 15 || c4 < 0)) {
											throw new RuntimeException("Invalid unicode in source at "+i);
										}
										currentChar = (char) (((c1 * 16 + c2) * 16 + c3) * 16 + c4);
									}
								} else {
									if (currentChar == '\'') {
										break;
									}
								}
							}
							break;
						case '"':
							while (i<length) {
								// get next char
								currentChar = source[i];
								if (currentChar == '\\' && source[i+1] == 'u') {
									//-------------unicode traitement ------------
									i++;
									int c1, c2, c3, c4;
									i++;
									while (source[i] == 'u') i++;
									if (((c1 = Character.getNumericValue(source[i++])) > 15
										|| c1 < 0)
										|| ((c2 = Character.getNumericValue(source[i++])) > 15 || c2 < 0)
										|| ((c3 = Character.getNumericValue(source[i++])) > 15 || c3 < 0)
										|| ((c4 = Character.getNumericValue(source[i++])) > 15 || c4 < 0)) {
										throw new RuntimeException("Invalid unicode in source at "+i);
									}
									currentChar = (char) (((c1 * 16 + c2) * 16 + c3) * 16 + c4);
								}
								if (currentChar == '\\') {
									// get next char
									currentChar = source[i];
									if (currentChar == '\\' && source[i+1] == 'u') {
										//-------------unicode traitement ------------
										i++;
										int c1, c2, c3, c4;
										i++;
										while (source[i] == 'u') i++;
										if (((c1 = Character.getNumericValue(source[i++])) > 15
											|| c1 < 0)
											|| ((c2 = Character.getNumericValue(source[i++])) > 15 || c2 < 0)
											|| ((c3 = Character.getNumericValue(source[i++])) > 15 || c3 < 0)
											|| ((c4 = Character.getNumericValue(source[i++])) > 15 || c4 < 0)) {
											throw new RuntimeException("Invalid unicode in source at "+i);
										}
										currentChar = (char) (((c1 * 16 + c2) * 16 + c3) * 16 + c4);
									}
								} else {
									if (currentChar == '"') {
										int currentPos=i;
										// get next char
										currentChar = source[i];
										if (currentChar == '\\' && source[i+1] == 'u') {
											//-------------unicode traitement ------------
											i++;
											int c1, c2, c3, c4;
											i++;
											while (source[i] == 'u') i++;
											if (((c1 = Character.getNumericValue(source[i++])) > 15
												|| c1 < 0)
												|| ((c2 = Character.getNumericValue(source[i++])) > 15 || c2 < 0)
												|| ((c3 = Character.getNumericValue(source[i++])) > 15 || c3 < 0)
												|| ((c4 = Character.getNumericValue(source[i++])) > 15 || c4 < 0)) {
												throw new RuntimeException("Invalid unicode in source at "+i);
											}
											currentChar = (char) (((c1 * 16 + c2) * 16 + c3) * 16 + c4);
										}
										if (source[i+1] != '"') {
											i=currentPos;
											break;
										}
									}
								}
							}
							break;
					}
					break;
				case 1: // first '/' has been found...
					switch (currentChar) {
						case '/':
							if (charLength == 1) {
								buffer.append(currentChar);
							} else  {
								for (int k=i-charLength; k<=i; k++) buffer.append(source[k]);
							}
							comment = LINE_COMMENT;
							break;
						case '*':
							if (charLength == 1) {
								buffer.append(currentChar);
							} else  {
								for (int k=i-charLength; k<=i; k++) buffer.append(source[k]);
							}
							comment = 2; // next step
							break;
						default:
							comment = 0;
							break;
					}
					break;
				case 2: // '/*' has been found...
					if (currentChar == '*') {
						comment = 3; // next step...
					} else {
						comment = BLOCK_COMMENT;
					}
					if (charLength == 1) {
						buffer.append(currentChar);
					} else  {
							for (int k=i-charLength; k<=i; k++) buffer.append(source[k]);
					}
					break;
				case 3: // '/**' has bee found, verify that's not an empty block comment
					if (charLength == 1) {
						buffer.append(currentChar);
					} else  {
						for (int k=i-charLength; k<=i; k++) buffer.append(source[k]);
					}
					if (currentChar == '/') { // empty block comment
						this.comments.add(buffer.toString());
						this.allTags.add(new ArrayList());
						comment = 0;
					} else {
						comment = DOC_COMMENT;
					}
					break;
				case LINE_COMMENT:
					if (currentChar == '\r' || currentChar == '\n') {
						/*
						if (currentChar == '\r' && source[i+1] == '\n') {
							buffer.append(source[++i]);
						}
						*/
						comment = 0;
						this.comments.add(buffer.toString());
						this.allTags.add(tags);
					} else {
						if (charLength == 1) {
							buffer.append(currentChar);
						} else  {
							for (int k=i-charLength; k<=i; k++) buffer.append(source[k]);
						}
					}
					break;
				case DOC_COMMENT:
					if (tag != null) {
						if (currentChar >= 'a' && currentChar <= 'z') {
							tag += currentChar;
						} else {
							tags.add(tag);
							tag = null;
						}
					}
					switch (currentChar) {
						case '@':
							if (!lineStarted || previousChar == '{') {
								tag = "";
								lineStarted = true;
							}
							break;
						case '\r':
						case '\n':
							lineStarted = false;
							break;
						case '*':
							break;
						default:
							if (!Character.isWhitespace(currentChar)) {
								lineStarted = true;
							}
					}
				case BLOCK_COMMENT:
					if (charLength == 1) {
						buffer.append(currentChar);
					} else  {
						for (int k=i-charLength; k<=i; k++) buffer.append(source[k]);
					}
					if (end && currentChar == '/') {
						comment = 0;
						lineStarted = false;
						this.comments.add(buffer.toString());
						this.allTags.add(tags);
						tags = new ArrayList();
					}
					end = currentChar == '*';
					break;
				default:
					// do nothing
					break;
			}
		}
	}

