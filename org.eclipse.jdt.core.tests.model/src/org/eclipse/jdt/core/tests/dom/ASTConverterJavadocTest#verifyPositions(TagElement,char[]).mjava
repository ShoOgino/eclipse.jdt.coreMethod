	/*
	 * Verify positions of fragments in source
	 */
	private void verifyPositions(TagElement tagElement, char[] source) {
		String text = null;
		// Verify tag name
		String tagName = tagElement.getTagName();
		int tagStart = tagElement.getStartPosition();
		if (tagElement.isNested()) {
			assertEquals(this.prefix+"Wrong start position for "+tagElement, '{', source[tagStart++]);
		}
		if (tagName != null) {
			text= new String(source, tagStart, tagName.length());
			assertEquals(this.prefix+"Misplaced tag name at "+tagStart, tagName, text);
			tagStart += tagName.length();
		}
		// Verify each fragment
		ASTNode previousFragment = null;
		Iterator elements = tagElement.fragments().listIterator();
		while (elements.hasNext()) {
			ASTNode fragment = (ASTNode) elements.next();
			if (fragment.getNodeType() == ASTNode.TEXT_ELEMENT) {
				if (previousFragment != null) {
					if (previousFragment.getNodeType() == ASTNode.TEXT_ELEMENT) {
						assertTrue(this.prefix+"Wrong length for text element "+previousFragment, source[tagStart] == '\r' || source[tagStart] == '\n');
						while (source[tagStart] == '*' || Character.isWhitespace(source[tagStart])) {
							tagStart++; // purge non-stored characters
						}
					} else {
						int start = tagStart;
						boolean newLine = false;
						while (source[start] == '*' || Character.isWhitespace(source[start])) {
							start++; // purge non-stored characters
							if (source[tagStart] == '\r' || source[tagStart] == '\n') {
								newLine = true;
							}
						}
						if (newLine) tagStart = start;
					}
				}
				text = new String(source, tagStart, fragment.getLength());
				assertEquals(this.prefix+"Misplaced or wrong text element at "+tagStart, text, ((TextElement) fragment).getText());
			} else {
				while (source[tagStart] == '*' || Character.isWhitespace(source[tagStart])) {
					tagStart++; // purge non-stored characters
				}
				if (fragment.getNodeType() == ASTNode.SIMPLE_NAME || fragment.getNodeType() == ASTNode.QUALIFIED_NAME) {
					verifyNamePositions(tagStart, (Name) fragment, source);
				} else if (fragment.getNodeType() == ASTNode.TAG_ELEMENT) {
					TagElement inlineTag = (TagElement) fragment;
					assertEquals(this.prefix+"Tag element has wrong start position", tagStart, inlineTag.getStartPosition());
					verifyPositions(inlineTag, source);
				} else if (fragment.getNodeType() == ASTNode.MEMBER_REF) {
					MemberRef memberRef = (MemberRef) fragment;
					// Store start position
					int start = tagStart;
					// Verify qualifier position
					Name qualifier = memberRef.getQualifier();
					if (qualifier != null) {
						text = new String(source, start, qualifier.getLength());
						assertEquals(this.prefix+"Misplaced or wrong member ref qualifier at "+start, text, qualifier.toString());
						verifyNamePositions(start, qualifier, source);
						start += qualifier.getLength();
						while (source[start] == '*' || Character.isWhitespace(source[start])) {
							start++; // purge non-stored characters
						}
					}
					// Verify member separator position
					assertEquals(this.prefix+"Misplace # separator for member ref"+memberRef, '#', source[start]);
					start++;
					while (source[start] == '*' || Character.isWhitespace(source[start])) {
						start++; // purge non-stored characters
					}
					// Verify member name position
					Name name = memberRef.getName();
					text = new String(source, start, name.getLength());
					assertEquals(this.prefix+"Misplaced or wrong member ref name at "+start, text, name.toString());
					verifyNamePositions(start, name, source);
				} else if (fragment.getNodeType() == ASTNode.METHOD_REF) {
					MethodRef methodRef = (MethodRef) fragment;
					// Store start position
					int start = tagStart;
					// Verify qualifier position
					Name qualifier = methodRef.getQualifier();
					if (qualifier != null) {
						text = new String(source, start, qualifier.getLength());
						assertEquals(this.prefix+"Misplaced or wrong member ref qualifier at "+start, text, qualifier.toString());
						verifyNamePositions(start, qualifier, source);
						start += qualifier.getLength();
						while (source[start] == '*' || Character.isWhitespace(source[start])) {
							start++; // purge non-stored characters
						}
					}
					// Verify member separator position
					assertEquals(this.prefix+"Misplaced # separator for member ref"+methodRef, '#', source[start]);
					start++;
					while (source[start] == '*' || Character.isWhitespace(source[start])) {
						start++; // purge non-stored characters
					}
					// Verify member name position
					Name name = methodRef.getName();
					text = new String(source, start, name.getLength());
					assertEquals(this.prefix+"Misplaced or wrong member ref name at "+start, text, name.toString());
					verifyNamePositions(start, name, source);
					start += name.getLength();
					// Verify arguments starting open parenthesis
					while (source[start] == '*' || Character.isWhitespace(source[start])) {
						start++; // purge non-stored characters
					}
					assertEquals(this.prefix+"Misplaced ( for member ref arguments "+methodRef, '(', source[start]);
					start++;
					// Verify parameters
					Iterator parameters = methodRef.parameters().listIterator();
					while (parameters.hasNext()) {
						MethodRefParameter param = (MethodRefParameter) parameters.next();
						// Verify parameter type positions
						while (source[start] == '*' || Character.isWhitespace(source[start])) {
							 start++; // purge non-stored characters
						}
						Type type = param.getType();
						text = new String(source, start, type.getLength());
						assertEquals(this.prefix+"Misplaced or wrong method ref parameter type at "+start, text, type.toString());
						if (type.isSimpleType()) {
							verifyNamePositions(start, ((SimpleType)type).getName(), source);
						}
						start += type.getLength();
						// Verify parameter name positions
						while (Character.isWhitespace(source[start])) { // do NOT accept '*' in parameter declaration
							 start++; // purge non-stored characters
						}
						name = param.getName();
						if (name != null) {
							text = new String(source, start, name.getLength());
							assertEquals(this.prefix+"Misplaced or wrong method ref parameter name at "+start, text, name.toString());
							start += name.getLength();
						}
						// Verify end parameter declaration
						while (source[start] == '*' || Character.isWhitespace(source[start])) {
							start++;
						}
						assertTrue(this.prefix+"Misplaced or wrong method ref parameter end at "+start, source[start] == ',' || source[start] == ')');
						start++;
						if (source[start] == ')') {
							break;
						}
					}
				}
			}
			tagStart += fragment.getLength();
			previousFragment = fragment;
		}
		if (tagElement.isNested()) {
			assertEquals(this.prefix+"Wrong end character for "+tagElement, '}', source[tagStart++]);
		}
	}

