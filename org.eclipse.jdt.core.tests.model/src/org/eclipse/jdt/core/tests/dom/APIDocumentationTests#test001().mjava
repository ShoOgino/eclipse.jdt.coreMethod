// https://bugs.eclipse.org/bugs/show_bug.cgi?id=202490
// checks that option ids and option default values match between the code and
// the javadoc
public void test001() throws CoreException, IllegalArgumentException, IllegalAccessException, IOException {
	// fetch JavaCore class
	Class javaCoreClass = JavaCore.class;
	// fetch JavaCore source file
	@SuppressWarnings("deprecation")Bundle bundle = org.eclipse.jdt.core.tests.Activator.getInstance().getBundle();
	URL url = bundle.getEntry("/");
System.err.println("Bundle URL = "+url);
	IPath path = new Path(FileLocator.toFileURL(url).getPath());
System.err.println("Bundle path = "+path);
	path = path.removeLastSegments(1).append("org.eclipse.jdt.core");
System.err.println("jdt.core path = "+path);
	String stringPath = path.toString() + "/model/org/eclipse/jdt/core/JavaCore.java"; 
	File javaCoreSourceFile = new File(stringPath);
System.err.println("JavaCore.java = "+javaCoreSourceFile+" exists? "+javaCoreSourceFile.exists());
	char[] sourceChars = null;
	if (javaCoreSourceFile.exists()) {
		sourceChars = org.eclipse.jdt.internal.compiler.util.Util.getFileCharContent(javaCoreSourceFile, null);
	} else {
		// experimental Q&D tweak: try to find the source bundle by manipulating the file name of the regular bundle's location:
		@SuppressWarnings("deprecation")Bundle[] sourceBundles = org.eclipse.jdt.core.tests.Activator.getPackageAdmin().getBundles("org.eclipse.jdt.core", null);
		if (sourceBundles != null && sourceBundles.length > 0) {
			bundle = sourceBundles[0];
System.err.println("Source Bundle = "+bundle);
			stringPath = bundle.getLocation();
System.err.println("Bundle Location = "+stringPath);
			if (stringPath.startsWith("reference:file:"))
				stringPath = stringPath.substring("reference:file:".length());
			stringPath = stringPath.replace("org.eclipse.jdt.core", "org.eclipse.jdt.core.source");
System.err.println("Source Bundle Location = "+stringPath);
			if (stringPath.endsWith(".jar")) {
				File jarFile = new File(stringPath);
System.err.println("Jar File = "+jarFile+" exists? "+jarFile.exists());
				try (ZipFile zipFile = new ZipFile(jarFile)) {
					ZipEntry entry = zipFile.getEntry("org/eclipse/jdt/core/JavaCore.java");
System.err.println("Zip Entry = "+entry);
System.err.println("Zip Entry Size = "+entry.getSize());
					try (InputStream inputStream = zipFile.getInputStream(entry)) {
						sourceChars = org.eclipse.jdt.internal.compiler.util.Util.getInputStreamAsCharArray(inputStream, (int)entry.getSize(), null);
					}
				}
			}
		}
	}
	if (sourceChars != null) {
		// load field values in a map
		Hashtable realOptionIDs = new Hashtable();
		Field[] fields = javaCoreClass.getDeclaredFields();
		for (int i = 0, l = fields.length; i < l; i++) {
			Field field = fields[i];
			int modifiers = field.getModifiers();
			if (Modifier.isPublic(modifiers) &&
					Modifier.isStatic(modifiers) &&
					field.getType() == String.class) {
				String constantValue = (String) field.get(null);
				if (constantValue.startsWith(JavaCore.PLUGIN_ID)) {
					realOptionIDs.put(field.getName(), constantValue);
				}
			}
		}
		// exempt a few values
		realOptionIDs.remove("PLUGIN_ID");
		realOptionIDs.remove("BUILDER_ID");
		realOptionIDs.remove("JAVA_SOURCE_CONTENT_TYPE");
		realOptionIDs.remove("MODEL_ID");
		realOptionIDs.remove("NATURE_ID");
		realOptionIDs.remove("DEFAULT_JAVA_FORMATTER");
		// build cross-index
		Hashtable realOptionNames = new Hashtable();
		Iterator optionIDs = realOptionIDs.entrySet().iterator();
		while (optionIDs.hasNext()) {
			Map.Entry optionID = (Map.Entry) optionIDs.next();
			realOptionNames.put(optionID.getValue(), optionID.getKey());
		}

		// fetch default option values
		Hashtable realDefaultValues = JavaCore.getDefaultOptions();
		// load documented values in a map
		ASTParser parser = ASTParser.newParser(JLS3_INTERNAL);
		parser.setSource(sourceChars);
		ASTNode rootNode = parser.createAST(null);
		final JavaCoreJavadocAnalyzer analyzer = new JavaCoreJavadocAnalyzer();
		final Hashtable javadocOptionIDs = new Hashtable();
		final Hashtable javadocDefaultValues = new Hashtable();
		final Hashtable deprecatedFields = new Hashtable();
		rootNode.accept(new ASTVisitor() {
			public boolean visit(FieldDeclaration node) {
				String key = ((VariableDeclarationFragment) node.fragments().get(0)).getName().getIdentifier();
				Javadoc javadoc = node.getJavadoc();
				if (javadoc != null) {
					analyzer.reset(javadoc.toString());
					String id, value;
					if ((id = analyzer.getOptionID()) != null) {
						javadocOptionIDs.put(key, id);
					}
					if ((value = analyzer.getDefaultValue()) != null) {
						javadocDefaultValues.put(id, value);
					}
					if (analyzer.isDeprecated()) {
						deprecatedFields.put(key, key /* not null */);
					}
				}
				return super.visit(node);
			}
		});
		// checking ids
		Iterator check = realOptionIDs.entrySet().iterator();
		String key, value;
		String expected = "", actual = "";
		while (check.hasNext()) {
			Map.Entry entry = (Map.Entry) check.next();
			key = (String) entry.getKey();
			value = (String) entry.getValue();
			if (deprecatedFields.get(key) == null) {
				if (!value.equals(javadocOptionIDs.get(key))) {
					expected = value;
					actual = (String) javadocOptionIDs.get(key);
					System.out.println("option ID mismatch for " + key + ", real: " + expected +
						", javadoc: " + actual);
				}
			}
		}
		check = javadocOptionIDs.entrySet().iterator();
		while (check.hasNext()) {
			Map.Entry entry = (Map.Entry) check.next();
			key = (String) entry.getKey();
			value = (String) entry.getValue();
			if (!value.equals(realOptionIDs.get(key))) {
				expected = value;
				actual = (String) realOptionIDs.get(key);
				System.out.println("option ID mismatch, javadoc " + expected +
					", real " + actual);
			}
		}
		// checking default values
		check = realDefaultValues.entrySet().iterator();
		while (check.hasNext()) {
			Map.Entry entry = (Map.Entry) check.next();
			key = (String) entry.getKey();
			value = (String) entry.getValue();
			String name = (String) realOptionNames.get(key);
			if (name != null && deprecatedFields.get(name) == null) {
				if (!value.equals(javadocDefaultValues.get(key)) &&
						!"org.eclipse.jdt.core.encoding".equals(key)) {
					expected = value;
					actual = (String) javadocDefaultValues.get(key);
					System.out.println("default value mismatch for " + key + ", real: " + expected +
						", javadoc: " + actual);
				}
			}
		}
		check = javadocDefaultValues.entrySet().iterator();
		while (check.hasNext()) {
			Map.Entry entry = (Map.Entry) check.next();
			key = (String) entry.getKey();
			value = (String) entry.getValue();
			if (!value.equals(realDefaultValues.get(key)) &&
					!"org.eclipse.jdt.core.compiler.problem.booleanMethodThrowingException".equals(key)) { // will remove once bug 216571 is fixed
				expected = value;
				actual = (String) realDefaultValues.get(key);
				System.out.println("default value mismatch for " + key + ", javadoc " + expected +
					", real " + actual);
			}
		}
		assertEquals("One or many discrepancies, including: ", expected, actual);
	} else {
		System.err.println("JavaCore.java not found, skipping APIDocumentationTests#test001");
	}
}

