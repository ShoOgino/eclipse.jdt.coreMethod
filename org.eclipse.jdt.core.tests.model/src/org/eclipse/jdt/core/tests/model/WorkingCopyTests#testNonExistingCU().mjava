/**
 * Creates a working copy on a non-existing compilation unit.
 * (regression test for bug 8921  DCR - Need a way to create a working copy ignoring existing files)
 */
public void testNonExistingCU() throws JavaModelException {
	ICompilationUnit nonExistingCU = this.getCompilationUnit("P/src/x/y/NonExisting.java");
	IWorkingCopy workingCopy = null;
	try {
		// getBuffer()
		workingCopy = (IWorkingCopy)nonExistingCU.getWorkingCopy();
		assertSourceEquals("Buffer should be empty", "", ((IOpenable)workingCopy).getBuffer().getContents());
		
		// exists()
		assertTrue("Working copy should exists", ((IJavaElement)workingCopy).exists());
		
		// getCorrespondingResource()
		assertEquals("Corresponding resource should be null", null, ((IJavaElement)workingCopy).getCorrespondingResource());
		
		// getOriginalElement()
		assertEquals("Unexpected orginal element", nonExistingCU, workingCopy.getOriginalElement());
		
		// getPath()
		assertEquals("Unexpected path", new Path("/P/src/x/y/NonExisting.java"), ((IJavaElement)workingCopy).getPath());
		
		// getResource()
		assertEquals("Unexpected resource", null, ((IJavaElement)workingCopy).getResource());
		
		// isConsistent()
		assertTrue("Working copy should be consistent", ((IOpenable)workingCopy).isConsistent());
		
		// restore()
		boolean exception = false;
		try {
			workingCopy.restore();
		} catch (JavaModelException e) {
			exception = true;
		}
		assertTrue("Should not be able to restore from original element", exception);
		
		// makeConsistent()
		((IOpenable)workingCopy).getBuffer().setContents(
			"public class X {\n" +
			"}");
		assertTrue("Working copy should not be consistent", !((IOpenable)workingCopy).isConsistent());
		((IOpenable)workingCopy).makeConsistent(null);
		assertTrue("Working copy should be consistent", ((IOpenable)workingCopy).isConsistent());
		
		// save()
		((IOpenable)workingCopy).getBuffer().setContents(
			"public class Y {\n" +
			"}");
		((IOpenable)workingCopy).save(null, false);
		assertTrue("Working copy should be consistent after save", ((IOpenable)workingCopy).isConsistent());
		assertTrue("Original cu should not exist", !nonExistingCU.exists());
		
		// commit()
		workingCopy.commit(false, null);
		assertTrue("Original cu should exist", nonExistingCU.exists());

		// isBasedOn()
		assertTrue("Working copy should not be based on original resource", !workingCopy.isBasedOn(nonExistingCU.getResource()));
		
	} finally {
		if (workingCopy != null) {
			workingCopy.destroy();
		}
		if (nonExistingCU.exists()) {
			nonExistingCU.delete(true, null);
		}
	}
}

