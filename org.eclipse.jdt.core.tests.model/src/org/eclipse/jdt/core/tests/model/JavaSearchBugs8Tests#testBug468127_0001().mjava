public void testBug468127_0001() throws CoreException {
	try {

		IJavaProject project = createJavaProject("P", new String[] {"src"}, new String[] { "/P/lib468127.jar", "JCL18_LIB" }, "bin", "1.8");
		createFile(
			"/P/src/X.java",
			"public class X {\n" +
			"	@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n" +
			"	public static void main(String[] args) {\n" +
			"		IY y = s -> foo(0);\n" +
			"		y.accept(0);\n" +
			"	}\n" +
			"	static private void foo(int i) {}\n" +
			"}\n"
		);

		String libSource = "final class MyDistinctOps {\n" +
				"    static <T> MyStatefulOp<T> makeRef() {\n" +
				"        return new MyStatefulOp<T>() {\n" +
				"			@SuppressWarnings(\"unused\")\n" +
				"			@Override\n" +
				"		 	void opEvaluateParallel() {\n" +
				"                TerminalOp<T, Void> forEachOp = ForEachOps.makeRef(t -> {}, false);\n" +
				"			}\n" +
				"    @SuppressWarnings({ \"unchecked\", \"rawtypes\", \"unused\" })\n" +
				"	 MySink<T> opWrapSink(MySink<T> sink) {\n" +
				"           return new MySink.ChainedReference(sink) {\n" +
				"\n" +
				"				@Override\n" +
				"				public void accept(Object t) {\n" +
				"                     downstream.accept(t);					\n" +
				"				}\n" +
				"            };\n" +
				"        }\n" +
				"        };\n" +
				"}\n" +
				"\n" +
				"interface TerminalOp<E_IN, R> {}\n" +
				"final static class ForEachOps {\n" +
				"    public static <T> TerminalOp<T, Void> makeRef(IY<? super T> action,\n" +
				"                                                  boolean ordered) {\n" +
				"    	return null;\n" +
				"    }\n" +
				"\n" +
				"}\n" +
				"\n" +
				"abstract static class MyStatefulOp<T> {\n" +
				"	abstract void opEvaluateParallel();\n" +
				"}\n" +
				"}\n" +
				"\n" +
				"interface MySink<T> extends IY<T> {\n" +
				"    static abstract class ChainedReference<T, E_OUT> implements MySink<T> {\n" +
				"    protected final MySink<T> downstream;\n" +
				"\n" +
				"    public ChainedReference(MySink<T> downstream) {\n" +
				"        this.downstream = downstream;\n" +
				"    }\n" +
				"}\n" +
				"}\n";

		String iy = "@FunctionalInterface\n" +
					"public interface IY<T> {\n" +
					"  public void accept(T t);\n" +
					"}\n";	
		try {
			String jarFileName = "lib468127.jar";
			String srcZipName = "lib468127.src.zip";
			createLibrary(project, jarFileName, srcZipName, new String[] {"IY.java", iy, "MyDistinctOps.java",libSource},
					new String[0], JavaCore.VERSION_1_8);
			IFile srcZip=(IFile) project.getProject().findMember(srcZipName);
			IFile jar = (IFile) project.getProject().findMember(jarFileName);
			JarPackageFragmentRoot root = (JarPackageFragmentRoot) project.getPackageFragmentRoot(jar);
			root.attachSource(srcZip.getFullPath(), null, null);
			waitUntilIndexesReady();

			SearchPattern pattern = SearchPattern.createPattern("IY.accept(T)", METHOD, REFERENCES, ERASURE_RULE);
			search(pattern, SearchEngine.createJavaSearchScope(new IJavaElement[] { project }, IJavaSearchScope.APPLICATION_LIBRARIES | IJavaSearchScope.SOURCES), this.resultCollector);
			assertSearchResults(
					"src/X.java void X.main(String[]) [accept(0)] EXACT_MATCH\n" + 
					"lib468127.jar void <anonymous>.accept(java.lang.Object) EXACT_MATCH");
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	finally {
		deleteProject("P");
	}
}

