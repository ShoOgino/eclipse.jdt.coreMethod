	/*
	 * Ensures that using AST.parseCompilationUint(IClassFile, boolean, WorkingCopyOwner) and 
	 * computing the bindings takes the owner's working copies into account.
	 */
	public void testParseCompilationUnit3() throws CoreException, IOException {
		ICompilationUnit workingCopy = null;
		try {
			createJavaProject("P1", new String[] {"src"}, new String[] {"JCL_LIB", "lib"}, "bin");
			
			// copy X.class in lib folder
			String sourceWorkspacePath = getSourceWorkspacePath();
			String targetWorkspacePath = getWorkspaceRoot().getLocation().toFile().getCanonicalPath();
			copyDirectory(new File(new File(sourceWorkspacePath, "AttachSourceTests"), "lib"), new File(new File(targetWorkspacePath, "P1"), "lib"));
			getProject("P1").refreshLocal(IResource.DEPTH_INFINITE, null);
			
			// create libsrc and attach source
			createFolder("P1/libsrc/p");
			createFile(
				"P1/libsrc/p/X.java",
				"package p;\n" +
				"public class X extends Y {\n" +
				"}"
			);
			IPackageFragmentRoot lib = getPackageFragmentRoot("P1/lib");
			lib.attachSource(new Path("/P1/libsrc"), null, null);
			
			// create Y.java in src folder
			createFolder("P1/src/p");
			createFile("P1/src/p/Y.java", "");
			
			// create working copy on Y.java
			TestWorkingCopyOwner owner = new TestWorkingCopyOwner();
			workingCopy = getCompilationUnit("P1/src/p/Y.java").getWorkingCopy(owner, null, null);
			workingCopy.getBuffer().setContents(
				"package p;\n" +
				"public class Y {\n" +
				"}"
			);
			workingCopy.makeConsistent(null);

			// parse and resolve class file
			IClassFile classFile = getClassFile("P1/lib/p/X.class");
			CompilationUnit cu = AST.parseCompilationUnit(
				classFile,
				true,
				owner);
			List types = cu.types();
			assertEquals("Unexpected number of types in AST", 1, types.size());
			TypeDeclaration type = (TypeDeclaration)types.get(0);
			ITypeBinding typeBinding = type.resolveBinding();
			ITypeBinding superType = typeBinding.getSuperclass();
			assertEquals(
				"Unexpected super type", 
				"p.Y",
				superType == null ? "<null>" : superType.getQualifiedName());
		} finally {
			if (workingCopy != null) {
				workingCopy.discardWorkingCopy();
			}
			deleteProject("P1");
		}
	}

