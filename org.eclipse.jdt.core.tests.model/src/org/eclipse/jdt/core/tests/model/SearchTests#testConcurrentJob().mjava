/*
 * Ensure that performing a concurrent job while indexing a jar doesn't use the old index.
 * (regression test for bug 35306 Index update request can be incorrectly handled)
 */
public void testConcurrentJob() throws CoreException, InterruptedException, IOException, TimeOutException {
	IndexManager indexManager = JavaModelManager.getJavaModelManager().getIndexManager();
	WaitingJob job = new WaitingJob();
	try {
		// setup: suspend indexing and create a project with one empty jar on its classpath
		indexManager.disable();
		JavaCore.run(new IWorkspaceRunnable() {
			public void run(IProgressMonitor monitor) throws CoreException {
				createJavaProject("P1", new String[] {}, new String[] {"/P1/jclMin.jar"}, "bin");
				createFile("/P1/jclMin.jar", EMPTY_JAR);
			}
		}, null);
		
		// add waiting job and wait for it to be executed
		indexManager.request(job);
		indexManager.enable();
		job.startingSem.acquire(30000); // wait for job to start (wait 30s max)
				
		final IJavaProject project = getJavaProject("P1");
			
		// start concurrent job
		final boolean[] success = new boolean[1];
		final WaitUntilReadyMonitor monitor = new WaitUntilReadyMonitor();
		Thread thread = new Thread() {
			public void run() {
				try {
					assertAllTypes(
						"Unexpected all types",
						project,
						WAIT_UNTIL_READY_TO_SEARCH,
						monitor,
						"java.io.Serializable\n" + 
						"java.lang.Class\n" + 
						"java.lang.CloneNotSupportedException\n" + 
						"java.lang.Error\n" + 
						"java.lang.Exception\n" + 
						"java.lang.IllegalMonitorStateException\n" + 
						"java.lang.InterruptedException\n" + 
						"java.lang.Object\n" + 
						"java.lang.RuntimeException\n" + 
						"java.lang.String\n" + 
						"java.lang.Throwable"
					);
				} catch (JavaModelException e) {
					e.printStackTrace();
					return;
				}
				success[0] = true;
			}
		};
		thread.setDaemon(true);
		thread.start();
			
		// wait for concurrent job to start
		monitor.sem.acquire(30000); // wait 30s max

		// change jar contents
		getFile("/P1/jclMin.jar").setContents(new FileInputStream(getExternalJCLPathString()), IResource.NONE, null);
			
		// resume waiting job
		job.runningSem.release();
		
		// wait for concurrent job to finish
		thread.join(10000); // 10s max
		
		assertTrue("Failed to get all types", success[0]);
				
	} finally {
		job.runningSem.release();
		deleteProject("P1");
		indexManager.enable();
	}
}

