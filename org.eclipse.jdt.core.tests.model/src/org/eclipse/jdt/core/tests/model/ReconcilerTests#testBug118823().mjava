/**
 * Bug 118823: [model] Secondary types cache not reset while removing _all_ secondary types from CU
 * @see "https://bugs.eclipse.org/bugs/show_bug.cgi?id=118823"
 */
public void testBug118823() throws CoreException, InterruptedException, IOException {
	
	// Class to listen for deltas on a compilation unit
	class TestDeltaListener implements IElementChangedListener {
		String unitName;
		boolean updated;
		TestDeltaListener(ICompilationUnit cu) {
			this.unitName = cu.getElementName();
		}
		public void elementChanged(ElementChangedEvent event) {
			if (isEventOnUnit((IJavaElementDelta)event.getSource())) {
				this.updated = true;
			}
		}
		private boolean isEventOnUnit(IJavaElementDelta delta) {
			IJavaElementDelta[] children = delta.getAffectedChildren();
			if (children != null && children.length > 0) {
				for (int i=0, l=children.length; i<l ; i++) {
					if (isEventOnUnit(children[i])) return true;
				}
			} else {
				if (this.unitName.equals(delta.getElement().getElementName()) && delta.getKind() == IJavaElementDelta.CHANGED) {
					return true;
				}
			}
			return false;
		}
	}

	// Start test
	try {
		// Resources creation
		IJavaProject project = createJavaProject("P1", new String[] {""}, new String[] {"JCL_LIB"}, "bin");
		String source1 = "class Test {}\n";
		IFile file = createFile(
			"/P1/Test.java", 
			source1
		);
		createJavaProject("P2", new String[] {""}, new String[] {"JCL_LIB"}, new String[] { "/P1" }, "bin");
		String source2 = 
			"class A {\n" +
			"	Secondary s;\n" +
			"}\n";
		createFile(
			"/P2/A.java",
			source2
		);
		waitUntilIndexesReady();
		this.workingCopies = new ICompilationUnit[2];
		this.wcOwner = new WorkingCopyOwner() {};

		// Get first working copy and verify that there's no error
		char[] sourceChars = source1.toCharArray();
		this.problemRequestor.initialize(sourceChars);
		this.workingCopies[0] = getCompilationUnit("/P1/Test.java").getWorkingCopy(new WorkingCopyOwner() {}, this.problemRequestor, null);
		assertNoProblem(sourceChars, this.workingCopies[0]);

		// Create delta listener on first working copy
		TestDeltaListener dListener = new TestDeltaListener(this.workingCopies[0]);
		JavaCore.addElementChangedListener(dListener);

		// Get second working copy and verify that there's one error (missing secondary type)
		this.problemRequestor.initialize(source2.toCharArray());
		this.workingCopies[1] = getCompilationUnit("/P2/A.java").getWorkingCopy(new WorkingCopyOwner() {}, this.problemRequestor, null);
		assertEquals("Working copy should not find secondary type 'Secondary'!", 1, this.problemRequestor.problemCount);
		assertProblems("Working copy should have problem!",
			"----------\n" +
			"1. ERROR in /P2/A.java (at line 2)\n" +
			"	Secondary s;\n" +
			"	^^^^^^^^^\n" +
			"Secondary cannot be resolved to a type\n" +
			"----------\n"
		);

		// Delete first working copy file and recreate it with secondary outside eclipse
		File ioFile = file.getLocation().toFile();
		ioFile.delete();
		source1 = 
			"public class Test {}\n" + 
			"class Secondary{}\n";
		Util.createFile(ioFile.getCanonicalPath(), source1);
		project.getProject().refreshLocal(IResource.DEPTH_INFINITE, null);

		// Wait for deltas on updated working copy
		int max = 0;
		while (!dListener.updated && max++ < 10) {
			Thread.sleep(100);
		}
		assertTrue("We should have compilation unit updated", dListener.updated);

		// Get first working copy and verify that there's still no error
		sourceChars = source1.toCharArray();
		this.problemRequestor.initialize(sourceChars);
		this.workingCopies[0].getBuffer().setContents(source1);
		this.workingCopies[0].reconcile(AST.JLS3,
			true, // force problem detection to see errors if any
			null,	// do not use working copy owner to not use working copies in name lookup
			null);
		assertNoProblem(sourceChars, this.workingCopies[0]);

		// Get second working copy and verify that there's any longer error
		sourceChars = source2.toCharArray();
		this.problemRequestor.initialize(sourceChars);
		this.workingCopies[1].getBuffer().setContents(source2);
		this.workingCopies[1].reconcile(AST.JLS3,
			true, // force problem detection to see errors if any
			null,	// do not use working copy owner to not use working copies in name lookup
			null);
		assertNoProblem(sourceChars, this.workingCopies[1]);
	} finally {
		deleteProject("P1");
		deleteProject("P2");
	}
}

