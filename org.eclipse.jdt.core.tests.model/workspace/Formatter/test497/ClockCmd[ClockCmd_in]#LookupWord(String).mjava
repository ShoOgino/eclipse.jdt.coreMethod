    /**
     *-----------------------------------------------------------------------------
     *
     * LookupWord --
     *
     *      Construct a ClockToken for the given word.
     *
     * Results:
     *      A ClockToken representing the given word.
     *
     * Side effects:
     *      None.
     *
     *-----------------------------------------------------------------------------
     */

    private ClockToken LookupWord(String word) // word to lookup
    {
        int ix;
        String[] names;
        String[][] zones;

        if (word.equalsIgnoreCase("am") || word.equalsIgnoreCase("a.m."))
            {
                return new ClockToken(ClockToken.MERIDIAN, Calendar.AM);
            }
        if (word.equalsIgnoreCase("pm") || word.equalsIgnoreCase("p.m."))
            {
                return new ClockToken(ClockToken.MERIDIAN, Calendar.PM);
            }

        // See if we have an abbreviation for a day or month.

        boolean abbrev;
        if (word.length() == 3)
            {
                abbrev = true;
            }
        else if (word.length() == 4 && word.charAt(3) == '.')
            {
                abbrev = true;
                word = word.substring(0, 3);
            }
        else
            {
                abbrev = false;
            }

        DateFormatSymbols symbols = new DateFormatSymbols(Locale.US);
        if (abbrev)
            {
                names = symbols.getShortMonths();
            }
        else
            {
                names = symbols.getMonths();
            }
        for (ix = 0; ix < names.length; ix++)
            {
                if (word.equalsIgnoreCase(names[ix]))
                    {
                        return new ClockToken(ClockToken.MONTH, ix);
                    }
            }
        if (abbrev)
            {
                names = symbols.getShortWeekdays();
            }
        else
            {
                names = symbols.getWeekdays();
            }
        for (ix = 0; ix < names.length; ix++)
            {
                if (word.equalsIgnoreCase(names[ix]))
                    {
                        return new ClockToken(ClockToken.DAY, ix);
                    }
            }

        // Drop out any periods and try the timezone table.

        StringBuffer withoutDotsBuf = new StringBuffer(word.length());
        for (ix = 0; ix < word.length(); ix++)
            {
                if (word.charAt(ix) != '.')
                    {
                        withoutDotsBuf.append(word.charAt(ix));
                    }
            }

        String withoutDots = new String(withoutDotsBuf);
        zones = symbols.getZoneStrings();

        for (ix = 0; ix < zones.length; ix++)
            {
                if (withoutDots.equalsIgnoreCase(zones[ix][2])
                        || withoutDots.equalsIgnoreCase(zones[ix][4]))
                    {
                        TimeZone zone = TimeZone.getTimeZone(zones[ix][0]);
                        return new ClockToken(ClockToken.ZONE, zone);
                    }
            }
        if (withoutDots.equalsIgnoreCase("dst"))
            {
                return new ClockToken(ClockToken.DST, null);
            }

        // Strip off any plural and try the units.

        String singular;
        if (word.endsWith("s"))
            {
                singular = word.substring(0, word.length() - 1);
            }
        else
            {
                singular = word;
            }
        if (singular.equalsIgnoreCase("year"))
            {
                return new ClockToken(ClockToken.MONTH_UNIT, 12);
            }
        else if (singular.equalsIgnoreCase("month"))
            {
                return new ClockToken(ClockToken.MONTH_UNIT, 1);
            }
        else if (singular.equalsIgnoreCase("fortnight"))
            {
                return new ClockToken(ClockToken.MINUTE_UNIT, 14 * 24 * 60);
            }
        else if (singular.equalsIgnoreCase("week"))
            {
                return new ClockToken(ClockToken.MINUTE_UNIT, 7 * 24 * 60);
            }
        else if (singular.equalsIgnoreCase("day"))
            {
                return new ClockToken(ClockToken.MINUTE_UNIT, 24 * 60);
            }
        else if (singular.equalsIgnoreCase("hour"))
            {
                return new ClockToken(ClockToken.MINUTE_UNIT, 60);
            }
        else if (singular.equalsIgnoreCase("minute"))
            {
                return new ClockToken(ClockToken.MINUTE_UNIT, 1);
            }
        else if (singular.equalsIgnoreCase("min"))
            {
                return new ClockToken(ClockToken.MINUTE_UNIT, 1);
            }
        else if (singular.equalsIgnoreCase("second"))
            {
                return new ClockToken(ClockToken.SEC_UNIT, 1);
            }
        else if (singular.equalsIgnoreCase("sec"))
            {
                return new ClockToken(ClockToken.SEC_UNIT, 1);
            }

        if (singular.equalsIgnoreCase("tomorrow"))
            {
                return new ClockToken(ClockToken.MINUTE_UNIT, 1 * 24 * 60);
            }
        else if (singular.equalsIgnoreCase("yesterday"))
            {
                return new ClockToken(ClockToken.MINUTE_UNIT, -1 * 24 * 60);
            }
        else if (singular.equalsIgnoreCase("today"))
            {
                return new ClockToken(ClockToken.MINUTE_UNIT, 0);
            }
        else if (singular.equalsIgnoreCase("now"))
            {
                return new ClockToken(ClockToken.MINUTE_UNIT, 0);
            }
        else if (singular.equalsIgnoreCase("last"))
            {
                return new ClockToken(-1, false);
            }
        else if (singular.equalsIgnoreCase("this"))
            {
                return new ClockToken(ClockToken.MINUTE_UNIT, 0);
            }
        else if (singular.equalsIgnoreCase("next"))
            {
                return new ClockToken(ClockToken.NEXT, 1);
            }
        else if (singular.equalsIgnoreCase("ago"))
            {
                return new ClockToken(ClockToken.AGO, 1);
            }
        else if (singular.equalsIgnoreCase("epoch"))
            {
                return new ClockToken(ClockToken.EPOCH, 0);
            }
        else if (singular.equalsIgnoreCase("stardate"))
            {
                return new ClockToken(ClockToken.STARDATE, 0);
            }

        // Since a military timezone (T) is used in the clock test of 8.3,
        // we can't ignore these timezones any longer...

        if (withoutDots.length() == 1)
            {
                int rawOffset = 0;
                boolean found = true;
                char milTz = Character.toLowerCase(withoutDots.charAt(0));

                if (milTz >= 'a' && milTz <= 'm')
                    {
                        rawOffset = milTz - 'a' + 1;
                    }
                else if (milTz >= 'n' && milTz < 'z')
                    {
                        rawOffset = 'n' - milTz - 1;
                    }
                else if (milTz != 'z')
                    {
                        found = false;
                    }
                if (found)
                    {
                        ClockToken zone = GetTimeZoneFromRawOffset(rawOffset);
                        if (zone != null)
                            {
                                return zone;
                            }
                    }
            }

        return new ClockToken(word);
    }

