    /**
     *-----------------------------------------------------------------------------
     *
     * GetDate --
     *
     *      Scan a human readable date string and construct a Date.
     *
     * Results:
     *      The scanned date (or null, if an error occured).
     *
     * Side effects:
     *      None.
     *
     *-----------------------------------------------------------------------------
     */

    private Date GetDate(String dateString, // Date string to scan
            Date baseDate, // Date to use as base
            boolean useGMT) // Boolean
    {
        GregorianCalendar calendar = new GregorianCalendar();
        Calendar now = Calendar.getInstance();
        now.setTime(baseDate);
        calendar.set(now.get(Calendar.YEAR), now.get(Calendar.MONTH), now
                .get(Calendar.DAY_OF_MONTH), 0, 0, 0);
        if (useGMT)
            {
                calendar.setTimeZone(TimeZone.getTimeZone("GMT"));
            }

        ClockToken[] dt = GetTokens(dateString, false);

        ParsePosition parsePos = new ParsePosition(0);
        ClockRelTimespan diff = new ClockRelTimespan();
        int hasTime = 0;
        int hasZone = 0;
        int hasDate = 0;
        int hasDay = 0;
        int hasOrdMonth = 0;
        int hasRel = 0;

        while (parsePos.getIndex() < dt.length)
            {
                if (ParseTime(dt, parsePos, calendar))
                    {
                        hasTime++;
                    }
                else if (ParseZone(dt, parsePos, calendar))
                    {
                        hasZone++;
                    }
                else if (ParseIso(dt, parsePos, calendar))
                    {
                        hasDate++;
                    }
                else if (ParseDate(dt, parsePos, calendar))
                    {
                        hasDate++;
                    }
                else if (ParseDay(dt, parsePos, diff))
                    {
                        hasDay++;
                    }
                else if (ParseOrdMonth(dt, parsePos, diff))
                    {
                        hasOrdMonth++;
                    }
                else if (ParseRelSpec(dt, parsePos, diff))
                    {
                        hasRel++;
                    }
                else if (ParseNumber(dt, parsePos, calendar, hasDate > 0
                        && hasTime > 0 && hasRel == 0))
                    {
                        if (hasDate == 0 || hasTime == 0 || hasRel > 0)
                            {
                                hasTime++;
                            }
                    }
                else if (ParseTrek(dt, parsePos, calendar))
                    {
                        hasDate++;
                        hasTime++;
                    }
                else
                    {
                        return null;
                    }
            }

        if (hasTime > 1 || hasZone > 1 || hasDate > 1 || hasDay > 1
                || hasOrdMonth > 1)
            {
                return null;
            }

        // The following line handles years that are specified using
        // only two digits.  The line of code below implements a policy
        // defined by the X/Open workgroup on the millinium rollover.
        // Note: some of those dates may not actually be valid on some
        // platforms.  The POSIX standard startes that the dates 70-99
        // shall refer to 1970-1999 and 00-38 shall refer to 2000-2038.
        // This later definition should work on all platforms.

        int thisYear = calendar.get(Calendar.YEAR);
        if (thisYear < 100)
            {
                if (thisYear >= 69)
                    {
                        calendar.set(Calendar.YEAR, thisYear + 1900);
                    }
                else
                    {
                        calendar.set(Calendar.YEAR, thisYear + 2000);
                    }
            }

        if (hasRel > 0)
            {
                if (hasTime == 0 && hasDate == 0 && hasDay == 0)
                    {
                        calendar.setTime(baseDate);
                    }
                // Certain JDK implementations are buggy WRT DST.
                // Work around this issue by adding a day instead
                // of a days worth of seconds.
                final int seconds_in_day = (60 * 60 * 24);
                int seconds = diff.getSeconds();
                boolean negative_seconds = (seconds < 0);
                int days = 0;
                if (negative_seconds)
                    seconds *= -1;
                while (seconds >= seconds_in_day)
                    {
                        seconds -= seconds_in_day;
                        days++;
                    }
                if (negative_seconds)
                    {
                        seconds *= -1;
                        days *= -1;
                    }
                if (days != 0)
                    {
                        calendar.add(Calendar.DATE, days);
                    }
                if (seconds != 0)
                    {
                        calendar.add(Calendar.SECOND, seconds);
                    }
                calendar.add(Calendar.MONTH, diff.getMonths());
            }

        if (hasDay > 0 && hasDate == 0)
            {
                SetWeekday(calendar, diff);
            }

        if (hasOrdMonth > 0)
            {
                SetOrdMonth(calendar, diff);
            }

        return calendar.getTime();
    }

