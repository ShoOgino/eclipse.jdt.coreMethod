// null analysis -- check resetting of large no. of fields
// see also https://bugs.eclipse.org/bugs/show_bug.cgi?id=369381
public void testBug247564n_2() {
	this.runNegativeTest(
		new String[] {
			"X.java",
			"public class X {\n" +
			"Object field0, \n" +						// more than 64 fields
			"field1, field2, field3, field4, \n" +
			"field5, field6, field7, field8, \n" +
			"field9, field10, field11, field12, \n" +
			"field13, field14, field15, field16, \n" +
			"field17, field18, field19, field20, \n" +
			"field21, field22, field23, field24, \n" +
			"field25, field26, field27, field28, \n" +
			"field29, field30, field31, field32, \n" +
			"field33, field34, field35, field36, \n" +
			"field37, field38, field39, field40, \n" +
			"field41, field42, field43, field44, \n" +
			"field45, field46, field47, field48, \n" +
			"field49, field50, field51, field52, \n" +
			"field53, field54, field55, field56, \n" +
			"field57, field58, field59, field60, \n" +
			"field61, field62, field63, field64; \n" +
			"  static final Object o2 = new Object();\n" +
			"  public X() {\n" +
			"    Object l0, l1, l2, l3, l4, l5, l6, l7, l8, l9,\n" +		// more than 64 locals
			"        l10, l11, l12, l13, l14, l15, l16, l17, l18, l19,\n" +
			"        l20, l21, l22, l23, l24, l25, l26, l27, l28, l29,\n" +
			"        l30, l31, l32, l33, l34, l35, l36, l37, l38, l39,\n" +
			"        l40, l41, l42, l43, l44, l45, l46, l47, l48, l49,\n" +
			"        l50, l51, l52, l53, l54, l55, l56, l57, l58, l59,\n" +
			"        l60, l61, l62, l63, l64, l65, l66, l67, l68, l69;\n" +
			"	 l69 = null;\n" +		// l69 has bits in extra[x][1]
			"	 o2.toString();\n" +	// resetNullInfoForFields() must not reset any bits in extra[x][1]
			"	 l69.toString();\n" +	// warn!
			"  }\n" +
			"}\n"},
			"----------\n" + 
			"1. ERROR in X.java (at line 30)\n" + 
			"	l69.toString();\n" + 
			"	^^^\n" + 
			"Null pointer access: The variable l69 can only be null at this location\n" + 
			"----------\n"
	);
}

