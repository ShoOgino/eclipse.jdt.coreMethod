	// local + wildcard
	// qualified allocation expression with type arguments
	public void test030() throws Exception {
		this.runConformTest(
			new String[] {
				"A.java",
				"import java.lang.annotation.Target;\n" + 
				"import static java.lang.annotation.ElementType.*;\n" + 
				"import java.lang.annotation.Retention;\n" + 
				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
				"@Target(TYPE_USE)\n" + 
				"@Retention(RUNTIME)\n" + 
				"@interface A {\n" + 
				"	String value() default \"default\";\n" + 
				"}\n",
				"B.java",
				"import java.lang.annotation.Target;\n" + 
				"import static java.lang.annotation.ElementType.*;\n" + 
				"import java.lang.annotation.Retention;\n" + 
				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
				"@Target(TYPE_USE)\n" + 
				"@Retention(CLASS)\n" + 
				"@interface B {\n" + 
				"	int value() default -1;\n" + 
				"}",
				"C.java",
				"import java.lang.annotation.Target;\n" + 
				"import static java.lang.annotation.ElementType.*;\n" + 
				"import java.lang.annotation.Retention;\n" + 
				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
				"@Target(TYPE_USE)\n" + 
				"@Retention(RUNTIME)\n" + 
				"@interface C {\n" + 
				"	char value() default '-';\n" + 
				"}\n",
				"D.java",
				"import java.lang.annotation.Target;\n" + 
				"import static java.lang.annotation.ElementType.*;\n" + 
				"import java.lang.annotation.Retention;\n" + 
				"import static java.lang.annotation.RetentionPolicy.*;\n" + 
				"@Target(TYPE_USE)\n" + 
				"@Retention(RUNTIME)\n" + 
				"@interface D {\n" + 
				"	char value() default '-';\n" + 
				"}\n",
				"X.java",
				"import java.util.Map;\n" +
				"import java.util.HashMap;\n" +
				"@SuppressWarnings({\"unchecked\",\"rawtypes\"})\n" + 
				"public class X {\n" + 
				"	Object newMap(Object o) {\n" + 
				"		Map<@A Object, ? super @C Map<@B String, @D Comparable>> map;\n" + 
				"		if (o == null) {\n" + 
				"			map = null;\n" + 
				"			System.out.println(map);\n" + 
				"		} else {\n" + 
				"			System.out.println(\"No map yet\");\n" + 
				"		}\n" + 
				"		map = new HashMap();\n" + 
				"		return map;\n" + 
				"	} \n" + 
				"}",
		},
		"");
		String expectedOutput =
			"    RuntimeVisibleTypeAnnotations: \n" + 
			"      #46 @A(\n" + 
			"        target type = 0x9 LOCAL_VARIABLE_GENERIC_OR_ARRAY\n" + 
			"        local variable entries:\n" + 
			"          [pc: 6, pc: 16] index: 2\n" + 
			"          [pc: 32, pc: 34] index: 2\n" + 
			"        locations = {0}\n" + 
			"      )\n" + 
			"      #47 @C(\n" + 
			"        target type = 0x1c WILDCARD_BOUND\n" + 
			"        wildcard location type = 0x9 LOCAL_VARIABLE_GENERIC_OR_ARRAY\n" + 
			"          local variable entries:\n" + 
			"                [pc: 6, pc: 16] index: 2\n" + 
			"                [pc: 32, pc: 34] index: 2\n" + 
			"              wildcard locations = {1}\n" + 
			"      )\n" + 
			"      #48 @D(\n" + 
			"        target type = 0x1d WILDCARD_BOUND_GENERIC_OR_ARRAY\n" + 
			"        wildcard location type = 0x9 LOCAL_VARIABLE_GENERIC_OR_ARRAY\n" + 
			"          local variable entries:\n" + 
			"                [pc: 6, pc: 16] index: 2\n" + 
			"                [pc: 32, pc: 34] index: 2\n" + 
			"              wildcard locations = {1}\n" + 
			"        locations = {1}\n" + 
			"      )\n" + 
			"    RuntimeInvisibleTypeAnnotations: \n" + 
			"      #44 @B(\n" + 
			"        target type = 0x1d WILDCARD_BOUND_GENERIC_OR_ARRAY\n" + 
			"        wildcard location type = 0x9 LOCAL_VARIABLE_GENERIC_OR_ARRAY\n" + 
			"          local variable entries:\n" + 
			"                [pc: 6, pc: 16] index: 2\n" + 
			"                [pc: 32, pc: 34] index: 2\n" + 
			"              wildcard locations = {1}\n" + 
			"        locations = {0}\n" + 
			"      )\n";
		checkDisassembledClassFile(OUTPUT_DIR + File.separator + "X.class", "X", expectedOutput, ClassFileBytesDisassembler.SYSTEM);
	}

