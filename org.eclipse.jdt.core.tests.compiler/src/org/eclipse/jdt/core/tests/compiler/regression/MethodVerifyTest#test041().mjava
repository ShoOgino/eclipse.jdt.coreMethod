	// https://bugs.eclipse.org/bugs/show_bug.cgi?id=83902
	public void test041() { // inherited cases for bridge methods, varargs clashes, return type conversion checks
		this.runNegativeTest(
			new String[] {
				"X.java",
				"public class X { public void foo(String... n) {} }\n" +
				"interface I { void foo(String[] n); }\n" +
				"class Y extends X implements I { }\n"
			},
			"----------\n" + 
			"1. WARNING in X.java (at line 3)\n" + 
			"	class Y extends X implements I { }\n" + 
			"	      ^\n" + 
			"Varargs methods should only override other varargs methods unlike X.foo(String...) and I.foo(String[])\n" + 
			"----------\n"
			// warning: foo(java.lang.String...) in X cannot implement foo(java.lang.String[]) in I; overridden method has no '...'
		);
		this.runNegativeTest(
			new String[] {
				"X.java",
				"public class X { public void foo(String[] n) {} }\n" +
				"interface I { void foo(String... n); }\n" +
				"class Y extends X implements I { }\n"
			},
			"----------\n" + 
			"1. WARNING in X.java (at line 3)\n" + 
			"	class Y extends X implements I { }\n" + 
			"	      ^\n" + 
			"Varargs methods should only override other varargs methods unlike X.foo(String[]) and I.foo(String...)\n" + 
			"----------\n"
			// warning: foo(java.lang.String[]) in X cannot implement foo(java.lang.String...) in I; overriding method is missing '...'
		);
		this.runConformTest(
			new String[] {
				"X.java",
				"public class X {\n" +
				"	public Y foo() {\n" +
				"		System.out.println(\"SUCCESS\");\n" +
				"		return null;\n" +
				"	}\n" +
				"	public static void main(String[] args) {\n" +
				"		((I) new Y()).foo();\n" +
				"	}\n" +
				"}\n" +
				"interface I { X foo(); }\n" +
				"class Y extends X implements I { }\n"
			},
			"SUCCESS"
		);
		this.runNegativeTest(
			new String[] {
				"X.java",
				"public class X { public A foo() { return null; } }\n" +
				"interface I { A<String> foo(); }\n" +
				"class Y extends X implements I { }\n" +
				"class A<T> { }\n"
			},
			"----------\n" + 
			"1. WARNING in X.java (at line 1)\n" + 
			"	public class X { public A foo() { return null; } }\n" + 
			"	                        ^\n" + 
			"A is a raw type. References to generic type A<T> should be parameterized\n" + 
			"----------\n" + 
			"2. WARNING in X.java (at line 3)\n" + 
			"	class Y extends X implements I { }\n" + 
			"	      ^\n" + 
			"Type safety: The return type A for foo() from the type X needs unchecked conversion to conform to A<String> from the type I\n" + 
			"----------\n"
			// warning: foo() in X implements foo() in I; return type requires unchecked conversion
		);
		this.runNegativeTest(
			new String[] {
				"X.java",
				"public class X { public Object foo() { return null; } }\n" +
				"interface I { <T> T foo(); }\n" +
				"class Y extends X implements I { }\n"
			},
			"----------\n" + 
			"1. WARNING in X.java (at line 3)\n" + 
			"	class Y extends X implements I { }\n" + 
			"	      ^\n" + 
			"Type safety: The return type Object for foo() from the type X needs unchecked conversion to conform to T from the type I\n" + 
			"----------\n"
			// NOTE: javac issues an error & a warning which contradict each other
			// if the method Object foo() is implemented in Y then only the warning is issued, so X should be allowed to implement the method
			// Y is not abstract and does not override abstract method <T>foo() in I
			// warning: foo() in X implements <T>foo() in I; return type requires unchecked conversion
		);
	}

