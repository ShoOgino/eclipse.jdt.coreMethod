	// 72644
	// TODO (kent) this should generate:
	// X is not abstract and does not override abstract method putAll(java.util.Map<? extends java.lang.String,? extends V>) in java.util.Map
	public void test298() {
		this.runConformTest(
			new String[] {
				"X.java", //---------------------------
				"import java.util.Collection;\n" + 
				"import java.util.Map;\n" + 
				"import java.util.Set;\n" + 
				"\n" + 
				"public class X<V> implements Map<String, V> {\n" + 
				"   private Map<String, V> backingMap;\n" + 
				"   \n" + 
				"   public static void main(String [] args) {\n" + 
				"        System.out.println(\"SUCCESS\");\n" + 
				"   }\n" + 
				"   public int size() { return 0; }\n" + 
				"   public boolean isEmpty() { return false; }\n" + 
				"   public boolean containsKey(Object key) { return false; }\n" + 
				"   public boolean containsValue(Object value) { return false; }\n" + 
				"   public V get(Object key) { return null; }\n" + 
				"   public V put(String key, V value) { return null; }\n" + 
				"   public V remove(Object key) { return null; }\n" + 
				"   public void clear() { }\n" + 
				"   public Set<String> keySet() { return null; }\n" + 
				"   public Collection<V> values() { return null; }\n" + 
				"   public void putAll(Map<String, ? extends V> t) { }\n" + 
				"   public Set<Map.Entry<String, V>> entrySet() {\n" + 
				"      return this.backingMap.entrySet();\n" + 
				"   }\n" + 
				"}\n",
			},
			"SUCCESS");
/* Also
name clash: putAll(java.util.Map<? extends java.lang.String,? extends V>) in GenericMap<S,V> and putAll(java.util.Map<? extends K,? extends V>)
in java.util.Map<S,V> have the same erasure, yet neither overrides the other

abstract class GenericMap<S, V> implements java.util.Map<S, V> {
   public void putAll(java.util.Map<? extends String, ? extends V> t) { }
}
 */
	}

