	private String[] errorsForInvalidTagsClassOrField(int visibility) {
		int length = CLASSES_ERRORS.length;
		if (reportInvalidJavadocTagsDeprecatedRef == null && reportInvalidJavadocTagsNotVisibleRef == null) {
			if (visibility == (length-1)) return CLASSES_ERRORS;
			String[] errors = new String[length];
			System.arraycopy(CLASSES_ERRORS, 0, errors, 0, length);
			return errors;
		}
		String[] errors = new String[visibility+1];
		for (int i=0, count=1; i<= visibility; i++) {
			StringBuffer buffer = new StringBuffer();
			StringTokenizer tokenizer = new StringTokenizer(CLASSES_ERRORS[i], "\n");
			while (tokenizer.hasMoreTokens()) {
				StringBuffer error = new StringBuffer();
				boolean add = true;
				for (int j=0; j<5; j++) {
					String line = tokenizer.nextToken();
					switch (j) {
						case 0:
							error.append(count);
							error.append(line.substring(line.indexOf('.')));
							break;
						case 3:
							if (CompilerOptions.DISABLED.equals(reportInvalidJavadocTagsDeprecatedRef)) {
								add = line.indexOf("is deprecated") == -1;
							}
							if (add && CompilerOptions.DISABLED.equals(reportInvalidJavadocTagsNotVisibleRef)) {
								add = line.indexOf("is not visible") == -1 && line.indexOf("visibility for malformed doc comments") == -1;
							}
						default:
							error.append(line);
					}
					error.append('\n');
				}
				if (add) {
					count++;
					buffer.append(error);
				}
			}
			errors[i] = buffer.toString();
		}
		return errors;
	}

