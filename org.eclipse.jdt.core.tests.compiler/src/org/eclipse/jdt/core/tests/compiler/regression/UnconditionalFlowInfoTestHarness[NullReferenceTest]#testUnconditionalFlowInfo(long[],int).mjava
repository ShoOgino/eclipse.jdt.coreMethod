/**
 * Return a fake unconditional flow info which bit fields represent the given
 * null bits for a local variable of id position within a class that would have 
 * no field.
 * @param nullBits the bits that must be set, given in the same order as the
 *        nullAssignment* fields in UnconditionalFlowInfo definition; use 0
 *        for a bit that is not set, 1 else
 * @param position the position of the variable within the bit fields; use
 *        various values to test different parts of the bit fields, within
 *        or beyond BitCacheSize
 * @return a fake unconditional flow info which bit fields represent the
 *         null bits given in parameter
 */
public static UnconditionalFlowInfoTestHarness testUnconditionalFlowInfo(
		long [] nullBits, int position) {
 	UnconditionalFlowInfoTestHarness result = 
 		new UnconditionalFlowInfoTestHarness();
	result.testPosition = position;
	if (position < BitCacheSize) {
		result.nullAssignmentStatusBit1 = nullBits[0] << position;
		result.nullAssignmentStatusBit2 = nullBits[1] << position;
		result.nullAssignmentValueBit1 = nullBits[2] << position;
		result.nullAssignmentValueBit2 = nullBits[3] << position;
	} 
 	else {
		int vectorIndex = (position / BitCacheSize) - 1,
			length = vectorIndex + 1;
        position %= BitCacheSize;
        result.extra = new long[extraLength][];
		result.extra[0] = new long[length];
		result.extra[1] = new long[length];
        for (int j = 2; j < extraLength; j++) {
		    result.extra[j] = new long[length];
		    result.extra[j][vectorIndex] = nullBits[j - 2] << 
		        position;
        }
	}
	if ((nullBits[0] | nullBits[1] | nullBits[2] | nullBits[3]) != 0) {
		result.tagBits |= NULL_FLAG_MASK;
	}
	result.maxFieldCount = 0;
	return result;
}

