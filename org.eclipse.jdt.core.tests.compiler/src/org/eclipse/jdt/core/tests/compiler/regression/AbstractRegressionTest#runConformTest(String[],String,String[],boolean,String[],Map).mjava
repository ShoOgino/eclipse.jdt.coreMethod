protected void runConformTest(String[] testFiles, String expectedSuccessOutputString, String[] classLib, boolean shouldFlushOutputDirectory, String[] vmArguments, Map customOptions) {

	if (shouldFlushOutputDirectory) Util.flushDirectoryContent(new File(OUTPUT_DIR));
	
	IProblemFactory problemFactory = getProblemFactory();
	Requestor requestor = new Requestor(problemFactory, OUTPUT_DIR.endsWith(File.separator) ? OUTPUT_DIR : OUTPUT_DIR + File.separator, false);
	
	Map options = getCompilerOptions();
	if (customOptions != null){
		options.putAll(customOptions);
	}
	Compiler batchCompiler =
		new Compiler(
			getNameEnvironment(new String[] {}, classLib),
			getErrorHandlingPolicy(),
			options,
			requestor,
			problemFactory);
	batchCompiler.compile(compilationUnits(testFiles)); // compile all files together
	if (!requestor.hasErrors) {
		String sourceFile = testFiles[0];
		
		// Compute class name by removing ".java" and replacing slashes with dots
		String className = sourceFile.substring(0, sourceFile.length() - 5).replace('/', '.').replace('\\', '.');

		if (vmArguments != null) {
			if (this.verifier != null) {
				this.verifier.shutDown();
			}
			this.verifier = new TestVerifier(false);
			this.createdVerifier = true;
		}		
		boolean passed = this.verifier.verifyClassFiles(sourceFile, className, expectedSuccessOutputString, this.classpaths, null, vmArguments);
		assertTrue(
			this.verifier.failureReason, // computed by verifyClassFiles(...) action
			passed
		);
		if (vmArguments != null) {
			if (this.verifier != null) {
				this.verifier.shutDown();
			}
			this.verifier = new TestVerifier(false);
			this.createdVerifier = true;
		}		
	} else {
		assertTrue("Unexpected problems: " + requestor.problemLog, false);
	}
}

