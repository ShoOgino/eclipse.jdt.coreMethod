	/**
	 * Log contains all problems (warnings+errors)
	 */
	protected void runNegativeTest(
		String[] testFiles, 
		String expectedProblemLog, 
		String[] classLib,
		boolean shouldFlushOutputDirectory, 
		Map customOptions, 
		boolean generateOutput,
		boolean showCategory,
		boolean showWarningToken,
		boolean skipJavac,
		boolean performStatementsRecovery) {
		// Non-javac part
		try {
			if (shouldFlushOutputDirectory)
				Util.flushDirectoryContent(new File(OUTPUT_DIR));
	
			IProblemFactory problemFactory = getProblemFactory();
			Requestor requestor = 
				new Requestor(
					problemFactory, 
					OUTPUT_DIR.endsWith(File.separator) ? OUTPUT_DIR : OUTPUT_DIR + File.separator, 
					generateOutput,
					null/*no custom requestor*/,
					showCategory,
					showWarningToken);
			Map options = getCompilerOptions();
			if (customOptions != null) {
				options.putAll(customOptions);
			}
			CompilerOptions compilerOptions = new CompilerOptions(options);
			compilerOptions.performMethodsFullRecovery = performStatementsRecovery;
			compilerOptions.performStatementsRecovery = performStatementsRecovery;
			Compiler batchCompiler = 
				new Compiler(
					getNameEnvironment(new String[]{}, classLib), 
					getErrorHandlingPolicy(), 
					compilerOptions,
					requestor, 
					problemFactory);
			batchCompiler.options.produceReferenceInfo = true;
			Throwable exception = null;
			try {
				batchCompiler.compile(Util.compilationUnits(testFiles)); // compile all files together
			} catch(RuntimeException e){
				exception = e;
				throw e;
			} catch(Error e) {
				exception = e;
				throw e;
			} finally {
				String platformIndependantExpectedLog = Util.convertToIndependantLineDelimiter(expectedProblemLog);
				computeProblemLog(testFiles, requestor, platformIndependantExpectedLog, exception);
			}
		// javac part
		} catch (AssertionFailedError e) {
			throw e;
		} finally {
			if (RUN_JAVAC && !skipJavac)
				runJavac(testFiles, expectedProblemLog, null, shouldFlushOutputDirectory);
		}
	}

