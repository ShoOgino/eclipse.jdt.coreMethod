	@SuppressWarnings("nls")
	public void process() 
	{
		try{
			final TypeDeclaration test = _env.getTypeDeclaration("sample.Test");
			if( test == null )
				TestCase.assertNotNull("failed to locate type 'sample.Test'", test);
			
			final Collection<AnnotationMirror> annotations = test.getAnnotationMirrors();
			final int numAnnotations = annotations == null ? 0 : annotations.size();
			TestCase.assertEquals("annotation number mismatch", 1, numAnnotations);
			
			final AnnotationMirror annotation = annotations.iterator().next();
			final AnnotationType annotationType = annotation.getAnnotationType();
			
			TestCase.assertEquals(
					"annotation type mismatch", 
					"sample.Test.Annotation", 
					annotationType.getDeclaration().getQualifiedName());
			
			final Map<AnnotationTypeElementDeclaration, AnnotationValue> elementValues =
				annotation.getElementValues();
			
			for( Map.Entry<AnnotationTypeElementDeclaration, AnnotationValue> entry : 
				 elementValues.entrySet() ){
				
				AnnotationTypeElementDeclaration elementDecl = entry.getKey();
				final String name = elementDecl.getSimpleName();
				final AnnotationValue value = entry.getValue();
				
				if( name.length() == 1 )
				{
					final Class expectedType;
					switch(name.charAt(0))
					{
					case 'b':
						expectedType = Byte.class;
						break;					
					case 'c':
						expectedType = Character.class;
						break;
					case 's':
						expectedType = Short.class;
						break;
					case 'i':
						expectedType = Integer.class;
						break;
					case 'l':
						expectedType = Long.class;
						break;
					case 'f':
						expectedType = Float.class;
						break;
					case 'd':
						expectedType = Double.class;
						break;
					default:
						TestCase.assertNotNull("unexpected member " + name, null);
						throw new IllegalStateException(); // won't get here.
					}
					assertValueTypeMatch(name, value.getValue(), expectedType);
				}	
				else{
					@SuppressWarnings("unused")
					final Class expectedElementType;
					if( "chars".equals(name) )
						expectedElementType = Character.class;
					else if( "bytes".equals(name) )
						expectedElementType = Byte.class;
					else if( "shorts".equals(name) )
						expectedElementType = Short.class;
					else if( "ints".equals(name) )
						expectedElementType = Integer.class;
					else if( "longs".equals(name) )
						expectedElementType = Long.class;
					else if( "floats".equals(name) )
						expectedElementType = Float.class;
					else if( "doubles".equals(name) )
						expectedElementType = Double.class;
					else{
						TestCase.assertNotNull("unexpected member " + name, null);
						throw new IllegalStateException(); // won't get here.
					}
				}
			}
		}
		catch( ComparisonFailure failure ){			
			if (!ProcessorTestStatus.hasErrors()) {
				ProcessorTestStatus.failWithoutException(failure.toString());
			}
			throw failure;
		}
		catch( junit.framework.AssertionFailedError error ){
			if (!ProcessorTestStatus.hasErrors()) {
				ProcessorTestStatus.failWithoutException(error.toString());
			}
			throw error;
		}
	}

