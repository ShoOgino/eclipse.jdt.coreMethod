	/**
	 * Test getDeclaredType() for nested parameterized types (Outer&lt;Foo&gt;.Inner&lt;Bar&gt;).
	 * @return true if tests passed
	 */
	private boolean examineGetDeclaredTypeNested() {
		TypeElement stringDecl = _elementUtils.getTypeElement(String.class.getName());
		TypeElement numberDecl = _elementUtils.getTypeElement(Number.class.getName());
		TypeElement mapDecl = _elementUtils.getTypeElement("java.util.HashMap");
		TypeElement iterDecl = _elementUtils.getTypeElement("java.util.HashMap.HashIterator");
		DeclaredType stringType = _typeUtils.getDeclaredType(stringDecl);
		DeclaredType numberType = _typeUtils.getDeclaredType(numberDecl);

		// HashMap<String, Number>
		DeclaredType outerType = _typeUtils.getDeclaredType(mapDecl, stringType, numberType);
		
		// HashMap<String, Number>.HashIterator<Number>
		DeclaredType decl = _typeUtils.getDeclaredType(outerType, iterDecl, new DeclaredType[] { numberType });
		
		List<? extends TypeMirror> args = decl.getTypeArguments();
		if (args.size() != 1) {
			reportError("Map<String, Number>.EntryIterator<Number> should have one argument but decl.getTypeArguments() returned " + args.size());
			return false;
		}
		if (!_typeUtils.isSameType(numberType, args.get(0))) {
			reportError("First arg of Map<String, Number>.EntryIterator<Number> was expected to be Number, but was: " + args.get(0));
			return false;
		}
		return true;
	}

