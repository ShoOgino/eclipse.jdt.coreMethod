	/**
	 * Check the model of targets.negative.pa.Negative5
	 * @return true if all tests passed
	 */
	public boolean checkNegative5() {
		class TestElement {
			String name;
			TypeElement element;
			TestElement(String name) {
				this.name = name;
				this.element = null;
			}
		}
		
		TestElement elements[] = new TestElement[] {
			new TestElement("targets.negative.pa.Negative5.C1"),
			new TestElement("targets.negative.pa.Negative5.C2"),
			new TestElement("targets.negative.pa.Negative5.I1"),
			new TestElement("targets.negative.pa.Negative5.I2"),
			new TestElement("targets.negative.pa.INegative5.C101"),
			new TestElement("targets.negative.pa.INegative5.C102"),
			new TestElement("targets.negative.pa.INegative5.I101"),
			new TestElement("targets.negative.pa.INegative5.I102")
		};
		for (TestElement testElement : elements) {
			testElement.element = _elementUtils.getTypeElement(testElement.name);
			if (null == testElement.element) {
				reportError("Element " + testElement.name + " was not found");
				return false;
			}
			
			// TODO: there are substantial differences between javac and Eclipse in how
			// missing types are recovered (e.g., as error types or as declared types),
			// and the toString() implementations are also different.  The JSR269 spec
			// does not require these to match.  Do we want to enforce matching anyway?
			TypeMirror superClass = testElement.element.getSuperclass();
			if (_reportFailingCases && superClass == null) {
				reportError("Element " + testElement.name + " has null superclass");
				return false;
			}
			List<? extends TypeMirror> superInterfaces = testElement.element.getInterfaces();
			if (_reportFailingCases && (superInterfaces == null || superInterfaces.isEmpty())) {
				reportError("Element " + testElement.name + " has empty list of superinterfaces");
				return false;
			}
		}
		
		return true;
	}

