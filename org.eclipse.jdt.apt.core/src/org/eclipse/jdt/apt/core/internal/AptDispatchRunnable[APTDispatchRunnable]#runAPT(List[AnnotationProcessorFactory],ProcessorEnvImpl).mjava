	private static APTResult runAPT(
			final List<AnnotationProcessorFactory> factories,
			final ProcessorEnvImpl processorEnv) 
	{
		try {
			if (factories.size() == 0)
			{
				if ( DEBUG ) trace( "runAPT: leaving early because there are no factories");
				return EMPTY_APT_RESULT;
			}
				
			if ( ! processorEnv.getFile().exists() )
			{
				if ( DEBUG ) trace( "runAPT: leaving early because file doesn't exist");
				return EMPTY_APT_RESULT;
			}				
		
			final Map<String, AnnotationTypeDeclaration> annotationDecls = getAnnotationTypeDeclarations(
					processorEnv.getAstCompilationUnit(), processorEnv);
			
			if (annotationDecls.isEmpty())
			{
				if ( DEBUG ) trace ( "runAPT:  leaving early because annotationDecls is empty" );
				return EMPTY_APT_RESULT;
			}

			GeneratedFileManager gfm = GeneratedFileManager.getGeneratedFileManager( processorEnv.getJavaProject().getProject() );
			Set<IFile> lastGeneratedFiles = gfm.getGeneratedFilesForParent( processorEnv.getFile() );
			
			for (int i = 0, size = factories.size(); i < size; i++) {
				final AnnotationProcessorFactory factory = (AnnotationProcessorFactory) factories.get(i);
				Set<AnnotationTypeDeclaration> factoryDecls = getAnnotations(factory, annotationDecls);
				boolean done = false;
				if( factoryDecls != null ){
					if(factoryDecls.size() == 0 ){
						done = true;
						factoryDecls = new HashSet(annotationDecls.values());
					}
				}
				if (factoryDecls != null && factoryDecls.size() > 0) {
					final AnnotationProcessor processor = factory
							.getProcessorFor(factoryDecls, processorEnv);
					if (processor != null)
					{
						if ( DEBUG ) trace( "runAPT: invoking processor " + processor.getClass().getName() );
						processor.process();
					}
				}

				if (annotationDecls.isEmpty() || done)
					break;
			}
			// TODO: (theodora) log unclaimed annotations.

			// notify the processor listeners
			final Set<AnnotationProcessorListener> listeners = processorEnv
					.getProcessorListeners();
			for (AnnotationProcessorListener listener : listeners) {
				EclipseRoundCompleteEvent event = null;
				if (listener instanceof RoundCompleteListener) {
					if (event == null)
						event = new EclipseRoundCompleteEvent(processorEnv);
					final RoundCompleteListener rcListener = (RoundCompleteListener) listener;
					rcListener.roundComplete(event);
				}
			}

			final Set<IFile> allGeneratedFiles = new HashSet<IFile>();
			Set<IFile> modifiedFiles = new HashSet<IFile>();
			Map<IFile, Boolean> filesMap = processorEnv.getGeneratedFiles();
			for (Map.Entry<IFile, Boolean> entry : filesMap.entrySet()) {
				allGeneratedFiles.add(entry.getKey());
				if (entry.getValue()) {
					modifiedFiles.add(entry.getKey());
				}
			}
			
			// any files that were generated for this parent on the last
			// run, but are no longer generated should be removed
			Set<IFile> deletedFiles = cleanupNoLongerGeneratedFiles( processorEnv.getFile(), lastGeneratedFiles, allGeneratedFiles, gfm );

			APTResult result = new APTResult( modifiedFiles, 
											  deletedFiles, 
											  processorEnv.getTypeDependencies(), 
											  processorEnv.getProblems() );
			processorEnv.close();
			return result;

			// log unclaimed annotations.
		} catch (Throwable t) {
			t.printStackTrace();
		}
		return EMPTY_APT_RESULT;
	}

