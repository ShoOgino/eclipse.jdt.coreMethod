	/**
	 *  Creates the generated source folder if it doesn't exist, and adds it as a source path
	 *  to the project.  To access the generated source folder, but not have it be created
	 *  or added as a source path, use getGeneratedSourceFolder().  Note that this method 
	 *  will take a resource lock if the generated source folder needs to be created on disk, 
	 *  and it will take a java model lock if the project's source paths need to be updated.
	 *  Care should be taken when calling this method to ensure that locking behavior is correct.    
	 *  
	 *  @return <code>true</code> iff the any resource or classpath has been modified. 
	 *  return <code>false</code> otherwise.
	 *  
	 *  @see #getFolder()
	 *  @see #isGeneratedSourceFolderConfigured()
	 */
	private boolean ensureGeneratedSourceFolder(){
		
		boolean reset = false;
		IFolder curSrcFolder = null;
	
		// Determine current state of affairs, with respect to
		// folder, folder name, and classpath.
		synchronized( this )
		{
			if( _generatedSourceFolder != null ){
				final IPath srcFolderPath = _generatedSourceFolder.getProjectRelativePath();
				
				if( !_generatedSourceFolderName.equals( srcFolderPath.toString()) ){
					// Folder name has been changed!  Save the current folder so we can clear it out later.
					reset = true;
					curSrcFolder = _generatedSourceFolder;
					_generatedSourceFolder = null;
				}
				else {
					// Folder name and folder are in sync.  Check that folder is on classpath.
					
					// If the folder doesn't exist on disk, there is no point examining the classpath.
					try{
						_generatedSourceFolder.refreshLocal( IResource.DEPTH_INFINITE, null );
					}
					catch(CoreException ce){
						AptPlugin.log(ce, "Failure during refreshLocal on " + srcFolderPath); //$NON-NLS-1$
					}
					if (!_generatedSourceFolder.exists()) {
						return false;
					}
					
					try {
						IJavaProject jp = _aptProject.getJavaProject();
						IClasspathEntry[] cp = jp.getRawClasspath();
						IPath path = _generatedSourceFolder.getFullPath();
						if (ClasspathUtil.isProjectClassPathUpToDate(jp, cp, path, null)) {
							return false;
						}
					}
					catch (JavaModelException jme) {
						AptPlugin.log(jme, "Failure examining the classpath"); //$NON-NLS-1$
					}
				}
			}
		}
		
		IFolder srcFolder = null;
		try{
			if( reset ){
				// Folder name was out of sync with folder.  Delete the old folder and classpath entry.
				ClasspathUtil.removeFromProjectClasspath(_aptProject.getJavaProject(), curSrcFolder, null );
				if ( curSrcFolder.exists() ){
					if( AptPlugin.DEBUG )
						AptPlugin.trace("deleting gen src dir " + curSrcFolder.getName() ); //$NON-NLS-1$
					curSrcFolder.delete( true, false, null );
				}
			}
				
			// don't take any locks while creating the folder, since we are doing file-system operations
			srcFolder = getFolder();
			srcFolder.refreshLocal( IResource.DEPTH_INFINITE, null );
			if (!srcFolder.exists()) {
				FileSystemUtil.makeDerivedParentFolders(srcFolder);
			}
				
			//
			// make sure __generated_src dir is on the cp if not already
			//
			ClasspathUtil.updateProjectClasspath( _aptProject.getJavaProject(), srcFolder, null );
			
			if(AptPlugin.DEBUG)
				AptPlugin.trace("Added directory " + srcFolder.getName() + " and updated classpath" ); //$NON-NLS-1$ //$NON-NLS-2$
		}
		catch(CoreException e){						
			e.printStackTrace();
			AptPlugin.log(e, "Failed to create generated source directory"); //$NON-NLS-1$
			return false;
		}
		
		synchronized ( this )
		{
			_generatedSourceFolder = srcFolder;
			return true;
		}
	}

