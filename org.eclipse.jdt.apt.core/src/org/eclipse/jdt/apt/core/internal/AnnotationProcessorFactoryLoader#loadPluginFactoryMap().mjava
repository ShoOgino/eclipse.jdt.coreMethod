	/**
	 * Discover and instantiate annotation processor factories by searching for plugins
	 * which contribute to org.eclipse.jdt.apt.core.annotationProcessorFactory.
	 * This method is used when running within the Eclipse framework.  When running
	 * standalone at the command line, use {@link #LoadFactoriesFromJars}.
	 * This method can be called repeatedly, but each time it will erase the previous
	 * contents of the set of known AnnotationProcessorFactoriesDefined by plugin and 
	 * do a full rediscovery.
	 */
	private void loadPluginFactoryMap() {
		assert PLUGIN_FACTORY_MAP.size() == 0 : "loadPluginFactoryMap() called more than once";

		IExtensionPoint extension = Platform.getExtensionRegistry().getExtensionPoint(
				"org.eclipse.jdt.apt.core",  //$NON-NLS-1$ - namecls of plugin that exposes this extension
				"annotationProcessorFactory"); //$NON-NLS-1$ - extension id
		IExtension[] extensions =  extension.getExtensions();
		// for all extensions of this point...
		for(int i = 0; i < extensions.length; i++){
			IConfigurationElement [] configElements = extensions[i].getConfigurationElements();
			// for all config elements named "factory"
			for(int j = 0; j < configElements.length; j++){
				String elementName = configElements[j].getName();
				if (!("factory".equals(elementName))) { //$NON-NLS-1$ - name of configElement
					continue;
				}
				try {
					Object execExt = configElements[j].createExecutableExtension("class"); //$NON-NLS-1$ - attribute name
					if (execExt instanceof AnnotationProcessorFactory){
						PLUGIN_FACTORY_MAP.put( execExt.getClass().getName(), (AnnotationProcessorFactory)execExt );
					}
				} catch(CoreException e) {
						e.printStackTrace();
				}
			}
		}
	}

