	private ICompilationUnit createNewWorkingCopy(ICompilationUnit parentCompilationUnit, String typeName,
			String contents, WorkingCopyOwner workingCopyOwner,
			IProblemRequestor problemRequestor, IProgressMonitor progressMonitor)
		throws CoreException, JavaModelException
	{	
		IProject project = parentCompilationUnit.getResource().getProject();
		IJavaProject jp = parentCompilationUnit.getJavaProject();

		//
		// create folder for generated source files
		//
		IFolder folder = ensureGeneratedSourceFolder( jp, progressMonitor );

		// 
		//  figure out package part of type & file name
		//
		String pkgName;
		String fname;
		int idx = typeName.lastIndexOf( '.' );
		if ( idx > 0 )
		{
		    pkgName = typeName.substring( 0, idx );
		    fname = 
				typeName.substring(idx + 1, typeName.length()) + ".java"; //$NON-NLS-1$
		}
		else
		{
			pkgName = ""; //$NON-NLS-1$
			fname = typeName + ".java"; //$NON-NLS-1$
		}

		//
		//  create compilation unit
		//
		IPackageFragmentRoot root = jp.getPackageFragmentRoot(folder);
		IPackageFragment pkgFragment = 
			root.createPackageFragment( pkgName, true, null );
		
		ICompilationUnit cu = pkgFragment.getCompilationUnit( fname );
		if ( cu == null || ! cu.getResource().exists() )
		{
		    cu = pkgFragment.createCompilationUnit(
			    fname, contents, true, progressMonitor );
		}
		else
		{
			makeReadOnly( cu, false );
		}

		
		//
		//  TODO:  can we call getWorkingCopy here?
		//
		cu.becomeWorkingCopy(problemRequestor, progressMonitor);
		ICompilationUnit workingCopy = cu;
		
		//
		// update maps
		//
		addEntryToWorkingCopyMaps( parentCompilationUnit, workingCopy );
		
		// we save this here since the resource has to exist on disk
		workingCopy.commitWorkingCopy( true, progressMonitor );
		
		//
		// make the file derived so that it is not checked into source control.
		//
		makeDerived( workingCopy );
		
		//
		// make working copy read-only
		//
		makeReadOnly( workingCopy, true );


		return workingCopy;
		
	}

