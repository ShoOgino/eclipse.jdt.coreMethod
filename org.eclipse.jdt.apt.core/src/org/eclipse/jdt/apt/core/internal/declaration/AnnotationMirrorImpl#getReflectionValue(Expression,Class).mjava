    private Object getReflectionValue(final Expression expr, final Class targetType)
        throws Throwable
    {
        if( expr == null ) return null;
		final Object constantValue = expr.resolveConstantExpressionValue();
		if( constantValue != null ) return constantValue;
        switch(expr.getNodeType())
        {
        case ASTNode.SIMPLE_NAME:
        case ASTNode.QUALIFIED_NAME:
            final Name name = (Name)expr;
            final IBinding nameBinding = name.resolveBinding();
            if( nameBinding.getKind() == IBinding.VARIABLE ) {
                final IVariableBinding varBinding = (IVariableBinding)nameBinding;
                final ITypeBinding declaringClass = varBinding.getDeclaringClass();
                if( declaringClass != null ){
                    final String className = new String( declaringClass.getBinaryName() );
                    final Class clazz = expr.getClass().getClassLoader().loadClass( className );
                    final Field returnedField = clazz.getField( varBinding.getName() );
                    if( returnedField.getType() != targetType )
                        throw new ClassCastException( targetType.getName() );
                    return returnedField.get(null);
                }
            }
            break;
        case ASTNode.ARRAY_INITIALIZER:
            assert targetType.isArray();
            final Class componentType = targetType.getComponentType();
            final char componentTypeName = componentType.getName().charAt(0);
            final ArrayInitializer arrayInit = (ArrayInitializer)expr;
            final List<Expression> exprs = arrayInit.expressions();
            final int length = exprs == null ? 0 : exprs.size();
            final Object array = Array.newInstance(componentType, length);
            if( length == 0) return array;

            for( int i=0; i<length; i++ ){
                final Expression element = exprs.get(i);
                final Object returnObj = getReflectionValue( element, componentType );
                // fill in the array.
                // If it is an array of some primitive type, we will need to unwrap it.
                if( componentType.isPrimitive() ){
                    if( componentType == boolean.class ){
                        final Boolean bool = (Boolean)returnObj;
                        Array.setBoolean( array, i, bool.booleanValue());
                    }
                    else if( componentType == byte.class ){
                        final Byte b = (Byte)returnObj;
                        Array.setByte( array, i, b.byteValue() );
                    }
                    else if( componentType == char.class ){
                        final Character c = (Character)returnObj;
                        Array.setChar( array, i, c.charValue() );
                    }
                    else if( componentType == double.class ){
                        final Double d = (Double)returnObj;
                        Array.setDouble( array, i, d.doubleValue() );
                    }
                    else if( componentType == float.class ){
                        final Float f = (Float)returnObj;
                        Array.setFloat( array, i, f.floatValue() );
                    }
                    else if( componentType == int.class ){
                        final Integer integer = (Integer)returnObj;
                        Array.setInt( array, i, integer.intValue() );
                    }
                    else if( componentType == long.class ){
                        final Long l = (Long)returnObj;
                        Array.setLong( array, i, l.longValue() );
                    }
                    else if( componentType == short.class ){
                        final Short s = (Short)returnObj;
                        Array.setShort( array, i, s.shortValue() );
                    }
                    else {
                        throw new IllegalStateException("unrecognized primitive type: "  + componentType );
                    }
                }
                else{
                    Array.set( array, i, returnObj );
                }
            }
            return array;
        case ASTNode.NORMAL_ANNOTATION:
        case ASTNode.MARKER_ANNOTATION:
        case ASTNode.SINGLE_MEMBER_ANNOTATION:
            return Factory.createAnnotationMirror((Annotation)expr, _annotated, _env);        
        case ASTNode.TYPE_LITERAL:
            throw new IllegalStateException("illegal expression " + expr);     
        }

        return null;
    }

