	private APTResult runAPT(
			final Map<AnnotationProcessorFactory, FactoryPath.Attributes> factories,
			final ProcessorEnvImpl processorEnv) 
	{
		final List<IFile> filesWithMissingType = new ArrayList<IFile>();
		final List<ICompilationUnit> unitsForFiles = new ArrayList<ICompilationUnit>();
		final APTResult result = runAPT(factories, processorEnv, filesWithMissingType, unitsForFiles, 0);
	
		//APTResult lastResult = result;
		if( processorEnv.getPhase() == Phase.BUILD )
		{	
			boolean generatedTypes = result.hasGeneratedTypes();
			int round = 1;
			while( generatedTypes && !filesWithMissingType.isEmpty() ){
				// compile all generated files and try to satisfy the missing generated types.
				//recompileGeneratedFiles(result.getNewFiles());
				
				final int numFiles = filesWithMissingType.size();
				assert numFiles == unitsForFiles.size() :
					"size mismatch"; //$NON-NLS-1$			
				// we are about to re-process the file, wipe out the problems and
				// type dependencies recorded from the previous run.
				for( IFile file :  filesWithMissingType ){
					result.removeDependenciesFrom(file);
					result.removeProblemsFrom(file);
				}
				
				final IFile[] files = new IFile[numFiles];
				final ICompilationUnit[] units = new ICompilationUnit[numFiles];
				for(int i=0; i<numFiles; i++ ){
					files[i] = filesWithMissingType.get(i);
					units[i] = unitsForFiles.get(i);
				}
				ProcessorEnvImpl newEnv = ProcessorEnvImpl.newProcessorEnvironmentForBuild(
						files, units, processorEnv.getJavaProject() );

				filesWithMissingType.clear();
				unitsForFiles.clear();
				APTResult newResult = runAPT(factories, newEnv, filesWithMissingType, unitsForFiles, round++);
				// Only have generated types if there are *new* generated files
				generatedTypes = hasNewFiles(result, newResult);
				
				result.merge(newResult);
				newEnv.close();
			}
		}
	
		return result;
	}

