    /**
     * Handling the following 2 cases
     * 1) For IProblems that does not have a starting and ending offset, 
     * place the problem at the class name. 
     * 
     * 2) For IProblems that does not have an ending offset, place the ending
     * offset at the end of the tightest ast node. 
     * We will only walk the ast once to determine the ending 
     * offsets of all the problems that do not have the information set. 
     */
    private void updateProblemLength()
    {	
    	// for those problems that doesn't have an ending offset, figure it out by
    	// traversing the ast.
    	// we do it once just before we post the marker so we only have to walk the ast 
    	// once.
    	for( Map.Entry<IFile, List<IProblem>> entry : _allProblems.entrySet() ){
    		int count = 0;
    		final IFile file = entry.getKey();
    		int[] classNameRange = null;
    		for( IProblem problem : entry.getValue() ){
    			if( problem.getSourceStart() < 0 ){
    				if( classNameRange == null )
    					classNameRange = getClassNameRange(file);
    				problem.setSourceStart(classNameRange[0]);
    				problem.setSourceEnd(classNameRange[1]);
    				problem.setSourceLineNumber(classNameRange[2]);
    			}
    			if( problem.getSourceEnd() < 0 ){
    				count ++;
    			}
    		}
    		
    		if( count > 0 ){
    			final CompilationUnit astUnit = getAstCompilationUnit(file);
    			if( astUnit != null ){
    			
    				final int[] startingOffsets = new int[count];
    		    	int index = 0;
	    			for( IProblem problem : entry.getValue() ){
	    				if( problem.getSourceEnd() < 0 )
	    					startingOffsets[index++] = problem.getSourceStart();
	    			}
	    			
	    			final EndingOffsetFinder lfinder = new EndingOffsetFinder(startingOffsets);
	    			
	    			astUnit.accept( lfinder );
	    	    	
	    	    	for(IProblem problem : entry.getValue() ){
	    				if( problem.getSourceEnd() < 0 ){
	    					int startingOffset = problem.getSourceStart();
	    					int endingOffset = lfinder.getEndingOffset(startingOffset);
	    	    			if( endingOffset == 0 )
	    	    				endingOffset = startingOffset;
	    	    			problem.setSourceEnd(endingOffset-1);
	    				}
	    			}
    			}
    			else{
        			for(IProblem problem : entry.getValue() ){
        				// set the -1 source end to be the same as the source start.
        				if( problem.getSourceEnd() < problem.getSourceStart() )
        					problem.setSourceEnd(problem.getSourceStart());
        			}
        		}
    		}
    		
    	}
    }

