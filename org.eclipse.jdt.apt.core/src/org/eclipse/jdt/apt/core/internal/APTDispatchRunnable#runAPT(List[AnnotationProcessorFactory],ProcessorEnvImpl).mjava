	private APTResult runAPT(
			final List<AnnotationProcessorFactory> factories,
			final ProcessorEnvImpl processorEnv) 
	{
		final List<IFile> filesWithMissingType = new ArrayList<IFile>();
		final List<char[]> sourceForFiles = new ArrayList<char[]>();
		final APTResult result = runAPT(factories, processorEnv, filesWithMissingType, sourceForFiles);
	
		//APTResult lastResult = result;
		if( processorEnv.getPhase() == Phase.BUILD )
		{	
			boolean generatedTypes = result.hasGeneratedTypes();
			while( generatedTypes && !filesWithMissingType.isEmpty() ){
				// compile all generated files and try to satisfy the missing generated types.
				//recompileGeneratedFiles(result.getNewFiles());
				
				final int numFiles = filesWithMissingType.size();
				assert numFiles == sourceForFiles.size() :
					"size mismatch"; //$NON-NLS-1$			
				// we are about to re-process the file, wipe out the problems and
				// type dependencies recorded from the previous run.
				for( IFile file :  filesWithMissingType ){
					result.removeDependenciesFrom(file);
					result.removeProblemsFrom(file);
				}
				
				final IFile[] files = new IFile[numFiles];
				final char[][] sources = new char[numFiles][];
				for(int i=0; i<numFiles; i++ ){
					files[i] = filesWithMissingType.get(i);
					sources[i] = sourceForFiles.get(i);
				}
				ProcessorEnvImpl newEnv = ProcessorEnvImpl.newProcessorEnvironmentForBuild(
						files, sources, processorEnv.getJavaProject() );

				filesWithMissingType.clear();
				sourceForFiles.clear();
				APTResult newResult = runAPT(factories, newEnv, filesWithMissingType, sourceForFiles);
				// Only have generated types if there are *new* generated files
				generatedTypes = hasNewFiles(result, newResult);
				
				result.merge(newResult);
				newEnv.close();
			}
		}
	
		return result;
	}

