    /**
     * Apply type conversion according to JLS 5.1.2 and 5.1.3 and / or auto-boxing.
     * @param expectedType the expected type
     * @param value the value where conversion may be applied to
     * @param name name of the member value
     * @param parent the of the annotation of the member value
     * @param env 
     * @return the value matching the expected type or itself if no conversion can be applied.
     */
    private static Object performNecessaryTypeConversion(final TypeMirror expectedType,
	    											     final Object value,
	    											     final String name,
	    											     final EclipseMirrorImpl parent,
	    											     final ProcessorEnvImpl env)
    {
    	if(expectedType == null )return value;
    	// apply widening or narrowing primitive type conversion based on JLS 5.1.2 and 5.1.3
    	if( expectedType instanceof PrimitiveType )
    	{    	
    		// widening byte -> short, int, long, float or double
    		// narrowing byte -> char
    		if( value instanceof Byte )
    		{
    			final byte b = ((Byte)value).byteValue();
    			switch( ((PrimitiveType)expectedType).getKind() )
    			{
    			case CHAR:
    				return new Character((char)b);
    			case SHORT:
    				return new Short((short)b);
    			case INT:
    				return new Integer((short)b);
    			case LONG:
    				return new Long((long)b);
    			case FLOAT:
    				return new Float((float)b);
    			case DOUBLE:
    				return new Double((double)b);
    			default:
    				// it is either already correct or it is completely wrong,
    				// which doesn't really matter what's returned
    				return value;
    			}
    		}
    		// widening short -> int, long, float, or double 
    		// narrowing short -> byte or char
    		else if( value instanceof Short )
    		{
    			final short s = ((Short)value).shortValue();
    			switch( ((PrimitiveType)expectedType).getKind() )
    			{
    			case BYTE:
    				return new Byte((byte)s);
    			case CHAR:
    				return new Character((char)s);  
    			case INT:
    				return new Integer((int)s ); 
    			case LONG:
    				return new Long((long)s);
    			case FLOAT:
    				return new Float((float)s);
    			case DOUBLE:
    				return new Double((double)s);
    			default:
    				// it is either already correct or it is completely wrong,
    				// which doesn't really matter what's returned
    				return value;
    			}
    		}
    		// widening char -> int, long, float, or double 
    		// narrowing char -> byte or short
    		else if( value instanceof Character )
    		{
    			final char c = ((Character)value).charValue();
    			switch( ((PrimitiveType)expectedType).getKind() )
    			{
    			case INT:
    				return new Integer((int)c ); 
    			case LONG:
    				return new Long((long)c);
    			case FLOAT:
    				return new Float((float)c);
    			case DOUBLE:
    				return new Double((double)c);
    			case BYTE:
    				return new Byte((byte)c);
    			case SHORT:
    				return new Short((short)c);  
    			
    			default:
    				// it is either already correct or it is completely wrong,
    				// which doesn't really matter what's returned
    				return value;
    			}
    		}
    		
    		// widening int -> long, float, or double 
    		// narrowing int -> byte, short, or char 
    		else if( value instanceof Integer )
    		{
    			final int i = ((Integer)value).intValue();
    			switch( ((PrimitiveType)expectedType).getKind() )
    			{    		
    			case LONG:
    				return new Long((long)i);
    			case FLOAT:
    				return new Float((float)i);
    			case DOUBLE:
    				return new Double((double)i);
    			case BYTE:
    				return new Byte((byte)i);
    			case SHORT:
    				return new Short((short)i);  
    			case CHAR:
    				return new Character((char)i);
    			default:
    				// it is either already correct or it is completely wrong,
    				// which doesn't really matter what's returned
    				return value;
    			}
    		}
    		// widening long -> float or double
    		else if( value instanceof Long )
    		{
    			final long l = ((Long)value).longValue();
    			switch( ((PrimitiveType)expectedType).getKind() )
    			{
    			case FLOAT:
    				return new Float((float)l);
    			case DOUBLE:
    				return new Double((double)l);    		
    			default:
    				// it is either already correct or it is completely wrong,
    				// which doesn't really matter what's returned
    				return value;
    			}
    		}
    		
    		// widening float -> double    		 
    		else if( value instanceof Float )
    		{
    			final float f = ((Float)value).floatValue();
    			switch( ((PrimitiveType)expectedType).getKind() )
    			{    			
    			case DOUBLE:
    				return new Double((double)f);    		
    			default:
    				// it is either already correct or it is completely wrong,
    				// which doesn't really matter what's returned
    				return value;
    			}
    		}
    		else // boolean or double case. Nothing we can do here.
    			return value;
    	}
    	// handle auto-boxing
    	else if( expectedType instanceof ArrayType)
    	{
    		final TypeMirror componentType = ((ArrayType)expectedType).getComponentType();
    		Object converted = value;
    		// if it is an error case, will just leave it as is.
    		if( !(componentType instanceof ArrayType ) )    		
    			converted = performNecessaryTypeConversion(componentType, value, name, parent, env);
    		
    		final AnnotationValue annoValue = createAnnotationValue(converted, name, 0, parent, env);
        	return Collections.singletonList(annoValue);
    	}
    	else // no change
    		return value;
    }

