	/**
	 * Remove a file from the build-time and reconcile-time dependency maps, and calculate
	 * the consequences of the removal. This is called in response to a file being deleted
	 * by the environment.
	 * <p>
	 * This operation affects the maps only. This operation is atomic with respect to map
	 * integrity. This operation does not touch the disk nor create, update, or discard
	 * any working copies.
	 * 
	 * @param f
	 *            can be a parent, generated, both, or neither.
	 * @param toDiscard
	 *            this set will be populated with a list of working copies that are no
	 *            longer in the maps and must be discarded. This operation must be done by
	 *            the caller without holding any locks.
	 * @param toDelete
	 *            this set will be populated with a list of generated files that are no
	 *            longer relevant and must be deleted. This operation must be done by the
	 *            caller without holding any locks.
	 */
	private synchronized void removeFileFromMaps(IFile f, Set<ICompilationUnit> toDiscard, Set<IFile> toDelete)
	{
		// Is this file the sole parent of files generated during build?
		// If so, add them to the deletion list. Then remove the file from
		// the build dependency list.
		Set<IFile> childFiles = _parentToGenFiles.getValues(f);
		for (IFile childFile : childFiles) {
			Set<IFile> parentFiles = _parentToGenFiles.getKeys(childFile);
			if (parentFiles.size() == 1 && parentFiles.contains(f)) {
				toDelete.add(childFile);
			}
		}
		boolean removed = _parentToGenFiles.removeKey(f);
		if (removed) {
			if (AptPlugin.DEBUG_GFM_MAPS) AptPlugin.trace( 
					"removed parent file from build dependencies: " + f); //$NON-NLS-1$
		}

		// Is this file the sole parent of types generated during reconcile?
		// If so, add them to the discard list and remove them from the working
		// copy list. Then remove the file (and its solely parented children)
		// from the reconcile dependency list.
		Set<ICompilationUnit> childWCs = _parentToGenWorkingCopies.getValues(f);
		for (ICompilationUnit childWC : childWCs) {
			Set<IFile> parentFiles = _parentToGenWorkingCopies.getKeys(childWC);
			if (parentFiles.size() == 1 && parentFiles.contains(f)) {
				toDiscard.add(childWC);
				ICompilationUnit removedWC = _workingCopies.remove(childWC.getResource());
				assert removedWC != null && removedWC.equals(childWC) :
					"Working copy list: get(f).getResource() != f, for wc " +  //$NON-NLS-1$
					childWC.getElementName();
			}
		}
		removed = _parentToGenWorkingCopies.removeKey(f);
		if (removed) {
			if (AptPlugin.DEBUG_GFM_MAPS) AptPlugin.trace( 
					"removed parent file from working copy dependencies: " + f); //$NON-NLS-1$
		}

		// Is this file being hidden by a blank working copy?  If so, remove that.
		ICompilationUnit wc = _hiddenBuiltTypes.remove(f);
		if (null != wc) {
			if (AptPlugin.DEBUG_GFM_MAPS) AptPlugin.trace( 
					"removed working copy from hidden types list: " + f); //$NON-NLS-1$
		}
		if (null != wc) {
			toDiscard.add(wc);
		}

		assert checkIntegrity();
	}

